<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7天入门数据结构和算法</title>
    <url>/posts/7%E5%A4%A9%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据结构和算法总览"><a href="#数据结构和算法总览" class="headerlink" title="数据结构和算法总览"></a>数据结构和算法总览</h2><p>线上课程</p>
<p>预习-基础知识自己预习和查看<br>课堂互动-一起思考回答问题<br>课后作业-按照切题方法完成</p>
<p>期待效果</p>
<p>职业顶尖级别 - 对算法数据结构的理解<br>一线互联网公司面试<br>LeetCode 300+的积累</p>
<a id="more"></a>

<p>《Outliers》 《异类:不一样的成功启示录》–马尔科姆·格拉德维尔</p>
<p>精通一个领域三步走</p>
<ul>
<li>Chunk it up 切碎知识点</li>
<li>Deliberate Practicing 刻意练习</li>
<li>Feedback 反馈</li>
</ul>
<p>Chunk it up</p>
<ul>
<li>庖丁解牛</li>
<li>脉络相连</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><a href="https://naotu.baidu.com/file/b832f043e2ead159d584cca4efb19703?token=7a6a56eb2630548c">数据结构脑图</a></p>
<ul>
<li><p>一维</p>
<ul>
<li>基础: 数组 array(string), 链表 linked list</li>
<li>高级: 栈 stack, 队列 queue,  双端队列 deque, 集合 set, 映射 map(hash or map), etc</li>
</ul>
</li>
<li><p>二维</p>
<ul>
<li>基础: 树 tree, 图 graph</li>
<li>高级: 二叉搜索树 binary search tree (red-black tree, AVL), 堆 heap, 并查集 disjoint set, 字典树Trie, etc</li>
</ul>
</li>
<li><p>特殊</p>
<ul>
<li>位运算 Bitwise, 布隆过滤器 BloomFilter</li>
<li>LRU Cache</li>
</ul>
</li>
</ul>
<h3 id="算法八点"><a href="#算法八点" class="headerlink" title="算法八点"></a>算法八点</h3><p><a href="https://naotu.baidu.com/file/0a53d3a5343bd86375f348b2831d3610?token=5ab1de1c90d5f3ec">算法脑图</a></p>
<p>基石-三点</p>
<ul>
<li>if-else, switch —&gt; 跳转 branch</li>
<li>for, while loop —&gt; 循环 iteration</li>
<li>递归 Recursion(Divide &amp; Conquer, Backtrace)</li>
</ul>
<p>所有复杂算法，最后其实就是找它的重复单元是什么</p>
<p>其余五点</p>
<ul>
<li>搜索Search: 深度优先算法 Depth first search, 广度优先算法 Breadth first search, A*, etc</li>
<li>动态规划 Dynamic Programming</li>
<li>二分查找 Binary Search</li>
<li>贪心 Greedy</li>
<li>数学 Math, 几何 Geometry</li>
</ul>
<h2 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h2><p>职业化运动</p>
<ul>
<li>基本功是区别业余和职业选手的根本</li>
<li>基础动作的分解训练和反复练习 –&gt; 最大的误区(只做一遍)<ul>
<li>乒乓球，台球，滑雪</li>
</ul>
</li>
</ul>
<p>解决办法</p>
<ul>
<li>刻意训练 – 过遍数(五毒神掌)</li>
<li>练习缺陷、弱点地方</li>
<li>不舒服、不爽、枯燥</li>
<li>生活中的乒乓球，台球等</li>
</ul>
<h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>即使反馈</p>
<ul>
<li>主动型反馈(自己去找)<ul>
<li>高手代码(GitHub, LeetCode, etc.)</li>
<li>第一视角直播</li>
</ul>
</li>
<li>被动型反馈(高手给你指点)<ul>
<li>code review</li>
<li>教练看你打，给你反馈</li>
</ul>
</li>
</ul>
<h2 id="刷题技巧"><a href="#刷题技巧" class="headerlink" title="刷题技巧"></a>刷题技巧</h2><h3 id="切题四件套–四步系统化思考方式"><a href="#切题四件套–四步系统化思考方式" class="headerlink" title="切题四件套–四步系统化思考方式"></a>切题四件套–四步系统化思考方式</h3><ul>
<li><p>Clarification 明确题目要求 阐明</p>
</li>
<li><p>Possible solutions 想<strong>所有</strong>可能的解法，比较不同的方法的时间空间复杂度，找出最优解法</p>
<ul>
<li>compare (time/space)</li>
<li>optimal (加强)</li>
</ul>
</li>
<li><p>Coding(多写)</p>
</li>
<li><p>Test cases(列举几个，测自己的程序，有始有终)</p>
</li>
</ul>
<h3 id="五毒神掌–五遍刷题法"><a href="#五毒神掌–五遍刷题法" class="headerlink" title="五毒神掌–五遍刷题法"></a>五毒神掌–五遍刷题法</h3><h4 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a>第一遍</h4><ul>
<li>花5分钟时间读题思考(最多10分钟，没有思路走第二步)</li>
<li><strong>直接看解法</strong>(不要纠结) 注意多解法比较优劣，</li>
<li>背诵和默写好的解法</li>
</ul>
<p>算法是理解和运用，不是创造算法</p>
<h4 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a>第二遍</h4><p>马上自己写–LeetCode提交，直到通过<br>多种解法比较、体会–&gt; 优化！</p>
<h4 id="第三遍"><a href="#第三遍" class="headerlink" title="第三遍"></a>第三遍</h4><p>过24小时后，再重复做题<br>不同解法的熟练程度—&gt;专项训练</p>
<h4 id="第四遍"><a href="#第四遍" class="headerlink" title="第四遍"></a>第四遍</h4><p>过了一周： 反复回来练习相同题目</p>
<h4 id="第五遍"><a href="#第五遍" class="headerlink" title="第五遍"></a>第五遍</h4><p>面试前一周恢复性训练(看自己时间安排)</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>职业训练: 拆分知识点、刻意练习、反馈</li>
<li>五步刷题法(五毒神掌)</li>
<li>做算法题最大误区: 只做一遍</li>
</ul>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p>插件VS Code Plugin里搜LeetCode</p>
<p>把Most Votes 最高票的前三个都看一遍</p>
<h3 id="CodeStyle-遵守代码规范"><a href="#CodeStyle-遵守代码规范" class="headerlink" title="CodeStyle 遵守代码规范"></a>CodeStyle 遵守代码规范</h3><h3 id="指法和小操作"><a href="#指法和小操作" class="headerlink" title="指法和小操作"></a>指法和小操作</h3><p>home, end (行头、行尾)<br>Word单词、选单词、选正行<br>IDE自动补全<br>Top tips for IDE-name 自行搜索ide相关使用技巧</p>
<h3 id="自顶向下编程"><a href="#自顶向下编程" class="headerlink" title="自顶向下编程"></a>自顶向下编程</h3><p>关键方法，关键内容放在上边</p>
<p>最开始思考大层次的逻辑</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Alfred</title>
    <url>/posts/Alfred/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Alfred是什么"><a href="#Alfred是什么" class="headerlink" title="Alfred是什么"></a>Alfred是什么</h2><ol>
<li>可以当做app快速启动(关闭)工具来使用</li>
<li>自定义搜索</li>
<li>workflow</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.jianshu.com/p/72fe06566fce">下载</a></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>唤起  <code>option+空格</code><br>设置  <code>command+,</code></p>
<a id="more"></a>

<h2 id="配置百度搜索"><a href="#配置百度搜索" class="headerlink" title="配置百度搜索"></a>配置百度搜索</h2><p>在配置页找到<code>Web Search</code> 点击右下角<code>Edit custom Search</code>. 在弹出框里配置</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Search URL: https://www.baidu.com/s?wd=&#123;query&#125;</span><br><span class="line">Title: 百度(随便写)</span><br><span class="line">keyWord: b</span><br></pre></td></tr></table></figure>

<p>点save</p>
<p>唤醒后再输入框输入<code>b (任意字符)</code> 会自动打开百度搜索</p>
<p>完成上述步骤后， 再点击”Features”-&gt;Default Results-&gt;”Setup fallback results”-&gt;点击弹出的窗口右下角”+”号-&gt;选择Custom Rearch 下的百度(上一步设置的Title)，操作步骤如下图。</p>
<p><img src="/posts/Alfred/addbaidu.png" alt="添加自定义search"><br><img src="/posts/Alfred/addbaidu-input.png" alt="设置百度内容"><br><img src="/posts/Alfred/setdefault.png" alt="修改默认搜索"><br><img src="/posts/Alfred/first-baidu.png" alt="修改默认搜索"></p>
<h2 id="配置自定义终端"><a href="#配置自定义终端" class="headerlink" title="配置自定义终端"></a>配置自定义终端</h2><p>终端使用iTerm2, 可以如下设置<br>在设置页面，左下角<code>Terminal/Shell</code>, 选择Custom</p>
<p>根据iTerm2的版本, <a href="https://github.com/stuartcryan/custom-iterm-applescripts-for-alfred">打开自定义脚本配置</a><br>复制到输入框,即可。</p>
<p>唤醒后， 输入<code>&gt; [shell命令]</code>即可自动打开iTerm2，执行[shell命令]</p>
<p>eg: <code>&gt; cd /</code></p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="百度搜索"><a href="#百度搜索" class="headerlink" title="百度搜索"></a>百度搜索</h3><p><code>option+空格</code> 唤醒, 随便输入内容，下拉列表显示百度搜索，直接回车。</p>
<h2 id="打开指定应用"><a href="#打开指定应用" class="headerlink" title="打开指定应用"></a>打开指定应用</h2><p><code>option+空格</code> 唤醒, 输入<code>设置</code>, <code>chrome</code>等应用名字，会直接显示app，回车打开。</p>
<ul>
<li><code>w</code> 可显示网易云音乐</li>
<li>iterm 打开终端</li>
</ul>
<h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>唤醒直接在输入框输入算式，即可显示结果</p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>在Web Search中添加<code>https://translate.google.cn/?text=&#123;query&#125;</code>，设置快捷键<code>tr</code></p>
<p>唤醒后输入<code>tr 翻译内容</code> 回车，可自动打开谷歌翻译</p>
<h3 id="默认字典翻译"><a href="#默认字典翻译" class="headerlink" title="默认字典翻译"></a>默认字典翻译</h3><p><code>define 翻译内容</code><br>只能翻译词, 没有谷歌智能,可以及时显示翻译内容，不用打开网页</p>
<p>可以在<code>features-&gt;Dictionary-&gt;Defined a word</code>修改<code>denife</code>为<code>de</code></p>
<h2 id="退出某个应用"><a href="#退出某个应用" class="headerlink" title="退出某个应用"></a>退出某个应用</h2><p><code>quit</code> 加空格</p>
<h2 id="alfred-每次开机运行后都提示是否允许访问通讯录"><a href="#alfred-每次开机运行后都提示是否允许访问通讯录" class="headerlink" title="alfred 每次开机运行后都提示是否允许访问通讯录"></a>alfred 每次开机运行后都提示是否允许访问通讯录</h2><p>在终端输入如下命令解决</p>
<p><code>sudo codesign -f -d -s - /Applications/Alfred\ 3.app/Contents/Frameworks/Alfred\ Framework.framework/Versions/A/Alfred\ Framework</code></p>
<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p>open用来打开文件，find用来显示文件所在位置</p>
<p>screensaver显示屏保</p>
<p>lock锁屏—(不生效)</p>
<p>sleep睡眠</p>
<p>trash废纸篓，emptytrash清空废纸篓</p>
<p>shutdown关机，restart重启，logout注销</p>
<h2 id="workflow-查询本机IP"><a href="#workflow-查询本机IP" class="headerlink" title="workflow 查询本机IP"></a>workflow 查询本机IP</h2><p><a href="https://github.com/zenorocha/alfred-workflows/blob/master/ip-address/ip-address.alfredworkflow">下载地址</a></p>
<p>双击导入， 输入ip，即可查询本机ip，按cmd+c可以复制</p>
<h2 id="好的链接推荐"><a href="#好的链接推荐" class="headerlink" title="好的链接推荐"></a>好的链接推荐</h2><p><a href="https://www.jianshu.com/p/e9f3352c785f">5分钟上手Mac效率神器Alfred以及Alfred常用操作</a><br><a href="https://blog.csdn.net/sinat_32023305/article/details/78739118">Alfred Workflow教程与实例</a><br><a href="http://www.alfredworkflow.com/">Workflow列表</a></p>
]]></content>
      <tags>
        <tag>Alfred</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Bundler源码编写</title>
    <url>/posts/Bundler%E6%BA%90%E7%A0%81%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p>安装依赖-<a href="https://babeljs.io/docs/en/babel-parser">相关文档</a></p>
<p><code>npm install @babel/parser @babel/traverse @babel/core @babel/preset-env --save</code></p>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">&#x27;./message.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<p>message.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; word &#125; <span class="keyword">from</span> <span class="string">&#x27;./word.js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`say <span class="subst">$&#123;word&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> message;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>word.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> word = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>bundler.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).default;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析入口文件和依赖</span></span><br><span class="line"><span class="keyword">const</span> moduleAnalyser = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="comment">// 使用babel解析文件成抽象语法树</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(content, &#123;</span><br><span class="line">        sourceType: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> dependencies = &#123;&#125;;</span><br><span class="line">    traverse(ast, &#123;</span><br><span class="line">        <span class="comment">// 声明</span></span><br><span class="line">        <span class="function"><span class="title">ImportDeclaration</span>(<span class="params">&#123; node &#125;</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取绝对路径的文件</span></span><br><span class="line">            <span class="keyword">const</span> dirname = path.dirname(filename);</span><br><span class="line">            <span class="keyword">const</span> newFile = <span class="string">&#x27;./&#x27;</span> + path.join(dirname, node.source.value);</span><br><span class="line">            dependencies[node.source.value] = newFile;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// babel转化es6代码到es5</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">        presets:: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 返回入口文件和依赖文件</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        filename,</span><br><span class="line">        dependencies,</span><br><span class="line">        code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试入口文件解析是否正常</span></span><br><span class="line"><span class="comment">// moduleAnalyser(&#x27;./src/index.js&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖图谱，分析入口文件及入口文件中引入文件的依赖</span></span><br><span class="line"><span class="keyword">const</span> makeDependenciesGraph = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryModule = moduleAnalyser(entry);</span><br><span class="line">    <span class="keyword">const</span> graphArr = [entryModule];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; graphArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = graphArr[i];</span><br><span class="line">        <span class="keyword">const</span> &#123; dependencies &#125; = item;</span><br><span class="line">        <span class="keyword">if</span> (dependencies) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j <span class="keyword">in</span> dependencies) &#123;</span><br><span class="line">                graphArr.push(moduleAnalyser(dependencies[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> graph = &#123;&#125;;</span><br><span class="line">    graphArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        graph[item.filename] = &#123;</span><br><span class="line">            dependencies: item.dependencies,</span><br><span class="line">            code: item.code</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成最终的代码</span></span><br><span class="line"><span class="keyword">const</span> generageCode = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> graph = <span class="built_in">JSON</span>.stringify(makeDependenciesGraph(entry));</span><br><span class="line">    <span class="comment">// 拿到entry, 执行entry对应的代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        (function(graph) &#123;</span></span><br><span class="line"><span class="string">            function require(module) &#123;</span></span><br><span class="line"><span class="string">                function localRequire(relativePath) &#123;</span></span><br><span class="line"><span class="string">                    return require(graph[module].dependencies[relativePath]);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">                (function(require, exports, code)&#123;</span></span><br><span class="line"><span class="string">                    eval(code)</span></span><br><span class="line"><span class="string">                &#125;)(localRequire, exports, graph[module].code)</span></span><br><span class="line"><span class="string">                return exports;</span></span><br><span class="line"><span class="string">            &#125;;</span></span><br><span class="line"><span class="string">            require(&#x27;<span class="subst">$&#123;entry&#125;</span>&#x27;);</span></span><br><span class="line"><span class="string">        &#125;)(<span class="subst">$&#123;graph&#125;</span>);</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const graphInfo = makeDependenciesGraph(&#x27;./src/index.js&#x27;);</span></span><br><span class="line"><span class="keyword">const</span> code = generageCode(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>CSS 代码示例</title>
    <url>/posts/CSS-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="设置元素readonly和disabled样式"><a href="#设置元素readonly和disabled样式" class="headerlink" title="设置元素readonly和disabled样式"></a>设置元素readonly和disabled样式</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#endDate</span><span class="selector-pseudo">:read-only</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>:pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#endDate</span><span class="selector-pseudo">:disabled</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>:not-allowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!---more--->

<h2 id="placeholder样式修改"><a href="#placeholder样式修改" class="headerlink" title="placeholder样式修改"></a>placeholder样式修改</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.input</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.input</span><span class="selector-pseudo">:-moz-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.input</span><span class="selector-pseudo">:-ms-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择被用户选取的元素部分"><a href="#选择被用户选取的元素部分" class="headerlink" title="选择被用户选取的元素部分"></a>选择被用户选取的元素部分</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:lightblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="css选择器，选择除了最后一个以外的元素"><a href="#css选择器，选择除了最后一个以外的元素" class="headerlink" title="css选择器，选择除了最后一个以外的元素"></a>css选择器，选择除了最后一个以外的元素</h2><p>场景：每个li都加右边框，除了最后一个<br>需要写个demo试一下，如果li里嵌套其他元素是否生效</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ab-character-con</span> <span class="selector-class">.l3</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span>&#123;</span><br><span class="line">    <span class="attribute">border-right</span>:<span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="css两端对齐"><a href="#css两端对齐" class="headerlink" title="css两端对齐"></a>css两端对齐</h2><p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓       名</span><br><span class="line">手  机   号</span><br><span class="line">电 话 号 码</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>手机号码<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>账号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// css</span><br><span class="line">div &#123;</span><br><span class="line">    margin: 10px 0;</span><br><span class="line">    width: 100px;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    text-align: justify;</span><br><span class="line">    text-align-last:justify</span><br><span class="line">&#125;</span><br><span class="line">div:after&#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>代码示例</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome插件</title>
    <url>/posts/Chrome%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>Chrome 有丰富的插件, 可以扩展出很多功能, 提高我们的工作效率.</p>
<h2 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a><a href="https://saladict.crimx.com/">沙拉查词</a></h2><p>hrome 中最好的一款翻译插件, chrome 应用商店该插件下的好评如潮.<br>在设置里关闭—默认用本扩展浏览 PDF</p>
<h2 id="Full-Page-Screen-Capture-全网页截屏"><a href="#Full-Page-Screen-Capture-全网页截屏" class="headerlink" title="Full Page Screen Capture (全网页截屏)"></a>Full Page Screen Capture (全网页截屏)</h2><p>该插件可以将整个网页截成一张长图, 并且支持编辑, 有时我们不方便分享网页时, 比如一些内网站点外网访问不了, 通过全网页截屏就是一个很好的办法.</p>
<a id="more"></a>

<h2 id="Infinity-新标签页"><a href="#Infinity-新标签页" class="headerlink" title="Infinity 新标签页"></a><a href="https://www.infinitynewtab.com/">Infinity 新标签页</a></h2><p>替换 chrome 原有首页的一个选择, 功能完善, 可以方便的管理和查找书签, 每天更换一个壁纸, 点击下边的小风车, 可以随机切换壁纸</p>
<h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>是另一款替换 chrome 原有首页的插件, 简介大气, 左上角可以搜索, 右上角展示天气, 中间展示时间, 下方默认有个 todo 的功能, 左下角可以对标签页进行设置.</p>
<h2 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h2><p>让浏览 github 代码变得像本地编辑器一样轻松, 可以搜索文件, 点击代码目录跳转等, 方便地在文件之间切换</p>
<h2 id="Access-Control-Allow-Credentials-true"><a href="#Access-Control-Allow-Credentials-true" class="headerlink" title="Access-Control-Allow-Credentials: true"></a>Access-Control-Allow-Credentials: true</h2><p>允许跨域访问</p>
<h2 id="Allow-Control-Allow-Origin"><a href="#Allow-Control-Allow-Origin" class="headerlink" title="Allow-Control-Allow-Origin: *"></a>Allow-Control-Allow-Origin: *</h2><p>同上</p>
<h2 id="Axure-RP-Extension-for-Chrome"><a href="#Axure-RP-Extension-for-Chrome" class="headerlink" title="Axure RP Extension for Chrome"></a>Axure RP Extension for Chrome</h2><p>Axure查看插件</p>
<h2 id="EditThisCookie"><a href="#EditThisCookie" class="headerlink" title="EditThisCookie"></a>EditThisCookie</h2><p>Cookie修改工具</p>
<h2 id="EverSync-Sync-bookmarks-backup-favorites"><a href="#EverSync-Sync-bookmarks-backup-favorites" class="headerlink" title="EverSync - Sync bookmarks, backup favorites"></a>EverSync - Sync bookmarks, backup favorites</h2><p>保存书签工具</p>
<h2 id="React-Developer-Tools"><a href="#React-Developer-Tools" class="headerlink" title="React Developer Tools"></a>React Developer Tools</h2><h2 id="Redux-DevTools"><a href="#Redux-DevTools" class="headerlink" title="Redux DevTools"></a>Redux DevTools</h2><h2 id="Vue-js-devtools"><a href="#Vue-js-devtools" class="headerlink" title="Vue.js devtools"></a>Vue.js devtools</h2><h2 id="Google-翻译"><a href="#Google-翻译" class="headerlink" title="Google 翻译"></a>Google 翻译</h2><p>谷歌翻译</p>
<h2 id="PageSpeed-Insights-with-PNaCl"><a href="#PageSpeed-Insights-with-PNaCl" class="headerlink" title="PageSpeed Insights (with PNaCl)"></a>PageSpeed Insights (with PNaCl)</h2><p>网站加载速度优化工具</p>
<h2 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a>掘金</h2><p>掘金tab页默认工具<br>为程序员、设计师、产品经理每日发现优质内容。</p>
<h2 id="潮汐-极简番茄钟与白噪音"><a href="#潮汐-极简番茄钟与白噪音" class="headerlink" title="潮汐 - 极简番茄钟与白噪音"></a>潮汐 - 极简番茄钟与白噪音</h2><p>潮汐，屡获殊荣的白噪音专注计时器，帮你保持专注，提升工作效率。</p>
<h2 id="PP谷歌访问助手-永久免费-不限时"><a href="#PP谷歌访问助手-永久免费-不限时" class="headerlink" title="PP谷歌访问助手-永久免费-不限时"></a>PP谷歌访问助手-永久免费-不限时</h2><p>帮助访问被封锁的谷歌和旗下网站。代理服务器稳定，VPN原理，HTTPS级别加密，确保通信安全。</p>
<h2 id="如何安装下载的CRX插件"><a href="#如何安装下载的CRX插件" class="headerlink" title="如何安装下载的CRX插件"></a>如何安装下载的CRX插件</h2><p>(1) 从设置-&gt;更多工具-&gt;扩展程序 打开扩展程序页面，或者地址栏输入 Chrome://extensions/ 按下回车打开扩展程序页<br>(2) 打开扩展程序页面的“开发者模式”(右上角)<br>(3) 将crx文件拖拽到扩展程序页面，完成安装</p>
<h2 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h2><p>安装后可以查找在<a href="https://www.tampermonkey.net/scripts.php">网站</a>找想要的脚本安装</p>
<p>安装方法</p>
<ul>
<li>chrome应用商店</li>
<li><a href="https://www.crx4chrome.com/">不翻墙可用</a></li>
<li>[Tampermonkey下载地址]<a href="https://www.crx4chrome.com/crx/755/">https://www.crx4chrome.com/crx/755/</a></li>
</ul>
<p><a href="https://greasyfork.org/zh-CN/users/104201-%E9%BB%84%E7%9B%90">破解VIP会员视频集合</a></p>
<h2 id="Proxy-SwitchyOmega"><a href="#Proxy-SwitchyOmega" class="headerlink" title="Proxy SwitchyOmega"></a>Proxy SwitchyOmega</h2><p>代理切换工具</p>
<h2 id="GoogleHelper"><a href="#GoogleHelper" class="headerlink" title="GoogleHelper"></a><a href="http://googlehelper.net/">GoogleHelper</a></h2><p>安装可以访问Google</p>
]]></content>
  </entry>
  <entry>
    <title>EventLoop事件循环执行顺序--promise,nextTick,setTimeout</title>
    <url>/posts/EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F--promise,nextTick,setTimeout/</url>
    <content><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>写出下题输出结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout0&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)  </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout3&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">3</span>)  </span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>));</span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>));</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>面试题正确的输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">script end</span><br><span class="line">nextTick</span><br><span class="line">async1 end</span><br><span class="line">promise3</span><br><span class="line">setTimeout0</span><br><span class="line">setImmediate</span><br><span class="line">setTimeout3</span><br></pre></td></tr></table></figure>

<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>node.js的开发者一定都知道它是单线程的，异步不阻塞且高并发的一门语言</p>
<p>node.js中的异步内部原理:（微任务与事件循环）</p>
<p>Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，异步任务最后基于事件循环机制还是要回到主线程，一个个排队执行。</p>
<h2 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a>详细讲解</h2><h3 id="1-本轮循环与次轮循环"><a href="#1-本轮循环与次轮循环" class="headerlink" title="1.本轮循环与次轮循环"></a>1.本轮循环与次轮循环</h3><p>异步任务可以分成两种。</p>
<ol>
<li>追加在本轮循环的异步任务</li>
<li>追加在次轮循环的异步任务</li>
</ol>
<p>所谓”循环”，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式. 本轮循环一定早于次轮循环执行。</p>
<p>Node 规定，<strong>process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。</strong></p>
<h3 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="2.process.nextTick()"></a>2.process.nextTick()</h3><p>1）process.nextTick不要因为有next就被好多小伙伴当作次轮循环。</p>
<p>2）<strong>Node 执行完所有同步任务，接下来就会执行process.nextTick的任务队列。</strong></p>
<p>3）开发过程中如果想让异步任务尽可能快地执行，可以使用process.nextTick来完成。</p>
<h3 id="3-微任务（microtack）"><a href="#3-微任务（microtack）" class="headerlink" title="3.微任务（microtack）"></a>3.微任务（microtack）</h3><p>根据语言规格，<strong>Promise对象的回调函数，会进入异步任务里面的”微任务”（microtask）队列。</strong></p>
<p><strong>微任务队列追加在process.nextTick队列的后面，也属于本轮循环。</strong></p>
<p>根据语言规格，Promise对象的回调函数，会进入异步任务里面的”微任务”（microtask）队列。</p>
<p>微任务队列追加在process.nextTick队列的后面，也属于本轮循环。所以，下面的代码总是先输出3，再输出4。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>// 输出结果3，4</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>// 输出结果 1，3，2，4</p>
<p>注意，只有前一个队列全部清空以后，才会执行下一个队列。两个队列的概念 nextTickQueue 和微队列microTaskQueue，也就是说开启异步任务也分为几种，像promise对象这种，开启之后直接进入微队列中，微队列内的就是那个任务快就那个先执行完，但是针对于队列与队列之间不同的任务，还是会有先后顺序，这个先后顺序是由队列决定的。</p>
<h3 id="4-事件循环的阶段（idle-prepare忽略了这个阶段）"><a href="#4-事件循环的阶段（idle-prepare忽略了这个阶段）" class="headerlink" title="4.事件循环的阶段（idle, prepare忽略了这个阶段）"></a>4.事件循环的阶段（idle, prepare忽略了这个阶段）</h3><p>事件循环最阶段最详细的讲解（官网：<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout%EF%BC%89">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout）</a></p>
<ol>
<li><p>timers阶段</p>
<p>次阶段包括setTimeout()和setInterval()</p>
</li>
<li><p>IO callbacks</p>
<p> 大部分的回调事件，普通的caollback</p>
</li>
<li><p>poll阶段</p>
<p>网络连接，数据获取，读取文件等操作</p>
</li>
<li><p>check阶段</p>
<p>setImmediate()在这里调用回调</p>
</li>
<li><p>close阶段<br> 一些关闭回调，例如socket.on(‘close’, …)</p>
</li>
</ol>
<ul>
<li>事件循环注意点</li>
</ul>
<p>1）Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。</p>
<p>同步任务<br>发出异步请求<br>规划定时器生效的时间<br>执行process.nextTick()等等</p>
<p>最后，上面这些事情都干完了，事件循环就正式开始了。</p>
<p>2）事件循环同样运行在单线程环境下，高并发也是依靠事件循环，每产生一个事件，就会加入到该阶段对应的队列中，此时事件循环将该队列中的事件取出，准备执行之后的callback。</p>
<p>3）假设事件循环现在进入了某个阶段，即使这期间有其他队列中的事件就绪，也会先将当前队列的全部回调方法执行完毕后，再进入到下一个阶段。</p>
<h4 id="5-事件循环中的setTimeOut与setImmediate"><a href="#5-事件循环中的setTimeOut与setImmediate" class="headerlink" title="5.事件循环中的setTimeOut与setImmediate"></a>5.事件循环中的setTimeOut与setImmediate</h4><p>由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码应该先输出1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。</p>
<p>这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。</p>
<p>实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。</p>
<p>但是，下面的代码一定是先输出2，再输出1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(<span class="string">&#x27;test.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line"> setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。</p>
<h4 id="6-同步任务中async以及promise的一些误解"><a href="#6-同步任务中async以及promise的一些误解" class="headerlink" title="6.同步任务中async以及promise的一些误解"></a>6.同步任务中async以及promise的一些误解</h4><ul>
<li>问题1:</li>
</ul>
<p>在那道面试题中，在同步任务的过程中，不知道大家有没有疑问，为什么不是执行完async2输出后执行async1 end输出，而是接着执行promise1？</p>
<p>解答:引用阮一峰老师书中一句话：“ async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。”<br>简单的说，先去执行后面的同步任务代码，执行完成后，也就是表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果。（其实还是本轮循环promise的问题，最后的resolve属于异步，位于本轮循环的末尾。）</p>
<ul>
<li>问题2:</li>
</ul>
<p>console.log(‘promise2’)为什么也是在resolve之前执行？</p>
<p>解答：注：此内容来源与阮一峰老师的ES6书籍，调用resolve或者reject并不会终结promise的参数函数的执行。因为立即resolved的Promise是<strong>本轮循环</strong>的末尾执行，同时总是<strong>晚于本轮循环的同步任务</strong>。正规的写法调用resolve或者reject以后，Promise的使命就完成了，后继操作应该放在then方法后面。所以最好在它的前面加上return语句，这样就不会出现意外</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//后面的语句不会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题3:</li>
</ul>
<p>promise3和script end的执行顺序是否有疑问？</p>
<p>解答：因为立即resolved的Promise是<strong>本轮循环</strong>的末尾执行，同时总是<strong>晚于本轮循环的同步任务</strong>。 Promise 是一个立即执行函数，但是他的成功（或失败：reject）的回调函数 resolve 却是一个异步执行的回调。当执行到 resolve() 时，这个任务会被放入到回调队列中，等待调用栈有空闲时事件循环再来取走它。本轮循环中最后执行的。</p>
<h2 id="整体结论"><a href="#整体结论" class="headerlink" title="整体结论"></a>整体结论</h2><p> 顺序的整体总结就是:<br> 同步任务-&gt; 本轮循环 -&gt;次轮循环<br> 正常语句 -&gt; nextTick -&gt; Promise对象的回调函数 -&gt; 事件循环中的setTimeOut与setImmediate</p>
<h2 id="附件-参考资料"><a href="#附件-参考资料" class="headerlink" title="附件:参考资料"></a>附件:参考资料</h2><p>node.js官网：</p>
<ul>
<li>[事件循环]：(<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout)">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout)</a></li>
<li><a href="https://nodejs.org/dist/latest-v10.x/docs/api/timers.html">Timers</a></li>
<li><a href="https://github.com/koala-coding/goodBlog/blob/master/docs/node/eventLoop.md">eventLoop解析</a></li>
</ul>
]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>nextTick</tag>
        <tag>async</tag>
        <tag>await</tag>
        <tag>setTimeout</tag>
        <tag>setImmediate</tag>
        <tag>EventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Express学习积累</title>
    <url>/posts/Express%E5%AD%A6%E4%B9%A0%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h2 id="express-官网"><a href="#express-官网" class="headerlink" title="express 官网"></a>express <a href="http://www.expressjs.com.cn/">官网</a></h2><h2 id="pexpress-应用生成器"><a href="#pexpress-应用生成器" class="headerlink" title="pexpress 应用生成器"></a><a href="http://www.expressjs.com.cn/starter/generator.html">pexpress 应用生成器</a></h2><p>想用node来做一个后台服务时，看到了express，可以直接生成一个简单的应用骨架。在此记录一下学习过程。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install express-generator -g</span><br></pre></td></tr></table></figure>

<p>express -h 查看可用的命令行选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">express -h</span><br><span class="line"></span><br><span class="line">  Usage: express [options] [dir]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --<span class="built_in">help</span>          output usage information</span><br><span class="line">    -V, --version       output the version number</span><br><span class="line">    -e, --ejs           add ejs engine support (defaults to jade)</span><br><span class="line">        --hbs           add handlebars engine support</span><br><span class="line">    -H, --hogan         add hogan.js engine support</span><br><span class="line">    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)</span><br><span class="line">        --git           add .gitignore</span><br><span class="line">    -f, --force         force on non-empty directory</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2. 创建应用"></a>2. 创建应用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">express node-server</span><br></pre></td></tr></table></figure>

<p>会自动创建好多文件<br>各文件含义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www // 启动服务，并监听端口</span><br><span class="line">├── package.json // 包管理文件</span><br><span class="line">├── public //直接访问端口会访问到的文件</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes // 路由设置，设置不同请求路径不同响应，user.js就是自定义的</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views   //渲染视图</span><br><span class="line">    ├── error.jade</span><br><span class="line">    ├── index.jade</span><br><span class="line">    └── layout.jade</span><br></pre></td></tr></table></figure>

<h2 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3. 安装依赖"></a>3. 安装依赖</h2><p>先进入项目路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> node-server</span><br></pre></td></tr></table></figure>

<p>安装所有依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DEBUG=node-server npm start</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>官网提示windows需要用下面的命令，实际测试，用上面的就可以。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> DEBUG=node-server &amp; npm start</span><br></pre></td></tr></table></figure>

<h2 id="在浏览器中打开-http-localhost-3000-网址就可以看到这个应用了"><a href="#在浏览器中打开-http-localhost-3000-网址就可以看到这个应用了" class="headerlink" title="在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了"></a>在浏览器中打开 <a href="http://localhost:3000/">http://localhost:3000/</a> 网址就可以看到这个应用了</h2><h3 id="express-热部署，修改不需要重新启动"><a href="#express-热部署，修改不需要重新启动" class="headerlink" title="express 热部署，修改不需要重新启动"></a>express 热部署，修改不需要重新启动</h3><p>安装node-dev</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g node-dev</span><br></pre></td></tr></table></figure>

<p>修改package.json的scripts，增加dev命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;node ./bin/www&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;node-dev ./bin/www&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="现在启动服务用-npm-run-dev-即可"><a href="#现在启动服务用-npm-run-dev-即可" class="headerlink" title="现在启动服务用 npm run dev 即可"></a>现在启动服务用 npm run dev 即可</h4><p>修改代码会发现已经更改。</p>
<h3 id="express-设置get和post用同一个方法"><a href="#express-设置get和post用同一个方法" class="headerlink" title="express 设置get和post用同一个方法"></a>express 设置get和post用同一个方法</h3><p>之前是 router.get(‘/‘) 或 router.post(‘/‘), 直接用router.all(‘/‘)即可</p>
<p>node读写文件api</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">readFile()</span><br><span class="line"></span><br><span class="line">writeFile()</span><br><span class="line"></span><br><span class="line">readFileAsync()</span><br><span class="line"></span><br><span class="line">writeFileAsync()</span><br><span class="line"></span><br><span class="line">createReadStream()</span><br><span class="line"></span><br><span class="line">createWriteStream()</span><br><span class="line"></span><br><span class="line">writestream的区别和例子没看到</span><br></pre></td></tr></table></figure>

<h2 id="vscode-调试node搞不定啊，"><a href="#vscode-调试node搞不定啊，" class="headerlink" title="vscode 调试node搞不定啊，~~~~~~~~~"></a>vscode 调试node搞不定啊，~~~~~~~~~</h2><h2 id="用express生成token-供权限校验"><a href="#用express生成token-供权限校验" class="headerlink" title="用express生成token 供权限校验"></a>用express生成token 供权限校验</h2>]]></content>
  </entry>
  <entry>
    <title>JavaScript - async/await</title>
    <url>/posts/JavaScript-async-await/</url>
    <content><![CDATA[<p><a href="https://segmentfault.com/a/1190000017718513">参考链接</a></p>
<p><code>async/await</code> 提供了使用同步样式代码编写异步代码的方式，而不会阻塞主线程。</p>
<h2 id="async-作用是什么"><a href="#async-作用是什么" class="headerlink" title="async 作用是什么"></a>async 作用是什么</h2><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">MDN</a>:</p>
<p>async 函数返回的是一个 Promise 对象。<br>async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，<br>async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。</p>
<p>如果 async 函数没有返回值， 它会返回 Promise.resolve(undefined)。</p>
<blockquote>
<p>语法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// statements</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> A=<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> A=<span class="keyword">async</span> ()=&gt;&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="await-作用是什么-MDN"><a href="#await-作用是什么-MDN" class="headerlink" title="await 作用是什么(MDN)"></a>await 作用是什么(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">MDN</a>)</h2><blockquote>
<p>语法</p>
</blockquote>
<p><code>[return_value] = await expression;</code></p>
<p>await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，await 可以等任意表达式的结果）。</p>
<p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p>
<p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p>
<blockquote>
<p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>
</blockquote>
<p>async函数中，如果有多个await关键字时，如果有一个await的状态变成了rejected，那么后面的操作都不会继续执行，promise也是同理await的返回结果就是后面promise执行的结果，可能是resolves或者rejected的值使用场景循环遍历方便了代码需要同步的操作（文件读取，数据库操作等）</p>
<a id="more"></a>

<h2 id="async-await-的优点"><a href="#async-await-的优点" class="headerlink" title="async/await 的优点"></a>async/await 的优点</h2><p><strong>async/await 带给我们的最重要的好处是同步编程风格。</strong></p>
<p>代码演示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getBooksByAuthorWithAwait</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> books = <span class="keyword">await</span> bookModel.fetchAll();</span><br><span class="line">    <span class="comment">// 这里的books就是异步执行返回的结果</span></span><br><span class="line">    <span class="keyword">return</span> books.filter(<span class="function"><span class="params">b</span> =&gt;</span> b.authorId === id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="function"><span class="title">getBooksByAuthorWithPromise</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bookModel.fetchAll().then(<span class="function"><span class="params">books</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> books.filter(<span class="function"><span class="params">b</span> =&gt;</span> b.authorId === id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里调用<code>this.getBooksByAuthorWithAwait(id)</code>返回的是Promise对象， 需要执行.then才能获取到异步返回的结果</strong></p>
<ul>
<li><p>很明显async/await版本比Promise版本更容易理解，如果忽略await关键字，代码看起来像其他任何同步代码。<br>目前所有主流浏览器都完全支持异步功能。</p>
</li>
<li><p>浏览器支持意味着不必转换代码。便于调试。</p>
</li>
<li><p>async关键字的好处。async声明<code>getBooksByAuthorWithAwait</code>函数返回值是一个Promise。</p>
</li>
</ul>
<p>调用者可以安全的使用<code>getBooksByAuthorWithAwait.then(...)</code>或<code>await getBooksByAuthorWithAwait()</code>.</p>
<p>Promise在异常情况下不能调用<code>.then</code>。有了async声明，这种情况就不会出现</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getBooksByAuthorWithPromise</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!authorId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bookModel.fetchAll()</span><br><span class="line">        .then(<span class="function"><span class="params">books</span> =&gt;</span> books.filter(<span class="function"><span class="params">b</span> =&gt;</span> b.authorId === id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果调用<code>getBooksByAuthorWithPromise</code>可能返回Promise(正常情况)或null(异常情况id为空), 在这种情况下，调用者不能调用.then()</p>
<h2 id="async-await-可能会产生误导"><a href="#async-await-可能会产生误导" class="headerlink" title="async/await 可能会产生误导"></a>async/await 可能会产生误导</h2><p>有人将<code>async/await</code>与Promise进行比较，并声称它是JavaScript下一代异步编程风格。<br><code>async/await</code>是一种改进，但它只不过是一种语法糖，不会完全改变编码风格。</p>
<p>本质上，async 函数仍然是Promise。 正确使用async函数之前，必须先了解Promise. 更糟糕的是大多数时，需要在使用Promise时同时使用async函数。</p>
<p>这意味着，getBooksByAuthorWithAwait将返回一个Promise，所以也可以使用.then(…)方式来调用它。</p>
<h2 id="async-await常见错误"><a href="#async-await常见错误" class="headerlink" title="async/await常见错误"></a>async/await常见错误</h2><p>使用async/await时，常见错误：</p>
<h3 id="太过串行化"><a href="#太过串行化" class="headerlink" title="太过串行化"></a>太过串行化</h3><p>尽管await可以使代码看起来像是同步的，但实际上他们仍然是异步的，必须避免太过串行化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getBooksByAuthor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> books = <span class="keyword">await</span> bookModel.fetchAll();</span><br><span class="line">    <span class="keyword">const</span> author = <span class="keyword">await</span> authorModel.fetch(id);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        author,</span><br><span class="line">        books: books.filter(<span class="function"><span class="params">book</span> =&gt;</span> book.authorId === id)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码看似正确，然而这是错误的。</p>
<ul>
<li><ol>
<li>await bookModel.fetchAll() 会等待fetchAll()直到fetchAll返回结果</li>
</ol>
</li>
<li><ol start="2">
<li>然后await authorModel.fetch(id) 被调用</li>
</ol>
</li>
</ul>
<p>第二个fetch不依赖于第一个fetch的结果，实际上可以并行调用。然而这里用了await，两个调用变成串行，总的执行时间比并行版本要长的多。</p>
<p>正确写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getBooksByAuthor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bookPromise = bookModel.fetchAll();</span><br><span class="line">    <span class="keyword">const</span> authorPromise = authorModel.fetch(id);</span><br><span class="line">    <span class="keyword">const</span> book = <span class="keyword">await</span> bookPromise;</span><br><span class="line">    <span class="keyword">const</span> author = <span class="keyword">await</span> authorPromise;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        author,</span><br><span class="line">        books: books.filter(<span class="function"><span class="params">book</span> =&gt;</span> book.authorId === id)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组中每个item都要请求异步数据，必须依赖Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getAuthor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 会引起串行调用，增加运行时间</span></span><br><span class="line">    <span class="comment">// const authors = _.map(</span></span><br><span class="line">    <span class="comment">//     authorIds,</span></span><br><span class="line">    <span class="comment">//     id =&gt; await authorModel.fetch(id)</span></span><br><span class="line">    <span class="comment">// );</span></span><br><span class="line">    <span class="comment">// 正确方式</span></span><br><span class="line">    <span class="keyword">const</span> promises = _.map(authorIds, <span class="function"><span class="params">id</span> =&gt;</span> authorModel.fetch(id));</span><br><span class="line">    <span class="keyword">const</span> authors = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，仍需将流程视为异步的，然后用await写出同步的代码，在复杂的流程中，直接使用Promise可能更方便。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在Promise中，异步函数有两个返回值： resolved 和 rejected。可以用.then()处理正常情况，用.catch()处理异常情况。然而用<code>async/await</code>方式处理错误比较棘手。</p>
<h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><p>推荐用try…catch语法捕获异常。所以最好把await命令放到try…catch代码块中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bookModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">fetchAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                reject(&#123;<span class="attr">error</span>: <span class="number">400</span>&#125;)</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getBooksByAuthorWithAwait</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> books = <span class="keyword">await</span> bookModel.fetchAll();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error); <span class="comment">// &#123;error: 400&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕捉到异常处理方法：</p>
<ul>
<li>返回一个正常值。(不在catch块中使用任何return语句，相当于return undefined)</li>
<li>想让调用者处理它，可以直接抛出普通的错误对象。如throw error。允许在Promise.catch中处理错误。</li>
</ul>
<p>使用try…catch好处：</p>
<ul>
<li>简单，易于理解</li>
<li>如果不需要每部执行错误处理，可以在一个try…catch块中包装多个await调用来处理一个地方的错误。</li>
</ul>
<p>这种方法有个缺陷，由于try…catch会捕获代码块中的异常，所以通常不会被Promise捕获的异常也会被捕获到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">fetchAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        cb();<span class="comment">// cb未定义，导致异常</span></span><br><span class="line">        <span class="keyword">return</span> fetch(<span class="string">&#x27;/books&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bookModel.fetchAll();</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 打印 cb is not undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码会打印<code>cb is not undefined</code>，这个错误是由console.log打印出来，而不是JavaScript本身。有时，这是致命的，如果BookModel被包含在一些列函数调用中，其中一个调用者吞噬了错误，那么很难找到这样一个未定义错误。</p>
<h3 id="让函数返回两个值"><a href="#让函数返回两个值" class="headerlink" title="让函数返回两个值"></a>让函数返回两个值</h3><p><code>[err, user] = await to(UserModel.findById(1));</code></p>
<h3 id="使用-catch"><a href="#使用-catch" class="headerlink" title="使用.catch"></a>使用.catch</h3><p>await的功能：它将等待Promise完成它的工作。Promise.catch()也会返回一个Promise。</p>
<p>所以我们可以这样处理错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// books === undefined if error happens,</span></span><br><span class="line"><span class="comment">// since nothing returned in the catch statement</span></span><br><span class="line"><span class="keyword">let</span> books = <span class="keyword">await</span> bookModel.fetchAll().catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(err);&#125;);</span><br></pre></td></tr></table></figure>

<p>这个方法有两个小问题：</p>
<ul>
<li>它是Promise和async函数的混合体。仍需要理解Promise是如何工作的。</li>
<li>错误理解先于正常路径，这是不直观的。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>async/await 关键字无疑是对J avaScript异步编程的改进。它可以使代码更容易阅读和调试。<br>然而，为了正确地使用它们，必须完全理解 Promise，因为 async/await 只不过是 Promise 的语法糖，本质上仍然是 Promise。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>es8</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript:for-of到generator</title>
    <url>/posts/JavaScript-for-of%E5%88%B0generator/</url>
    <content><![CDATA[<h1 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h1><p>在<code>JavaScript</code>中, 循环数组可以通过<code>map, filter, for of</code> 等来遍历一个数组.</p>
<p>为什么for of 可以遍历数组或类数组对象(<code>String, Maps, Sets, arguments</code>)？<br>为什么不能用来遍历一个对象？</p>
<p>循环数组时，需要两个信息：</p>
<blockquote>
<ol>
<li>对应下标的值</li>
<li>是否遍历结束的标志</li>
</ol>
</blockquote>
<p>在控制台打印一个数组看一下结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.dir(arr);</span><br></pre></td></tr></table></figure>

<p>在__proto__中可以看到<code>Symbol(Symbol.iterator)</code><br><strong>数组或类数组对象的原型中都实现了一个方法<code>Symbol.iterator</code></strong></p>
<p>可以用以下方法查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.dir(map);</span><br><span class="line"><span class="keyword">const</span> str = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.dir(str);</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.dir(set);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="iterator-迭代器"><a href="#iterator-迭代器" class="headerlink" title="iterator(迭代器)"></a>iterator(迭代器)</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">迭代协议 mdn文档</a></p>
<p>The iterator protocol(可迭代协议允许) JavaScript 对象去定义或定制它们的迭代行为.<br>所以上面出现的<code>Symbol.iterator</code>就是数组对于这个协议的实现。</p>
<h3 id="数组怎么实现了一个iterator呢？"><a href="#数组怎么实现了一个iterator呢？" class="headerlink" title="数组怎么实现了一个iterator呢？"></a>数组怎么实现了一个iterator呢？</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators">MDN 文档</a></p>
<p>一个迭代器对象 ，知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在  JavaScript 中 迭代器是一个对象，它提供了一个next() 方法，用来返回序列中的下一项。这个方法返回包含两个属性：done和 value。</p>
<p>这里获取上面数组的<code>Symbol.iterator</code>, 打印出来看看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.dir(iterator);</span><br></pre></td></tr></table></figure>
<p>在iterator的原型中有<code>next</code>方法，执行next方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: 2, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: 3, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当下标超出时，value:undefined<br>iterator每次都返回一个对象，这个对象包含两个信息，当前下标的值<code>value</code>, 遍历是否结束的标志<code>done</code></p>
</blockquote>
<p><strong>为什么for of 不能遍历一个对象呢？JavaScript 的对象中没有实现一个这样的 iterator</strong></p>
<p>可以打印看一下<code>console.log(&#123;&#125;)</code></p>
<h3 id="为什么在Object中没有内置迭代器？"><a href="#为什么在Object中没有内置迭代器？" class="headerlink" title="为什么在Object中没有内置迭代器？"></a>为什么在Object中没有内置迭代器？</h3><p>先了解一下基本概念</p>
<p>遍历对象只会在两种层级上对一个<code>JavaScript</code>对象进行遍历：</p>
<ul>
<li>程序的层级。对一个对象进行迭代，是在迭代展示其结构的对象属性。举个栗子：<code>Array.prototype.length</code>这个属性与对象的结构相关，但却不是它的数据。</li>
<li>数据的层级。迭代数据结构并提取它的数据。举个栗子：迭代数组，对它的每个数据进行迭代，如果<code>arr=[a，b，c]</code>，迭代器访问的是<code>1,2,3</code></li>
</ul>
<p><strong><code>JavaScript</code>虽然不支持用<code>for of</code>遍历对象，但提供了<code>for in</code> 方法来遍历所有非<code>Symbol</code>类型并且是可枚举的属性。</strong></p>
<p>标准不支持，自己实现一个for-of来遍历对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> &#123; key, value &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> &#123; key, value &#125; <span class="keyword">of</span> &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在实现iterator代码中，用到了Generator 结构：<code>function*() &#123;&#125;</code></p>
<h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generators</a></h2><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen(); </span><br><span class="line"><span class="comment">// &quot;Generator &#123; &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里打印一下gen， <code>console.dir(gen)</code><br>可以看到<code>next</code>方法。执行看结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = gen();</span><br><span class="line">s.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">s.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">s.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">s.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>generator可以实例化出一个iterator，yield语句就是用来中断代码的执行的。配合next() 方法，每次只会执行一个yield语句。</p>
<h3 id="generator特性"><a href="#generator特性" class="headerlink" title="generator特性"></a>generator特性</h3><ul>
<li><p>yield后面可以跟上另一个Generator, 并且他们会按照次序执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* gen2();</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = gen();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1,4,5,2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>return 会终结整个Generator。卸载return后的yield不会执行。</p>
</li>
</ul>
<h3 id="Generator有什么用？"><a href="#Generator有什么用？" class="headerlink" title="Generator有什么用？"></a>Generator有什么用？</h3><p>能够中断执行代码，帮助我们控制异步代码的执行顺序。</p>
<p>例如有两个异步的函数 A 和 B, 并且 B 的参数是 A 的返回值，也就是说，如果 A 没有执行结束，我们不能执行 B</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">effect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; param &#125; = <span class="keyword">yield</span> A();</span><br><span class="line">  <span class="keyword">const</span> &#123; result &#125; = <span class="keyword">yield</span> B(param);</span><br><span class="line">  <span class="built_in">console</span>.table(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = effect();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure>

<p>执行两次 next() 得到结果，看起来很繁琐。<br>假设每次执行 A() / B() 的请求结束之后，都会自动执行 next() 即可解决。</p>
<p>参考<a href="https://github.com/tj/co">co</a>源码</p>
<h2 id="Generator原理"><a href="#Generator原理" class="headerlink" title="Generator原理"></a>Generator原理</h2><p>async 和await 只是Generator的语法糖。<br><a href="https://dvajs.com/guide/concepts.html#effect">dva</a>中有Effect概念，它就是使用Generator来解决异步请求的问题。</p>
<h3 id="Generator和Promise如何异步编程"><a href="#Generator和Promise如何异步编程" class="headerlink" title="Generator和Promise如何异步编程"></a>Generator和Promise如何异步编程</h3><p>一些基本概念：</p>
<ul>
<li>Generator作为 ES6 中使用协程的解决方案来处理异步编程的具体实现，它的特点是: Generator 中可以使用 yield 关键字配合实例 gen 调用 next() 方法，来将其内部的语句分割执行。 简言之 : next() 被调用一次，则 yield 语句被执行一句，随着 next() 调用， yield 语句被依次执行。</li>
</ul>
<p>Promise表示一个异步操作的最终状态（完成或失败），以及其返回的值。参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise-MDN</a></p>
<p>异步编程使用Generator和Promise实现的原理：</p>
<ol>
<li>因为 Generator 本身 yield 语句是分离执行的，所以我们利用这一点，在 yield 语句中返回一个 Promise 对象</li>
<li>首次调用 Generator 中的 next() 后, 假设返回值叫 result ,那么此时 result.value 就是我们定义在 yield 语句中的 Promise 对象</li>
</ol>
<blockquote>
<p>注意：在这一步，我们已经把原来的执行流程暂停，转而执行 Promise 的内容,已经实现了控制异步代码的执行，因为此时我们如果不继续执行 next() 则 generator 中位于当前被执行的 yield 后面的内容，将不会继续执行,这已经达到了我们需要的效果<br>3. 接下来我们就是在执行完当前 Promise 之后，让代码继续往下执行，直到遇到下一个 yield 语句:<br>这一步是最关键的  所以我们怎么做呢:</p>
</blockquote>
<ul>
<li>步骤1： 在当前的 Promise 的 then() 方法中，继续执行 gen.next()</li>
<li>步骤2： 当 gen.next() 返回的结果 result.done === true 时,我们拿到 result.value【也就是一个新的 Promise 对象】再次执行并且在它的then() 方法中继续上面的步骤1，直至 result.done === false 的时候。这时候调用 resolve() 使 promise 状态改变，因为所有的 yield 语句已经被执行完。</li>
</ul>
<p>步骤1 保证了我们可以走到下一个 yield 语句<br>步骤2 保证了下一个 yield 语句执行完不会中断，直至 Generator 中的最后一个 yield 语句被执行完。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><blockquote>
<p>从co库中的一个demo开始，了解我们的整个异步请求封装实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> me.loginAction(me.form);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>引入co库，并且用co来包裹了一个generator（生成器）对象。<br>接下来我们看下co对于包裹起来的generator做了什么处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.获取当前co函数的执行上下文环境,获取到参数列表</span></span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 2.返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  判断并且使用ctx:context(上下文环境)和arg:arguments(参数列表)初始化generator并且复制给gen</span></span><br><span class="line">    <span class="comment">// 注意:</span></span><br><span class="line">    <span class="comment">// gen = gen.apply(ctx, args)之后</span></span><br><span class="line">    <span class="comment">// 我们调用 gen.next() 时，返回的是一个指针，实际的值是一个对象</span></span><br><span class="line">    <span class="comment">// 对象的形式：&#123;done:[false | true], value: &#x27;&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.apply(ctx, args);</span><br><span class="line">    <span class="comment">// 当返回值不为gen时或者gen.next的类型不为function【实际是判断是否为generator】时</span></span><br><span class="line">    <span class="comment">// 当前promise状态被设置为resolve而结束</span></span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">    <span class="comment">// 否则执行onFulfilled()</span></span><br><span class="line">    onFulfilled();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里发生了什么</p>
<ol>
<li>返回一个 promise</li>
<li>promise 中将被包裹的 generator 实例化为一个指针，指向 generator 中第一个 yield 语句</li>
<li>判断 generator 实例化出来的指针是否存在：如果没有 yield 语句则指针不存在, 判断指针 gen.next() 方法是否为 function ：如果不为 function 证明无法执行 gen.next()<br>条件有一项不满足就将 promise 的状态置为 resolve<br>否则执行 onFulfilled()</li>
</ol>
<p>看下 onFulfilled() 的实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在执行onFulfilled时，定义了一个ret来储存gen.next(res)执行后的指针对象</span></span><br><span class="line">    <span class="keyword">var</span> ret;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    ret = gen.next(res);</span><br><span class="line">    <span class="comment">// 在这里，yield语句抛出的值就是&#123;value:me.loginAction(me.form), done:false&#125;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将ret对象传入到我们定义在promise中的next方法中</span></span><br><span class="line">    next(ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>onFulfilled 最主要的工作就是</p>
<ol>
<li>执行 gen.next() 使代码执行到 yield 语句</li>
<li>将执行后返回的结果传入我们自定义的 next() 方法中</li>
</ol>
<p>next() 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 进入next中首先判断我们传入的ret的done状态:</span></span><br><span class="line"><span class="comment">// 情况1:ret.done = true 代表我们这个generator中所有yield语句都已经执行完。</span></span><br><span class="line"><span class="comment">// 那么将ret.value传入到resolve()中，promise的状态变成解决，整个过程结束。</span></span><br><span class="line">    <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line"><span class="comment">// 情况2:当前ret.done = false 代表generator还未将所有的yield语句执行完，那么这时候</span></span><br><span class="line"><span class="comment">// 我们把当前上下文和ret.value传入toPromise中，将其转换为对应的Promise对象`value`</span></span><br><span class="line">    <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line"><span class="comment">// 当value确实是一个promise对象的时候，return value.then(onFulfilled,onRejected)</span></span><br><span class="line"><span class="comment">// 我们重新进入到了generator中，执行下一条yield语句</span></span><br><span class="line">    <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">    + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="built_in">String</span>(ret.value) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>next 主要工作</p>
<ol>
<li>判断上一次 yield 语句的执行结果</li>
<li>将 yield 的 result 的 value 值【其实就是我们要异步执行的 Promise 】</li>
<li>执行 value 的 then 方法，重新进入到 onFulfilled 方法中，而在 onFulfilled 中，我们又将进入到当前方法，如此循环的调用，实现了 generator 和 Promise 的执行切换，从而实现了 Promise 的内容按照我们所定义的顺序执行。</li>
</ol>
<p>至此实现异步操作的控制。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://juejin.im/post/5c4045d1f265da617831ace3">前端怪谈_2从 Dva 的 Effect 到 Generator + Promise 实现异步编程</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>es6</tag>
        <tag>for of</tag>
        <tag>generator</tag>
        <tag>iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript算法之复杂度分析</title>
    <url>/posts/JavaScript%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5c2a1d9d6fb9a04a0f654581">JavaScript 算法之复杂度分析</a></p>
<p>想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念—–复杂度分析。</p>
<p>==<strong>是数据结构和算法学习的精髓。</strong>==</p>
<p>是什么：<br>数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。<br>数据结构是为算法服务的，算法是要作用再特定的数据结构上的。</p>
<p>学什么：</p>
<ol>
<li>效率和资源消耗的度量衡–复杂度分析。</li>
<li>最常用、最基础的20个数据结构与算法，学习他们的：“来历”、“特点”、“适合解决什么问题”和“实际的应用场景”。<br> 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire树<br> 算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</li>
</ol>
<p>怎么学:</p>
<ol>
<li>边学边练，每周花 1~2 小时集中攻关三节课涉及的数据结构和算法，全部写出来。</li>
<li>主动提问、多思考、多互动。在留言区增加自己的留言。</li>
<li>自我激励，每次学习完做一篇学习笔记。</li>
<li>沉下心不要浮躁，先把这些基础的数据结构和算法，还有学习方法熟练掌握后，再追求更高层次。</li>
</ol>
<a id="more"></a>

<h2 id="为什么需要复杂度分析"><a href="#为什么需要复杂度分析" class="headerlink" title="为什么需要复杂度分析"></a>为什么需要复杂度分析</h2><p>执行代码进行复杂度分析弊端</p>
<ol>
<li>测试结果非常依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ol>
<h2 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h2><p>不需要具体的测试数据来测试，就可以粗略估计算法执行效率的方法</p>
<p>一、什么是复杂度分析？</p>
<ol>
<li>数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。</li>
<li>因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</li>
<li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。</li>
<li>复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</li>
</ol>
<p>二、为什么要进行复杂度分析？</p>
<ol>
<li>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。</li>
<li>掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</li>
</ol>
<p>三、如何进行复杂度分析？</p>
<ol>
<li><p>大O表示法</p>
<p> 1）来源<br> 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br> 2）特点<br> 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</p>
</li>
<li><p>复杂度分析法则</p>
</li>
</ol>
<p>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</p>
<p>四、常用的复杂度级别？</p>
<p>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）</p>
<p>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）</p>
<p>五、如何掌握好复杂度分析方法？<br>复杂度分析关键在于多练，所谓孰能生巧。</p>
<h2 id="06-链表（上）：如何实现LRU缓存淘汰算法"><a href="#06-链表（上）：如何实现LRU缓存淘汰算法" class="headerlink" title="06 | 链表（上）：如何实现LRU缓存淘汰算法"></a>06 | 链表（上）：如何实现LRU缓存淘汰算法</h2><p>五、应用<br>1.如何分别用链表和数组实现LRU缓冲淘汰策略？<br>1）什么是缓存？<br>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。<br>2）为什么使用缓存？即缓存的特点<br>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。<br>3）什么是缓存淘汰策略？<br>指的是当缓存被用满时清理数据的优先顺序。<br>4）有哪些缓存淘汰策略？<br>常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。<br>5）链表实现LRU缓存淘汰策略<br>当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。<br>6）数组实现LRU缓存淘汰策略<br>方式一：首位置保存最新访问数据，末尾位置优先清理<br>当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。<br>方式二：首位置优先清理，末尾位置保存最新访问数据<br>当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）<br>2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）<br>1）前提：字符串以单个字符的形式存储在单链表中。<br>2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。<br>3）将链表中的字符倒序存储一份在另一个链表中。<br>4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。<br>六、设计思想<br>时空替换思想：“用空间换时间” 与 “用时间换空间”<br>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一、什么是递归？</p>
<ol>
<li>递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。</li>
<li>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</li>
<li>基本上，所有的递归问题都可以用递推公式来表示，比如</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">f(n) = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">f(n)=n*f(n-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>二、为什么使用递归？递归的优缺点？</p>
<ol>
<li>优点：代码的表达力很强，写起来简洁。</li>
<li>缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</li>
</ol>
<p>三、什么样的问题可以用递归解决呢？</p>
<p>一个问题只要同时满足以下3个条件，就可以用递归来解决：</p>
<ol>
<li>问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。</li>
<li>问题与子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ol>
<p>四、如何实现递归？</p>
<ol>
<li><p>递归代码编写</p>
<p> 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p>
</li>
<li><p>递归代码理解</p>
</li>
</ol>
<p>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。<br>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。<br>而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>
<p>五、递归常见问题及解决方案</p>
<ol>
<li>警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。</li>
<li>警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。</li>
</ol>
<p>六、如何将递归改写为非递归代码？</p>
<p>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/posts/Linux/</url>
    <content><![CDATA[<p>终端上传下载文件</p>
<p>在终端往linux上传文件<br><code>rz -b</code></p>
<p>中文的无法上传，需要先将文件名改为英文的，上传上去后，再改为中文。</p>
<p>下载<br><code>sz  -b</code></p>
<p>参考:<a href="https://segmentfault.com/a/1190000011048277">链接</a></p>
<h2 id="一、命令基本格式"><a href="#一、命令基本格式" class="headerlink" title="一、命令基本格式"></a>一、命令基本格式</h2><p><a href="http://www.cnblogs.com/ShaYeBlog/p/5576601.html">http://www.cnblogs.com/ShaYeBlog/p/5576601.html</a></p>
<p>git 打tag</p>
<blockquote>
<p>命令 [选项][参数]</p>
</blockquote>
<p>注意：<br>    1. 个别命令不遵循此格式<br>    2. 有多个选项，可以写在一起<br>    3. 简写：-a == -all, ll == ls -l</p>
<h3 id="1-1-ls"><a href="#1-1-ls" class="headerlink" title="1.1 ls"></a>1.1 ls</h3><ul>
<li>ls -a 显示所有文件，包括隐藏文件</li>
<li>ls -l 显示详细信息</li>
<li>ls -d 查看目录属性</li>
<li>ls -h 人性化显示文件大小 ，K/M</li>
<li>ls -i 显示inode</li>
</ul>
<h3 id="1-2-文件权限-10位"><a href="#1-2-文件权限-10位" class="headerlink" title="1.2 文件权限(10位)"></a>1.2 文件权限(10位)</h3><blockquote>
<p>第一位是文件类型，后面每3位一组</p>
</blockquote>
<p>-rw-r-r–</p>
<ul>
<li>-文件类型(-文件 d目录 l软链接)</li>
<li>rw- u所有者</li>
<li>r– g所属组</li>
<li>r– o其他人</li>
<li>r 读 w 写 x 执行</li>
</ul>
<a id="more"></a>

<h2 id="二、文件处理命令"><a href="#二、文件处理命令" class="headerlink" title="二、文件处理命令"></a>二、文件处理命令</h2><p>linux中一切皆文件。目录为目录文件。普通文件用来保存数据，目录文件用来保存目录。</p>
<h3 id="2-1-常用目录介绍及作用"><a href="#2-1-常用目录介绍及作用" class="headerlink" title="2.1 常用目录介绍及作用"></a>2.1 常用目录介绍及作用</h3><ol>
<li><p>/ 根目录</p>
</li>
<li><p>/sbin ，/bin 命令保存目录</p>
<blockquote>
<p>根目录下的bin和sbin，usr下的bin 和sbin都是用来保存系统命令。bin目录下的命令任何用户都可以执行，sbin下只有root才可以执行。Linux通过此方式区分用户权限</p>
</blockquote>
</li>
<li><p>/boot 启动目录，启动相关文件</p>
</li>
<li><p>/dev 设备文件保存目录</p>
</li>
<li><p>/etc 配置文件保存目录</p>
</li>
<li><p>/home  普通用户的家目录</p>
</li>
<li><p>/lib 系统库保存目录</p>
</li>
<li><p>/mnt 系统挂载u盘、移动硬盘目录</p>
</li>
<li><p>/media 挂载光盘目录</p>
</li>
<li><p>/misc 外接磁带机挂载目录</p>
</li>
<li><p>/root 超级用户的家目录</p>
</li>
<li><p>/tmp 临时目录 可存放临时数据</p>
</li>
<li><p>/proc 直接写入内存的</p>
</li>
<li><p>/sys 同 /proc不能直接操作</p>
</li>
<li><p>/usr 系统软件资源目录</p>
<ul>
<li>/usr/bin/ 系统命令 (普通用户)</li>
<li>/usr/sbin/ 系统命令 (超级用户)</li>
</ul>
</li>
</ol>
<h3 id="2-2-目录处理文件命令"><a href="#2-2-目录处理文件命令" class="headerlink" title="2.2 目录处理文件命令"></a>2.2 目录处理文件命令</h3><ul>
<li><p>mkdir -p [目录名]<br>  -p 递归创建<br>  make directories<br>  mkdir  src<br>  mkdir  bin</p>
</li>
<li><p>cd 切换所在目录</p>
<p>  change directory</p>
<blockquote>
<p>简化操作</p>
</blockquote>
<p>  cd ~ 进入当前用户的家目录<br>  cd - 进入上次目录<br>  cd .. 进入上一级目录<br>  cd . 进入当前目录</p>
</li>
<li><p>pwd 查看当前所在目录位置<br>  print working directory</p>
</li>
</ul>
<h3 id="2-3-文件处理命令"><a href="#2-3-文件处理命令" class="headerlink" title="2.3 文件处理命令"></a>2.3 文件处理命令</h3><ul>
<li><p>rmdir [目录名] 删除空目录</p>
<p>  remove empty directory</p>
</li>
<li><p>rm -rf [文件或目录] 删除文件或目录</p>
<p>  选项：</p>
<pre><code>-r 删除目录
-f 强制

rm [文件名] :提示是否删除
rm -r [目录]: 删除目录需加-r，目录中含有子文件，将继续询问是否删除
rm -rf [目录]: 删除目录，直接删除

**自杀指令** rm -rf /</code></pre>
</li>
<li><p>cp [选项] [原文件或目录] [目标目录] 复制</p>
<p>  copy</p>
<pre><code>  -r 复制目录
  -p 连带文件属性复制
  -d 若源文件是链接文件，则复制链接属性
  -a 相当于-pdr 目标文件和源文件属性相同
  被复制文件的时间为执行复制命令的时间，若要使被复制的文件与原文件属性完全一致，需加 -a</code></pre>
<hr>
<pre><code>eg:
cp abc /tmp/ 若目标目录不加文件名，则原名复制
cp abc /tmp/ana 目标文件加入文件名，改名复制
cp -r ja/ /tmp/ 复制目录
cp -a ja/ /tmp/ 完全复制，包含所有属性</code></pre>
</li>
<li><p>mv [原文件或目录] [目标目录] move</p>
<pre><code>eg:
mv ja /tmp/ 剪切
mv abc longls 原文件与目标目录在同一个目录，则为重命名</code></pre>
</li>
<li><p>date 查看当前系统时间</p>
</li>
</ul>
<h3 id="2-4-链接命令"><a href="#2-4-链接命令" class="headerlink" title="2.4 链接命令"></a>2.4 链接命令</h3><ul>
<li><p>格式化硬盘<br>??</p>
</li>
<li><p>ln -s [源文件] [目标文件]    link</p>
</li>
</ul>
<blockquote>
<p>选项 -s 创建软链接</p>
</blockquote>
<ul>
<li><p>硬链接特征</p>
<p>  拥有相同i节点和存储block块，可以看做是同一个文件。</p>
<p>  硬链接与源文件拥有相同的i节点。</p>
<p>  删除原文件或硬链接文件的任何一文件，不影响文件索引操作？？？原文件删除了吗？</p>
<pre><code>1）可以通过i节点识别
2）不能跨分区建立
3）ln ./source/abc ./target/bcd.hard 创建后，引用计数+1
1) ls -i ./souce/abc ./target/bcd.hard 可使用ls -i 来查看文件i节点</code></pre>
<p>  不建议创建硬链接文件：</p>
<ul>
<li>文件过于隐蔽，除了i节点很难区分它是不是硬链接</li>
<li>硬链接限制较多，不能跨分区，不能针对目录，使用中容易出现错误使用方法</li>
</ul>
</li>
<li><p>软链接特征</p>
<ol>
<li>类似于Windows的快捷方式</li>
<li>软链接拥有自己的i节点和block块，只保存原文件的文件名和节点号，并没有实际的文件数据。</li>
<li>软链接的权限都为777，但实际权限要看原文件权限。</li>
<li>修改任意文件，另一个都会改变。</li>
<li>删除原文件，软链接不能用</li>
<li>创建软链接，原文件一定要写绝对路径，否则软链接会到它所在的同一个目录去找原文件</li>
</ol>
</li>
</ul>
<p><a href="https://www.processon.com/view/link/59b296fae4b0d3fbea262c6c%22">硬链接与软链接图</a></p>
<h2 id="三、文件搜索命令"><a href="#三、文件搜索命令" class="headerlink" title="三、文件搜索命令"></a>三、文件搜索命令</h2><h3 id="3-1-locate-文件名"><a href="#3-1-locate-文件名" class="headerlink" title="3.1 locate 文件名"></a>3.1 locate 文件名</h3><pre><code>速度快，但只能按照文件名搜索，不能进行更复杂的搜索</code></pre>
<h3 id="3-2-whereis"><a href="#3-2-whereis" class="headerlink" title="3.2 whereis"></a>3.2 whereis</h3><pre><code>用于搜索命令所在的路径已经帮助文档所在的位置
-b: 只查找可执行文件
-m: 只查找帮助文件</code></pre>
<h3 id="3-3-which"><a href="#3-3-which" class="headerlink" title="3.3 which"></a>3.3 which</h3><pre><code>能看到命令的路径，如果有别名，还能看到别名的说明
只能看到外部安装的命令，如pwd.</code></pre>
<h3 id="3-4-PATH"><a href="#3-4-PATH" class="headerlink" title="3.4 $PATH"></a>3.4 $PATH</h3><pre><code>类似于Windows的环境变量，执行命令时，从path定义的目录中寻找
echo $PATH</code></pre>
<h3 id="3-5-whoami"><a href="#3-5-whoami" class="headerlink" title="3.5 whoami"></a>3.5 whoami</h3><pre><code>显示当前用户</code></pre>
<h3 id="3-6-whatis"><a href="#3-6-whatis" class="headerlink" title="3.6 whatis"></a>3.6 whatis</h3><pre><code>查询一个命令执行什么功能，并将结果打印到终端上</code></pre>
<h3 id="3-7-find-搜索范围-搜索条件"><a href="#3-7-find-搜索范围-搜索条件" class="headerlink" title="3.7 find [搜索范围] [搜索条件]"></a>3.7 find [搜索范围] [搜索条件]</h3><blockquote>
<ol>
<li>默认完全匹配</li>
<li>避免大范围搜索，非常浪费资源，建议不在直接’/‘目录下搜索</li>
</ol>
</blockquote>
<pre><code>find /root -iname test 不区分要搜索的test大小写格式
find /root -user root 搜索root目录下所有属于root用户的文件
find /root -nouser 没有所属者的文件。

linux中每个文件都有所属者，如果没有，一般都是垃圾文件。
但还是有特殊的，内核产生的文件，就没有所属者，一般在proc和sys目录下；
还有外来文件，u盘拷入的文件也会忽略所有者</code></pre>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><pre><code>通配符有3种
1. * 匹配任何字符
    find /home -name &quot;*test*&quot;,显示所有名字带test的文件
    find /home -name &quot;*&quot;, home目录下所有文件，包括隐藏文件
2. ? 匹配任意一个字符
3. [] 匹配任意一个中括号内的字符，
    find /home -name &quot;test[12]&quot; 显示test1 test2文件
    find /home -name &quot;[12]*&quot; 显示1或2开头的文件
    find /home -name &quot;*[12]&quot; 显示所有1或2结尾的文件</code></pre>
<h4 id="find-按文件时间搜索"><a href="#find-按文件时间搜索" class="headerlink" title="find 按文件时间搜索"></a>find 按文件时间搜索</h4><pre><code>1. find /home -mtime +10 在home目录下，查找10天前修改的文件
2. find /home -mtime 10                    10天前当天的文件
3. find /home -mtime -10                   10天内修改的文件

atime 文件访问时间  ctime 改变文件属性 mtime 修改文件内容</code></pre>
<h4 id="find-目录-size-大小"><a href="#find-目录-size-大小" class="headerlink" title="find 目录 -size 大小"></a>find 目录 -size 大小</h4><pre><code>小写k和大写M
find /etc -size +20k -a -size -50k  查找/etc/目录下大于20k并且小于50k的文件
-a and 与，两个条件都满足
-o or  或，两个条件满足一个即可

find /etc -size +20k -a -size -50k -exec ls -lh &#123;&#125; \;
查找/etc 目录下，大于20k且小于50k的文件，并显示详细信息
-exec/ -ok 命令 &#123;&#125; \; 对搜索结果执行操作

固定格式：-exec &#123;&#125; \\ ，表示直接对前面的搜索结果进行后面的命令处理。？？？</code></pre>
<h4 id="grep-选项-字符串-文件名"><a href="#grep-选项-字符串-文件名" class="headerlink" title="grep [选项] 字符串 文件名"></a>grep [选项] 字符串 文件名</h4><pre><code>-i 忽略大小写
-v 排除指定字符串</code></pre>
<blockquote>
<p>find与grep的区别</p>
</blockquote>
<pre><code>find: 在系统中搜索符合条件的文件名，如果需要匹配，使用通配符，为完全匹配
grep: 在文件中搜索符合条件的字符串，如果需要匹配，使用正则表达式，为包含匹配</code></pre>
<h2 id="四、帮助命令"><a href="#四、帮助命令" class="headerlink" title="四、帮助命令"></a>四、帮助命令</h2><h3 id="4-1-man-命令名称-manual"><a href="#4-1-man-命令名称-manual" class="headerlink" title="4.1 man 命令名称  manual"></a>4.1 man 命令名称  manual</h3><p>进入man命令操作，q退出；输入: / -d 搜索’-d’字符串；按n往下搜，shfit+n 网上搜</p>
<h3 id="4-2-其他帮助命令"><a href="#4-2-其他帮助命令" class="headerlink" title="4.2 其他帮助命令"></a>4.2 其他帮助命令</h3><ul>
<li><p>命令 –help</p>
</li>
<li><p>info 命令<br>  ls –help</p>
<p>  -回车 进入带*号的命令<br>  -u 进入上层页面<br>  -n 进入下一个帮助小节<br>  -p 进入上一个帮助小节<br>  -q 退出</p>
</li>
</ul>
<h2 id="五、压缩与解压缩命令"><a href="#五、压缩与解压缩命令" class="headerlink" title="五、压缩与解压缩命令"></a>五、压缩与解压缩命令</h2><blockquote>
<p>.zip .gz .bz2 .tar.gz .tar.bz2</p>
</blockquote>
<h3 id="5-1-zip"><a href="#5-1-zip" class="headerlink" title="5.1 zip"></a>5.1 zip</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip 压缩文件名 源文件 <span class="comment"># 压缩文件</span></span><br><span class="line">zip -r 压缩目录名 源目录 <span class="comment"># 压缩目录</span></span><br><span class="line"></span><br><span class="line">unzip 压缩文件 <span class="comment"># 解压缩文件</span></span><br></pre></td></tr></table></figure></code></pre>
<h3 id="5-2-gz"><a href="#5-2-gz" class="headerlink" title="5.2 gz"></a>5.2 gz</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip 源文件 <span class="comment"># 压缩为.gz格式的压缩文件，源文件会消失</span></span><br><span class="line">gzip -c 源文件&gt;压缩文件 <span class="comment"># 压缩为.gz格式，源文件会保留</span></span><br><span class="line">gzip -r 目录 <span class="comment"># 压缩目录下所有的文件夹，但不能压缩目录</span></span><br><span class="line"></span><br><span class="line">gzip -d 压缩文件 <span class="comment"># 解压缩文件</span></span><br><span class="line">gunzip 压缩文件 <span class="comment"># 解压缩文件</span></span><br></pre></td></tr></table></figure></code></pre>
<h3 id="5-3-bzip格式"><a href="#5-3-bzip格式" class="headerlink" title="5.3 bzip格式"></a>5.3 bzip格式</h3><p>bzip 不能压缩目录</p>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bzip2 源文件 <span class="comment"># 压缩文件 源文件会消失</span></span><br><span class="line">bzip2 -k 源文件 <span class="comment"># 压缩后 保留源文件</span></span><br><span class="line"></span><br><span class="line">bzip -d 压缩文件 <span class="comment"># 解压bzip2文件</span></span><br><span class="line">bunbzip 压缩文件 <span class="comment"># 解压文件</span></span><br></pre></td></tr></table></figure></code></pre>
<h3 id="5-4-tar-gz-tar-bz2"><a href="#5-4-tar-gz-tar-bz2" class="headerlink" title="5.4 tar.gz tar.bz2"></a>5.4 tar.gz tar.bz2</h3><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf 打包文件名 源文件 <span class="comment"># 压缩为tar格式</span></span><br><span class="line">tar -zvcf 压缩包名.tar.gz 源文件 <span class="comment"># 压缩为.tar.gz格式</span></span><br><span class="line">tar -jvcf 压缩包名.tar.bz2 源文件 <span class="comment"># 压缩为.tar.bz2格式</span></span><br><span class="line"><span class="comment"># -c 打包</span></span><br><span class="line"><span class="comment"># -v 显示过程</span></span><br><span class="line"><span class="comment"># -f 指定打包后的文件名</span></span><br><span class="line"></span><br><span class="line">tar -xvf 打包文件名 <span class="comment"># 解压tar格式</span></span><br><span class="line">tar -zxvf 压缩包名.tar.gz <span class="comment"># 解压.tar.gz格式</span></span><br><span class="line">tar -jxvf 压缩包名.tar.bz2 <span class="comment"># 解压.tar.bz2格式</span></span><br><span class="line"><span class="comment"># -x 解压包</span></span><br><span class="line"><span class="comment"># -z 压缩为tar.gz格式</span></span><br><span class="line"><span class="comment"># -j 压缩为.tar.bz2格式</span></span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<p>其他用法</p>
</blockquote>
<pre><code>1. 指定解压位置
tar -jxvf打包文件名 -C 绝对路径
2. 同时压缩多个文件到指定路径
tar -zcvf 绝对路径 （/tmp/） 打包文件名 源文件 源文件
3. 查看压缩包内文件，不解压
tar -ztvf 压缩包文件名

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg <span class="comment"># 将目录里所有jpg文件打包成tar.jpg</span></span><br><span class="line">tar –czf jpg.tar.gz *.jpg <span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span></span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg <span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span></span><br><span class="line">tar –cZf jpg.tar.Z *.jpg <span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span></span><br><span class="line">rar a jpg.rar *.jpg <span class="comment"># rar格式的压缩，需要先下载rar for linux</span></span><br><span class="line">zip jpg.zip *.jpg <span class="comment"># zip格式的压缩，需要先下载zip for linux</span></span><br></pre></td></tr></table></figure></code></pre>
<p>解压</p>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar –xvf file.tar <span class="comment"># 解压 tar包</span></span><br><span class="line">tar -xzvf file.tar.gz <span class="comment"># 解压tar.gz</span></span><br><span class="line">tar -xjvf file.tar.bz2 <span class="comment"># 解压 tar.bz2</span></span><br><span class="line">tar –xZvf file.tar.Z <span class="comment"># 解压tar.Z</span></span><br><span class="line">unrar e file.rar <span class="comment"># 解压rar</span></span><br><span class="line">unzip file.zip <span class="comment"># 解压zip</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<h2 id="六、关机和重启命令"><a href="#六、关机和重启命令" class="headerlink" title="六、关机和重启命令"></a>六、关机和重启命令</h2><h3 id="6-1-关机和重启"><a href="#6-1-关机和重启" class="headerlink" title="6.1 关机和重启"></a>6.1 关机和重启</h3><blockquote>
<p>shutdown [选项] 时间</p>
</blockquote>
<pre><code>时间后面加&quot;&amp;&quot;,表示将当前计划任务放置后台运行！若不放置，当前界面直到关机/重启都无法进行操作。
这时，如果当前用户按下ctrl+c ，可以取消本次关机或重启的操作；
而其他用户按下ctrl+c，不会取消关机或重启，但可以中断退出，继续其他操作。</code></pre>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><pre><code>-h 关机
-r 重启
-c 取消上一个关机命令</code></pre>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><pre><code> now //现在
 时: 分 // 后面的时间可以使用[+m]格式，表示多少分钟后执行。
 也可以用[hh:mm]格式，表示指定的时间执行，该时间是24小时制的</code></pre>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><pre><code>shutdown -h 05:30 设定凌晨05:30关机
shutdown -h now 立即关机
shutdown -r 05:30 设定凌晨05:30重启
shutdown -r now 立即重启
shutdown -c 取消前一个关机或重启命令</code></pre>
<h3 id="6-2-系统运行级别"><a href="#6-2-系统运行级别" class="headerlink" title="6.2 系统运行级别"></a>6.2 系统运行级别</h3><pre><code>runlevel 查看运行级别 前级别 当前级别
logout 注销

0    //关机
1    //单用户(类似windows安全模式）
2    //不完全多用户，不含NFS服务（字符界面，不包含文件共享服务）
3    //完全多用户（字符界面）
4    //未分配
5    //图形界面
6    //重启</code></pre>
<h2 id="七、挂载与卸载命令"><a href="#七、挂载与卸载命令" class="headerlink" title="七、挂载与卸载命令"></a>七、挂载与卸载命令</h2><h3 id="7-1-挂载-可理解为分配盘符"><a href="#7-1-挂载-可理解为分配盘符" class="headerlink" title="7.1 挂载(可理解为分配盘符)"></a>7.1 挂载(可理解为分配盘符)</h3><p>(1)查询与自动挂载</p>
<p>mount 查询系统中已挂载的设备<br>mount -a 依据配置文件/etc/fstab的内容，自动挂载</p>
<p>光盘 U盘 数据不建议写入自动挂载</p>
<p>(2) 挂载命令的格式</p>
<blockquote>
<p>mount [-t 文件系统] [-o 特殊选项][设备文件名][挂载点]</p>
</blockquote>
<h4 id="mount选项"><a href="#mount选项" class="headerlink" title="mount选项"></a>mount选项</h4><p>-t 文件系统：加入文件系统类型来指定挂载的类型，ext3,ext4,光盘：iso9660等文件系统<br>-o 特殊选项：可以指定挂载的额外选项</p>
<h2 id="7-2-挂载-卸载光盘-没用了吧"><a href="#7-2-挂载-卸载光盘-没用了吧" class="headerlink" title="7.2 挂载/卸载光盘 没用了吧"></a>7.2 挂载/卸载光盘 没用了吧</h2><h2 id="7-3-挂载U盘"><a href="#7-3-挂载U盘" class="headerlink" title="7.3 挂载U盘"></a>7.3 挂载U盘</h2><p>先看U盘的设备名，然后再挂载</p>
<p>fdisk -l //查看系统中已经识别的硬盘</p>
<p>mount -t vfat /dev/sdb1 /mnt/usb/</p>
<p>注:</p>
<pre><code>vfat 指的是fat32文件系统，单个文件不超过4G
Linux默认不支持NTFS文件系统，可以下载ntfs-3g软件安装</code></pre>
<h2 id="八、用户登录查看命令"><a href="#八、用户登录查看命令" class="headerlink" title="八、用户登录查看命令"></a>八、用户登录查看命令</h2><h3 id="8-1-w"><a href="#8-1-w" class="headerlink" title="8.1 w"></a>8.1 w</h3><pre><code>查看系统当前信息(负载和开机时间等信息) 当前已经登录的用户及用什么终端进入。</code></pre>
<blockquote>
<p>load average: X.XX X.XX X.XX 表示系统在1分钟内 5分钟内 15分钟内 的平均负载(CPU内存)<br>USER: 用户<br>TTY:登录终端 pts/0 第一个远程终端<br>LOGIN@: 登录时间<br>IDLE: 用户闲置时间<br>JCPU: 指的是和该终端连接的所有进程占用的时间。<br>PCPU: 指当前进程所占用的时间<br>WHAT: 当前正在运行的命令</p>
</blockquote>
<h3 id="8-2-who-与w类似，但信息有所简化"><a href="#8-2-who-与w类似，但信息有所简化" class="headerlink" title="8.2 who 与w类似，但信息有所简化"></a>8.2 who 与w类似，但信息有所简化</h3><pre><code>会显示登录来源IP地址</code></pre>
<h3 id="8-3-last"><a href="#8-3-last" class="headerlink" title="8.3 last"></a>8.3 last</h3><pre><code>查看当前登录和过去登录的用户信息
可以看到reboot时间，实际是查看/var/log/wtmp但必须用last命令才能看</code></pre>
<h3 id="8-4-lastlog"><a href="#8-4-lastlog" class="headerlink" title="8.4 lastlog"></a>8.4 lastlog</h3><pre><code>查看所有用户最后一次登录时间
/var/log/lastlog 不能直接看，也是用lastlog看</code></pre>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ul>
<li>:w 报错</li>
<li>:q 退出</li>
<li>:! 强制保存</li>
<li>:ls 列出所有文件</li>
<li>:n 下一个</li>
<li>:N 上一个</li>
<li>:15跳转到指定行</li>
<li>/xxx 从光标位置开始向后搜索 xxx 字符串</li>
<li>?xxx 从光标位置开始向前搜索</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>mac 经验</title>
    <url>/posts/Mac%20%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="mac日常经验积累"><a href="#mac日常经验积累" class="headerlink" title="mac日常经验积累"></a>mac日常经验积累</h2><p>记录日常经验</p>
<h2 id="在-Mac-OS-X-的-Terminal-上如何修改行首的显示"><a href="#在-Mac-OS-X-的-Terminal-上如何修改行首的显示" class="headerlink" title="在 Mac OS X 的 Terminal 上如何修改行首的显示"></a>在 Mac OS X 的 Terminal 上如何修改行首的显示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo scutil --<span class="built_in">set</span> HostName 新的主机名</span><br></pre></td></tr></table></figure>

<p>执行命令后，再输入 exit 结束当前终端进程。重新打开终端，就会发现主机名已经修改为新的主机名了。</p>
<p>然后重启terminal</p>
<h2 id="keyboard键盘设置"><a href="#keyboard键盘设置" class="headerlink" title="keyboard键盘设置"></a>keyboard键盘设置</h2><p>按command+空格或用Alfred搜keyboard, 打开键盘设置窗口<br>把按键重复和重复前延迟调到最快，可提升打字效率</p>
<h2 id="窗口平铺工具"><a href="#窗口平铺工具" class="headerlink" title="窗口平铺工具"></a>窗口平铺工具</h2><p><a href="https://itunes.apple.com/cn/app/magnet/id441258766?mt=12&ign-mpt=uo=4">Magnet</a></p>
<p>在xclient.info可以下载到</p>
<h2 id="mac创建文件夹需要密码"><a href="#mac创建文件夹需要密码" class="headerlink" title="mac创建文件夹需要密码"></a>mac创建文件夹需要密码</h2><p>从终端进到目标文件夹或目标文件夹上级</p>
<p>执行<code>sudo chmod -R 777 xxx</code>, xxx是你需要添加写权限的文件夹名称</p>
<h2 id="mac录屏"><a href="#mac录屏" class="headerlink" title="mac录屏"></a>mac录屏</h2><p>自带软件即可录制<br>QuickTime Player</p>
<h2 id="mac-安装-tomcat"><a href="#mac-安装-tomcat" class="headerlink" title="mac 安装 tomcat"></a>mac 安装 tomcat</h2><ol>
<li><p>按照百度经验，安装Java jdk，配置环境变量<br> 检查Java版本 java -version<br> echo $JAVA_HOME</p>
</li>
<li><p>下载tomcat，官网版</p>
</li>
<li><p>修改授权<br> 进入tomcat的bin目录,修改授权</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ bin <span class="built_in">pwd</span></span><br><span class="line">/Users/yp/Documents/workspace/apache-tomcat-7.0.68/bin</span><br><span class="line">➜ bin sudo chmod 755 *.sh</span><br></pre></td></tr></table></figure>

<ol>
<li>sudo为系统超级管理员权限.</li>
<li>chmod 改变一个或多个文件的存取模式</li>
<li>755代表用户对该文件拥有读、写、执行的权限，同组的其他人员拥有执行和读的权限，没有写的权限，其它用户的权限和同组人员一样.</li>
<li>777代表，user,group ,others ,都有读写和可执行权限.</li>
<li>chmod -R 777 folername,获取文件夹权限.</li>
</ol>
</li>
</ol>
<!---more--->

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>二、启动<br>执行启动命令 sudo sh ./startup.sh<br>访问<a href="http://localhost:8080/">http://localhost:8080/</a></p>
<p>关闭</p>
<p>sudo sh ./shutdown.sh</p>
<p>或直接./shutdown.sh</p>
<p>安装 nginx</p>
<p>先安装 homebrew</p>
<p>brew install nginx</p>
<p>mac 下 vim 快捷键</p>
<p>不在编辑状态下按 dd 删除行<br><a href="https://www.jianshu.com/p/6f13474d36ac">链接</a></p>
<h2 id="查看mac内存和cpu占用"><a href="#查看mac内存和cpu占用" class="headerlink" title="查看mac内存和cpu占用"></a>查看mac内存和cpu占用</h2><p>系统自带APP–活动监视器, 可以查看</p>
<h2 id="mac-添加任何来源允许权限"><a href="#mac-添加任何来源允许权限" class="headerlink" title="mac 添加任何来源允许权限"></a>mac 添加任何来源允许权限</h2><p>在命令行执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  sudo spctl --master-disable</span><br></pre></td></tr></table></figure>

<p>输入密码,再回到隐私里，就能看到任何来源.</p>
<h2 id="如何卸载-paragon-NTFS-for-mac"><a href="#如何卸载-paragon-NTFS-for-mac" class="headerlink" title="如何卸载 paragon NTFS for mac"></a>如何卸载 paragon NTFS for mac</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">找到 /Library/Application Support/Paragon Software 目录</span><br><span class="line"></span><br><span class="line">sudo ./com.paragon-software.ntfs.uninstall</span><br></pre></td></tr></table></figure>

<h2 id="mac本地绑定hosts"><a href="#mac本地绑定hosts" class="headerlink" title="mac本地绑定hosts"></a>mac本地绑定hosts</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts  </span><br><span class="line"></span><br><span class="line">添加以下内容</span><br><span class="line">10.180.112.208 www.baidu.com www.jd.com</span><br></pre></td></tr></table></figure>

<p>可以添加多个域名, 也可以一个</p>
<h2 id="mac手势快捷键"><a href="#mac手势快捷键" class="headerlink" title="mac手势快捷键"></a>mac手势快捷键</h2><p>1.三指拖动✨✨✨✨✨<br>    设置-&gt;辅助功能-&gt;鼠标与触控板-&gt;触控板选项-&gt;启动拖移-&gt;三指拖移<br>    可以在触控板在任何软件标题栏拖动该窗口<br>2.docker程序坞缩放✨✨✨✨✨<br>    放大选中, 最大<br>    鼠标放到docker上可以看到该程序图标放大<br>3.点按✨✨✨✨✨<br>    设置-&gt;触控板-&gt;轻点来点按<br>    单机只需轻点触控板, 不用用力按<br>4.显示器排列✨✨✨✨✨<br>    设置-&gt;显示器-&gt;排列<br>    mac如果外接显示器,可以拖动显示器位置来排列位置,方便鼠标移动到另一个显示器<br>5.全屏下切换窗口✨✨✨<br>    四指滑动</p>
<h2 id="mac安装homebrew"><a href="#mac安装homebrew" class="headerlink" title="mac安装homebrew"></a>mac安装<a href="https://brew.sh/index_zh-cn">homebrew</a></h2><p>Homebrew的安装非常简单，打开终端复制、粘贴以下命令，回车，搞定(请放心使用，原汁原味的官方安装方法搬运）<br><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
<h2 id="新建管理员用户怎么弄"><a href="#新建管理员用户怎么弄" class="headerlink" title="新建管理员用户怎么弄"></a>新建管理员用户怎么弄</h2><p>点击“系统偏好设置”-“用户与群组”,点解锁，输入密码，然后点击左下角的“+”新建一个管理员用户，然后回到电脑主屏幕，点击右上角菜单的当前用户，然后选择新建的用户切换进入使用。</p>
<h2 id="触发角"><a href="#触发角" class="headerlink" title="触发角"></a>触发角</h2><p>在「桌面与屏幕保护程序」-「屏幕保护程序」<br>可以设置鼠标在每个角落的时候相应的操作。</p>
<p>可用于锁屏，显示桌面</p>
<h2 id="MAC-快捷键"><a href="#MAC-快捷键" class="headerlink" title="MAC 快捷键"></a>MAC 快捷键</h2><p>Mac中主要有四个修饰键，分别是Command，Control，Option和Shift。</p>
<p>Command是Mac里最重要的修饰键，在大多数情况下相当于Windows下的Ctrl。所以以下最基本操作很好理解：<br>Command-Z 撤销<br>Command-X 剪切　　<br>Command-C 拷贝（Copy）　　<br>Command-V 粘贴　　<br>Command-A 全选（All）　　<br>Command-S 保存（Save)　　<br>Command-F 查找（Find）</p>
<p>截图：<br>Command-Shift-4 截取所选屏幕区域到一个文件　　<br>Command-Shift-3 截取全部屏幕到文件　　<br>Command-Shift-Control-3 截取全部屏幕到剪贴板　　<br>Command-Shift-4 截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口　　<br>Command-Shift-Control-4 截取所选屏幕区域到剪贴板，或按空格键仅捕捉一个窗<br>现在直接用微信的快捷键了</p>
<p>在应用程序中：<br>Command-Option-esc 打开强制退出窗口　　<br>Command-H 隐藏（Hide）当前正在运行的应用程序窗口　　<br>Command-Option-H 隐藏（Hide）其他应用程序窗口　　<br>Command-Q 退出（Quit）最前面的应用程序　　<br>Command-Shift-Z 重做，也就是撤销的逆向操作　　<br>Command-Tab 在打开的应用程序列表中转到下一个最近使用的应用程序，相当于Windows中（Alt+Tab）　　<br>Command-Option-esc 打开“强制退出”窗口，如果有应用程序无响应，可在窗口列表中选择强制退出</p>
<p>文本处理：<br>Command-右箭头 将光标移至当前行的行尾　　<br>Command-B 切换所选文字粗体（Bold）显示　　<br>fn-Delete 相当于PC全尺寸键盘上的Delete，也就是向后删除　　<br>fn-上箭头 向上滚动一页（Page Up）　　<br>fn-下箭头 向下滚动一页（Page Down）　　<br>fn-左箭头 滚动至文稿开头（Home）　　<br>fn-右箭头 滚动至文稿末尾（End）　　<br>Command-右箭头 将光标移至当前行的行尾　　<br>Command-左箭头 将光标移至当前行的行首　　<br>Command-下箭头 将光标移至文稿末尾　　<br>Command-上箭头 将光标移至文稿开头　　<br>Option-右箭头 将光标移至下一个单词的末尾　　<br>Option-左箭头 将光标移至上一个单词的开头　　<br>Control-A 移至行或段落的开头</p>
<p>在Finder中：<br>Command-Option-V 剪切文件　　<br>Command-Shift-N 新建文件夹（New）　　<br>Command-Shift-. 显示或隐藏系统文件　　<br>Command-Shift-G 调出窗口，可输入绝对路径直达文件夹（Go）　　<br>return 这个其实不算快捷键，点击文件，按下可重命名文件　　<br>Command-O 打开所选项。在Mac里打开文件不像Windows里直接按Enter　　<br>Command-Option-V 作用相当于Windows里的文件剪切。在其它位置上对文件复制（Command-C），在目的位置按下这个快捷键，文件将被剪切到此位置　　<br>Command-上箭头 打开包含当前文件夹的文件夹，相当于Windows里的“向上”　　<br>Command-Delete 将文件移至废纸篓　　<br>Command-Shift-Delete 清倒废纸篓　　<br>空格键 快速查看选中的文件，也就是预览功能</p>
<p>在浏览器中：<br>Control-Tab 转向下一个标签页　　<br>Command-L 光标直接跳至地址栏　　<br>Control-Tab 转向下一个标签页　　<br>Control-Shift-Tab 转向上一个标签页　　<br>Command-加号或等号 放大页面　　<br>Command-减号 缩小页面</p>
<p>切换同个软件的不同窗口  command+`</p>
<h2 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h2><p><code>ctrl+command+q</code></p>
<h2 id="触摸板"><a href="#触摸板" class="headerlink" title="触摸板"></a>触摸板</h2><p>触摸板可以设置成触摸板轻敲替代按下的…</p>
<h2 id="如何重置-Mac-上的-NVRAM"><a href="#如何重置-Mac-上的-NVRAM" class="headerlink" title="如何重置 Mac 上的 NVRAM"></a>如何重置 Mac 上的 NVRAM</h2><p><a href="https://support.apple.com/zh-cn/HT204063">https://support.apple.com/zh-cn/HT204063</a></p>
<h2 id="重置-Mac-上的系统管理控制器-SMC"><a href="#重置-Mac-上的系统管理控制器-SMC" class="headerlink" title="重置 Mac 上的系统管理控制器 (SMC)"></a>重置 Mac 上的系统管理控制器 (SMC)</h2><p><a href="https://support.apple.com/zh-cn/HT201295">https://support.apple.com/zh-cn/HT201295</a></p>
<h2 id="UI-切图工具"><a href="#UI-切图工具" class="headerlink" title="UI 切图工具"></a>UI 切图工具</h2><ul>
<li><p><a href="http://www.sketchcn.com/">sketch</a><br>绘图工具<br><a href="https://www.zhinin.com/sketch-mac.html">下载破解版</a></p>
</li>
<li><p><a href="http://www.fancynode.com.cn/pxcook">PxCook</a><br>生成前端代码利器</p>
</li>
<li><p><a href="http://www.fancynode.com.cn/flavor">Flavor</a><br>sketch导出为PxCook插件Flavor</p>
</li>
</ul>
<h2 id="Xmind安装"><a href="#Xmind安装" class="headerlink" title="Xmind安装"></a>Xmind安装</h2><p><a href="http://www.carrotchou.blog/6539.html">下载地址</a><br>下载主程序和破解补丁。 先安装主程序，按照破解补丁里的步骤安装即可。</p>
<h2 id="mac关闭指定端口"><a href="#mac关闭指定端口" class="headerlink" title="mac关闭指定端口"></a>mac关闭指定端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsof -i:8090</span><br><span class="line">udo <span class="built_in">kill</span> -9 [pid]</span><br><span class="line"><span class="comment"># eg</span></span><br><span class="line">udo <span class="built_in">kill</span> -9 59296</span><br></pre></td></tr></table></figure>

<h2 id="Windows虚拟机"><a href="#Windows虚拟机" class="headerlink" title="Windows虚拟机"></a>Windows虚拟机</h2><p><a href="http://soft.macx.cn/6205.htm">http://soft.macx.cn/6205.htm</a></p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>解锁Alfred, Workflow</p>
<h2 id="iPhone-8强制重启"><a href="#iPhone-8强制重启" class="headerlink" title="iPhone 8强制重启"></a>iPhone 8强制重启</h2><p>先按音量+，再按音量-，再长按电源键10s左右会显示开机画面。</p>
<h2 id="homebrew-软件下载安装利器"><a href="#homebrew-软件下载安装利器" class="headerlink" title="homebrew 软件下载安装利器"></a>homebrew 软件下载安装利器</h2><p>[下载安装]<a href="https://brew.sh/index_zh-cn)">https://brew.sh/index_zh-cn)</a><br><a href="https://formulae.brew.sh/formula/">所有软件列表</a><br>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install wget</span><br></pre></td></tr></table></figure>

<h2 id="在finder左侧边栏建立新文件夹"><a href="#在finder左侧边栏建立新文件夹" class="headerlink" title="在finder左侧边栏建立新文件夹"></a>在finder左侧边栏建立新文件夹</h2><p>打开finder在设备找到电脑磁盘<code>Macintosh HD</code>或在桌面找到<code>Macintosh HD</code>，</p>
<p>进入用户，选择自己的用户名，新建文件夹，然后拖动到左边边栏即可。想要删除直接右击，选中，从边栏移除.</p>
<p>详见<a href="https://jingyan.baidu.com/article/3052f5a1081d4397f31f862c.html">百度经验链接</a></p>
<h2 id="mac浏览器全屏地址栏被隐藏"><a href="#mac浏览器全屏地址栏被隐藏" class="headerlink" title="mac浏览器全屏地址栏被隐藏"></a>mac浏览器全屏地址栏被隐藏</h2><p>左上角视图–&gt; 在全屏模式下始终显示工具栏gst<br>gst</p>
<h2 id="mac常用软件下载地址"><a href="#mac常用软件下载地址" class="headerlink" title="mac常用软件下载地址"></a>mac常用软件下载地址</h2><p><a href="https://mac-torrent-download.net/">mac-torrent-download</a></p>
<p><a href="https://xclient.info/">xclient.info</a>👍👍👍👍👍</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.zhihu.com/question/20873070">程序员如何优雅地使用 macOS？</a></li>
</ul>
]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac快速搭建开发环境</title>
    <url>/posts/Mac%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>因为笔记本电池坏了，要送机维修，用了半天时间快速换电脑从0搭建得心应手的开发环境。特记录留念。</p>
<h2 id="Mac键盘设置"><a href="#Mac键盘设置" class="headerlink" title="Mac键盘设置"></a>Mac键盘设置</h2><p>系统设置-&gt; 键盘-&gt; 调到最快</p>
<h2 id="Git-初始化"><a href="#Git-初始化" class="headerlink" title="Git 初始化"></a>Git 初始化</h2><p>先创建目录</p>
<p>mkdir /Users/zjp(此处为电脑用户名)/.ssh</p>
<p>将原来电脑里的 known_hosts，id_rsa.pub， id_rsa放到这个目录下即可 用git命令</p>
<a id="more"></a>

<h2 id="Git-命令快捷方式"><a href="#Git-命令快捷方式" class="headerlink" title="Git 命令快捷方式"></a>Git 命令快捷方式</h2><p>bdgp</p>
<p>在 ~/.oh-my-zsh/plugins/git的 git.plugin.zsh文件末尾添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">bdgp</span></span>() &#123;</span><br><span class="line"> <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> != 0 ]] &amp;&amp; [[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> != 1 ]]; <span class="keyword">then</span></span><br><span class="line"> git push origin head:refs/<span class="keyword">for</span>/<span class="string">&quot;<span class="variable">$&#123;*&#125;</span>&quot;</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> [[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> == 0 ]] &amp;&amp; <span class="built_in">local</span> b=<span class="string">&quot;<span class="subst">$(git_current_branch)</span>&quot;</span></span><br><span class="line"> git push origin head:refs/<span class="keyword">for</span>/<span class="string">&quot;<span class="variable">$&#123;b:=$1&#125;</span>&quot;</span></span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="homebrew-安装地址"><a href="#homebrew-安装地址" class="headerlink" title="homebrew 安装地址"></a>homebrew 安装地址</h2><p>因为HomeBrew官网提供的安装办法会报错，所以改用以下方法，简介好用，强烈推荐！！！<br><a href="https://zhuanlan.zhihu.com/p/111014448">知乎链接</a><br>然后就可以正常安装插件</p>
<p>各个插件的安装要根据每个插件的安装指南对应安装</p>
<h2 id="iTerm2下载"><a href="#iTerm2下载" class="headerlink" title="iTerm2下载"></a>iTerm2下载</h2><p>因为网速原因下载最新版会特别慢<br><a href="https://www.zhinin.com/wp-content/themes/2019_v0.1/down.php?id=25574">低版本下载链接</a></p>
<p><strong>经验</strong>不用从官网下载，直接将原电脑应用程序里的文件压缩通过隔空传送发送到新电脑即可。</p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>详见<a href="http://believezjp.oriht.com/posts/iTerm2%E5%AE%8C%E7%BE%8E%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C/">我的博客believezjp.oriht.com链接</a><br><strong>Oh-my-zsh的安装都要用库对应的方法安装</strong></p>
<h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><p>搜狗输入法（外观-简约黑2，候选9个字）</p>
<p>Vscode</p>
<p>微信开发者工具</p>
<p>百度开发者工具</p>
<p>GitKraken(只能安装6.5.1版本以下的)</p>
<p>PdfGuru</p>
<h3 id="vscode插件安装"><a href="#vscode插件安装" class="headerlink" title="vscode插件安装"></a>vscode插件安装</h3><p>直接安装Settings Sync同步即可</p>
<h2 id="Node环境安装"><a href="#Node环境安装" class="headerlink" title="Node环境安装"></a>Node环境安装</h2><p>直接官网下安装包</p>
<h2 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h2><p>打开Finder里的各个目录查看文件，压缩传送新电脑即可</p>
<p>然后就可以下代码开始搬砖了~~</p>
]]></content>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/posts/MongoDB/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.mongodb.com/download-center#community">下载链接</a></p>
<p>下载完直接安装</p>
<h2 id="管理工具：-Robomongo-和-Mongochef"><a href="#管理工具：-Robomongo-和-Mongochef" class="headerlink" title="管理工具： Robomongo 和 Mongochef"></a>管理工具： Robomongo 和 Mongochef</h2>]]></content>
  </entry>
  <entry>
    <title>Node-常用工具</title>
    <url>/posts/Node-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="supervisor-监听Node改动"><a href="#supervisor-监听Node改动" class="headerlink" title="supervisor 监听Node改动"></a>supervisor 监听Node改动</h2><p><a href="http://supervisord.org/">supervisor 官网</a><br>是一个进程控制系统</p>
<p>平时，我们 <code>node app.js</code> 后，当我们修改了 app.js 的内容，就需要关闭 node 命令行再执行 node app.js。<br>而我们使用 supervisor 后，我们修改了 app.js 中的内容，只要点击保存，即可生效保存后的代码，实现实时监听 node 代码的变动。</p>
<a id="more"></a>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol>
<li>安装插件：<code>npm i supervisor -g</code></li>
<li>运行命令：<code>supervisor app.js</code></li>
<li>查看运行：<code>localhost:3000</code></li>
</ol>
<p><strong>执行命令必须在项目的根目录启动。不管服务启动文件在什么位置。</strong></p>
<p>例如：Express4.0中，启动文件位于<code>./bin/www</code>，启动时，必须在<code>./</code>下执行<code>supervisor bin/www</code></p>
<p>没有任何参数启动服务，默认监控所有文件, 文件夹的变化，一旦有变化，服务就会重启。</p>
<p>这样会出现很多问题：将日志存入某些文件夹，或上传附件等，都会导致服务器文件的变化，必然引起node服务器的重启。</p>
<p>不想监控某些文件夹，可以使用-i参数。如：忽略根目录下的private, 可以这样启动：<br><code>supervisor -i ./private myapp</code><br>忽略多个文件夹，则用<code>,</code>隔开<br><code>supervisor -i ./private,./otherdir myapp</code></p>
<h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p>运行：<code>supervisor</code></p>
<h2 id="PM2-Node进程管理"><a href="#PM2-Node进程管理" class="headerlink" title="PM2 - Node进程管理"></a>PM2 - Node进程管理</h2><p><a href="https://www.npmjs.com/package/pm2">PM2- NPM</a><br><a href="https://pm2.io/doc/en/runtime/quick-start/">官网</a><br>PM2 是 Node 进程管理工具，可以利用它来简化很多 Node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。<br>下面就对 PM2 进行入门性的介绍，基本涵盖了 PM2 的常用的功能和配置：</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol>
<li>全局安装 <code>PM2：npm i pm2 -g</code></li>
<li>监听应用：<code>pm2 start index.js</code></li>
<li>查看所有进程：<code>pm2 list</code></li>
<li>查看某个进程：<code>pm2 describe App name/id</code></li>
<li>停止某个进程：<code>pm2 stop App name/id</code></li>
<li>停止所有进程：<code>pm2 stop all</code></li>
<li>重启某个进程：<code>pm2 restart App name/id</code></li>
<li>删除某个进程：<code>pm2 delete App name/id</code></li>
<li>查看所有的进程状态：pm2 status</li>
</ol>
<p>supervisor 是监听单个进程的话，那么 PM2 就是监听多个进程。</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li><code>--watch</code>：监听应用目录源码的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件</li>
<li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目，可以弥补node.js缺陷</li>
<li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如–ignore-watch=”test node_modules “some scripts”</li>
<li>-n –name：应用的名称。查看应用信息的时候可以用到</li>
<li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径，有默认路径</li>
<li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径，有默认路径</li>
<li><code>--interpreter &lt;interpreter&gt;</code>：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用</li>
</ul>
<h2 id="通过yaml管理多个应用"><a href="#通过yaml管理多个应用" class="headerlink" title="通过yaml管理多个应用"></a>通过yaml管理多个应用</h2><p>process.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">script   :</span> <span class="string">app.js</span></span><br><span class="line">    <span class="attr">instances:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">exec_mode:</span> <span class="string">cluster</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">script :</span> <span class="string">worker.js</span></span><br><span class="line">    <span class="attr">watch  :</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">env    :</span></span><br><span class="line">      <span class="attr">NODE_ENV:</span> <span class="string">development</span></span><br><span class="line">    <span class="attr">env_production:</span></span><br><span class="line">      <span class="attr">NODE_ENV:</span> <span class="string">production</span></span><br></pre></td></tr></table></figure>

<p>启动: <code>pm2 start process.yml</code></p>
<h2 id="环境切换"><a href="#环境切换" class="headerlink" title="环境切换"></a>环境切换</h2><p>开发中会有多个环境(开发，测试，生产等), 根据不同环境切换各种情景</p>
<p>pm2通过在配置文件中的<code>env_xx</code>来声明不同环境的配置，然后在启动时通过<code>--env</code>参数指定运行环境</p>
<p>环境变量如下定义</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;production&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://www.example.com/&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;env_dev&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;development&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://wdev.example.com/&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;env_test&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;REMOTE_ADDR&quot;: &quot;http://wtest.example.com/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用中通过process.env.REMOTE_ADDR等来读取配置中声明的变量</p>
<p>启动指定的环境：<code>pm2 start app.js --env development</code></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js -i 3 <span class="comment"># 开启三个进程</span></span><br><span class="line">pm2 start app.js -i max <span class="comment"># 根据机器CPU核数，开启对应数目的进程</span></span><br></pre></td></tr></table></figure>

<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p><code>pm2 logs</code></p>
<h2 id="查看监控"><a href="#查看监控" class="headerlink" title="查看监控"></a>查看监控</h2><p><code>pm2 monit</code></p>
<h2 id="开机自动启动"><a href="#开机自动启动" class="headerlink" title="开机自动启动"></a>开机自动启动</h2><ol>
<li>运行 <code>pm2 startup</code>，即在<code>/etc/init.d/</code> 目录下生成 <code>pm2-root</code> 的启动脚本，且自动将 <code>pm2-root</code> 设为服务；</li>
<li>通过pm2 save保存当前进程状态。</li>
</ol>
<h2 id="详细介绍pm2"><a href="#详细介绍pm2" class="headerlink" title="详细介绍pm2"></a>详细介绍pm2</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 -h <span class="comment"># help</span></span><br><span class="line">pm2 <span class="comment"># 语法介绍</span></span><br></pre></td></tr></table></figure>

<h2 id="node版本升级"><a href="#node版本升级" class="headerlink" title="node版本升级"></a>node版本升级</h2><p>先清缓存<br>安装n模块<br>升级到指定版本/最新版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm cache clean -f</span><br><span class="line"></span><br><span class="line">npm install -g n</span><br><span class="line"></span><br><span class="line">n stable</span><br></pre></td></tr></table></figure>

<p>安装完成后，查看Node的版本<br><code>node -v</code></p>
]]></content>
      <tags>
        <tag>node</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS 进阶</title>
    <url>/posts/NodeJS-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p><a href="https://github.com/nswbmw/N-blog">参考资料</a></p>
<h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h2><p>官网下载直接安装</p>
<p>安装成功后，输入npm -v 和node -v 测试。</p>
<p>Linux安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://nodejs.org/dist/v6.9.1/node-v6.9.1.tar.gz</span><br><span class="line">tar -xzvf node-v6.9.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> node-v6.9.1</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>使用<a href="https://github.com/creationix/nvm">nvm</a> 或 <a href="https://github.com/tj/n">n</a></p>
<h3 id="npm-源管理工具"><a href="#npm-源管理工具" class="headerlink" title="npm 源管理工具"></a>npm 源管理工具</h3><p>nrm 用来切换官方npm源和国内npm源，也可以用来切换官方npm源和公司私有npm源</p>
<p>全局安装 nrm :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i nrm -g</span><br></pre></td></tr></table></figure>

<p>查看nrm内置的npm源地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure>

<p>切换源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm use cnpm</span><br></pre></td></tr></table></figure>

<p>非常棒的博客：<a href="http://blog.fens.me/">http://blog.fens.me</a><br> <a href="http://blog.fens.me/series-nodejs/">http://blog.fens.me/series-nodejs/</a></p>
<p>Node  教程<br><a href="https://github.com/nswbmw/N-blog/">https://github.com/nswbmw/N-blog/</a></p>
<p>Node文档地址：<br><a href="https://nodejs.org/api/fs.html#fs_event_open">https://nodejs.org/api/fs.html#fs_event_open</a><br>中文文档<br><a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a><br>关于文件读取，写入 File System<br>  读取文件</p>
<p><a href="https://segmentfault.com/a/1190000004957223">https://segmentfault.com/a/1190000004957223</a></p>
<p>express<br><a href="http://www.expressjs.com.cn/starter/generator.html">http://www.expressjs.com.cn/starter/generator.html</a><br>node+mongodb搭建博客<br><a href="https://segmentfault.com/a/1190000011794598">https://segmentfault.com/a/1190000011794598</a></p>
<p>Node 自学完全总结<br><a href="http://www.jianshu.com/p/22f62a08559f">http://www.jianshu.com/p/22f62a08559f</a></p>
<p>Node.js教程<br>七天学会NodeJS<br><a href="http://nqdeng.github.io/7-days-nodejs/#1.1">http://nqdeng.github.io/7-days-nodejs/#1.1</a></p>
<p><a href="http://www.open-open.com/lib/view/1392611872538#_label2">http://www.open-open.com/lib/view/1392611872538#_label2</a></p>
<p><a href="https://github.com/alsotang/node-lessons">https://github.com/alsotang/node-lessons</a></p>
<blockquote>
<p>我来对创业公司中使用 Nodejs，做一个小总结，我们在妥善处理了 运维、集群管理、性能调优等等这些传统语言已经做的非常棒非常成熟的领域，在大部分的创业公司，都可以由前端团队推动，来使用 Nodejs 去接管数据访问层与渲染层的事情，等到公司规模上来以后，就可以依靠更资深的工程师以及原来团队的沉淀，来做 比如日志、监控系统、分布式服务接入这些事情，Nodejs 的落地需要前端工程师，需要 Nodejs 工程师，更需要强大的运维之锤，了解除了 JS 以外的更多技能，比如数据库，比如系统的设计，比如接口服务，比如团队规范协作流程等等等等，在大公司可以扎根一个方向挖下去，在小公司则需要放眼天下，筹备未来。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>NodeJS中的内存泄漏</title>
    <url>/posts/NodeJS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<p>内存泄漏(Memory Leak): 由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。严重的情况下导致内存达到某个极限会使得应用程序崩溃。</p>
<p>传统的 C/C++ 中存在指针，对象用完后未释放等情况导致的内存泄漏。而在使用虚拟机执行的语言中如 Java、JavaScript 由于使用了 GC （Garbage Collection，垃圾回收）机制自动释放内存，使得程序员的精力得到的极大的解放，不用再像传统语言那样时刻对于内存的释放而战战兢兢。</p>
<p>即便有了 GC 机制可以自动释放，但这并不意味这内存泄漏的问题不存在了。内存泄漏依旧是开发者们不能绕过的一个问题，今天让我们来了解如何分析 Node.js 中的内存泄漏。</p>
<h2 id="GC-in-Node-js"><a href="#GC-in-Node-js" class="headerlink" title="GC in Node.js"></a>GC in Node.js</h2><p>Node.js 使用 V8 作为 JavaScript 的执行引擎，所以讨论 Node.js 的 GC 情况就等于在讨论 V8 的 GC。</p>
<p>在 V8 中一个对象的内存是否被释放，是看程序中是否还有地方持有改对象的引用。</p>
<p>在 V8 中，每次 GC 时，是根据 root 对象 (浏览器环境下的 window，Node.js 环境下的 global ) 依次梳理对象的引用，如果能从 root 的引用链到达访问，V8 就会将其标记为可到达对象，反之为不可到达对象。被标记为不可到达对象（即无引用的对象）后就会被 V8 回收。</p>
<p>更多细节，可以参见 <a href="https://yq.aliyun.com/articles/592878">解读 V8 GC</a>。</p>
<p>在 Node.js 中内存泄露的原因就是本该被清除的对象，被可到达对象引用以后，未被正确的清除而常驻内存。</p>
<h2 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>使用全局变量或未定义的变量，不会被清除掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">global</span>.b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的就是内部函数可以访问定义在外部函数中的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">functionout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bigData =newBuffer(<span class="number">100</span>);</span><br><span class="line">  inner =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> bigData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于inner挂载在root上，导致bigData不会被释放</p>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除</p>
<p>node Agent keepAlive 为 true 时，可能造成的内存泄漏。</p>
<p>当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听，而产生内存泄漏。</p>
<p>所以要了解添加事件的对象的生命周期。自己添加的事件监听，必须自己移除。</p>
<p><a href="https://github.com/nodejs/node/issues/9268">node Agent keepAlive 内存泄漏</a></p>
<h3 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h3><p>还有一些其他的情况可能会导致内存泄漏，比如缓存。</p>
<p>在使用缓存的时候，得清楚缓存的对象的多少，如果缓存对象非常多，得做限制最大缓存数量处理。还有就是非常占用 CPU 的代码也会导致内存泄漏，服务器在运行的时候，如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高。</p>
<h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2><p>ESLint 检测代码检查非期望的全局变量。</p>
<p>使用闭包的时候，得知道闭包了什么对象，还有引用闭包的对象何时清除闭包。避免写出复杂的闭包</p>
<p>绑定事件的时候，一定得在恰当的时候清除事件。在编写一个类的时候，推荐使用 init 函数对类的事件监听进行绑定和资源申请，然后 destroy 函数对事件和占用资源进行释放。</p>
<h2 id="定位内存泄漏"><a href="#定位内存泄漏" class="headerlink" title="定位内存泄漏"></a>定位内存泄漏</h2><p>正常使用就可以重现的内存泄漏，只要在测试环境模拟就可以排查</p>
<p>对于偶然的内存泄漏，一般会与特殊的输入有关系。想稳定重现这种输入是很耗时的过程。如果不能通过代码的日志定位到这个特殊的输入，那么推荐去生产环境打印内存快照了。需要注意的是，打印内存快照是很耗 CPU 的操作，可能会对线上业务造成影响。</p>
<p>快照工具推荐使用 <a href="https://github.com/bnoordhuis/node-heapdump">heapdump</a> 用来保存内存快照，使用 <a href="https://github.com/Jam3/devtool">devtool</a> 来查看内存快照。使用 heapdump 保存内存快照时，只会有 Node.js 环境中的对象，不会受到干扰（如果使用 node-inspector 的话，快照中会有前端的变量干扰）。</p>
<p>PS：安装 heapdump 在某些 Node.js 版本上可能出错，建议使用 <code>npm install heapdump -target=Node.js</code> 版本来安装。</p>
<h3 id="打印内存快照"><a href="#打印内存快照" class="headerlink" title="打印内存快照"></a>打印内存快照</h3><p>将 heapdump 引入代码中，使用 heapdump.writeSnapshot 就可以打印内存快照了了。为了减少正常变量的干扰，可以在打印内存快照之前会调用主动释放内存的 gc() 函数（启动时加上 —expose-gc 参数即可开启）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> heapdump =<span class="built_in">require</span>(<span class="string">&#x27;heapdump&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> save =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    gc();</span><br><span class="line">    heapdump.writeSnapshot(<span class="string">&#x27;./&#x27;</span>+<span class="built_in">Date</span>.now()+<span class="string">&#x27;.heapsnapshot&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在打印线上的代码的时候，建议按照内存增长情况来打印快照。heapdump 可以使用 kill 向程序发送信号来打印内存快照（只在 *nix 系统上提供）。</p>
<p><code>kill -USR2 &lt;pid&gt;</code></p>
<p>推荐打印 3 个内存快照，一个是内存泄漏之前的内存快照，一个是少量测试以后的内存快照，还有一个是多次测试以后的内存快照。<br>第一个内存快照作为对比，来查看在测试后有哪些对象增长。在内存泄漏不明显的情况下，可以与大量测试以后的内存快照对比，这样能更容易定位。</p>
<h3 id="对比内存快照找出泄漏位置"><a href="#对比内存快照找出泄漏位置" class="headerlink" title="对比内存快照找出泄漏位置"></a>对比内存快照找出泄漏位置</h3><p>通过内存快照找到数量不断增加的对象，找到增加对象是被谁给引用，找到问题代码，改正之后就行，具体问题具体分析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>&#123;EventEmitter&#125;=<span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> heapdump =<span class="built_in">require</span>(<span class="string">&#x27;heapdump&#x27;</span>);</span><br><span class="line"><span class="built_in">global</span>.test =newEventEmitter();</span><br><span class="line">heapdump.writeSnapshot(<span class="string">&#x27;./&#x27;</span>+<span class="built_in">Date</span>.now()+<span class="string">&#x27;.heapsnapshot&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> innerData =newBuffer(<span class="number">100</span>);</span><br><span class="line">    onst outClosure3 =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> innerData;</span><br><span class="line">    &#125;;</span><br><span class="line">    test.on(<span class="string">&#x27;error&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    outClosure3();&#125;<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    run3();</span><br><span class="line">&#125;</span><br><span class="line">gc();</span><br><span class="line">heapdump.writeSnapshot(<span class="string">&#x27;./&#x27;</span>+<span class="built_in">Date</span>.now()+<span class="string">&#x27;.heapsnapshot&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里是对错误代码的最小重现代码。</p>
<p>首先使用 node —expose-gc index.js 运行代码，将会得到两个内存快照，之后打开 devtool，点击 profile，载入内存快照。打开对比，Delta 会显示对象的变化情况，如果对象 Delta 一直增长，就很有可能是内存泄漏了。</p>
<p>其实这三处对象增长都是一个问题导致的。test 对象中的 error 监听事件中闭包引用了 innerData 对象，导致 buffer 没有被清除，从而导致内存泄漏。<br>其实这里的 error 监听事件中没有引用 innerData 为什么会闭包引用了 innerData 对象，这个问题很是疑惑，后来弄清是 V8 的优化问题，在文末会额外讲解一下。对于对比快照找到问题，得看你对代码的熟悉程度，还有眼力了。</p>
]]></content>
      <tags>
        <tag>NodeJS</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>React中API使用的正确姿势</title>
    <url>/posts/React%E4%B8%ADAPI%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<h2 id="惰性初始化state"><a href="#惰性初始化state" class="headerlink" title="惰性初始化state"></a>惰性初始化state</h2><p>defaultValue 参数只会在组件的初始渲染中起作⽤，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获<br>得，则可以传⼊⼀个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调⽤：</p>
<p><strong>这种写法可以避免定义多个state时，每次渲染都要执行初始化操作，而用惰性初始化state，可以解决重复初始化的问题。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每次setInputValue引起的重新渲染进⼊函数组件内defaultValue都会被忽略。</span></span><br><span class="line"><span class="keyword">const</span> TestInput= <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultValue = props.value || <span class="string">&#x27;请输⼊&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> [inputValue,setInputValue] = useState(defaultValue)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input value=&#123;inputValue&#125; onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span>setInputValue(e.target.value)&#125; /&gt; &#123;<span class="keyword">in</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestInput</span><br><span class="line"></span><br><span class="line"><span class="comment">//使⽤函数来解决每次渲染 state 需要通过复杂计算获得的问题</span></span><br><span class="line"><span class="keyword">const</span> TestInput= <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [inputValue,setInputValue] = useState(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> props.value || <span class="string">&#x27;请输⼊&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input value=&#123;inputValue&#125; onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span>setInputValue(e.target.value)&#125; /&gt; &#123;<span class="keyword">in</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestInput</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>React条件渲染</title>
    <url>/posts/React%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p><a href="https://github.com/dt-fe/weekly/blob/master/61.%E7%B2%BE%E8%AF%BB%E3%80%8AReact%20%E5%85%AB%E7%A7%8D%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E3%80%8B.md">参考链接</a><br>模板条件渲染在开发中常用，什么时候用什么方式？怎么写较好？</p>
<p>先罗列常见方式:</p>
<h2 id="IF-ELSE"><a href="#IF-ELSE" class="headerlink" title="IF/ELSE"></a>IF/ELSE</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<!--- more --->

<h2 id="return-null"><a href="#return-null" class="headerlink" title="return null"></a>return null</h2><p>不需要返回可以返回null, 代替空div, 提升效率</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组件变量"><a href="#组件变量" class="headerlink" title="组件变量"></a>组件变量</h2><p>将组件赋值给变量，可以在return前任意修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    component = <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h2><p>逻辑不复杂可以避免if else</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flag ? <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h2><p>最方便!!!</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flag &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p>立即执行函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"><span class="comment">/* arguments */</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)(<span class="comment">/* arguments */</span>);</span><br><span class="line"></span><br><span class="line">&lt;!-- ？？？什么情况用？？？ --&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)()&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h2><p>将一大块的逻辑拆分成子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SubRender /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubRender</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="IF-组件–什么时候用"><a href="#IF-组件–什么时候用" class="headerlink" title="IF 组件–什么时候用"></a>IF 组件–什么时候用</h2><p>做一个条件渲染组件 IF 代替 js 函数的 if：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;If condition=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">  &lt;span&gt;Hi!&lt;/span&gt;</span><br><span class="line">&lt;/If&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个组件实现也很简单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> If = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> condition = props.condition || <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> positive = props.then || <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> negative = props.else || <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> condition ? positive : negative;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>返回一个新组件的函数，并且接收一个组件作为参数<br>在高阶组件里写条件语句，返回不同的组件即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">higherOrderComponent</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">EnhancedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AnotherComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>要不要封装，怎么封装，取决于应用复杂度。</p>
<p>对于任何代码封装，都会增加这段代码连接逻辑的复杂度。</p>
<p>假定无论如何代码的复杂度都是恒定不变的，下面这段代码，连接复杂度为0，而对于render函数而言，<br>逻辑复杂度是100.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> isOk ? <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">Component2</span> /&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拆分成两个函数，逻辑复杂度对render, SubComponent来说都是50，但连接复杂度是50:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SubComponent</span>/&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>/&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isOk ? <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">Component2</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过函数拆分，降低了每个函数的逻辑复杂度，却提高了连接复杂度。</p>
<blockquote>
<p>假设一个程序员可以一次性轻松记忆10个函数。如果再多，函数之间的调用关系会让人头大。</p>
</blockquote>
<h2 id="应用较小时"><a href="#应用较小时" class="headerlink" title="应用较小时"></a>应用较小时</h2><p>应用较小时，假设共有10个函数，如果做了逻辑抽象，拆分出了10个子函数，那么总逻辑复杂度不变，函数变成20个。</p>
<p>此时，要修改项目，需要找到关键代码的位置。</p>
<p>如果没有做逻辑抽象， 小明可以一下记住10个函数，很快完成需求。</p>
<p>做了逻辑抽象，需要理解的逻辑复杂度是不变的。但要读20个函数，小明需要在线索中不断跳转，还是只找了10个关键函数，但一共就20个函数，逻辑并不复杂，这值得吗？</p>
<p>这时，会觉得，简单的逻辑，却花了较长的时间找代码。</p>
<h2 id="应用较大时"><a href="#应用较大时" class="headerlink" title="应用较大时"></a>应用较大时</h2><p>应用较大时，假设有500个函数，不考虑抽象后带来的复用好处，假设都无法复用，那么做逻辑抽象后，总逻辑复杂度不变，函数变成了1000个。</p>
<p>小明接到需求开始维护项目。<br>从一开始没能理解项目的全貌，所以开始一步步探索。</p>
<p>现在有两种选择：一是在未做逻辑抽象时的探索，一是在做过逻辑抽象后的探索。</p>
<p>假设没有做逻辑抽象，小明需面对500个这种函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (renderComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> isOk ? <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">Component2</span> /&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isReady ? <span class="xml"><span class="tag">&lt;<span class="name">Component3</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">Component4</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果做了逻辑抽象，需面对1000个这种函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (renderComponent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component1And2</span> /&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component3And4</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>项目庞大后，总函数数量并不会影响对线索的查找，而总线索深度也几乎总是固定的，一般在5层左右。</strong></p>
<p>小明理解5个或10个函数成本差不多，但没有做逻辑抽象时，这5个函数各自掺杂了其他逻辑，这5个函数各自掺杂了其他逻辑，反而影响对函数的理解。</p>
<p>这时做逻辑抽象是合适的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，推荐使用子函数，子组件，IF组件，高阶组件做条件渲染，因为这四种方式都能提高程序的抽象能力。</p>
<p>往往抽象后的代码会更具有复用性，单个函数逻辑更清晰，在切面编程时更利于理解。</p>
<p>当项目很简单时，整个项目的理解成本都很低，抽象带来的复杂度反而让项目变成了需要切面编程时就得不偿失了。</p>
<p>总结：</p>
<ul>
<li>当项目很简单，或条件渲染的逻辑确认无法复用时，推荐在代码中用 &amp;&amp; 或三元运算符、IIFE等直接实现条件渲染。</li>
<li>当项目复杂时，尽量使用子函数，子组件，IF组件，高阶组件等方式做更有抽象度的条件渲染。</li>
<li>在做逻辑抽象时，考虑下项目的复杂度, 避免因为抽象带来的成本增加，让本可以整体理解的项目变得支离破碎。</li>
</ul>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实战读书笔记</title>
    <url>/posts/Redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul>
<li><a href="https://redis.io/">redis官网</a></li>
<li><a href="http://www.redis.cn/download.html">redis中文下载安装</a></li>
<li><a href="http://www.redis.cn/documentation.html">redis中文文档</a></li>
</ul>
<p>当你需要以接近实时的速度访问快速变动的数据流时，Redis这样的键值数据库就是你的最佳选择。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载、解压、编译Redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.2.tar.gz</span><br><span class="line">tar xzf redis-5.0.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.2</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>提示错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure>

<p>解决, 输入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<p>回车后，系统弹出下载xcode，点击确认，下载完成后即可。（实际上不是下载xcode，可能下载xcode有关插件，下载时长约1分钟）</p>
<blockquote>
<p>在这里发生个有趣的现象，直接拷贝到终端里执行会报错无法识别参数，手动敲了一遍可以执行😶😳😳</p>
</blockquote>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在redis安装目录下，进入src，执行<code>./redis-server</code>可以看到启动画面</p>
<p>另开一个终端，在同样目录下，执行<code>./redis-cli</code>, 连接成功。</p>
<h2 id="客户端常用命令"><a href="#客户端常用命令" class="headerlink" title="客户端常用命令"></a>客户端常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>set key value</td>
<td>设置 key 的值</td>
</tr>
<tr>
<td>get key</td>
<td>获取 key 的值</td>
</tr>
<tr>
<td>exists key</td>
<td>查看此 key 是否存在</td>
</tr>
<tr>
<td>del key</td>
<td>删除存储在给定键中的值</td>
</tr>
<tr>
<td>keys *</td>
<td>查看所有的 key</td>
</tr>
<tr>
<td>flushall</td>
<td>消除所有的 key</td>
</tr>
</tbody></table>
<p>Redis与其他软件的相同与不同</p>
<p>Redis是一个远程内存数据库，具有复制特性及未解决问题而升高的独一无二的数据模型。</p>
<p>Redis提供了5种不同类型的数据结构，各种问题都可映射到这些数据结构。</p>
<h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><h2 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h2><p>Redis 是一个速度非常快的非关系数据库(non-relational database), 可以存储键(key)与5种不同类型的值之间的映射(mapping), 可以将存储在内存的键值对数据持久化到硬盘，还可以通过复制，持久化和客户端分片等特性，可以将redis扩展成一个能够包含数百GB数据、每秒处理上百万请求的系统。</p>
<h2 id="redis能做什么"><a href="#redis能做什么" class="headerlink" title="redis能做什么"></a>redis能做什么</h2><h2 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h2><p>5种结构<br>|结构类型|存储的值|读写能力|<br>|——-|——-|——|<br>|string(字符串)|可以是字符串、整数或浮点数|对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或自减操作|<br>|list(列表)  |一个链表，每个节点都包含一个字符串|从链表两端推入或弹出元素；根据偏移量对链表进行trim;读取单个或多个元素；根据值查找或移除元素|<br>|set(集合)   |包含字符串的无序收集器(unordered collection), 并且被包含的每个字符串都是独一无二、各不相同的|添加、获取、移除单个元素；检查一个元素是否存在；计算交集，并集，差集；从集合里随机获取元素|<br>|hash(散列)  |包含键值对的无序散列表|添加、获取移除单个键值对；获取所有键值对|<br>|zset(有序集合)|字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列书序有分值大小决定|添加、获取、移除单个元素；根据分值范围(range)或成员来获取元素|</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>形如: <code>hello: world</code></p>
<p>set, get, del 使用示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hello world</span><br><span class="line">get hello</span><br><span class="line">del hello</span><br><span class="line">get hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令返回1表示成功执行， 0表示执行失败</p>
</blockquote>
<h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><p>一个列表结构可以有序的存储多个字符串，<strong>列表可以包含相同的元素</strong><br>形如: <code>list-key: [item, item2, item]</code></p>
<p>列表命令<br>|命令|行为|<br>|—|—-|<br>|lpush  |将元素推入列表左端(left end)|<br>|rpush  |            …右端(right end)|<br>|lpop   |从列表左端弹出元素|<br>|rpop   |从右端弹出元素  |<br>|lrange key start stop |获取列表给定范围所有值, 支持负索引, -1表示最右边第一个元素|<br>|llen key| 获取列表中元素的个数,时间复杂度为O(1)|<br>|lrem key count value| 删除列表中前count个值为value的元素,返回值是实际删除的个数|<br>|lindex |获取列表在给定位置的单个元素|<br>|lset key index value| 将索引为index的元素赋值为value|<br>|ltrim key start end| 删除指定索引范围之外的所有元素|<br>|linsert key BEFORE|AFTER pivot value| 从左往右查找值为pivot的元素，根据第二个参数是before还是after来决定将value插入到该元素前面还是后面|<br>|rpoplpush source destination| 将元素从一个列表转到另一个列表|</p>
<p>说明:</p>
<blockquote>
<p>count &gt; 0, lrem从列表左边开始删除前count个值为value的元素<br>count &lt; 0, lrem从列表右边开始删除前count个值为value的元素<br>count = 0, lrem删除所有值为value的元素<br>ltrim和lpush一起使用来限制列表中元素的数量，比如记录日志只保留最近100条，每次加入元素时调用一次ltrim</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lpush logs <span class="variable">$newLogs</span></span><br><span class="line">ltrim logs 0 99</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lpush numbers 1</span><br><span class="line"><span class="comment"># 支持同时增加多个元素</span></span><br><span class="line">lpush numbers 2 3</span><br><span class="line"><span class="comment"># 此时数据为[3, 2, 1]</span></span><br><span class="line">rpush numbers 0 -1</span><br><span class="line"><span class="comment"># 此时数据为[3, 2, 1, 0, -1]</span></span><br><span class="line"></span><br><span class="line">lpop numbers <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">rpop numbers <span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line">llen numbers <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">lrange numbers 0 -1 <span class="comment"># 获取所有元素</span></span><br><span class="line"></span><br><span class="line">lrem</span><br><span class="line">lindex list-key 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>想把列表当栈使用, 用 <code>lpush</code> 和 <code>lpop</code> 或 <code>rpush</code>和 <code>rpop</code><br>想当队列使用, 用 <code>lpush</code> 和 <code>rpop</code> 或 <code>rpush</code> 和 <code>lpop</code></p>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>集合通过散列表保证自己<strong>存储的每个字符串是各不相同的</strong>(这些散列表只有键，没有与键相关联的值)</p>
<p>集合与列表对比<br>|对比项|集合|散列|<br>|–|—-|—|<br>|存储内容|至多2(32)-1个字符串|至多2(32)-1个字符串|<br>|有序性|否|是|<br>|唯一性|是|否|</p>
<p>集合使用无序(unordered)方式存储元素.<br>形如: <code>setkey: [item, item2, item3]</code></p>
<p>集合类型在Redis内部是使用值为空的散列表(hash table)实现的</p>
<p>常用操作是加入或删除元素，判断某个元素是否存在等，时间复杂度都是O(1)</p>
<p>多个集合类型键之间还可以进行并集，交集和差集运算</p>
<p>集合命令<br>|命令|行为|<br>|—|—-|<br>|sadd       |将给定元素添加到集合|<br>|smembers   |返回集合所有元素(慢，慎用)|<br>|sismember  |检查给定元素是否存在|<br>|srem       |如果给定元素存在，移除|</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sadd setkey item</span><br><span class="line">sadd setkey item2</span><br><span class="line">sadd setkey item3</span><br><span class="line">sadd setkey item // 失败</span><br><span class="line">smembers setkey</span><br><span class="line">sismember setkey item4</span><br><span class="line">sismember setkey item</span><br><span class="line">srem setkey item2</span><br><span class="line">srem setkey item2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="hash-散列"><a href="#hash-散列" class="headerlink" title="hash 散列"></a>hash 散列</h2><p>散列可以存储多个键值对之间的映射，和字符串一样，既可以是字符串也可以是数字值，并且可以对散列存储的数字值执行自增自减操作。</p>
<p>散列很多当面像一个微缩版的redis，不少字符串命令都有相应的散列版本。</p>
<p>形如：<code>hashset: [&#123;subkey1: value1&#125;,&#123;subkey2: value2&#125;,&#123;subkey3: value3&#125;,]</code></p>
<p>散列命令<br>|命令|  行为|<br>|—|——|<br>|hset   |在散列里关联给定的键值对|<br>|hget   |获取给定散列键的值|<br>|hgetall|获取散列所有键值对|<br>|hdel   |如果键存在，移除|</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hset hashkey subkey1 value1</span><br><span class="line">hset hashkey subkey2 value2</span><br><span class="line">hset hashkey subkey3 value3</span><br><span class="line">hgetall hashkey</span><br><span class="line">hdel hashkey subkey2</span><br><span class="line">hdel hashkey subkey2</span><br><span class="line">hdel hashkey subkey1</span><br><span class="line">hgetall hashkey</span><br></pre></td></tr></table></figure>

<h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h2><p>有序集合和散列一样，都用于存储键值对，有序集合的键值被称为成员(member)，每个成员都是各不相同的；<br>而有序集合的值被称为分值(score)，分值必须为浮点数。<br>有序集合是Redis里唯一一个既可以根据成员访问元素，又可以根据分值及分值的排序顺序来访问元素的结构</p>
<p>有序集合和列表类型区别</p>
<p>相同点:</p>
<ol>
<li>都是有序的</li>
<li>都可以获得某一范围的元素</li>
</ol>
<p>不同点:</p>
<ol>
<li>列表通过链表实现，获取靠近两端的数据速度极快，当元素增多，访问会变慢，所以更适合实现如’新鲜事’或’日志’这样很少访问中间元素的应用</li>
<li>有序集合类型是使用散列表和跳跃表(Skip list)实现的，及时读取中间部分的数据速度也很快(时间复杂度O(log(N)))</li>
<li>列表中不能简单的调整某个元素的位置，但有序集合可以(通过更改这个元素的分数)</li>
<li>有序集合比列表类型更耗内存</li>
</ol>
<h3 id="有序集合命令"><a href="#有序集合命令" class="headerlink" title="有序集合命令"></a>有序集合命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>zadd</td>
<td>将带有给定分值的成员添加到有序集合里</td>
</tr>
<tr>
<td>zrange</td>
<td>根据元素在有序排列中所处的位置，从有序集合李获取多少个元素</td>
</tr>
<tr>
<td>zrangebyscore</td>
<td>获取有序集合在给定分值范围内的所有元素</td>
</tr>
<tr>
<td>zrem</td>
<td>如果给定成员存在，移除</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zadd zsetkey 728 member1</span><br><span class="line">zadd zsetkey 928 member0</span><br><span class="line">zadd zsetkey 928 member0</span><br><span class="line"></span><br><span class="line">zrange zsetkey 0 -1 withscores</span><br><span class="line">zrangebyscore zsetkey 0 800 withscores</span><br><span class="line"></span><br><span class="line">zrem zsetkey member1</span><br><span class="line">zrem zsetkey member1</span><br><span class="line"></span><br><span class="line">zrange zsetkey 0 -1 withscores</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>数据库</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/posts/VSCode/</url>
    <content><![CDATA[<p><a href="https://github.com/varHarrie/Dawn-Blossoms/issues/10">插件列表</a></p>
<h2 id="主命令框"><a href="#主命令框" class="headerlink" title="主命令框"></a>主命令框</h2><p><code>Command+Shift+P</code>: 打开命令面板。在打开的输入框内，可以输入任何命令，例如：</p>
<p>按一下<code>Backspace</code>会进入到<code>Command+P</code>模式</p>
<p>在<code>Command+P</code>下输入&gt;可以进入<code>Command+Shift+P</code>模式</p>
<p>在<code>Command+P</code>窗口下还可以:</p>
<p>  ○ 文件名 跳转到对应文件<br>  ○ <code>?</code> 列出当前可执行的动作<br>  ○ <code>!</code> 显示 Errors或 Warnings，也可以<code>Command+Shift+M</code><br>  ○ <code>:</code> 跳转到行数，也可以<code>Command+G</code>直接进入<br>  ○ <code>@</code> 跳转到 symbol（搜索变量或者函数），也可以<code>Command+Shift+O</code>直接进入<br>  ○ <code>@</code> 根据分类跳转 symbol，查找属性或函数，也可以<code>Command+Shift+O</code>后输入:进入<br>  ○ <code>#</code> 根据名字查找 symbol，也可以 Command+T</p>
<a id="more"></a>

<h2 id="2-2、常用快捷键"><a href="#2-2、常用快捷键" class="headerlink" title="2.2、常用快捷键"></a>2.2、常用快捷键</h2><h3 id="2-2-1、编辑器与终端窗口管理"><a href="#2-2-1、编辑器与终端窗口管理" class="headerlink" title="2.2.1、编辑器与终端窗口管理"></a>2.2.1、编辑器与终端窗口管理</h3><p>同时打开多个Vscode（查看多个项目）</p>
<p><code>Command+Shift+N</code> 打开一个新窗口<br><code>Command+Shift+W</code> 关闭窗口 同时打开多个编辑器（查看多个文件）<br><code>Command+N</code> 新建文件<br><code>Ctrl+Tab</code> 文件之间切换<br><code>Command+\</code> 分割出一个新的编辑器<br><code>Command+1</code>、<code>Command+2</code>、<code>Command+3</code>左中右 3 个编辑器的快捷键<br>Editor之间的互相切换： <code>Shift + Command + [(])</code></p>
<h3 id="2-2-2、工作区的快捷键"><a href="#2-2-2、工作区的快捷键" class="headerlink" title="2.2.2、工作区的快捷键"></a>2.2.2、工作区的快捷键</h3><p>工作区的显示和隐藏： <code>Command + B</code><br>工作区和编辑区的切换： <code>Command + shift + E</code><br>工作区文件资源管理器的文件选择：H/J/K/L代表文件夹折叠(如果不是一个文件夹，将会跳到这个文件所属的文件夹上，以便可以后面折叠整个文件夹)、聚焦下一个文件、聚焦上一个文件、文件夹展开(如果不是一个文件夹，将会在编辑区打开这个文件)<br>打开文件之后需要固定在开启状态下：<code>Command + K + Enter</code><br>打开调试面板：<code>Command + Shift + D</code></p>
<h3 id="2-2-3、终端区的快捷键"><a href="#2-2-3、终端区的快捷键" class="headerlink" title="2.2.3、终端区的快捷键"></a>2.2.3、终端区的快捷键</h3><p>`Ctrl + ``打开终端</p>
<p>主题：<br>winter is coming<br>Dracula 主题<br>espresso 主题    这个是左侧黑色，编辑区白色的~~<br>monokai light<br>sunrise<br>woolen<br>theme-bluloco-dark<br>theme-bluloco-light<br>github   非常给力</p>
<p>快捷键：</p>
<p>ctrl + p 快速打开一个文件<br>ctrl + G 跳转到指定行<br>ctrl + F 在当前文件中搜索<br>ctrl + shift + k 删除当前行</p>
<p>home 跳转到行的开始<br>end 跳转到行的结尾</p>
<p>ctrl + home 跳转到文件的开始<br>ctrl + end 跳转到文件的结尾</p>
<p>ctrl + shift + [  折叠一个代码块<br>ctrl + shift + ]  展开一个代码块</p>
<p>f3/shift + f3  发现下一处/发现上一处<br>ctrl + D 可以批量选中同一个元素，然后进行变量或方法名的重命名<br>ctrl + shift + o 在当前文件查找一个方法<br> alt + shift + f 格式化代码<br> F12 跳转到定义处<br> ctrl + i  选中当前行</p>
<p>另外，通过路径<br>        File -&gt; Preferences -&gt; Keyboard Shortcuts中的链接，可以打开keybindings.json文件，定义自己的快捷键<br>     例如：定义把所有字符转化为大写/小写，修改文件keybindings.json文件。然后，通过 ctrl+shift+u 快捷键就可以把一个变量修改为大写。通过ctrl+shift+l把大写的变量变成小写。<br>8405da39ed76ac45f91c7ac4261fa687eb7566a2</p>
<p>Settings Sync   同步插件<br>插件：<br>ESLint   //js文件规范化<br>HTML CSS Support   //html,css<br>html css snippets  html,css 提示，自动补全</p>
<p>Vetur  //vue文件支持<br>vscode-icons 文件前显示图标<br>mithril emmet  // zen coding<br>Path Autocomplete<br>PHP IntelliSense</p>
<p>waka Time //统计写代码时间<br> 自动闭合标签<br>Auto Close Tag<br>颜色变值的实际颜色<br>Color Highlight<br>括号高亮<br>Bracket Pair Colorizer，，</p>
<p>markdown preview enhanced 预览markdown非常好<br>Prettier - Code formatter 自动格式化代码 ，可以自动格式化<br>“editor.formatOnSave”: true</p>
<p>VS Code 终端字体间距过宽<br>解决办法：<br>终端用VSCode的默认字体，编辑器可以用自定义的字体<br>终端使用的字体不能是等宽字体，否则会出现这样的问题</p>
<p>vscode自动给所有的import改为实际路径而不是相对路径，解决办法<br>自动更新 import 语句的路径</p>
<p>默认用户设置<br>// 启用或禁用在 VS Code 中重命名或移动文件时自动更新 import 语句的路径。可选值有: “prompt” (在每次重命名时提示)、”always” (始终自动更新路径) 和 “never” (从不重命名路径且不要提示)。要求工作区使用高于 2.9 版本的 TypeScript。<br>“typescript.updateImportsOnFileMove.enabled”: “prompt”</p>
<p>如果把这个值改成always<br>，就会自动修改所有的import</p>
<ul>
<li><p>VS Code setting Sync插件配置经验：<br>按照教程提示按shift+alt+u 会弹出输入框要求输入github中的token，第一次可以输入<br>如果输入错误，再次按快捷键会不断提示token过期或错误。</p>
<p>解决办法: 找到settings.json文件同目录下的syncLocalSettings.json<br>查找办法，鼠标放到setting.json的打开标签上会显示文件目录，右键可打开所在目录。<br>C:\Users\zhaojianpeng3\AppData\Roaming\Code\User</p>
<p>修改文件中的token为github中对应的token，保存文件。重新按快捷键即可启用。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Vue理论</title>
    <url>/posts/Vue%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="前端理论"><a href="#前端理论" class="headerlink" title="前端理论"></a>前端理论</h2><h2 id="Vue-js-优势"><a href="#Vue-js-优势" class="headerlink" title="Vue.js 优势"></a>Vue.js 优势</h2><p>主要是基于以下几个方面的考虑。</p>
<ul>
<li><p>体积：19kB（min+gzip）</p>
</li>
<li><p>API 和学习成本：</p>
</li>
<li><p>声明式组件模板和分离样式表，更接近于传统开发模式，抵触心理小。</p>
</li>
<li><p>响应式的组件状态跟踪：更新状态代码更简洁，组件树重新渲染效率更高。</p>
</li>
<li><p>清晰简洁的生命周期钩子函数和单向数据流：页面逻辑和状态更新更可控。</p>
</li>
<li><p>运行时报错和告警详细：方便新手入门和规避常见错误。</p>
</li>
<li><p>工具链完整性：webpackLoader（加载 Vue 单文件组件）、开发者工具（DevTools）、脚手架（vue-cli）、单元测试友好（vue-test-utils）。</p>
</li>
<li><p>运行时性能：</p>
</li>
<li><p>VirtualDOM 来管理组件树渲染到真实 DOM 的状态同步，使用高效的算法<br>来最小化 DOM 操作的次数。</p>
</li>
<li><p>由于响应式设计，不需要优化组件树再次渲染的范围。</p>
</li>
<li><p>组件树静态部分被单独处理，重新渲染不需要重新构建。</p>
</li>
<li><p>同构渲染：</p>
</li>
<li><p>高性能、开箱即用的方案，包括前后端可用的路由和状态管理组件，降低了<br>使用的门槛。</p>
</li>
<li><p>深度 webpack 集成，简化了代码分割和构建调试流程。</p>
</li>
<li><p>前后端分离：前端拥有完整独立的开发、测试、部署的流程，与后端完全分离，<br>减少沟通成本。</p>
</li>
<li><p>模块化与组件化：封装可重用 UI 组件、业务逻辑，提升代码库的可复用性、<br>可测试性。</p>
</li>
<li><p>流程自动化：提升效率、避免重复手工工作、保证质量、自动资源优化等等。</p>
</li>
<li><p>页面加载性能优化：建立前端监控体系、优化资源加载、使用离线化策略。</p>
</li>
</ul>
<h2 id="前后端分离的关键点在于前端拥有完整独立的开发、测试、部署的流程，与后端完全分离"><a href="#前后端分离的关键点在于前端拥有完整独立的开发、测试、部署的流程，与后端完全分离" class="headerlink" title="前后端分离的关键点在于前端拥有完整独立的开发、测试、部署的流程，与后端完全分离"></a>前后端分离的关键点在于前端拥有完整独立的开发、测试、部署的流程，与后端完全分离</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">在赫尔墨斯项目中，我们把页面的组装完全放置到了前端项目，后端只提供</span><br><span class="line">AJAX 的接口用于获取和提交数据。前端页面完全静态化，构建完毕之后连同相应的</span><br><span class="line">静态资源通过 CI 直接发布到 CDN</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化开发的优势主要有以下几个方面。</p>
<ul>
<li>更好的代码组织结构和开发协作：通过细致的文件夹、文件拆分，更易于管理<br>复杂的代码库，更易于多人协作开发，降低文件合并时候冲突的发生概率，方<br>便编写单元测试。</li>
<li>依赖管理：不再需要手动管理脚本的加载顺序。</li>
<li>优化：</li>
<li>代码打包（Bundle）：合并小模块，抽取公共模块，在资源请求数和浏览器缓<br>存利用方面进行合适的取舍。</li>
<li>代码分割（Split）：允许按需加载 JS 代码（分路由、异步组件），解决单页面<br>应用（SPA）首屏加载速度问题。</li>
<li>Tree Shaking：利用 ES6 模块的静态化特性，可以在构建过程中分析出代<br>码库中未使用到的代码，从最终的 bundle 中去除，从而减少 JS●Bundle 的<br>尺寸。</li>
<li>Scope Hoisting：ES6 模块内容导入和导出绑定是活动的，可以将多个小<br>模块合并到一个函数当中，对于重复变量名进行合适的重命名，从而减少<br>Bundle 的尺寸和提升加载速度。</li>
</ul>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>模块化是解决如何封装和复用一段逻辑代码的话，组件化要解决的是如何<br>封装和复用一个用户界面元素，例如，一个按钮、一个弹出框，亦或是一个轮播图。</p>
<h3 id="页面-静态页面-树-节点描述-数据-功能逻辑"><a href="#页面-静态页面-树-节点描述-数据-功能逻辑" class="headerlink" title="页面 = 静态页面(树 + 节点描述 + 数据) + 功能逻辑"></a>页面 = 静态页面(树 + 节点描述 + 数据) + 功能逻辑</h3><p>技术领域有一个软件设计范式：==“约定大于配置”==，旨在减少 软件开发<br>人员需要做决定的数量，做到简单而又不失灵活。在插件编写过程中开发者应多注意<br>使用场景和性能的有机结合，使用恰当的语法，尽可能减少开发者的配●置，不求迎合<br>各个场景。</p>
<h2 id="webView性能优化"><a href="#webView性能优化" class="headerlink" title="webView性能优化"></a>webView性能优化</h2><p>所以与浏览器不同，App 中打开 WebView 的第一步并不是建立连接，而是启<br>动浏览器内核。</p>
<ul>
<li>WebView 初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。</li>
<li>后端处理慢，可以让服务器分 trunk 输出，在后端计算的同时前端也加载网络<br>静态资源。</li>
<li>脚本执行慢，就让脚本在最后运行，不阻塞页面解析。</li>
<li>同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。</li>
<li>WebView 初始化慢，就随时初始化好一个 WebView 待用。</li>
<li>DNS 和链接慢，想办法复用客户端使用的域名和链接。</li>
<li>脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。</li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>antDesign</title>
    <url>/posts/antDesign/</url>
    <content><![CDATA[<h2 id="记录踩过的坑"><a href="#记录踩过的坑" class="headerlink" title="记录踩过的坑"></a>记录踩过的坑</h2><p>数组必须要key的解决办法</p>
<p>由于有些数据没有唯一key值。需要自行添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> localCounter = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">this</span>.data.forEach(<span class="function"><span class="params">el</span>=&gt;</span>&#123;</span><br><span class="line">    el.id = localCounter++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向数组中动态添加元素时，</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...user,</span><br><span class="line">        id: localCounter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态路由，传参获取参数"><a href="#动态路由，传参获取参数" class="headerlink" title="动态路由，传参获取参数"></a>动态路由，传参获取参数</h2><p>定义路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/coupons/relateProducts/:couponBatchId&#x27;</span>: &#123;</span><br><span class="line">    component: dynamicWrapper(app, [<span class="string">&#x27;coupons&#x27;</span>], <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../routes/Coupons/RelateProducts&#x27;</span>))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在组件中获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.match.params.couponBatchId</span><br></pre></td></tr></table></figure>

<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><h2 id="多级对象setState"><a href="#多级对象setState" class="headerlink" title="多级对象setState"></a>多级对象setState</h2><p>可以单独取出来，修改后再整体放进去</p>
<h2 id="一个组件是modal，打开就查询一次，在哪执行查询"><a href="#一个组件是modal，打开就查询一次，在哪执行查询" class="headerlink" title="一个组件是modal，打开就查询一次，在哪执行查询"></a>一个组件是modal，打开就查询一次，在哪执行查询</h2><p>在componentWillReceiveProps里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里的nextProps为修改后的状态值</span></span><br><span class="line"></span><br><span class="line">    用<span class="built_in">this</span>.props可以获取到修改之前的props</span><br><span class="line"></span><br><span class="line">    通过<span class="built_in">this</span>.props和nextProps两者对比可以看是否需要更新和操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>componentwillreceiveprops会自动接收参数，导致页面不断渲染<br>需要配合this.props使用<br>componentDidMount不会触发</p>
<p>lodash.has</p>
<h2 id="select-用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示"><a href="#select-用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示" class="headerlink" title="select 用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示"></a>select 用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示</h2><h2 id="form表单重置按钮"><a href="#form表单重置按钮" class="headerlink" title="form表单重置按钮"></a>form表单重置按钮</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleReset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.form.resetFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Select-组件使用"><a href="#Select-组件使用" class="headerlink" title="Select 组件使用"></a>Select 组件使用</h2><p>Select 赋值，用this.props.form.setFieldsValues();</p>
<p>select动态赋值给select。，只显示value，没显示label，显示label无法提交<br>类型要匹配，数字就是数字，字符串就是字符串</p>
<h2 id="a元素绑定事件"><a href="#a元素绑定事件" class="headerlink" title="a元素绑定事件"></a>a元素绑定事件</h2><p>给a绑定事件，一定要这样绑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;a onClick=&#123;<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">this</span>.showDetail(record.key)&#125;&gt;详情&lt;/a&gt;</span><br><span class="line">handleMouseOver = <span class="function">(<span class="params">key</span>) =&gt;</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">display</span>: key &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写了models一定要在common的router.js中getRouterData<br>的dynamicWrapper<br>中引入文件夹名字，才能自动引入到app._models中</p>
<p>service 中的api要添加request.</p>
<p>models中要添加reducer，</p>
<p>在页面中要用redux定义好的state，需要在connect中引入<br>@connect(({loading, coupons}) =&gt; ({<br>    data: coupons,<br>}))</p>
<p>action调用成功后，在reducer里改了状态， 打印出来发生变化了，但页面没变化。</p>
<p>在div中写的可以变化，在input或textarea中不会发生变化。</p>
<p>加了mapPropsToFields后，修改的值回响应到textarea上，</p>
<p>但所有输入框输入的值被清空了</p>
<p>不想用redux，直接用组件里的state，怎么搞？</p>
<p>在dispatch后添加callback.直接用</p>
<p>this.props.form.setFieldsValue({<br>    uids: payload.data.join()<br>});</p>
<p> 一个页面多个form，点击每个form的提交，其他form的字段会跟着提交</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Form的FormItem如果是rangePicker，则设置<span class="string">`style=&#123;&#123;width:100%&#125;&#125;`</span>，可以让输入框响应容器</span><br></pre></td></tr></table></figure>

<p>Form的label和input输入框的宽度通过调节labelCol，wrapperCol<br>来设置，总长度为24</p>
<p>啊啊啊啊大经验啊！！！！</p>
<p>nginx的proxy配置一定要前后路径一致</p>
<p><code>&#39;POST /coupon/v1/(.*)&#39;: &#39;&lt;http://10.64.38.89:8081/coupon/v1/&#39;,&gt;</code></p>
<p>前面是coupon/v1后面也一定是coupon/v1,<br>不能前面是coupon 后面是coupon/v1<br>项目一定要放在www目录下</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>antDesign</tag>
      </tags>
  </entry>
  <entry>
    <title>axios积累</title>
    <url>/posts/axios%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h2 id="使用axios在url后统一加参数遇到的问题"><a href="#使用axios在url后统一加参数遇到的问题" class="headerlink" title="使用axios在url后统一加参数遇到的问题"></a>使用axios在url后统一加参数遇到的问题</h2><p>如果是get请求，直接加在url后面</p>
<p><code>https://www.baidu.com?a=1&amp;b=2</code></p>
<p>如果要get, post, put都加呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    ...params,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">    params: data,</span><br><span class="line">&#125;)</span><br><span class="line">axios.post(url, &#123;</span><br><span class="line">    params: data,</span><br><span class="line">&#125;)</span><br><span class="line">axios.put(url, &#123;</span><br><span class="line">    params: data,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 如果在url和post的data中都加同样参数的话，有的后端服务会报错，无法正常解析。</p>
<p>axios在data中添加参数后，会根据get，post不同请求方法，选择不同的参数拼接方式.</p>
<blockquote>
<p>get: 加到url后，<br>post, put加到post的data中。</p>
</blockquote>
<p>综上: 添加url参数可以根据具体需求选择直接加在url后还是加到data中。</p>
]]></content>
  </entry>
  <entry>
    <title>canvas实战</title>
    <url>/posts/canvas%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="CANVAS游戏实战思路"><a href="#CANVAS游戏实战思路" class="headerlink" title="CANVAS游戏实战思路"></a>CANVAS游戏实战思路</h2><ol>
<li>绘图基础<br> 添加图形、图片、设置颜色</li>
<li>动起来<br> 画布定时重绘</li>
<li>加入键盘鼠标控制<br> 可操控</li>
</ol>
<p>动画框架<a href="https://pixijs.io/">PixiJS</a></p>
]]></content>
  </entry>
  <entry>
    <title>centos安装git</title>
    <url>/posts/centos%E5%AE%89%E8%A3%85git/</url>
    <content><![CDATA[<h2 id="centos安装git"><a href="#centos安装git" class="headerlink" title="centos安装git"></a>centos安装git</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>yum install -y git</p>
<h2 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h2><p>git –version</p>
<h2 id="生成公钥并复制到服务器上"><a href="#生成公钥并复制到服务器上" class="headerlink" title="生成公钥并复制到服务器上"></a>生成公钥并复制到服务器上</h2><h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><p>ssh-keygen -t rsa</p>
<h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><p>cat .ssh/id_rsa.pub</p>
<h3 id="复制id-rsa-pub里的公钥到服务器上的authorized-keys文件"><a href="#复制id-rsa-pub里的公钥到服务器上的authorized-keys文件" class="headerlink" title="复制id_rsa.pub里的公钥到服务器上的authorized_keys文件"></a>复制id_rsa.pub里的公钥到服务器上的authorized_keys文件</h3><p>拷贝出来，复制到github.com的settings的SSH and GPG keys中</p>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>yum install -y nodejs//行不通，版本太旧了</p>
<p>参考：<a href="http://wiki.jikexueyuan.com/project/nodejs-guide/install.html">http://wiki.jikexueyuan.com/project/nodejs-guide/install.html</a></p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>yum remove nodejs -y</p>
<h2 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h2><p>1.确保系统下 g++ 版本在 4.6 以上，python 版本在 2.6 以上。</p>
<p>2.从 nodejs.org 下载 tar.gz 后缀的 NodeJS 最新版源代码包并解压到某个位置。</p>
<p>wget <a href="https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz">https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz</a></p>
<p>3.进入解压到的目录，使用以下命令编译和安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zvxf node-v4.5.0.tar.gz</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>centos</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>h5开发积累</title>
    <url>/posts/h5%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<ol>
<li>图片切图高度750*1334</li>
</ol>
<p>h5滚动画布插件</p>
<ul>
<li><a href="https://github.com/pbakaus/scroller">scroller</a></li>
<li><a href="https://www.npmjs.com/package/animateJs">animateJs</a></li>
<li><a href="https://github.com/CreateJS/TweenJS">TweenJS</a></li>
<li><a href="https://pixijs.io/">pixi.js</a></li>
</ul>
<p>H5 要考虑的因素:<br>. 屏幕旋转自动适配<br>元素根据屏幕确定位置</p>
<a id="more"></a>

<h2 id="网易-o-h5"><a href="#网易-o-h5" class="headerlink" title="网易(^o^)/~ h5"></a>网易(^o^)/~ h5</h2><p><a href="http://d.news.163.com/">总网站</a></p>
<p><a href="http://news.163.com/special/fdh5_sleeping_14/">睡姿大比拼—加密</a></p>
<p><a href="http://news.163.com/special/fdh5_tongnian_rt/">滑向童年 不是pixi</a></p>
<p><a href="http://go.163.com/web/20180423_aa3/index.html">jquery实现的</a></p>
<h2 id="pixi-学习资料"><a href="#pixi-学习资料" class="headerlink" title="pixi 学习资料"></a>pixi 学习资料</h2><p><a href="https://pixijs.io/examples/">官网例子</a><br><a href="http://pixijs.io/pixi-sound/examples/">声音插件</a><br>都可以在npm中找到</p>
<p>手机端video标签不能自动显示封面，需设置poster</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol>
<li><p>微信里面的音乐不能自动播放，<br>如果用dom的自动播放，浏览器里的又不能自动播放。<br>网易也是选择一种实现的。</p>
</li>
<li><p>图片虚化，原因：最外层容器缩小了0.5，导致所有素材缩小0.5.但这不是虚化的原因，因为其他网页也是这样虚化的。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>iTerm2完美的终端体验</title>
    <url>/posts/iTerm2%E5%AE%8C%E7%BE%8E%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>mac 自带的终端实在是差劲，改用 iTerm2 可以 6 到飞起~~~</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.iterm2.com/">直接下载</a>安装即可。</p>
<h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装<a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a></h2><p>安装方法由于会经常更新，请点击链接跳转查看安装办法</p>
<!--- more --->

<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>修改 ZSH_THEME=”主题名”</p>
<p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>找到如下配置<br>ZSH_THEME=”robbyrussell”<br>修改为<br>ZSH_THEME=”ys”</p>
<p>可以根据自己喜好选择不同的主题</p>
<p><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes">主题配置库</a></p>
<h2 id="代码高亮-zsh-syntax-highlighting"><a href="#代码高亮-zsh-syntax-highlighting" class="headerlink" title="代码高亮(zsh-syntax-highlighting)"></a>代码高亮(<a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md">zsh-syntax-highlighting</a>)</h2><p>安装方法详见链接</p>
<h2 id="自动提示命令-zsh-autosuggestions"><a href="#自动提示命令-zsh-autosuggestions" class="headerlink" title="自动提示命令(zsh-autosuggestions)"></a>自动提示命令(<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a>)</h2><p>安装方法详见链接</p>
<h2 id="自动切换目录-autojump"><a href="#自动切换目录-autojump" class="headerlink" title="自动切换目录(autojump)"></a>自动切换目录(<a href="https://github.com/wting/autojump">autojump</a>)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install autojump</span><br></pre></td></tr></table></figure>

<p>根据提示将以下内容添加到~/.zshrc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ -f /usr/<span class="built_in">local</span>/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/<span class="built_in">local</span>/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure>

<p>刚开始装了不会有效果，需多进几个目录，就可以看到效果</p>
<h3 id="快捷键-j"><a href="#快捷键-j" class="headerlink" title="快捷键 j"></a>快捷键 j</h3><p>按 tab 可以选择下拉里提示的内容</p>
<p>权重值越高，优先级越高<br>要调整某个目录的优先级，需要先进入到文件目录下，进行调整</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示数据库中的统计数据, (前面的数字是权重值)</span></span><br><span class="line">j -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加某个目录的权重</span></span><br><span class="line">j -i 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 降低某个目录权重</span></span><br><span class="line">j -d 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除无用数据</span></span><br><span class="line">j --purge</span><br></pre></td></tr></table></figure>

<h3 id="使用中发现的问题"><a href="#使用中发现的问题" class="headerlink" title="使用中发现的问题"></a>使用中发现的问题</h3><p>如果两个目录后面的文件夹名相同，例如<code>/home/abc/de</code>和<code>/home/de</code>，权重级别不一样，<br>直接用<code>j de</code>不会每次都跳转到权重高的目录，如果不是想要的可以再次执行<code>j de</code>即可</p>
<h2 id="homebrew-更新"><a href="#homebrew-更新" class="headerlink" title="homebrew 更新"></a>homebrew 更新</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>在安装一些软件时，会遇到 updating homebrew 卡住的问题，这时 control+c 断开，执行 brew update.</p>
<p>会成功更新。</p>
<p>网上还有说法是更换 brew 镜像源—没试过。</p>
<h2 id="启动问候语设置"><a href="#启动问候语设置" class="headerlink" title="启动问候语设置"></a>启动问候语设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">sudo pico motd</span><br><span class="line">输入密码后输入问候语</span><br><span class="line"></span><br><span class="line">按control+x退出，按y确认， 按回车确认，</span><br><span class="line">用 y保存退出，再 y一次确认文件名motd</span><br></pre></td></tr></table></figure>

<p>打开新标签页，即可看到提示语</p>
<h2 id="安装-iTerm2-后替换为系统自带的-bash"><a href="#安装-iTerm2-后替换为系统自带的-bash" class="headerlink" title="安装 iTerm2 后替换为系统自带的 bash"></a>安装 iTerm2 后替换为系统自带的 bash</h2><p>打开 iTerm2-&gt;prefrences-&gt;profiles-command<br>选择 command 输入<code>/bin/bash</code>即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改iterm 默认程序</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复原来的bash</span></span><br><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开新标签</span></span><br><span class="line"><span class="built_in">command</span>+t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭标签</span></span><br><span class="line"><span class="built_in">command</span>+w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同一个Tab内的分屏切换</span></span><br><span class="line">Command + [</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tab之间的切换</span></span><br><span class="line">Command + 数字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 垂直切分窗口</span></span><br><span class="line"><span class="built_in">command</span>+d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平切分窗口</span></span><br><span class="line"><span class="built_in">command</span>+<span class="built_in">shift</span>+d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制窗口</span></span><br><span class="line">左上角shell-&gt;duplicate Tab 以当前路径下打开新的窗口</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入与返回全屏模式</span></span><br><span class="line"><span class="built_in">command</span>+enter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前快照</span></span><br><span class="line">Window &gt; Save Window Arrangement.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复快照：</span></span><br><span class="line">Window &gt; Restore Window Arrangement</span><br><span class="line"></span><br><span class="line">可以在Preferences &gt; General &gt; Open saved window arrangement.设置自动恢复快照</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从终端进入Finder</span></span><br><span class="line"></span><br><span class="line">进入某个目录</span><br><span class="line">open .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finder 进终端</span></span><br><span class="line">直接拖拽</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史命令</span></span><br><span class="line"><span class="built_in">command</span> + ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看剪贴板历史</span></span><br><span class="line"><span class="built_in">command</span> + <span class="built_in">shift</span> + h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令搜索</span></span><br><span class="line">Ctrl + r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除当前行命令</span></span><br><span class="line">Ctrl + u</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳转到行首</span></span><br><span class="line">Ctrl + a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳转到行尾</span></span><br><span class="line">Ctrl + e</span><br></pre></td></tr></table></figure>

<h2 id="自动补全插件-incr-—如果提示多了会卡的很严重，曾经用过，后来替换成-zsh-autosuggestions"><a href="#自动补全插件-incr-—如果提示多了会卡的很严重，曾经用过，后来替换成-zsh-autosuggestions" class="headerlink" title="自动补全插件 incr —如果提示多了会卡的很严重，曾经用过，后来替换成 zsh-autosuggestions"></a>自动补全插件 incr —如果提示多了会卡的很严重，曾经用过，后来替换成 zsh-autosuggestions</h2><p>下载此插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mimosa-pudica.net/src/incr-0.2.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将此插件放到oh-my-zsh目录的插件库下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在~/.zshrc文件末尾加上</span></span><br><span class="line"><span class="built_in">source</span> ~/.oh-my-zsh/plugins/incr/incr*.zsh</span><br><span class="line"><span class="comment"># 更新配置</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<h2 id="命令参数提示"><a href="#命令参数提示" class="headerlink" title="命令参数提示"></a>命令参数提示</h2><p>举个栗子，之前偶尔需要用到删除文件夹的操作，rm -r [path]，但是常常会忘记中间的参数是什么，现在我只需要这么做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入 rm - ， 然后按tab</span></span><br><span class="line">rm -</span><br><span class="line">-R  -r  -- remove directories and their contents recursively</span><br><span class="line">-f      -- ignore nonexistent files, never prompt</span><br><span class="line">-i      -- prompt before every removal</span><br></pre></td></tr></table></figure>

<h2 id="git-快捷键"><a href="#git-快捷键" class="headerlink" title="git 快捷键"></a>git 快捷键</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh">插件git.plugin.zsh地址</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/plugins/git</span><br><span class="line">less git.plugin.zsh</span><br></pre></td></tr></table></figure>

<p>在这里可以看到常用的git命令别名</p>
<h2 id="官方插件列表"><a href="#官方插件列表" class="headerlink" title="官方插件列表"></a><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview">官方插件列表</a></h2><p>看别人在用的插件</p>
<ul>
<li>fasd</li>
<li>history</li>
</ul>
<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  查看当前所用的 Shell</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统内已安装的 Shell</span></span><br><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>

<h2 id="iterm中git-status-显示字符，不显示中文"><a href="#iterm中git-status-显示字符，不显示中文" class="headerlink" title="iterm中git status 显示字符，不显示中文"></a>iterm中git status 显示字符，不显示中文</h2><p>  解决方法：在命令行执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="rz-sz上传下载文件"><a href="#rz-sz上传下载文件" class="headerlink" title="rz/sz上传下载文件"></a>rz/sz上传下载文件</h2><ol>
<li><p>安装lrzsz <code>brew install lrzsz</code></p>
</li>
<li><p>下载配置iTerm2的相关脚本</p>
<p> <a href="https://github.com/luxihk/iterm2-zmodem">脚本地址</a></p>
<p> 在/usr/local/bin目录下直接执行：</p>
<p> <code>wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</code><br> 赋予可执行权限<br> <code>chmod +x /usr/local/bin/iterm2-send-zmodem.sh /usr/local/bin/iterm2-recv-zmodem.sh</code></p>
</li>
<li><p>配置ITerm2</p>
<p> Term2的配置项：iTerm2的Preferences-&gt; Profiles -&gt; Default -&gt; Advanced -&gt; Triggers的Edit按钮。</p>
<p> 然后配置项如下：</p>
<table>
<thead>
<tr>
<th>Regular Expression</th>
<th>Action</th>
<th>Parameters</th>
<th>Instant</th>
</tr>
</thead>
<tbody><tr>
<td>rz waiting to receive.\<em>\</em>B0100</td>
<td>Run Silent Coprocess</td>
<td>/usr/local/bin/iterm2-send-zmodem.sh</td>
<td>checked</td>
</tr>
<tr>
<td>\<em>\</em>B00000000000000</td>
<td>Run Silent Coprocess</td>
<td>/usr/local/bin/iterm2-recv-zmodem.sh</td>
<td>checked</td>
</tr>
</tbody></table>
<p> 注意最后一项需要你将Instant选项勾上，否则将不生效</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>终端</tag>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery插件思路整理</title>
    <url>/posts/jQuery%E6%8F%92%E4%BB%B6%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="jQuery插件的封装"><a href="#jQuery插件的封装" class="headerlink" title="jQuery插件的封装"></a>jQuery插件的封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>

<p>闭包的作用<br>–避免全局依赖<br>–避免第三方破坏<br>–兼容jQuery操作符‘$’和jQuery</p>
<!---more--->

<h2 id="开发方式"><a href="#开发方式" class="headerlink" title="开发方式"></a>开发方式</h2><ul>
<li>类级别组件开发</li>
<li>即给jQuery命名空间下添加新的全局函数，也称静态方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如：<code>$.ajax,$.extend()</code></p>
<ul>
<li>对象级别组件开发</li>
<li>即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法, 也称动态方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里 <code>$.fn === $.prototype</code><br>例如：<code>addClass()、attr()</code> 等，需要创建实例来调用</p>
<ul>
<li>链式调用<br>eg: <code>$(&quot;div&quot;).next().addClass()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li><p>return this 返回当前对象，来维护插件的链式调用</p>
</li>
<li><p>each 循环实现每个元素的访问</p>
</li>
<li><p>单例模式</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.myPlugin  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> me = $(<span class="built_in">this</span>),</span><br><span class="line">        instance = me.data(<span class="string">&quot;myPlugin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        me.data(<span class="string">&quot;myPlugin&quot;</span>,(instance= <span class="keyword">new</span> Plugin()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码说明：<br>-如果实例存在则不再重新创建实例<br>-利用data()来存放插件对象的实例</p>
<p>   jQuery插件的开发包括两种：<br>一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。<br>1、类级别的插件开发<br>类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：<br>1.1 添加一个新的全局函数<br>添加一个全局函数，我们只需如下定义：<br>Java代码  </p>
<p>jQuery.foo = function() {<br>alert(‘This is a test. This is only a test.’);<br>};</p>
<p>1.2 增加多个全局函数<br>添加多个全局函数，可采用如下定义：<br>Java代码  </p>
<p>jQuery.foo = function() {<br>alert(‘This is a test. This is only a test.’);<br>};<br>jQuery.bar = function(param) {<br>alert(‘This function takes a parameter, which is “‘ + param + ‘“.’);<br>};<br>调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar(‘bar’);<br>1.3 使用jQuery.extend(object);<br>Java代码  </p>
<p>jQuery.extend({<br>foo: function() {<br>alert(‘This is a test. This is only a test.’);<br>},<br>bar: function(param) {<br>alert(‘This function takes a parameter, which is “‘ + param +’”.’);<br>}<br>});  </p>
<p>1.4 使用命名空间<br>虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。<br>Java代码  </p>
<p>jQuery.myPlugin = {<br>foo:function() {<br>alert(‘This is a test. This is only a test.’);<br>},<br>bar:function(param) {<br>alert(‘This function takes a parameter, which is “‘ + param + ‘“.’);<br>}<br>};<br>采用命名空间的函数仍然是全局函数，调用时采用的方法：<br>$.myPlugin.foo();<br>$.myPlugin.bar(‘baz’);  </p>
<p>通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。<br>2、对象级别的插件开发<br>对象级别的插件开发需要如下的两种形式：、<br>形式1：<br>Java代码  </p>
<p>(function($){<br>$.fn.extend({<br>pluginName:function(opt,callback){<br>          // Our plugin implementation code goes here.<br>}<br>})<br>})(jQuery);<br>形式2：<br>Java代码  </p>
<p>(function($) {<br>$.fn.pluginName = function() {<br>     // Our plugin implementation code goes here.<br>};<br>})(jQuery);<br>       上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突.<br>2.1 在JQuery名称空间下申明一个名字<br>这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和$.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“</p>
<p>Java代码  </p>
<p>$.fn.hilight = function() {<br>  // Our plugin implementation code goes here.<br>};<br>我们的插件通过这样被调用：<br>$(‘#myDiv’).hilight();</p>
<p>但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易或更易读的实现；而且这样更符合面向对象。 这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样，函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们需要暴露出来的，都可以在”hilight” 函数中被声明属性。稍后继续。<br>2.2 接受options参数以控制插件的行为<br>让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给插件函数。例如：<br>Java代码  </p>
<p>// plugin definition<br>$.fn.hilight = function(options) {<br>  var defaults = {<br>    foreground: ‘red’,<br>    background: ‘yellow’<br>  };<br>  // Extend our default options with those provided.<br>  var opts = $.extend(defaults, options);<br>  // Our plugin implementation code goes here.<br>};<br>我们的插件可以这样被调用：<br>$(‘#myDiv’).hilight({<br>  foreground: ‘blue’<br>});</p>
<p>2.3 暴露插件的默认设置<br>我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖和修改插件。接下来我们开始利用函数对象。</p>
<p>Java代码  </p>
<p>// plugin definition<br>$.fn.hilight = function(options) {<br>  // Extend our default options with those provided.<br>  // Note that the first arg to extend is an empty object -<br>  // this is to keep from overriding our “defaults” object.<br>  var opts = $.extend({}, $.fn.hilight.defaults, options);<br>  // Our plugin implementation code goes here.<br>};<br>// plugin defaults - added as a property on our plugin function<br>$.fn.hilight.defaults = {<br>  foreground: ‘red’,<br>  background: ‘yellow’<br>};<br>现在使用者可以包含像这样的一行在他们的脚本里：<br>//这个只需要调用一次，且不一定要在ready块中调用<br>$.fn.hilight.defaults.foreground = ‘blue’;<br>接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色：<br>$(‘#myDiv’).hilight();</p>
<p>如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的覆盖这些新的默认值：<br>// 覆盖插件缺省的背景颜色<br>$.fn.hilight.defaults.foreground = ‘blue’;<br>// …<br>// 使用一个新的缺省设置调用插件<br>$(‘.hilightDiv’).hilight();<br>// …<br>// 通过传递配置参数给插件方法来覆盖缺省设置<br>$(‘#green’).hilight({<br>  foreground: ‘green’<br>});<br>2.4 适当的暴露一些函数<br>这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如，我们插件的实现里面可以定义一个名叫”format”的函数来格式化高亮文本。我们的插件现在看起来像这样，默认的format方法的实现部分在hiligth函数下面。<br>Java代码  </p>
<p>// plugin definition<br>$.fn.hilight = function(options) {<br>  // iterate and reformat each matched element<br>  return this.each(function() {<br>    var $this = $(this);<br>    // …<br>    var markup = $this.html();<br>    // call our format function<br>    markup = $.fn.hilight.format(markup);<br>    $this.html(markup);<br>  });<br>};<br>// define our format function<br>$.fn.hilight.format = function(txt) {<br>return ‘<strong>‘ + txt + ‘</strong>‘;<br>};<br>      我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。<br>      考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用者暴露”transitions”对象，使他们添加自己变换定义。插件中定义就像这样：<br>$.fn.cycle.transitions = {<br>// …<br>};<br>这个技巧使其他人能定义和传递变换设置到Cycle插件。<br>2.5 保持私有函数的私有性<br>这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯定是否暴露特定的函数，那么你也许不需要那样做。<br>那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。<br>Java代码  </p>
<p> (function($) {<br>  // plugin definition<br>  $.fn.hilight = function(options) {<br>    debug(this);<br>    // …<br>  };<br>  // private function for debugging<br>  function debug($obj) {<br>    if (window.console &amp;&amp; window.console.log)<br>      window.console.log(‘hilight selection count: ‘ + $obj.size());<br>  };<br>//  …<br>})(jQuery);</p>
<p>我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。<br>2.6 支持Metadata插件<br>在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个Metadata插件，因为它让你使用不多的”markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它非常简单。更新：注释中有一点优化建议。<br>Java代码  </p>
<p>$.fn.hilight = function(options) {<br>  // …<br>  // build main options before element iteration<br>  var opts = $.extend({}, $.fn.hilight.defaults, options);<br>  return this.each(function() {<br>    var $this = $(this);<br>    // build element specific options<br>    var o = $.meta ? $.extend({}, opts, $this.data()) : opts;<br>    //…<br> 这些变动行做了一些事情：它是测试Metadata插件是否被安装如果它被安装了，它能扩展我们的options对象通过抽取元数据这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从”markup”处驱动行为,如果我们选择了“markup”：<br> 调用的时候可以这样写： jQuery.foo(); 或 $.foo();</p>
<p>Java代码  </p>
<!--  markup  -->
<div class="hilight { background: 'red', foreground: 'white' }">
  Have a nice day!
</div>
<div class="hilight { foreground: 'orange' }">
  Have a nice day!
</div>
<div class="hilight { background: 'green' }">
  Have a nice day!
</div>
现在我们能高亮哪些div仅使用一行脚本：  
$('.hilight').hilight();

<p>2.7 整合<br>下面使我们的例子完成后的代码：</p>
<p>Java代码  </p>
<p>// 创建一个闭包<br>(function($) {<br>  // 插件的定义<br>  $.fn.hilight = function(options) {<br>    debug(this);<br>    // build main options before element iteration<br>    var opts = $.extend({}, $.fn.hilight.defaults, options);<br>    // iterate and reformat each matched element<br>    return this.each(function() {<br>      $this = $(this);<br>      // build element specific options<br>      var o = $.meta ? $.extend({}, opts, $this.data()) : opts;<br>      // update element styles<br>      $this.css({<br>        backgroundColor: o.background,<br>        color: o.foreground<br>      });<br>      var markup = $this.html();<br>      // call our format function<br>      markup = $.fn.hilight.format(markup);<br>      $this.html(markup);<br>    });<br>  };<br>  // 私有函数：debugging<br>  function debug($obj) {<br>    if (window.console &amp;&amp; window.console.log)<br>      window.console.log(‘hilight selection count: ‘ + $obj.size());<br>  };<br>  // 定义暴露format函数<br>  $.fn.hilight.format = function(txt) {<br>    return ‘<strong>‘ + txt + ‘</strong>‘;<br>  };<br>  // 插件的defaults<br>  $.fn.hilight.defaults = {<br>    foreground: ‘red’,<br>    background: ‘yellow’<br>  };<br>// 闭包结束<br>})(jQuery);</p>
<p>这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。<br>3、总结<br>jQuery为开发插件提拱了两个方法，分别是：<br>jQuery.fn.extend(object);  给jQuery对象添加方法。<br>jQuery.extend(object);  为扩展jQuery类本身.为类添加新的方法。<br>3.1 jQuery.fn.extend(object);<br>fn 是什么东西呢。查看jQuery代码，就不难发现。<br>jQuery.fn = jQuery.prototype = {<br>init: function( selector, context ) {//….<br>//……<br>};<br>原来 jQuery.fn = jQuery.prototype.对prototype肯定不会陌生啦。虽然 javascript　没有明确的类的概念，但是用类来理解它，会更方便。jQuery便是一个封装得非常好的类，比如我们用 语句　$(“#btn1”) 会生成一个 jQuery类的实例。<br>jQuery.fn.extend(object); 对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。<br>比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这么做：<br>$.fn.extend({<br>     alertWhileClick:function(){<br>         $(this).click(function(){<br>              alert($(this).val());<br>          });<br>      }<br>});<br>$(“#input1”).alertWhileClick(); //页面上为：<input id="input1" type="text"/><br>$(“#input1”)　为一个jQuery实例，当它调用成员方法 alertWhileClick后，便实现了扩展，每次被点击时它会先弹出目前编辑里的内容。<br>3.2 jQuery.extend(object);<br>为jQuery类添加添加类方法，可以理解为添加静态方法。如：<br>$.extend({<br>    add:function(a,b){return a+b;}<br>});<br>便为　jQuery　添加一个为 add　的　“静态方法”，之后便可以在引入 jQuery　的地方，使用这个方法了，$.add(3,4); //return 7</p>
]]></content>
      <tags>
        <tag>jQuery</tag>
        <tag>插件</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/posts/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ul>
<li><p>String是复合类型，int ,float 是基本类型<br>  复合类型是对象类型，对象自己提供了比较方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;A&quot;</span>; String b = a+<span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(a==b);-----------<span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>串与子串<br>substring(begin,end)  包含begin，不含end，半开区间[begin,end);</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>进制转换<br>  Integer.parseInt(串,进制)<br>  Integer.toString(整数,进制)<br>  Integer.toBinaryString(数值)<br>  Integer.toHexString(数值)</p>
</li>
<li><p>时间计算<br>long a = 365L<em>24</em>60<em>60</em>1000  ———-转为long型，自动向long型转换<br>long a = (long)……<br>long a = 1L*……————-非侵入式</p>
</li>
</ul>
<ul>
<li><p>类型转换<br>  自动向高级别转换<br>  byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double<br>  无需特殊需要，尽量使用int</p>
</li>
<li><p>构造<br>  初始化一个对象的时候对他进行一次初生的洗礼，设置一些初始值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">()</span></span>&#123;<span class="comment">//没有返回值。没有void比有void更牛。构造方法也可以有多个。</span></span><br><span class="line">    多种出生方式，</span><br><span class="line">    只选择一种</span><br><span class="line">    没有提供构造方法，默认提供一种，当提供了以后，需要提供一个默认的。</span><br><span class="line">    重载 overload 名字相同，但参数不同，（个数，类型）</span><br><span class="line">    <span class="comment">//成员数据(字段)的初始化</span></span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>) x==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>) x==<span class="number">18</span>;</span><br><span class="line">        <span class="keyword">else</span> x =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x )</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>堆栈，一般指栈。</p>
</li>
<li><p>定义数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];<span class="comment">//默认为0</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">null</span>;</span><br><span class="line">a =<span class="keyword">new</span> <span class="keyword">int</span>[][<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>斐波那契数列 1，1，2，3，5，8，18，21</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="keyword">int</span> b =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> c =  a+b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    a= b;</span><br><span class="line">    b= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">30</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    a[i] = a[i-<span class="number">1</span>]+a[i-<span class="number">2</span>];</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] a = &#123;&#123;<span class="number">2</span>,<span class="number">9</span>,<span class="number">4</span>&#125;,&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,&#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>传递的参数最大为8字节，实际上java不可能传递对象，至多，java传递对象的引用。</p>
<ul>
<li>数组的应用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;1234567&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] cc = s.toCharArray();</span><br></pre></td></tr></table></figure>

<ul>
<li>数组弱点<br>  1.大小固定，不能扩展<br>  2.在数组中插入、删除元素操作复杂<br>动态数组–Vector  ArrayList.<br>  任意位置插入，删除容易<br>  可以动态增长<br>  随机访问比数组慢</li>
</ul>
<ul>
<li><p>this<br>  this是隐藏的形参变量，是一个地址值(对象内存中地址)，是栈变量<br>  形式参数的值从实参拷贝过来</p>
</li>
<li><p>static<br>  构造方法不适合</p>
<pre><code>  构造方法在每次创建对象的时候，自动执行
  不创建对象，构造方法就没有机会执行</code></pre>
<p>  static块在类加载入内存时执行一次</p>
<pre><code>  仅仅执行一次，不会反复执行
  与类同时存在</code></pre>
</li>
</ul>
<ul>
<li><p>继承<br>  封装是基础，继承是桥梁，多态是华彩乐章<br>  继承的目的，重用代码，为多态铺平代码<br>  java采用接口代替多继承<br>  java类只能继承一个类，但可以实现多个接口</p>
</li>
<li><p>方法覆盖<br>  子类与父类中同名的方法</p>
</li>
<li><p>重载<br>  重载是编译时可以区分的<br>  覆盖是在运行时决定调用哪个方法<br>  覆盖是多态的基础</p>
</li>
</ul>
<ul>
<li><p>泛化<br>  对象不发生变化，只是指针发生变化<br>  是指针引用的泛化，并不是对象的泛化，并不是类的泛化</p>
</li>
<li><p>多态<br>  意义  很牛！！！  多态，泛化</p>
</li>
<li><p>final  惯用法<br>  静态常量<br>  用来定义若干个选项，增加可读性</p>
</li>
<li><p>异常控制<br>  把异常的发现和处理分离</p>
</li>
<li><p>分工  专门的人做专门的事    生产不断社会化的过程。<br>  设计与编码分离<br>  功能和实现分离<br>  错误的发现和控制分离</p>
</li>
<li><p>异常处理</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//   2</span></span><br><span class="line"><span class="comment">//出异常  </span></span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行顺序: 1243</p>
<ul>
<li><p>重定向</p>
<blockquote>
<blockquote>
<p>追加<br>输出到<br>&lt;导入</p>
</blockquote>
</blockquote>
</li>
<li><p>抽象方法，有一个抽象方法就是抽象类abstract<br>松耦合的秘诀</p>
</li>
<li><p>内部类对象<br>  外部类对象不存在无法创建内部类对象<br>  外部类对象.new 内部类()</p>
</li>
<li><p>匿名对象类<br>  匿名对象 ：对象只用了一次</p>
</li>
<li><p>匿名类<br>  想临时创建实现某个接口类，只用一次，不值得命名<br>  继承类是临时的<br>  对象，继承类所创建的对象是临时的；继承类所创建对象需要多次使用，注意泛化。</p>
</li>
<li><p>编译<br>javac -classpath d:\abc\xyz  A.java<br>命令行选项，编译选项<br>可以简写成-cp<br>寻找class文件<br>  javac.exe所在位置的相对位置<br>  -classpath参数所指定的位置<br>  classpath环境变量所声称的位置</p>
</li>
<li><p>打包<br>jar.exe 能处理打包和解包的工作<br>  jar -cvf A.java</p>
</li>
<li><p>文档自动化<br>  javadoc -d 文档位置 xx.java<br>  javadoc -d 文档位置 -encoding utf-8  制定编码方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@param</span> x 参数的描述</span><br><span class="line"><span class="meta">@return</span> 返回值的描述</span><br><span class="line"><span class="meta">@exception</span> 可能抛出的异常</span><br><span class="line"><span class="meta">@see</span> 参见其他模块</span><br><span class="line"><span class="meta">@version</span> 版本号</span><br><span class="line"><span class="meta">@author</span> 作者</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*我的文档自动化示例类&lt;br&gt;</span></span><br><span class="line"><span class="comment">*第二行  x&lt;sup&gt;2&lt;/sup&gt;+Y&lt;sup&gt;2&lt;/sup&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *在数组中处理查找整数，返回位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> init <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] x,<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</li>
</ul>
<h1 id="android-开发环境搭建经验积累"><a href="#android-开发环境搭建经验积累" class="headerlink" title="android 开发环境搭建经验积累"></a>android 开发环境搭建经验积累</h1><ul>
<li>Android Studio中显示：<br>HAX is not working and emulator runs in emulation mode<br>时，去<br>Tools-&gt;Android-&gt;SDK Manager<br>然后选中<br>Extras-&gt;Intel X86 Emulator Accelerator (HAXM installer)<br>并安装即可。<br>记得如果HAX效果没生效，则试试重启Android Studio试试，或许就可以了。<br>相对来说：和之前的Eclipse+ADT时代，要先后自己手动下载HAX相关工具并安装和配置，的做法相比，Android Studio中只需要选中并安装即可搞定，要方便多了。</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>基础知识</tag>
        <tag>笔记</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>js 定时器</title>
    <url>/posts/js-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、定时器"><a href="#一、定时器" class="headerlink" title="一、定时器"></a>一、定时器</h2><h2 id="setTimeout-设置一个定时器，在定时器到期后，执行一段代码或代码段"><a href="#setTimeout-设置一个定时器，在定时器到期后，执行一段代码或代码段" class="headerlink" title="setTimeout: 设置一个定时器，在定时器到期后，执行一段代码或代码段"></a>setTimeout: 设置一个定时器，在定时器到期后，执行一段代码或代码段</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutId = <span class="built_in">window</span>.setTimeout(func[, delay, param1, param2, ... ]);</span><br><span class="line"><span class="keyword">var</span> timeoutId = <span class="built_in">window</span>.setTimeout(code[, delay]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>timeoutId: 定时器ID</li>
<li>func: 延迟执行的函数</li>
<li>code: 延迟执行的代码字符串，不推荐使用，原理类似eval</li>
<li>delay: 延迟的时间(单位：毫秒)，默认值0</li>
<li>param1, param2: 向延迟函数传递的参数。</li>
</ul>
<!--- more --->

<h2 id="setInterval-以固定时间间隔重复调用一个函数或代码段"><a href="#setInterval-以固定时间间隔重复调用一个函数或代码段" class="headerlink" title="setInterval: 以固定时间间隔重复调用一个函数或代码段"></a>setInterval: 以固定时间间隔重复调用一个函数或代码段</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalId = <span class="built_in">window</span>.setInterval(func, delay[, param1, param2, ...]);</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="built_in">window</span>.setInterval(code, delay);</span><br></pre></td></tr></table></figure>

<ul>
<li>intarvalId: 重复操作的ID</li>
<li>func: 延迟调用的函数</li>
<li>code: 代码段</li>
<li>delay: 延迟时间，没有默认值</li>
</ul>
<h2 id="setImmediate：-在浏览器完全结束当前运行的操作之后立即执行指定的函数-仅IE10和Node0-10-实现-，类似setTimeout-func-0"><a href="#setImmediate：-在浏览器完全结束当前运行的操作之后立即执行指定的函数-仅IE10和Node0-10-实现-，类似setTimeout-func-0" class="headerlink" title="setImmediate： 在浏览器完全结束当前运行的操作之后立即执行指定的函数(仅IE10和Node0.10+实现)，类似setTimeout(func, 0)"></a>setImmediate： 在浏览器完全结束当前运行的操作之后立即执行指定的函数(仅IE10和Node0.10+实现)，类似setTimeout(func, 0)</h2><p>setImmediate设计来是为保证让代码在下一次事件循环执行，以前setTimeout(0)这种不可靠的方式可以丢掉了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> immediateId = setImmediate(func[, param1, param2, ...]);</span><br><span class="line"><span class="keyword">var</span> immediateId = setImmediate(func);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">testSetImmediate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> label = <span class="string">&#x27;setImmediate&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.time(label);</span><br><span class="line"></span><br><span class="line">    setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(label);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>immediateId: 定时器ID</li>
<li>func: 回调</li>
</ul>
<h2 id="requestAnimationFrame-帧动画的API-根据浏览器的刷新频率而定"><a href="#requestAnimationFrame-帧动画的API-根据浏览器的刷新频率而定" class="headerlink" title="requestAnimationFrame: 帧动画的API,根据浏览器的刷新频率而定"></a>requestAnimationFrame: 帧动画的API,根据浏览器的刷新频率而定</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestId = <span class="built_in">window</span>.requestAnimationFrame(func);</span><br></pre></td></tr></table></figure>

<ul>
<li>func: 回调</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>es6中的异步模型。在setTimeout(0), setImmediate,requestAnimationFrame和Promise中，Promise优先级最高。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testSetImmediate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> label = <span class="string">&#x27;setImmediate&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.time(label);</span><br><span class="line"></span><br><span class="line">    setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(label);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> label = <span class="string">&#x27;Promise&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.time(label);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(label);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testSetImmediate();</span><br><span class="line">testPromise();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尽管setImmediated 先注册，Promise先执行</p>
<h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h2><p>是Nodejs中的API，比Promise更早执行</p>
<blockquote>
<p>事实上，Promise不会进入异步队列，而是直接在主线程队列尾强插一个任务，虽然不会阻塞主线程，但会阻塞异步任务的执行。如果有嵌套的process.nextTick，那异步任务就永远没机会被执行到了。<br>使用的时候要谨慎。但Vue中的nextTick是这个实现的吗？？？</p>
</blockquote>
<h2 id="二、-show-me-the-code"><a href="#二、-show-me-the-code" class="headerlink" title="二、 show me the code"></a>二、 show me the code</h2><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalId, timeoutId;</span><br><span class="line">timeoutId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&#x27;console.log(5)&#x27;</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">intervalId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别输出2,4,5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="setInterval-和setTimeout-的区别"><a href="#setInterval-和setTimeout-的区别" class="headerlink" title="setInterval 和setTimeout 的区别"></a>setInterval 和setTimeout 的区别</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;interval&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出一次timeout，每隔1s输出一次interval</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****-------------------***/</span></span><br><span class="line"><span class="comment">//通过setTimeout模拟setInterval和setInterval的区别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (times++ &gt; max) &#123;</span><br><span class="line">       <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">       <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; <span class="number">990000000</span>; i++)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;,</span><br><span class="line">delay = <span class="number">100</span>,</span><br><span class="line">times = <span class="number">0</span>,</span><br><span class="line">max = <span class="number">5</span>,</span><br><span class="line">start = <span class="built_in">Date</span>.now(),</span><br><span class="line">intervalId,</span><br><span class="line">timeoutId;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imitateInterval</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">        <span class="keyword">if</span>(times &lt;= max) &#123;</span><br><span class="line">            imitateInterval(fn, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imitateInterval(callback, delay);</span><br><span class="line">intervalId = <span class="built_in">setInterval</span>(callback, delay);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>setTimeout 和setInterval 仅在执行次数上有区别：setTimeout只执行一次，setInterval执行n次。</p>
</li>
<li><p>通过setTimeout模拟的setInterval与setInterval的区别在于：<br>  <strong>setTimeout只在回调完成之后才回去调用下一次定时器</strong>，<br>  而setInterval不管回调函数执行情况，<strong>到达规定时间就会在事件队列中插入一个执行回调的事件</strong>，所以，用setInterval时要谨慎，比如发送请求失败，会造成死链堆积。</p>
</li>
</ul>
<h2 id="show-me-what-you-can-do"><a href="#show-me-what-you-can-do" class="headerlink" title="show me what you can do"></a>show me what you can do</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目1</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    t = <span class="literal">false</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t)&#123;&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**----------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**----------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    shout: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    waitAndShout: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.shout();</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.waitAndShout();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="The-truth"><a href="#The-truth" class="headerlink" title="The truth"></a>The truth</h2><ul>
<li>第一题：</li>
</ul>
<blockquote>
<p>alert永远不会执行，因为js是单线程，且定时器的回调在等待当前正在执行的任务完成后才执行，<br>而while(true){}进入死循环一直占用线程，不给回调函数执行机会</p>
</blockquote>
<ul>
<li>第二题</li>
</ul>
<blockquote>
<p>输出55555. 当i=0时，生成一个定时器，将回调插入事件队列中，等待当前队列无任务执行再执行。此时for循环正在执行，回调被搁置。当for循环执行完成后，队列中有5个回调函数，都执行console.log(i),因为当前js没有使用块级作用域，所以i的值在for循环结束后一直为5，输出5个5.</p>
</blockquote>
<ul>
<li>第三题</li>
</ul>
<blockquote>
<p>报错：Uncaught TypeError: this.shout is not a function<br>setTimeout()调用的代码运行在与所在函数完全分离的执行环境上，导致代码中的this指向window(或全局)对象，window对象不存在shout方法，所以报错。</p>
</blockquote>
<p>修改方案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    shout: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    waitAndShout: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span>; <span class="comment">// 这里将this赋给一个变量</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.shout();</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.waitAndShout();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h2><ul>
<li>JS引擎基于事件循环，只有一个线程，会强制异步事件排队执行</li>
<li>如果setInterval的回调执行时间长于指定的延迟，setInterval将无间隔的一个接一个执行</li>
<li>this的指向问题可以通过bind函数，定义变量，箭头函数的方式解决。</li>
<li>多个定时器如不及时清除，会存在干扰，是延迟时间捉摸不透。所以不管定时器有没有执行完，及时清除已经不需要的定时器是个好习惯。</li>
<li>如果setTimeout和setInterval都在延迟100ms之后执行，那么谁先注册谁就先执行回调函数。</li>
</ul>
<p><a href="http://www.alloyteam.com/2016/05/javascript-timer/">JavaScript定时器与执行机制解析</a><br><a href="http://ssh.today/blog/something-about-js-timer">参考</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>js-组合函数 </title>
    <url>/posts/js-%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>compose函数，会接收若干个函数作为参数，每个函数执行后的输出作为下一个函数的输出，直至最后一个函数的输出作为最终的结果。</p>
<p>show code~~~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="string">&#x27;3.56&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> data = <span class="built_in">parseFloat</span>(n);</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Math</span>.round(data); <span class="comment">// =&gt; 最终结果 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 组合函数</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="string">&#x27;3.56&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> number = compose(<span class="built_in">Math</span>.round,<span class="built_in">parseFloat</span>);</span><br><span class="line"><span class="keyword">let</span> result = number(n); <span class="comment">// =&gt;4 最终结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上代码的核心是通过<code>compose</code>将<code>parseFloat</code>和<code>Math.round</code>组合到一个返回一个新函数 <code>number</code></p>
<p>这就是函数式组合，将两个函数组合在一起以便能及时的构造出一个新函数。</p>
<a id="more"></a>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>需求: 一个字符串，将字符串转化为大写，然后逆序。</p>
<p>常规思路：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;jspool&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先转成大写，再逆序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> upperStr = str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> upperStr.split(<span class="string">&#x27;&#x27;</span>).reverse().join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(str);</span><br></pre></td></tr></table></figure>

<p>代码没问题，现在改需求。将字符串大写之后，每个字符拆开并封装成一个数组。<code>&quot;jspool&quot; =&gt; [&quot;J&quot;,&quot;S&quot;,&quot;P&quot;,&quot;O&quot;,&quot;O&quot;,&quot;L&quot;]</code></p>
<p>为了修改这个目标，需要修改之前封装的函数，这就破坏了设计模式的开闭原则。</p>
<blockquote>
<p>开闭原则：软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。</p>
</blockquote>
<p>用组合思想怎么写呢?</p>
<p>原需求实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;jspool&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> toUpperAndReverse = compose(stringReverse, stringToUpper)</span><br><span class="line"><span class="keyword">let</span> result = toUpperAndReverse(str) <span class="comment">// &quot;LOOPSJ&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在实现新需求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;jspool&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToArray</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> toUpperAndArray = compose(stringToArray, stringToUpper)</span><br><span class="line"><span class="keyword">let</span> result = toUpperAndArray(str) <span class="comment">// =&gt; [&quot;J&quot;,&quot;S&quot;,&quot;P&quot;,&quot;O&quot;,&quot;O&quot;,&quot;L&quot;]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，需求变更时，没有打破封装以前的代码，只是新增了函数功能，把函数进行重新组合。</p>
<blockquote>
<p>可能有人会有疑问，应用组合的方式书写代码，当需求变更时，依然也修改了代码，不是也算破坏了开闭原则么？其实我们修改的是调用的逻辑代码，并没有修改封装、抽象出来的代码，而这种书写方式也正是开闭原则所提倡的。</p>
</blockquote>
<p>现在又改需求: 字符串转大写后，截取前3个字符，然后转为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;jspool&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToUpper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toUpperCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThreeCharacters</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.substring(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringToArray</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> toUpperAndGetThreeAndArray = compose(stringToArray, getThreeCharacters,stringToUpper)</span><br><span class="line"><span class="keyword">let</span> result = toUpperAndGetThreeAndArray(str) <span class="comment">// =&gt; [&quot;J&quot;,&quot;S&quot;,&quot;P&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上，组合的方式是抽象单一功能的函数，再组成复杂功能，代码逻辑更清晰，也给维护带来巨大方便。</p>
<h2 id="实现组合"><a href="#实现组合" class="headerlink" title="实现组合"></a>实现组合</h2><p>新函数执行时，按照<strong>由右向左</strong>的顺序依次执行传入<code>compose</code>中的函数，每个函数的执行结果作为下一个函数的入参，直到最后一个函数的输出作为最终的输出结果。</p>
<p>如果compose函数接收的函数数量是固定的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f,g</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(g(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f,g</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(g(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际compose接收的参数个数是不确定的，我们考虑用rest参数来接收：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在compose接收的参数fns是一个数组，如何将数组中的函数<code>从右向左</code>依次执行.</p>
<p>用数组的reduceRight来实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fns.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">arg, fn</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(arg);</span><br><span class="line">        &#125;, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了compose函数~~</p>
<h2 id="实现管道"><a href="#实现管道" class="headerlink" title="实现管道"></a>实现管道</h2><p>compose的数据流是<code>从右到左</code>, 因为右侧函数首先执行，左侧最后执行。<br>但有人喜欢从左至右的执行方式。</p>
<blockquote>
<p>从左至右处理数据流的过程称之为管道(pipeline)</p>
</blockquote>
<p>只需将<code>reduceRight</code>替换为<code>reduce</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pipe</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fns.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">arg, fn</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(arg);</span><br><span class="line">        &#125;, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>组合函数</tag>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题答案记录</title>
    <url>/posts/leetcode%E5%88%B7%E9%A2%98%E7%AD%94%E6%A1%88%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="LeetCode刷题答案记录"><a href="#LeetCode刷题答案记录" class="headerlink" title="LeetCode刷题答案记录"></a>LeetCode刷题答案记录</h2><h2 id="常见算法思路"><a href="#常见算法思路" class="headerlink" title="常见算法思路"></a>常见算法思路</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><pre><code>二分搜索是一种在有序数组中查找某一特定元素的搜索算法。
二分搜索算法的时间复杂度为 O(log n)，相比较顺序搜索的 O(n) 时间复杂度，它要快很多。

首先要求出数组的中间下标（整数），从而获取到中间值：
`const mid = Math.floor((start + end) / 2)`

但在一些极端情况下 `start+ end` 可能直接超出最大安全数，所以更谨慎的写法
`const mid = Math.floor(start + (end - start) / 2)`

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(start + (end - start) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (arr[mid]<span class="string">` &lt; target) &#123;</span></span><br><span class="line"><span class="string">        start = mid + 1</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        end = mid</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></code></pre>
<a id="more"></a>

<h2 id="第一题-求和，在数组中找两个元素加起来等于一个数"><a href="#第一题-求和，在数组中找两个元素加起来等于一个数" class="headerlink" title="第一题 求和，在数组中找两个元素加起来等于一个数"></a>第一题 求和，在数组中找两个元素加起来等于一个数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 暴力查找，循环两次</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n^2)， 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, il = nums.length, sumArr = [];</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; il; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; il; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (**nums**[i] === target - nums[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i, j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;not find~&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> * 匹配不到的存入map, 循环的时候去map里找是否有匹配的</span></span><br><span class="line"><span class="comment"> * 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度：O(n) 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arrObj = &#123;&#125;, i = <span class="number">0</span>, il = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; il; i++ ) &#123;</span><br><span class="line">        <span class="keyword">let</span> extra = target - nums[i];</span><br><span class="line">        <span class="comment">// 放进去的值可能是0，不能用if(arrObj[extra]) 判断是否有值</span></span><br><span class="line">        <span class="keyword">if</span> (arrObj[extra] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="comment">// 放入数组的顺序，前面的先放进去的，所以i在后面</span></span><br><span class="line">            <span class="keyword">return</span> [arrObj[extra], i];</span><br><span class="line">        &#125;</span><br><span class="line">        arrObj[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第2题-两个链表求和"><a href="#第2题-两个链表求和" class="headerlink" title="第2题 两个链表求和"></a>第2题 两个链表求和</h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>这个题是参考答案做的。</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment">*     this.val = val;</span></span><br><span class="line"><span class="comment">*     this.next = null;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> List = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> head = List;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l1 !== <span class="literal">null</span> || l2 !== <span class="literal">null</span> || sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            sum = sum + l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            sum = sum + l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">            sum -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">        head = head.next;</span><br><span class="line"></span><br><span class="line">        sum = carry;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> List.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="第3题-查找字符串中子字符串最长长度"><a href="#第3题-查找字符串中子字符串最长长度" class="headerlink" title="第3题 查找字符串中子字符串最长长度"></a>第3题 查找字符串中子字符串最长长度</h2><p>刚开始的思路是放到map里，后来发现会有bdfb的情况，所以不能用map来判断是否存在，改为用数组判断是否存在，存在就从所在位置删除之前的数组</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @lc app=leetcode id=3 lang=javascript</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* [3] Longest Substring Without Repeating Characters</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sArr = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> maxArr = [];</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = sArr.length; i &lt; il; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = sArr[i];</span><br><span class="line">        <span class="keyword">if</span> (maxArr.includes(tmp)) &#123;</span><br><span class="line">            maxArr = maxArr.slice(maxArr.indexOf(tmp) + <span class="number">1</span>, maxArr.length);</span><br><span class="line">            maxArr.push(tmp);</span><br><span class="line">            l = maxArr.length;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxArr.push(tmp);</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; max) &#123;</span><br><span class="line">            max = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 厉害的解法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27;&#x27;</span>).reduce(<span class="function">(<span class="params">max, v, i</span>) =&gt;</span> &#123;</span><br><span class="line">        left = map[v] &gt;= left ? map[v] + <span class="number">1</span> : left;</span><br><span class="line">        map[v] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(max, i - left + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<h2 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a>4. 寻找两个有序数组的中位数</h2><p>两个有序数组求中位数，<br>问题一般化为，求两个有序数组的第k个数，当k = (m+n)/2时为原问题的解。</p>
<p>怎么求第k个数？分别求出第一个和第二个数组的第 k / 2个数 a 和 b，然后比较 a 和 b，<br>当a &lt; b ，说明第 k 个数位于 a数组的第 k / 2个数后半段，<br>或者b数组的 第 k / 2 个数前半段，问题规模缩小了一半，然后递归处理就行。 时间复杂度是 O(log(m+n))</p>
<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/zhen-zheng-ologmnde-jie-fa-na-xie-shuo-gui-bing-pa/">链接</a></p>
<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/">解法二</a>：</p>
<p>将两个数组合成一个数组，用二分法查找中间位置的元素。(因为二分法的复杂度是O(log(m+n)))</p>
<h2 id="367-有效的完全平方数–二分法"><a href="#367-有效的完全平方数–二分法" class="headerlink" title="367. 有效的完全平方数–二分法"></a>367. 有效的完全平方数–二分法</h2><pre><code>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPerfectSquare = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">0</span> || num === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> end = num;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(start + (end - start) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> tmp = mid * mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp === num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; num) &#123;</span><br><span class="line">            end = mid -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<h2 id="744-寻找比目标字母大的最小字母–二分法"><a href="#744-寻找比目标字母大的最小字母–二分法" class="headerlink" title="744. 寻找比目标字母大的最小字母–二分法"></a>744. 寻找比目标字母大的最小字母–二分法</h2><p>给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。</p>
<p>数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nextGreatestLetter = <span class="function"><span class="keyword">function</span>(<span class="params">letters, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> max = letters.length;</span><br><span class="line">    <span class="comment">// 边界处理，</span></span><br><span class="line">    <span class="keyword">if</span> (letters[max -<span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> last = binarySearch(letters, <span class="number">0</span>, max, target);</span><br><span class="line">    <span class="comment">// 这里取值时候不能直接用last，可能会有last === letters.length</span></span><br><span class="line">    <span class="keyword">return</span> letters[last % letters.length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, start, end, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(start + (end - start)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最优解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nextGreatestLetter = <span class="function"><span class="keyword">function</span>(<span class="params">letters, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = letters[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = letters.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (letters[mid] &gt; target) &#123;</span><br><span class="line">        res = letters[mid];</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="852-山脉数组的峰顶索引-Peak-Index-in-a-Mountain-Array"><a href="#852-山脉数组的峰顶索引-Peak-Index-in-a-Mountain-Array" class="headerlink" title="852. 山脉数组的峰顶索引  Peak Index in a Mountain Array"></a>852. 山脉数组的峰顶索引  Peak Index in a Mountain Array</h2><p>我们把符合下列属性的数组 A 称作山脉：</p>
<p>A.length &gt;= 3<br>存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> end = A.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(start + (end - start) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &lt; A[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; A[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">const</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> mid = (i + j) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (A[mid - <span class="number">1</span>] &lt; A[mid] &amp;&amp; A[mid] &gt; A[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; A[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> recursive(mid + <span class="number">1</span>, j)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recursive(i, mid - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recursive(<span class="number">1</span>, A.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce 解法</span></span><br><span class="line"><span class="keyword">var</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.reduce(<span class="function">(<span class="params">acc, curr, i</span>) =&gt;</span> (<span class="string">&#x27;undefined&#x27;</span> === <span class="keyword">typeof</span> acc || A[acc] &lt; curr ? i : acc), <span class="literal">undefined</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<h2 id="475-供暖器-Heaters"><a href="#475-供暖器-Heaters" class="headerlink" title="475. 供暖器  Heaters"></a>475. 供暖器  Heaters</h2><p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p>
<p>现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。</p>
<p>所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。<br>示例 1:</p>
<p>输入: [1,2,3],[2]<br>输出: 1<br>解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。<br>示例 2:</p>
<p>输入: [1,2,3,4],[1,4]<br>输出: 1<br>解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种，没通过</span></span><br><span class="line"><span class="keyword">var</span> findRadius = <span class="function"><span class="keyword">function</span>(<span class="params">houses, heaters</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现将房屋和加热器从小到大排序</span></span><br><span class="line">    houses.sort(sortNum);</span><br><span class="line">    heaters.sort(sortNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> housesL = houses.length;</span><br><span class="line">    <span class="keyword">const</span> heatersL = heaters.length;</span><br><span class="line">    <span class="comment">// 先定义半径为0</span></span><br><span class="line">    <span class="keyword">let</span> radius = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环每个house</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;housesL; i++) &#123;</span><br><span class="line">        <span class="comment">// 比较房间和加热器最大值，取最大值作为最小值？</span></span><br><span class="line">        <span class="keyword">let</span> min = houses[housesL - <span class="number">1</span>] &gt; heaters[heatersL - <span class="number">1</span>] ? houses[housesL - <span class="number">1</span>] : heaters[heatersL - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 比较house到每个heater的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;heatersL; j++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前house到当前heater的绝对距离</span></span><br><span class="line">            <span class="keyword">const</span> diff = <span class="built_in">Math</span>.abs(heaters[j] - houses[i]);</span><br><span class="line">            <span class="comment">// 最小值大于绝对值，取绝对值，反之取最小值</span></span><br><span class="line">            min = min &gt;= diff? diff : min;</span><br><span class="line">            <span class="comment">// 如果绝对值大于最小值，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (diff &gt; min) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果半径小于最小值，用最小值，反之用当前半径</span></span><br><span class="line">            radius = radius &lt; min ? min : radius;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束，返回最小的radius</span></span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，可以通过</span></span><br><span class="line"><span class="keyword">var</span> findRadius = <span class="function"><span class="keyword">function</span>(<span class="params">houses, heaters</span>) </span>&#123;</span><br><span class="line">    houses.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    heaters.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> n = houses.length;</span><br><span class="line">    <span class="keyword">const</span> m = heaters.length;</span><br><span class="line">    <span class="keyword">let</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="literal">Infinity</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = j; k &lt; m; k++) &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;check!!&#x27;, houses[i], heaters[k]);</span></span><br><span class="line">        <span class="comment">// 获取当前heaters到每个屋子的最小值</span></span><br><span class="line">        temp = <span class="built_in">Math</span>.min(temp, <span class="built_in">Math</span>.abs(heaters[k] - houses[i]));</span><br><span class="line">        <span class="comment">// 如果heater的值小于house的值，从heater当前的值开始循环</span></span><br><span class="line">        <span class="keyword">if</span> (heaters[k] &lt; houses[i]) &#123;</span><br><span class="line">            j = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果heater的值大于house的值，取当前house到heater的距离和当前tmp的最小值，并跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (heaters[k] &gt; houses[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) temp = <span class="built_in">Math</span>.min(temp, <span class="built_in">Math</span>.abs(houses[i] - heaters[j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        radius = <span class="built_in">Math</span>.max(radius, temp);</span><br><span class="line">        <span class="comment">// console.log(&#x27;==&#x27;, temp, radius);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最优解</span></span><br><span class="line"><span class="keyword">var</span> findRadius = <span class="function"><span class="keyword">function</span>(<span class="params">houses, heaters</span>) </span>&#123;</span><br><span class="line">    heaters.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left;</span><br><span class="line">    <span class="keyword">let</span> right;</span><br><span class="line">    <span class="keyword">let</span> mid;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, size = houses.length; i &lt; size; i++) &#123;</span><br><span class="line">        target = houses[i];</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = heaters.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (heaters[mid] === target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heaters[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> distLeft =</span><br><span class="line">        left &gt;= <span class="number">0</span> &amp;&amp; left &lt; heaters.length</span><br><span class="line">            ? <span class="built_in">Math</span>.abs(houses[i] - heaters[left])</span><br><span class="line">            : <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">        <span class="keyword">let</span> distRight =</span><br><span class="line">        right &gt;= <span class="number">0</span> &amp;&amp; right &lt; heaters.length</span><br><span class="line">            ? <span class="built_in">Math</span>.abs(houses[i] - heaters[right])</span><br><span class="line">            : <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"></span><br><span class="line">        dist = <span class="built_in">Math</span>.max(dist, <span class="built_in">Math</span>.min(distLeft, distRight));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
]]></content>
  </entry>
  <entry>
    <title>node cli开发调试经验总结</title>
    <url>/posts/node-cli%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="node命令行工具开发调试"><a href="#node命令行工具开发调试" class="headerlink" title="node命令行工具开发调试"></a>node命令行工具开发调试</h2><p>npm link命令通过链接目录和可执行文件，实现npm包命令的全局可执行。</p>
<p>简要地讲，这个命令主要做了两件事：</p>
<ol>
<li>为npm包目录创建软链接，将其链到{prefix}/lib/node_modules/package(包名)</li>
<li>为可执行文件(bin)创建软链接，将其链到{prefix}/bin/{name}</li>
</ol>
<p>在<code>package.json</code>中配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;ltsnode&quot;: &quot;bin/ltsnode.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ltsnode.js中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定运行环境为node</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;运行ltsnode命令&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="在VsCode里debug模式里调试"><a href="#在VsCode里debug模式里调试" class="headerlink" title="在VsCode里debug模式里调试"></a>在VsCode里debug模式里调试</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;启动程序&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;skipFiles&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;&lt;node_internals&gt;/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// 这里是命令行需要传入的参数</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;10&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// 这里是命令行入口文件的位置，一般放在bin文件夹下</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/bin/ltsnode.js&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后，点击启动程序，即可开始调试。上一步下一步在VsCode正中间顶部。<br>可以使用<code>console.log</code>输出结果到调试控制台</p>
<h2 id="在命令行里里调试"><a href="#在命令行里里调试" class="headerlink" title="在命令行里里调试"></a>在命令行里里调试</h2><p><code>npm link</code></p>
<p>再运行<code>npm link</code>即可</p>
<p>然后再命令行里执行命令<code>ltsnode</code>看效果</p>
<p>进入<code>/usr/local/lib/node_modules</code>会发现一个软链，指向自己项目目录<br><code>ltsnode -&gt; /Users/zhaojianpeng/Desktop/workspaces/ltsnode</code></p>
<h2 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h2><ol>
<li>执行<code>npm link</code>报错</li>
</ol>
<p>开发过程遇到的报错</p>
<ul>
<li><p><code>ENOENT: no such file or directory, chmod &#39;/usr/local/lib/node_modules/videocount/bin/videocount&#39;</code><br>  解决办法：在<code>package.json</code>中</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;videocount&quot;: &quot;bin/videocount.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>  这里一定要加后缀名js</p>
</li>
<li><p><code>npm ERR! Refusing to delete /usr/local/bin/ltsnode: ../../../Users/zhaojianpeng/.config/yarn/link/ltsnode/bin/ltsnode symlink target is not controlled by npm /usr/local/bin</code></p>
</li>
<li><p><code>npm ERR! EEXIST: file already exists, symlink &#39;../lib/node_modules/ltsnode/bin/ltsnode.js&#39; -&gt; &#39;/usr/local/bin/ltsnode&#39;</code></p>
</li>
</ul>
<p>解决办法：<br>尝试了各种办法，删缓存，升级npm版本。执行<code>npm link</code>总是报错。<br><strong>执行<code>rm /usr/local/bin/ltsnode</code>删除软链</strong>搞定~~~</p>
<p>在<code>/usr/local/bin/node_modules</code>里删除软链不好使</p>
<p>期间用到知识</p>
<p>一、使用淘宝镜像<br>1.临时使用<br>npm –registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> install express</p>
<p>2.持久使用<br>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>3.通过cnpm<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>二、使用官方镜像<br>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p>
<p>三、查看npm源地址<br>npm config get registry</p>
<p>删除软链<br><code>rm -rf ltsnode</code></p>
]]></content>
  </entry>
  <entry>
    <title>php积累</title>
    <url>/posts/php%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p>boolean值传到前端的时候转成了1</p>
<p>PHP 脚本可放置于文档中的任何位置。<br>PHP 脚本以 <?php 开头，以 `?>` 结尾：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 此处是 PHP 代码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment">//这里是代码，哈哈</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>PHP 文件的默认文件扩展名是 “.php”。<br>PHP 文件通常包含 HTML 标签以及一些 PHP 脚本代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot; Hello World!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="comment">//这是单行注释</span></span><br><span class="line"> <span class="comment">#这也是 单行注释</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>变量大小写分明</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;My car is&quot;</span> .<span class="variable">$color</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;My car is&quot;</span> .<span class="variable">$COLOR</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;My car is&quot;</span> .<span class="variable">$coLOR</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>PHP 变量规则：<br>变量以 <code>$</code> 符号开头，其后是变量的名称<br>变量名称必须以字母或下划线开头<br>变量名称不能以数字开头<br>变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）<br>变量名称对大小写敏感（<code>$y</code> 与 <code>$Y</code> 是两个不同的变量）<br>==注释：PHP 变量名称对大小写敏感！==</p>
<p>PHP 有三种不同的变量作用域：<br>local（局部）<br>global（全局）<br>static（静态）<br>PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$GLOBALS</span>[<span class="string">&#x27;y&#x27;</span>]=<span class="variable">$GLOBALS</span>[<span class="string">&#x27;x&#x27;</span>]+<span class="variable">$GLOBALS</span>[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">static</span> <span class="variable">$x</span>=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">$x</span>;</span><br><span class="line">  <span class="variable">$x</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>echo 和 print 语句</li>
</ul>
<p>echo 和 print 之间的差异：<br>echo - 能够输出一个以上的字符串<br>print - 只能输出一个字符串，并始终返回 1</p>
<ul>
<li><p>并置运算符（Concatenation Operator）<br>在 PHP 中，只有一个字符串运算符。<br>并置运算符 <code>.</code> 用于把两个字符串值连接起来。<br>要把两个变量连接在一起，请使用这个点运算符 <code>.</code><br>严格区别于其他语言的<code>+</code></p>
</li>
<li><p><code>strlen()</code>和<code>strpos()</code><br><code>strlen()</code> 函数用于计算字符串的长度。<br><code>strpos()</code> 函数用于在字符串内检索一段字符串或一个字符。</p>
</li>
</ul>
<p>PHP 的真正威力源自于它的函数。<br>在 PHP 中，提供了超过 700 个内建的函数。</p>
<p>创建 PHP 函数：<br>所有的函数都使用关键词 <code>function()</code> 来开始<br>命名函数 - 函数的名称应该提示出它的功能。函数名称以字母或下划线开头。</p>
<p><code>$_REQUEST</code> 变量<br>PHP 的 <code>$_REQUEST</code> 变量包含了 <code>$_GET</code>, <code>$_POST</code> 以及 <code>$_COOKIE</code> 的内容。<br>PHP 的 <code>$_REQUEST</code> 变量可用来取得通过 GET 和 POST 方法发送的表单数据的结果。</p>
<p><code>mktime()</code> 函数<br>返回一个日期的 UNIX 时间戳<br><code>mktime(hour,minute,second,month,day,year,is_dst)</code></p>
<ul>
<li>服务器端引用（Server Side Includes）<br>通过 <code>include()</code> 或 <code>require()</code> 函数，您可以在服务器执行 PHP 文件之前在该文件中插入一个文件的内容。</li>
</ul>
<p>除了它们处理错误的方式不同之外，这两个函数在其他方面都是相同的。include() 函数会生成一个警告（但是脚本会继续执行），而 require() 函数会生成一个致命错误（fatal error）（在错误发生后脚本会停止执行）。</p>
<ul>
<li><code>PHP Session</code><br>在您把用户信息存储到 <code>PHP session</code> 中之前，首先必须启动会话。<br>注释：<code>session_start()</code> 函数必须位于 html 标签之前：</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> session_start(); <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>上面的代码会向服务器注册用户的会话，以便您可以开始保存用户信息，同时会为用户会话分配一个 UID。</p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/posts/test/</url>
    <content><![CDATA[<p>Welcome test page.<br>post to github.<br>commit new line.<br>add new line for git test.</p>
]]></content>
  </entry>
  <entry>
    <title>《我生有涯愿无尽》读书笔记</title>
    <url>/posts/%E3%80%8A%E6%88%91%E7%94%9F%E6%9C%89%E6%B6%AF%E6%84%BF%E6%97%A0%E5%B0%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>摘自得到APP</p>
<h2 id="怎样像梁漱溟那样，依靠自学，建立独立的思想体系"><a href="#怎样像梁漱溟那样，依靠自学，建立独立的思想体系" class="headerlink" title="怎样像梁漱溟那样，依靠自学，建立独立的思想体系"></a>怎样像梁漱溟那样，依靠自学，建立独立的思想体系</h2><p>梁漱溟说，人们总以为知道很多，处处显得很渊博才算学问。 <strong>其实渊博并不算学问。什么才是学问呢？是能把眼前的道理和材料加以系统化、深刻化。</strong> 他把这个建立独立思想、获得真正学问的过程，分成了八个步骤。</p>
<p>第一步是通过用心思来建立主见。梁漱溟说，什么是哲学的道理？其实就是偏见，美其名曰的话，可以说是主见。只要是哲学家，就一定是极端的。哲学家用心思地思考问题，寻找能够贯通一切的普遍性道理。只要这个主见建立起来，他就不会再接受模棱两可、混乱矛盾的东西，会坚定地排斥不同观点。<strong>人通过独立思考获得的主见也许是浅薄的，但纵然浅薄，也是真正属于自己的。</strong> 他说，胡适的主见就很浅，但因为是他独立的心得，而且理论亲切动人，所以能自成一派。别人不行，因为连浅薄的主见都没有。</p>
<a id="more"></a>

<p>有了主见之后，第二步就是去思考旁人的意见与自己不同在哪里？这后面隐藏着什么问题？梁漱溟对学问两个字的解释是“学着认识问题”。比较糟糕的学习是：道理知道了一大堆，却提不出一个问题来。</p>
<p>最初的主见和问题是通往思想和学问的萌芽，有了这个萌芽，才能在不断的学习中吸收养料，长出学问的大树。在此之后的第三步，就能进入真正的读书和学习了。经过了之前的训练，在读书时，人会自然而然地注意到不一样的见解，发现不能解释的事情，思考和推求背后的解决办法，吸收成为真实的知识。</p>
<p>第四步，是学然后知不足。用心之后，你自然就知道，自己那一点儿浅显的见识，是不足以解决问题的。这就像木心说过的一句话：“有人一看书就卖弄，多看几遍再卖弄吧。多看几遍就不卖弄了。” 梁漱溟在一次面向哲学系学生的讲演时说：学哲学千万不要轻易说自己懂。你要是真懂了柏拉图，那你就等于是柏拉图。只有自己知道自己不懂，才有可能找到解决问题的方法。</p>
<p>前面这四步，是从问题到学习，再到逐渐形成思想的修炼过程。在这个过程里不断打磨，就可以把范围很广的知识，收集整理成为一个思想系统。到了这个时候，就可以进入第五步：由浅入深，以简化繁。<strong>梁漱溟说，凡是有系统的思想，经过整合和抽象，表现出来的形式都很简单，仿佛只有一两句话。</strong> 有些人谈论学问时堆砌一堆名词，论证繁复，旁征博引，实际上却没有自己的思想，学问也是不通的。</p>
<p>后三个步骤，是判断思想和学识高度的标准。第六步是运用自如。有则禅宗故事说，一位禅师对人讲：“你们有一车兵器，拿出一件又一件，却不会使用。老僧虽然只有寸铁，便能杀人。”因为这寸铁就是他自己的思想方法，所以知道怎么运用。当问题来了，他能认识，能判断，能抓住中心所在。而茫然地判断不出问题的关键和解决方向，就说明没有自己的思想和学问。</p>
<p>第七步的标准是对他人的清晰判断力。当人站在一个思想高度上以后，就会对旁人的思想水平一目了然。到了思想圆熟、炉火纯青的第八步，人说出来的每句话，都是精巧透彻的。有大学问的人，说出来的话，形式上是平常的、随意的，其中却蕴含着万变不离其宗的高明道理。</p>
<p>梁漱溟说，这八个层次，他一直是在前四层，也就是建立主见、寻找问题和寻求解答上下功夫；至于后面四层，只能说是虽不能至，心向往之。</p>
<p>芝加哥大学历史教授、汉学家艾恺一直从事梁漱溟研究。在接受艾恺的访谈时，梁漱溟说：孔子和王阳明是圣人，我是个普通人。但我与普通人有一点不同，我“在雾中远远地看见了孔子是怎么回事，王阳明是怎么回事，远远地看见”。儒家解决了他的人生问题，让他不再认为“人生是苦”，转而以躬身入局的态度，谨慎地相信“这个世界会好起来”。对于现实的中国，无论他的主张是否行得通，他都遵照郑重的人生观思考过、求索过了，他远远的历史背影，已经加入了古代儒者的行列。</p>
<p>梁漱溟认为拥有独立思想，要从建立主见、学会对比思想差异、寻求问题开始。通过在学习中寻求解决方案，建立自己的思想系统。真正的学问，是把眼前的道理和材料系统化，深刻化。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>俗语</title>
    <url>/posts/%E4%BF%97%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="宁可荤口念佛，不可素口骂人"><a href="#宁可荤口念佛，不可素口骂人" class="headerlink" title="宁可荤口念佛，不可素口骂人"></a>宁可荤口念佛，不可素口骂人</h2><p>字面上的意思是说，我们宁可吃肉喝酒，口中念佛，但是不能吃素却骂人。</p>
<p>这里所说的“荤口”，是指的我们普通人，因为这些人酒肉穿肠过，没有什么吃喝忌讳。虽然不刻意去戒口，但是每时每刻心中友善，口中念佛。这句话是老祖宗嘱咐他们的子孙后代，不必拘泥于形式主义，只要我们心中有佛，口中有德，不吃斋吃素也可以。因为人必定是杂食动物，只要做到不浪费，就难能可贵了，做到口出善言就很好了，所以就有了农村俗语“宁可荤口念佛”这句话。</p>
<p>“不可素口骂人”，它引申的意义就是，一个每天吃斋吃素的人，却张口就骂人，这是万万不可的。这就说明他吃斋念佛只是表象，而内心是丑恶的，从他口吐脏言就能说明一切，他所做的修行也是假的。 在古代有个封建思想，说这样的人会遭到报应，因为这些人是“伪善者”。老祖宗告诫后人，千万不要每天吃斋吃素，以为就成了修行人，如果不修口德也是做无用功。就像有些人“居庙堂之上”，却不理民生疾苦，是一个道理，要知道“法网恢恢，疏而不漏”。念佛其实就是为了让人无欲无求，心存善心，骂人显然就是违背了这样的理念。而吃荤不会伤害到别人，但是骂人却可以影响着其它人，也会伤害到其它人，这样看来就宁可荤口念佛，不可素口骂人了。</p>
<p>所以“宁可荤口念佛，不可素口骂人”，就是老祖宗告诫后人，我们宁可做一个“酒肉穿肠过”的善良人，也不要做一个“假仁假义”的伪君子。因为有一些人打着“修行人”的旗号，却做着下流人的事情，或者利用信仰到处去骗钱，这就是对信仰的欺骗，迷信的说法就是会“遭天谴”。</p>
<p>其实吃荤是犯了戒律，但是就算是吃荤了，只要心中有佛，那还是可以念佛的，心存善念，就可成佛。而就算是不吃荤天天念着佛经，但是却口上不留德，天天就知道骂人，这显然违背了做人道德，一边骂着人一边念着佛，那可是非常虚伪的行为。</p>
<p>总之，这句话说的就是骂人可比吃荤更加严重，就算吃荤也可以成佛，但是嘴上无德的话，是始终都得不到别人的尊重，也会影响自身修行的。</p>
<p>过去农村老人都会教育自己的子女，一定不要随便骂人，否则宁愿去吃荤念佛，也不能表里不一，对人不尊。现实生活当中不乏这样的人，表面上吃斋念佛，一副虔诚，实质上举止乖张，动不动就爆粗口，根本没有一点儒雅的样子。这样的人是最令人讨厌的，也是最不受欢迎的人。</p>
<p>如果我们往深层次剖析，这个农村俗语的意义就非常深刻了。不仅显示出了现实生活中，一些人的本性，也告诉我们通过人的表象，要看看他的本质属性，也就能够分清善恶，把好坏人进行区分了。</p>
]]></content>
  </entry>
  <entry>
    <title>前端性能的监控和优化</title>
    <url>/posts/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>理解性能监控和优化的一般方法</li>
<li>移动端的性能</li>
<li>运用工具来监控和优化</li>
</ul>
<h2 id="性能优化的重要性"><a href="#性能优化的重要性" class="headerlink" title="性能优化的重要性"></a>性能优化的重要性</h2><pre><code>1. 性能和PV直接相关
2. 性能与收入有关
3. 前端容易产生性能的瓶颈
4. 无线设备性能问题更明显</code></pre>
<p>反面案例: 百科某次上线，性能下降20% ====&gt; PV流失近15%====&gt; 收入下降10%</p>
<p>移动端更严重<br>DOM ready时间： wifi 2.3s, 3G/4G 4.2s, 2G 首字节5-6s， 8s+</p>
<h3 id="一、何为前端性能"><a href="#一、何为前端性能" class="headerlink" title="一、何为前端性能"></a>一、何为前端性能</h3><p>打开一个网站，需要经过多少步</p>
<p>性能优化的一般思路</p>
<ol>
<li>减少请求次数</li>
<li>减少请求体积</li>
<li>加快请求速度</li>
<li>缩短渲染时间</li>
</ol>
<a id="more"></a>

<h2 id="二、指标的确定、采集和分析"><a href="#二、指标的确定、采集和分析" class="headerlink" title="二、指标的确定、采集和分析"></a>二、指标的确定、采集和分析</h2><h3 id="基于用户角度的关键指标选取"><a href="#基于用户角度的关键指标选取" class="headerlink" title="基于用户角度的关键指标选取"></a>基于用户角度的关键指标选取</h3><ol>
<li>页面打不开 – 白屏时间(DNS查询，TCP连接，发送请求，等待响应)</li>
<li>页面显示不出来 – 首屏时间(html传输，静态资源下载)</li>
<li>按钮点击不了 – 用户可操作(解析文档，执行JS/CSS规则，计算布局)</li>
<li>图片显示慢 – 页面总下载(渲染完成)</li>
</ol>
<h3 id="怎么采集展示"><a href="#怎么采集展示" class="headerlink" title="怎么采集展示"></a>怎么采集展示</h3><p>页面打开的时间起点到页面渲染完成的时间各阶段时间分布，总占比</p>
<h3 id="数据波动"><a href="#数据波动" class="headerlink" title="数据波动"></a>数据波动</h3><p>波动即意味着性能发生变化，需要注意</p>
<h3 id="占比更重要"><a href="#占比更重要" class="headerlink" title="占比更重要"></a>占比更重要</h3><p>总下载的时间，各阶段的用户下载占比(很快0-2，较快2-4，可接受4-8，很慢8+)</p>
<h4 id="数据采集-首屏时间"><a href="#数据采集-首屏时间" class="headerlink" title="数据采集-首屏时间"></a>数据采集-首屏时间</h4><pre><code>图片是制约首屏的主要因素

获取首屏图片的加载耗时即可获取大概首屏时间</code></pre>
<h5 id="首屏统计流程"><a href="#首屏统计流程" class="headerlink" title="首屏统计流程"></a>首屏统计流程</h5><ol>
<li>首屏大概位置执行统计JS</li>
<li>绑定所有图片加载事件</li>
<li>页面onload之后找到最慢一张图片加载时间</li>
</ol>
<h4 id="数据采集-可操作时间"><a href="#数据采集-可操作时间" class="headerlink" title="数据采集- 可操作时间"></a>数据采集- 可操作时间</h4><pre><code>DomReady或核心JS加载完毕</code></pre>
<h4 id="数据采集-总下载时间"><a href="#数据采集-总下载时间" class="headerlink" title="数据采集-总下载时间"></a>数据采集-总下载时间</h4><pre><code>onload or 异步渲染完成</code></pre>
<h3 id="浏览器性能API"><a href="#浏览器性能API" class="headerlink" title="浏览器性能API"></a>浏览器性能API</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming">Performance Timing</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API">Resource Timing</a></p>
<h2 id="三、常用的优化方法"><a href="#三、常用的优化方法" class="headerlink" title="三、常用的优化方法"></a>三、常用的优化方法</h2><ol>
<li><p>雅虎性能优化军规</p>
</li>
<li><p>可优化的点</p>
<ol>
<li>DNS查询<ol>
<li>DNS缓存(浏览器、操作系统)</li>
<li>减少DNS数(一个页面不超过4个, DNS预查询dns-prefetch)</li>
</ol>
</li>
<li>建立连接<ol>
<li>使用CDN 提速10%-20%(缩短距离，降低连接时间)</li>
</ol>
</li>
<li>发送请求<ol>
<li>减少HTTP请求(打包JS，CSS文件，图片合并)</li>
<li>Keep alive 减少TCP请求连接数</li>
</ol>
</li>
<li>内容传输<ol>
<li>文件压缩(js, css, html),代码混淆 60%+</li>
<li>代码精简 减少无用代码，提高质量</li>
<li>gzip</li>
</ol>
</li>
<li>缓存<ol>
<li>Expires、Cache-Control</li>
<li>Last-Modified</li>
<li>Etag</li>
</ol>
</li>
<li>充分利用缓存–强缓存(文件名md5后缀)</li>
</ol>
</li>
<li><p>前端工程化与性能优化–静态资源管理<br> 自动将样式表放在头部，脚本放在底部，并按需加载</p>
</li>
<li><p>代码的性能–css</p>
<ul>
<li>书写高效的CSS selectors</li>
<li>删除没用的CSS代码</li>
<li>避免使用CSS expressions(实践中比较难~~~)</li>
<li>把CSS放到页面顶部</li>
<li>不要缩放图片–很大的图片缩到很小展示，耗性能</li>
</ul>
</li>
<li><p>代码的性能–JavaScript</p>
<ul>
<li>数据结构和算法优化</li>
<li>避免with, eval</li>
<li>减少跨上下文查找: 全部变量、属性</li>
<li>避免arguments、debugger</li>
<li>缓存计算结果</li>
</ul>
</li>
<li><p>DOM才是性能大头</p>
<ul>
<li>避免DOM重绘(避免访问childNode数组，读写分离)，不在for循环重绘DOM</li>
<li>收回、重复利用DOM</li>
<li>缓存数据而不是DOM</li>
</ul>
</li>
<li><p>MVVM 框架的DOM<br> 只在需要时才更新DOM<br> 性能：JS Engine &gt; Render Engine</p>
</li>
<li><p>React的性能优化</p>
<ol>
<li><p>shouldComponentUpdate / PureComponent</p>
</li>
<li><p>全局数据store管理(redux) + immutable</p>
</li>
<li><p>在shouldComponentUpdate里全部return false,在componentWillReceiveProps里判断是否需要更新</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 只有某些数据发生改变时进行绘图</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.props.data !== nextProps.data) &#123;</span><br><span class="line">            <span class="built_in">this</span>.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Debounce防抖延迟更新<br>  compositionstart, compositionend 解决中文输入时的频繁更新</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DebounceText</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.props_onChange = debounce(<span class="built_in">this</span>.props.onchange, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    onChange = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            value: val</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.props_onChange(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.props, &#123;<span class="attr">value</span>: <span class="built_in">this</span>.state.value&#125;);</span><br><span class="line">        <span class="keyword">delete</span> props.onChange;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.onChange&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>React 性能优化</p>
<ul>
<li>redux –&gt; mobx, mobx-state-tree 对redux性能优化，主动用observer观察数据的变化…</li>
<li>避免过度的动画效果</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="四、极致的性能优化"><a href="#四、极致的性能优化" class="headerlink" title="四、极致的性能优化"></a>四、极致的性能优化</h2><ol>
<li>懒加载(lazy render), 逐屏加载，优化首屏时间</li>
<li>bigRender 减少DOM数，提升首屏（DOM树转为注释，页面滚动到指定位置才加载）</li>
<li>bigpipe 一次请求，分chunk方式获取所有内容，后端并发<br> Request-header (http 1.1)<ul>
<li>transfer-encoding: chunked</li>
<li>content-length<br>先给前端吐一个结构，在HTML结束后，输出一些js代码渲染内容上去<br>性能提升<br>  贴吧首页白屏提升40%<br>  FRS页贴吧列表区展示时间提升20%<br>弊端<br>  代码复杂度<br>  后端成本</li>
</ul>
</li>
</ol>
<h2 id="五、移动端的性能"><a href="#五、移动端的性能" class="headerlink" title="五、移动端的性能"></a>五、移动端的性能</h2><ol>
<li><p>显性加载- loading页</p>
</li>
<li><p>首屏优先</p>
<ul>
<li>单页应用首屏后端渲染</li>
<li>逐屏加载</li>
<li>滚动加载(用户无感知，提速30%)</li>
</ul>
</li>
<li><p>减少首屏图片数量，减少请求</p>
<ul>
<li>使用其他方式代替图片: css3,svg,iconfont</li>
<li>合适的图片类型: webP &gt; jpg, png8&gt;gif</li>
<li>避免使用dataURL</li>
<li>响应式图片<br>  分辨率、Retina<br>  srcset, picture</li>
</ul>
</li>
<li><p>加载过程的优化</p>
<ul>
<li>预加载: 提前加载下一页</li>
<li>避免302重定向</li>
<li>异步加载广告等第三方资源</li>
<li>减少cookie：静态资源域名不适用cookie</li>
<li>长缓存</li>
</ul>
</li>
<li><p>执行过程的优化</p>
<ul>
<li>合理使用CSS 3D加速</li>
<li>避免批量绑定数量，使用事件代理</li>
<li>严格控制DOM数，缓存数据而不是DOM（不超20层）</li>
<li>用touchstart, touchend代替click</li>
</ul>
</li>
<li><p>利用Native的能力</p>
<p>将一些不频繁更新的一些东西本地化</p>
<ul>
<li><p>Hybird的加速方式</p>
<ul>
<li>模板资源本地化，极大提速首屏</li>
<li>模板资源的增量下发</li>
<li>图片缓存：imageCache</li>
<li>利用NA(native)的Request、socket长连接</li>
<li>利用NA获取用户信息、位置等</li>
</ul>
<p>手百使用Hybird的性能收益</p>
<ul>
<li>相比H5方案，首屏时间降低60%+</li>
<li>模板增量下发，体积减小90%</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前端性能十分关键，影响PV 和收入<br>找到关键指标，用统计到的数据说话<br>性能优化贯穿页面的整个响应过程<br>无线端更需要优化<br>监控-分析-优化，利用现有的工具方案</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>性能优化</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/posts/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="学习方法：如何在工作内外获得持续的技术成长"><a href="#学习方法：如何在工作内外获得持续的技术成长" class="headerlink" title="学习方法：如何在工作内外获得持续的技术成长"></a>学习方法：如何在工作内外获得持续的技术成长</h2><p>参考链接</p>
<ul>
<li><a href="https://juejin.im/post/5cbd7477f265da039d32834e">学习方法：如何在工作内外获得持续的技术成长</a></li>
</ul>
<p>看文章写的很好，摘一些对自己有用的东西保存下来</p>
<h2 id="成长本质是突破天花板"><a href="#成长本质是突破天花板" class="headerlink" title="成长本质是突破天花板"></a>成长本质是突破天花板</h2><p>成长是一件很难捉摸和量化的事情，完全不同的环境和主观意识加上完全不同的行动措施既可以让一个人快速成为某个领域的顶尖高手，也可能完全相反。</p>
<a id="more"></a>

<h2 id="了解技术的成本和门槛"><a href="#了解技术的成本和门槛" class="headerlink" title="了解技术的成本和门槛"></a>了解技术的成本和门槛</h2><p>对技术寻根溯源追求本质是最重要的，但比这个更重要的是自己的时间分配和如何选择，你的时间远比你以为的要值钱的多，请珍惜它。</p>
<p>哪些技术栈是时间长度相对可被接受，也就是哪些学习成本可以被接受是你需要思考的，思考清楚后，再去选择，会更有侧重，然后再来看不同的技术学习成本背后，哪个更贴合自己。</p>
<h2 id="求变之前要先认清自己"><a href="#求变之前要先认清自己" class="headerlink" title="求变之前要先认清自己"></a>求变之前要先认清自己</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是谁？我的身份是？未来我想要做什么？当下我可以做什么？我擅长什么？我还需要学会什么？</span><br></pre></td></tr></table></figure>

<p>答案永远在变化，也永远没在变，时间越久思考的越久经历也越多，就会距离它最真实的答案越近。</p>
<p>其实有太多太多的问题，我们可以尝试问自己，但我们往往找别人去问，挑选跟自己内心与未来无关的话题，其实所有的答案都取决于自己接下来 3 ~ 9 个月具体的行动，这些答案来源于内心的原动力以及自己规划的最优或者最可执行路径，可一旦我们眼睛看到 9 个月后的结果，而忽视这个可执行路径，甚至忽略原动力的时候，结果就变得非常惋惜，忽略整个思考过程，也就压根无法了解自己的真实诉求和真实能力。</p>
<h2 id="习惯养成与定目标计划"><a href="#习惯养成与定目标计划" class="headerlink" title="习惯养成与定目标计划"></a>习惯养成与定目标计划</h2><p>在经过深思熟虑后去制定的目标成功的概率更大，而脑袋一热跑出来的目标往往会泡汤，泡汤倒也罢了，这会让自己陷入定目标 - 执行难度过大 - 放弃 - 再定目标这样的死循环，信心和成就感一天天挫败下去，就变成了今日的自己，晚上想千万条路早上起来走原路，越来越麻木越来越气馁。</p>
<p>建议: 制定目标要考虑能不能坚持下来，如果不能坚持下来，就修正。坚持两三周慢慢形成习惯，并从中受益获取一些兴趣和成就感，这时候才是定目标的时候，因为这时候，习惯正在养成。</p>
<p>当有了一种正在建立或者成熟的习惯，也定了具体的目标后，就可以定具体的计划了。计划就是行动指南，要一板一眼的去执行，坚决不能马虎大意，最好一条条写下来。比如：</p>
<ul>
<li>每周晚上10点钟，花10分钟读书</li>
<li>每周六花一小时整理笔记</li>
<li>每周日花2小时对遇到的问题进行深入研究</li>
</ul>
<p>再把这个规律性的事项，分解到每一天，每一天都要打一个对勾，任务才算完成，完成后给自己一个激励，比如说连续5天完成，看场电影之类。指定明确的奖惩细则，叠加到每日的手机/电脑行程中，给自己强有力的提醒，坚持三个月，一个习惯大概率就能养成了，就可以定第二个目标去养成第二个习惯了。</p>
<p>所以习惯和目标及计划的关系是，定目标前要尽可能先养成一个潜在的习惯，把自己的底线测试出来，然后调整目标，再拆解目标形成规律性的计划，最后把计划完成跟奖惩关联起来，并通过软硬件来跟自己进行互动提醒。这注定是一个单调的过程，但这一定是一个越坚持越好玩的过程，等习惯训练有了雏形的时候，才会真正启动持续成长这件事情。</p>
<h2 id="训练稳定的思维路径"><a href="#训练稳定的思维路径" class="headerlink" title="训练稳定的思维路径"></a>训练稳定的思维路径</h2><p>我们前面对自己有了更客观的认知，也培养了完成目标的习惯，这两个前提条件就成立了，还缺第三样东西，就是稳定的思维路径，最刻板也最简单的思维方式就是穷尽式的提问，也就是前面认清自己这里，我用列举问题的这种办法，来让自己不断的接近某一个真相，那么面对任何一个困局的时候，都可以用这种方法。实际上，当你把几十个问题都回答一遍的过程中，你可以继续写下更击中灵魂的问题，而这次问题写下去的时候，往往答案就自然浮出水面。</p>
<p>提问的套路可以更简单一些，就是 What Why How，这个问题是什么，当前的真相是什么，为什么发生，为什么走到这个地步，基于这些原因要如何解决，无论任何事情，都逼自己去捉摸它去思考它的前因后果，慢慢会发现自己会变成一个喜欢上思考和善于思考的人，再也不是之前的那个鲁莽的毛头小子，看问题只看负面看现象只看表面。</p>
<p>认识自己、习惯养成、思维训练这三个要成年累月持续的做，当这些都逐渐变成长在自己身体内的一种能力的时候，所以你面临的问题都不会让你像之前那样焦虑，在做完这么长铺垫后，我们再来看如何获得持续的技术成长。</p>
<h2 id="工作内外的技术成长"><a href="#工作内外的技术成长" class="headerlink" title="工作内外的技术成长"></a>工作内外的技术成长</h2><p>成长是经常不符合预期的，请记住，它大概率是不符合预期的，原因是自己的预期本身是非常主观不准确的，同时成长只是过程的积累并不是一个很直观的结果。<br>基于这样的背景，我们希望达成的共识是，无论成长是否预期，我都希望有持续的成长，同时盼望奇迹的发生 - 就是远超预期的成长会发生在我身上。</p>
<h3 id="工作内的成长主要来自项目"><a href="#工作内的成长主要来自项目" class="headerlink" title="工作内的成长主要来自项目"></a>工作内的成长主要来自项目</h3><p>带着这样的期望，我们回到工作内工作外会发现，所有的成长最核心的过程指标就是项目经验，工作内天然就可以沉淀，那么如何沉淀或者挖掘成长点呢？</p>
<p>很多人在面试中会被问到一个问题「你做的项目有什么难点」。可能大家会把思维局限在我做的这个业务有什么难的地方，我用了什么牛逼的技术去解决了业务上的什么难题。我相信大部分人不会有这样的经历，由此会觉得这个问题很难答。那么这个问题其实就可以引申为我们如何在工作中、业务中发现问题并得到成长？</p>
<p>如何实现业务在大部分情况下不会是一个难题，<strong>但是如何把业务中相关的组件、逻辑等等可以复用的东西抽象出来，这就是一个难题了。你可以通过学习比你厉害的同事的代码，也可以学习这方面业内顶尖的库是如何实现的，这就是在工作中学习及成长。</strong></p>
<p>在实现业务的过程中，大家肯定会使用各种各样的库及框架。那么当我们熟练使用这个库的时候，就应该尽可能的去了解常用的库的实现原理。我们可以通过文章去了解，也可以通过阅读源码去了解，这也是在工作中学习及成长。</p>
<p>实际上大部分工作场景中的项目，深度的思考持续的思考都会带来较大的技术成长，但往往我们没有耐心和动力去做这件事情，因为会有雇佣心态，也就是你付我那点工资，凭什么我想破头皮去捉摸怎么优化它，这就等于是把自己拦到了池子之外，公司付薪水（无论多少）是购买了你的时间，而你的成长是基于这些时间如何在池子里学游泳技能，池子大小水温深浅甚至形状你都很难有控制权，但蛙泳仰泳自由泳甚至闭气潜水这些都是自己说了算，如果这些都玩溜了，去任意一个池子都能如鱼得水，不是么？</p>
<p>例如：打造工作相关的工具链，让每个流程不独立进行。</p>
<p>所以工作内，不仅靠耐心，还要有不怕吃亏的心态，更要有善于发现的双眼，无数机会都在你面前，都可以持续不断的带来成长，同时给自己团队和个人带来更多效率和体验的提升。</p>
<h3 id="工作外的成长主要来自尝试与思考"><a href="#工作外的成长主要来自尝试与思考" class="headerlink" title="工作外的成长主要来自尝试与思考"></a>工作外的成长主要来自尝试与思考</h3><p>工作外的成长更简单易操作一些，往往就是技术储备、技术尝鲜和总结思考，技术储备一部分是为了自己的职业考虑，比如学习 RN/Flutter/Go 等，另一方面也可以是为了自己公司业务未来的可能性领域，比如 NodeJS/Taro/MPVue 等等，所有感兴趣的方向都可以去学习储备。<br>另外就是自己的想法，可以把他变成现实，比如一个行程提醒小工具，一个萝莉妹子叫起床小工具，一个自动生成周末食谱的工具等等，任何一个生活痛点和创意想法，都可以动手把它实现出来，前后端可以一起做，技术栈可以激进，所有的这些尝鲜都会带来技术视野的扩张，也会带来技术深度的沉淀。<br>最值得尝试的就是思考和总结，把任何自己学习的框架，看过的书，做过的项目，甚至解决过的 Bug，都可以有序的整理起来，把这些整理变成文字和图表，来强化自己对于技术的记忆，所有的这些记忆重复训练的次数越多，对于他们的理解和运营就越娴熟，往往最慢的反而是最有效的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>成长是一个永恒的话题，互联网几十年来，无数的新人问成长，也无数的新人变老人，有的混成一方大拿，有的混成螺丝工头，抛开经济环境、行业趋势和公司经营，更多时候取决于我们成长的是一些学习方法，更根本上依然是我们对于自己的理解、规划和持之以恒的执行，这里面无关运气更关乎实力，不是环境带来的成长去选择你，而是你选择在任何环境中都能成长，具备选择权后，剩下的无非是规划、执行与坚持，无它！</p>
]]></content>
      <tags>
        <tag>学习方法</tag>
        <tag>经验积累</tag>
      </tags>
  </entry>
  <entry>
    <title>原型</title>
    <url>/posts/%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="js原型继承的几种方式"><a href="#js原型继承的几种方式" class="headerlink" title="js原型继承的几种方式"></a>js原型继承的几种方式</h2><ol>
<li>原型链继承</li>
</ol>
<p>2，构造函数继承（对象冒充继承）</p>
<p>3，组合继承（原型链继承+构造函数继承）</p>
<p>4，原型式继承</p>
<p>5, 寄生组合式继承</p>
<p>一。原型链继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=<span class="string">&quot;run&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="string">&quot;20&quot;</span>; <span class="comment">//Run继承了Show,通过原型，形成链条</span></span><br><span class="line">&#125;</span><br><span class="line">Run.prototype=<span class="keyword">new</span> Show();</span><br><span class="line"><span class="keyword">var</span> show=<span class="keyword">new</span> Run();</span><br><span class="line">alert(show.name)<span class="comment">//结果：run</span></span><br></pre></td></tr></table></figure>

<p>二。构造函数继承（对象冒充继承）</p>
<p>为了解决引用共享和超类型无法传参的问题，我们采用一种叫借用构造函数的技术，或<br>者成为对象冒充(伪造对象、经典继承)的技术来解决这两种问题</p>
<p>2.优缺点<br>可以实现多继承,不能继承原型属性/方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=[<span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Hello&#x27;</span>]</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Desk</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    Box.call(<span class="built_in">this</span>,age); <span class="comment">//对象冒充，给超类型传参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> desk = <span class="keyword">new</span> Desk(<span class="number">200</span>);</span><br><span class="line">alert(desk.age);<span class="comment">//200</span></span><br><span class="line">alert(desk.name);<span class="comment">//[&#x27;Lee&#x27;,&#x27;Jack&#x27;,&#x27;Hello&#x27;]</span></span><br><span class="line">desk.name.push(<span class="string">&#x27;AAA&#x27;</span>); <span class="comment">//添加的新数据，只给 desk</span></span><br><span class="line">alert(desk.name)<span class="comment">//[&#x27;Lee&#x27;,&#x27;Jack&#x27;,&#x27;Hello&#x27;,&#x27;AAA&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>三。组合继承（原型链继承+构造函数继承）</p>
<p>借用构造函数虽然解决了刚才两种问题， 但没有原型， 复用则无从谈起。 所以， 我们需<br>要原型链+借用构造函数的模式，这种模式成为组合继承。</p>
<p>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = [<span class="string">&#x27;Lee&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>]</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Box.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Desk</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Box.call(<span class="built_in">this</span>, age); <span class="comment">//对象冒充</span></span><br><span class="line">&#125;</span><br><span class="line">Desk.prototype = <span class="keyword">new</span> Box(); <span class="comment">//原型链继承</span></span><br><span class="line">Desk.prototype.constructor = Desk; <span class="comment">// 组合继承也是需要修复构造函数指向的。</span></span><br><span class="line"><span class="keyword">var</span> desk = <span class="keyword">new</span> Desk(<span class="number">100</span>);</span><br><span class="line">alert(desk.run());</span><br></pre></td></tr></table></figure>

<p>四。原型式继承</p>
<p>这种继承借助原型并基于已有的对象创建新对象，<br>同时还不必因此创建自定义类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">o</span>) </span>&#123; <span class="comment">//传递一个字面量函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//创建一个构造函数</span></span><br><span class="line">F.prototype = o; <span class="comment">//把字面量函数赋值给构造函数的原型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">//最终返回出实例化的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box = &#123; <span class="comment">//字面量对象</span></span><br><span class="line">    name : <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">    arr : [<span class="string">&#x27;哥哥&#x27;</span>,<span class="string">&#x27;妹妹&#x27;</span>,<span class="string">&#x27;姐姐&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> box1 = obj(box); <span class="comment">//传递</span></span><br><span class="line">alert(box1.name);</span><br><span class="line">box1.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">alert(box1.name);</span><br><span class="line">alert(box1.arr);</span><br><span class="line">box1.arr.push(<span class="string">&#x27;父母&#x27;</span>);</span><br><span class="line">alert(box1.arr);</span><br><span class="line"><span class="keyword">var</span> box2 = obj(box); <span class="comment">//传递</span></span><br><span class="line">alert(box2.name);</span><br><span class="line">alert(box2.arr); <span class="comment">//引用类型共享了</span></span><br></pre></td></tr></table></figure>

<p>五。寄生组合式继承</p>
<p>寄生组合式继承解决了两次调用的问题，组合式继承就会有两次调用的情况</p>
<p>基本模型如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);  <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType;              <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype;                <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面的寄生式继承和寄生组合模型式继承还搞不懂，哈哈哈，好尴尬</p>
<p>寄生组合继承，解决了两次调用的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Person.prototype.constructor == Person;</span><br><span class="line">person1.__proto__ == Person.prototype;</span><br><span class="line">person1.constructor == Person;</span><br><span class="line"></span><br><span class="line">person1.__proto__ === Person.prototype</span><br><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line">Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.__proto__</span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">b.constructor === <span class="built_in">Array</span>;</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">c.constructor === <span class="built_in">Date</span>;</span><br><span class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">d.constructor === <span class="built_in">Function</span>;</span><br><span class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function）</span></span><br><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Boolean</span>.prototype)  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">RegExp</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Error</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype)     <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">Person.__proto__ == <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype)<span class="comment">// function()&#123;&#125; (空函数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Array</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype) <span class="comment">// [] (空数组)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"> animal.price = <span class="number">2000</span>;</span><br><span class="line"> dog.prototype = animal;</span><br><span class="line"> <span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"> <span class="built_in">console</span>.log(dog.price) <span class="comment">//undefined</span></span><br><span class="line"> <span class="built_in">console</span>.log(tidy.price) <span class="comment">// 2000</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原型和原型链是JS实现继承的一种模型。<br>原型链的形成是真正是靠<strong>proto</strong> 而非prototype</p>
<h2 id="JavaScript继承实现"><a href="#JavaScript继承实现" class="headerlink" title="JavaScript继承实现"></a>JavaScript继承实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;动物发声:&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">Dog.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过原型链找‘基本类’原型里的同名方法</span></span><br><span class="line">    <span class="built_in">this</span>.__proto__.__proto__.speak.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪, 我是&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line">Cat.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过原型链找‘基本类’原型里的同名方法</span></span><br><span class="line">    <span class="built_in">this</span>.__proto__.__proto__.speak.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;喵喵, 我是&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animalSpeak</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animalSpeak(<span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log()</span><br><span class="line">animalSpeak(<span class="keyword">new</span> Cat(<span class="string">&#x27;小喵&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//动物发声:</span></span><br><span class="line"><span class="comment">//汪汪, 我是 大黄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物发声:</span></span><br><span class="line"><span class="comment">//喵喵, 我是 小喵</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享"><a href="#Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享"></a>Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享</h2><p>我在写的时候,用了两种,一个是 ES5和 ES6的方案</p>
<p>ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">ParentClass.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m parent!&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//若是要多个参数可以用apply 结合 ...解构</span></span><br><span class="line">    ParentClass.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype = <span class="built_in">Object</span>.create(ParentClass.prototype);</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line">SubClass.prototype.sayChildHello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m child &quot;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testA = <span class="keyword">new</span> SubClass(<span class="string">&#x27;CRPER&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create()的polyfill</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    function pureObject(o)&#123;</span></span><br><span class="line"><span class="comment">        //定义了一个临时构造函数</span></span><br><span class="line"><span class="comment">         function F() &#123;&#125;</span></span><br><span class="line"><span class="comment">         //将这个临时构造函数的原型指向了传入进来的对象。</span></span><br><span class="line"><span class="comment">         F.prototype = obj;</span></span><br><span class="line"><span class="comment">         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。</span></span><br><span class="line"><span class="comment">         //因为该实例的原型是obj对象。</span></span><br><span class="line"><span class="comment">         return new F();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// ES6: 其实就是ES5的语法糖,不过可读性很强..</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m parent!&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayChildHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m child &quot;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上</span></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;override parent method !,I&#x27;m sayHello Method&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testA = <span class="keyword">new</span> SubClass(<span class="string">&#x27;CRPER&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>到这里就结束了么…不,这只是笔试,</p>
<p>问的时候你用过静态方法,静态属性,私有变量么?</p>
<p>这个静态方法是ES6之后才有这么个玩意,有这么些特点</p>
<p>方法不能给 this引用,可以给类直接引用<br>静态不可以给实例调用,比如 let a = new ParentClass =&gt; a.sayHello() 会抛出异常<br>父类静态方法,子类非 static 方法没法覆盖父类<br>静态方法可以给子类继承<br>静态属性可以继承也可以被修改<br>看下面的代码..</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m parent!&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">testFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;emm...Parent test static Func&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayChildHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m child &quot;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;override parent method !,I&#x27;m sayHello Method&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">testFunc2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.testFunc() + <span class="string">&#x27;fsdafasdf&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ParentClass.sayHello(); <span class="comment">// success print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> ParentClass(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">a.sayHello() <span class="comment">// throw error</span></span><br><span class="line"></span><br><span class="line">SubClass.sayHello(); <span class="comment">// 同名 static 可以继承且覆盖</span></span><br><span class="line"></span><br><span class="line">SubClass.testFunc2(); <span class="comment">// 可以继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testA = <span class="keyword">new</span> SubClass(<span class="string">&#x27;CRPER&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>私有变量这个我没答出来,只是说了下没有 private 这个关键字和基本用下划线的人为区分</p>
<p>所以回来只是找了下相关的资料,发现有一个比较好的模拟方案,就是 WeakMap ;</p>
<p>WeakMap 可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了.</p>
<p>const _ = new WeakMap(); // 实例化,value 必须为对象,有 delete,get,has,set四个方法,看名字都知道了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWeakMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id, barcode</span>)</span> &#123;</span><br><span class="line">        __.set(<span class="built_in">this</span>, &#123; id,barcode &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">testFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; id,barcode &#125; = __.get(<span class="built_in">this</span>); <span class="comment">// 获取对应的值</span></span><br><span class="line">        <span class="keyword">return</span> &#123; id,barcode &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>jQuery</tag>
        <tag>插件</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>富文本编辑器调研</title>
    <url>/posts/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h1 id="富文本编辑器draft-js调研"><a href="#富文本编辑器draft-js调研" class="headerlink" title="富文本编辑器draft-js调研"></a>富文本编辑器draft-js调研</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>移动端和PC端富文本编辑器技术选型, Facebook开源框架draft-js调研</p>
<h2 id="与现有富文本编辑器比较"><a href="#与现有富文本编辑器比较" class="headerlink" title="与现有富文本编辑器比较"></a>与现有富文本编辑器比较</h2><table>
<thead>
<tr>
<th>项目</th>
<th align="left">draft</th>
<th align="center">现有</th>
</tr>
</thead>
<tbody><tr>
<td>样式</td>
<td align="left">可以自定义，引用css文件，内联样式</td>
<td align="center">可以自定义，引用css文件</td>
</tr>
<tr>
<td>自定义块组件</td>
<td align="left">用draft提供的语法，<a href="https://draftjs.org/docs/advanced-topics-custom-block-render-map">自定义块</a>，定义策略类型，根据类型渲染组件</td>
<td align="center">拼HTML</td>
</tr>
<tr>
<td>移动端支持</td>
<td align="left"><a href="https://draftjs.org/docs/advanced-topics-issues-and-pitfalls.html#mobile-not-yet-supported">官网申明不支持</a></td>
<td align="center">未测试</td>
</tr>
<tr>
<td>上手</td>
<td align="left">需熟悉提供的接口及一些概念，<a href="https://draftjs.org/docs/api-reference-rich-utils">一系列接口</a></td>
<td align="center">操作DOM,调用原生浏览器提供的方法</td>
</tr>
<tr>
<td>数据存储</td>
<td align="left">自定义的object对象，带来调试难点，需熟悉数据格式</td>
<td align="center">html</td>
</tr>
<tr>
<td>格式转换</td>
<td align="left">提供<code>convertToRaw</code>接口，将draft的<code>ContentState</code>转成js对象，不直接提供HTML(点击事件，交互等). 需要插件转HTML(自定义组件特殊功能插件可能不支持)</td>
<td align="center">以HTML格式存储</td>
</tr>
<tr>
<td>编辑器中DOM操作，获取焦点(删除商品块无法整个删除，编辑区有video，按删除键，无法删除)</td>
<td align="left">demo中有问题</td>
<td align="center">实际使用也有问题，可以通过hack方式解决</td>
</tr>
</tbody></table>
<h2 id="存在的风险点"><a href="#存在的风险点" class="headerlink" title="存在的风险点"></a>存在的风险点</h2><ol>
<li><p>移动端兼容性</p>
</li>
<li><p>数据存储为draft自定义格式，开发调试困难，在展示时，需要转成HTML，官方未提供转换插件，转换过程会造成所见非所得的情况</p>
</li>
<li><p>对外提供的API封装原生的方法，开发难度大</p>
</li>
<li><p>由于内部封装逻辑过重，遇到问题从根源处解决难度大</p>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><p>由于存在风险点较多，暂时不考虑以draft为基础框架。</p>
</li>
<li><p>目前富文本编辑器框架对移动端支持普遍不够，会持续调研现有框架，如<code>quilljs, 小米社区</code>等。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>小程序开发积累</title>
    <url>/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="小程序开发经验积累"><a href="#小程序开发经验积累" class="headerlink" title="小程序开发经验积累"></a>小程序开发经验积累</h2><h2 id="小程序setData时，数据没更新"><a href="#小程序setData时，数据没更新" class="headerlink" title="小程序setData时，数据没更新"></a>小程序setData时，数据没更新</h2><p>由于小程序不支持将 data 中任何一项的 value 设为 undefined ，在 setState 的时候也请避免这么用。你可以使用 null 来替代。</p>
<p>setData有的值之前有值，重新set为undefined时，会导致页面不更新<br>解决办法<br>判断是undefined时，将值设为null</p>
<p><code>key ? key : null</code></p>
<a id="more"></a>

<h2 id="小程序用get请求传数组时，取到的值不正确"><a href="#小程序用get请求传数组时，取到的值不正确" class="headerlink" title="小程序用get请求传数组时，取到的值不正确"></a>小程序用get请求传数组时，取到的值不正确</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: [<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;sss&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>应改为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: [<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;sss&#x27;</span>].join(<span class="string">&#x27;,&#x27;</span>gst)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="js判断小程序环境"><a href="#js判断小程序环境" class="headerlink" title="js判断小程序环境"></a>js判断小程序环境</h2><p>小程序内置web-view引入页面时，<br><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html">官方文档</a>建议通过 <code>window.__wxjs_environment === &#39;miniprogram&#39;</code> 判断小程序环境。经测试在安卓有些设备上会失效。</p>
<p><code>wx.miniProgram.getEnv</code>也会失效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.miniProgram.getEnv(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.miniProgram) &#123;</span><br><span class="line">        <span class="comment">// 走在小程序的逻辑</span></span><br><span class="line">        alert(<span class="string">&quot;小程序环境&quot;</span> + <span class="built_in">window</span>.__wxjs_environment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>通过userAgent 判断<br><code>const isMiniProgram = /miniProgram/i.test(navigator.userAgent.toLowerCase());</code></p>
<h2 id="UserAgent-详解"><a href="#UserAgent-详解" class="headerlink" title="UserAgent 详解"></a>UserAgent 详解</h2><p>通过UA来判断不同的设备或浏览器是开发者最常用的方法</p>
<p><strong>在控制台打印<code>navigator.userAgent</code>查看</strong></p>
<blockquote>
<p>Android 系统下的微信 User Agent</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">7.1</span><span class="number">.1</span>; MI <span class="number">6</span> Build/NMF26X; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">57.0</span><span class="number">.2987</span><span class="number">.132</span> MQQBrowser/<span class="number">6.2</span> TBS/<span class="number">043807</span> Mobile Safari/<span class="number">537.36</span> MicroMessenger/<span class="number">6.6</span><span class="number">.1</span><span class="number">.1220</span>(<span class="number">0x26060135</span>) NetType/WIFI Language/zh_CN</span><br></pre></td></tr></table></figure>

<blockquote>
<p>iPhone 系统下的微信 User Agent</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (iPhone; CPU iPhone OS <span class="number">9_3_2</span> like Mac OS X) AppleWebKit/<span class="number">601.1</span><span class="number">.46</span> (KHTML, like Gecko) Mobile/13F69 MicroMessenger/<span class="number">6.6</span><span class="number">.1</span> NetType/4G Language/zh_CN</span><br></pre></td></tr></table></figure>

<blockquote>
<p>微信内置浏览器与小程序中的User Agent 对比</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安卓系统中小程序 User Agent</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">7.1</span><span class="number">.1</span>; MI <span class="number">6</span> Build/NMF26X; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">57.0</span><span class="number">.2987</span><span class="number">.132</span> MQQBrowser/<span class="number">6.2</span> TBS/<span class="number">043807</span> Mobile Safari/<span class="number">537.36</span> MicroMessenger/<span class="number">6.6</span><span class="number">.1</span><span class="number">.1220</span>(<span class="number">0x26060135</span>) NetType/4G Language/zh_CN MicroMessenger/<span class="number">6.6</span><span class="number">.1</span><span class="number">.1220</span>(<span class="number">0x26060135</span>) NetType/4G Language/zh_CN miniProgram</span><br><span class="line"><span class="comment">// 安卓系统中微信内置浏览器 User Agent</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">7.1</span><span class="number">.1</span>; MI <span class="number">6</span> Build/NMF26X; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">57.0</span><span class="number">.2987</span><span class="number">.132</span> MQQBrowser/<span class="number">6.2</span> TBS/<span class="number">043807</span> Mobile Safari/<span class="number">537.36</span> MicroMessenger/<span class="number">6.6</span><span class="number">.1</span><span class="number">.1220</span>(<span class="number">0x26060135</span>) NetType/4G Language/zh_CN</span><br></pre></td></tr></table></figure>

<p>以上字符串为MI6安卓设备中获得。可以看出微信小程的UA和微信内置浏览器UA是不同的，特别是最后的’miniProgram’字符串。而在iPhone系统设备中UA是一致的， 小程序和微信内置浏览器UA没有区别。</p>
<h3 id="UA检测和判断方法"><a href="#UA检测和判断方法" class="headerlink" title="UA检测和判断方法"></a>UA检测和判断方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/MicroMessenger/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;当前为微信访问&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开源工具推荐"><a href="#开源工具推荐" class="headerlink" title="开源工具推荐"></a>开源工具推荐</h2><p><a href="https://github.com/faisalman/ua-parser-js">UAParser.js</a></p>
<p>目前生产环境使用该库来判断移动，Android，iOS等环境。</p>
<h2 id="小程序里一定要用https-无法访问http"><a href="#小程序里一定要用https-无法访问http" class="headerlink" title="小程序里一定要用https, 无法访问http"></a>小程序里一定要用https, 无法访问http</h2><p>解决办法：配置Charles<br><a href="https://www.cnblogs.com/xcsn/p/7538371.html">https://www.cnblogs.com/xcsn/p/7538371.html</a></p>
<h2 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h2><p>onload —-&gt;  onshow  —-&gt;  onready<br>即使在onload阶段发生跳转，后面的流程还是会继续执行。</p>
<p>原则上onload 只会执行一次，onshow每次页面显示才会显示。</p>
<p>所有页面onload阶段的options是从跳转的page url后跟的参数取到的。</p>
<h2 id="组件button样式"><a href="#组件button样式" class="headerlink" title="组件button样式"></a>组件button样式</h2><p>button去掉边框(适用于百度小程序)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span>&#123;</span><br><span class="line">    <span class="attribute">backgrond</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="button-阻止冒泡"><a href="#button-阻止冒泡" class="headerlink" title="button 阻止冒泡"></a>button 阻止冒泡</h2><p>有的button 设置了默认操作例如open-type=’share’<br>点击以后父容器有click事件，也会触发。</p>
<p>解决办法：<br>在button绑定一个方法 return false;</p>
<h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>用过wepy各种坑，弃坑</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="https://blog.csdn.net/i10630226/article/details/81042421">微信小程序：一些运行细节及针对性的优化策略</a></p>
<h2 id="微信小程序开发资源汇总"><a href="#微信小程序开发资源汇总" class="headerlink" title="微信小程序开发资源汇总"></a><a href="https://github.com/justjavac/awesome-wechat-weapp">微信小程序开发资源汇总</a></h2><h2 id="好的目录结构"><a href="#好的目录结构" class="headerlink" title="好的目录结构"></a><a href="https://github.com/ranshaw/weapp-quick-start">好的目录结构</a></h2><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">├── README.md                 // 说明文档</span><br><span class="line">├── dist                      // 编译后的代码，用小程序开发工具打开此文件夹</span><br><span class="line">├── mock.js                   // 模拟数据的文件</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── project.config.json       // 项目配置文件</span><br><span class="line">├── src                       // 项目代码都在这个文件夹下</span><br><span class="line">│   ├── app.js                // 等同于小程序根目录下的app.js</span><br><span class="line">│   ├── app.json              // 等同于小程序根目录下的app.json</span><br><span class="line">│   ├── app.wxss              // 等同于小程序根目录下的app.wxss</span><br><span class="line">│   ├── assets                // 项目中使用到的静态资源</span><br><span class="line">│   │   └── images</span><br><span class="line">│   │       ├── example</span><br><span class="line">│   │       └── tab</span><br><span class="line">│   ├── components            // 公用的组件</span><br><span class="line">│   ├── page                  // 存放小程序的各个页面文件</span><br><span class="line">│   │   ├── example           // example 页面</span><br><span class="line">│   │   │   ├── components    // example页面中的组件</span><br><span class="line">│   │   │   ├── index.js</span><br><span class="line">│   │   │   ├── index.json</span><br><span class="line">│   │   │   ├── index.wxml</span><br><span class="line">│   │   │   ├── index.wxss</span><br><span class="line">│   │   │   ├── services      // example页面中接口</span><br><span class="line">│   │   │   ├── template      // example页面中的模板</span><br><span class="line">│   │   │   └── wxs           // example页面中的wxs文件</span><br><span class="line">│   │   ├── globalStore.js    // 全局共享的数据</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       ├── index.js</span><br><span class="line">│   │       ├── index.json</span><br><span class="line">│   │       ├── index.wxml</span><br><span class="line">│   │       └── index.wxss</span><br><span class="line">│   ├── template              // 公用的模板</span><br><span class="line">│   └── utils                 // 公用的方法或工具</span><br><span class="line">│       ├── config.js         // 全局的一些配置信息</span><br><span class="line">│       ├── create.js         // 状态管理插件</span><br><span class="line">│       ├── mitt.js           // 状态管理插件</span><br><span class="line">│       ├── obaa.js           // 状态管理插件</span><br><span class="line">│       ├── util.js           // 公用方法</span><br><span class="line">│       ├── wxRequest.js      // 封装的小程序请求数据方法</span><br><span class="line">│       └── wxapi.js          // 对小程序api进行Promise封装</span><br><span class="line">└── weapp.config.js           // 对脚手架的配置文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="小程序的双线程结构"><a href="#小程序的双线程结构" class="headerlink" title="小程序的双线程结构"></a>小程序的双线程结构</h2><p>与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，<br>在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。</p>
<h2 id="小程序更新视图数据的通信流程"><a href="#小程序更新视图数据的通信流程" class="headerlink" title="小程序更新视图数据的通信流程"></a>小程序更新视图数据的通信流程</h2><p>每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下：</p>
<ul>
<li><p>小程序逻辑层调用宿主环境的 setData 方法。</p>
</li>
<li><p>逻辑层执行 JSON.stringify 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过evaluateJavascript 执行脚本将数据传输到渲染层。</p>
</li>
<li><p>渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。</p>
</li>
<li><p>ebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。<br>  经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到UI视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。</p>
</li>
</ul>
<h2 id="引发渲染性能问题的原因"><a href="#引发渲染性能问题的原因" class="headerlink" title="引发渲染性能问题的原因"></a>引发渲染性能问题的原因</h2><ul>
<li>setData传递大量新数据<br>  数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程。</li>
<li>频繁的执行setData操作<br>  频繁的执行 setData 会让 WebView JS 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。</li>
<li>过多的页面节点数<br>  页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。<br>  每次执行 setData 更新视图，WebView JS 线程都要遍历节点树计算新旧节点数差异部分。当页面节点数量越多，计算的时间开销越大，减少节点树节点数量可以有效降低重渲染的时间开销。</li>
</ul>
<h2 id="渲染性能优化"><a href="#渲染性能优化" class="headerlink" title="渲染性能优化"></a>渲染性能优化</h2><h3 id="setData优化"><a href="#setData优化" class="headerlink" title="setData优化"></a>setData优化</h3><ol>
<li><p>减少 setData 数据传输量</p>
<p> <strong>仅传输视图层使用到的数据，其他 JS 环境用到的数据存放到 data 对象外。</strong></p>
<p> 合理利用局部更新。</p>
<p> setData 支持使用 数据路径 的方式对对象的局部字段进行更新。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只更新需要更新的数据！！！</span></span><br><span class="line"><span class="comment">// 后台获取列表数据</span></span><br><span class="line"><span class="keyword">const</span> list = requestSync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新整个列表----错误❌</span></span><br><span class="line"><span class="built_in">this</span>.setData(&#123; list &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部更新列表---√</span></span><br><span class="line"><span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    <span class="string">&#x27;list[0].src&#x27;</span>: list[<span class="number">0</span>].src</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>降低 setData 执行频率</p>
<p> 在不影响业务流程的前提下，将多个 setData 调用合并执行，减少线程间通信频次。</p>
</li>
<li><p>善用自定义组件</p>
</li>
</ol>
<p>小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似.</p>
<p>在页面引用自定义组件后，当初始化页面时，Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用.</p>
<p>基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。</p>
<p>当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。</p>
<p>当然，并不是使用自定义组件越多会越好，页面每新增一个自定义组件， Exparser 需要多管理一个组件实例，内存消耗会更大，当内存占用上升到一定程度，有可能导致 iOS 将部分 WKWebView 回收，安卓机体验会变得更加卡顿。因此要合理的使用自定义组件，同时页面设计也要注意不滥用标签。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小程序双线程架构决定了数据通信优化会是性能优化中一个比较重要的点。<br>而上述提到的几个优化建议只是优化渲染性能中的一部分，要想让你的页面体验变得更加丝滑，<br>就要熟悉小程序框架的底层原理，根据小程序框架的特点，编写出“合身”的前端代码。</p>
<h2 id="小程序传递url里有特殊字符，比如"><a href="#小程序传递url里有特殊字符，比如" class="headerlink" title="小程序传递url里有特殊字符，比如+"></a>小程序传递url里有特殊字符，比如+</h2><p>用 <code>encodeURIComponent(JSON.stringify(address))</code>,方式传递，在接收时，不用decode,直接获取即可<br>如果不用encode，获取到的值里+会丢失</p>
<h2 id="小程序textarea适配问题"><a href="#小程序textarea适配问题" class="headerlink" title="小程序textarea适配问题"></a>小程序textarea适配问题</h2><p>在页面中用到了textarea，测试发现的问题：</p>
<ol>
<li>高度无法自适应</li>
<li>删除时，光标会自动到第一个</li>
<li>有的手机上多行展示不自动换行</li>
</ol>
<p>解决办法:</p>
<p>挨个排除每个属性，看是哪个属性影响导致的。<br>发现 <code>auto-height</code> 导致的问题，去掉auto-height，采用css设置height为固定高度，解决问题</p>
<h2 id="处理一些兼容性问题时，要先看手百APP是不是最新版的，有可能是旧版的APP导致的问题"><a href="#处理一些兼容性问题时，要先看手百APP是不是最新版的，有可能是旧版的APP导致的问题" class="headerlink" title="处理一些兼容性问题时，要先看手百APP是不是最新版的，有可能是旧版的APP导致的问题"></a>处理一些兼容性问题时，要先看手百APP是不是最新版的，有可能是旧版的APP导致的问题</h2>]]></content>
      <tags>
        <tag>经验积累</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序高性能打造之路</title>
    <url>/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%AB%98%E6%80%A7%E8%83%BD%E6%89%93%E9%80%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5e7d4487e51d4546d83af560">原文链接</a></p>
<p>小程序页面的标准</p>
<ul>
<li>极致的页面性能</li>
<li>友好的产品体验</li>
<li>稳定的系统服务</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>思维导图列表</title>
    <url>/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="../img/xmind/%E6%89%A7%E8%A1%8C%E6%9C%89%E9%81%93%E5%9B%9B%E6%AD%A5%E6%B3%95.xmind">执行有道四步法</a></p>
]]></content>
  </entry>
  <entry>
    <title>思维导图笔记</title>
    <url>/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>1.要想高效的利用本书，很重要的一点就是必须加强练习！！！</p>
<p>2.左脑处理逻辑、词汇、表单、数字、线性和分析等所谓的学术活动。右脑主司节奏、想象、色彩、幻想、空间感、完整倾向(整体观念)和维度。 </p>
<p>3.鼓励人们去开发他们以前认为很弱的脑区。会产生一种协同效应，使整个脑区的智力水平都随之提高。</p>
<p>4.当我们说自己某些方面行，某些方面不行时，我们实际是指已经很成功的开发出来了的潜力和尚未开发出来的，仍然处在蛰伏状态的潜能。如果能将蛰伏状态下的潜能开发出来，大脑将释放出巨大的“能量”。</p>
<p>5.大脑每分钟约要进行10万~100万次不同的化学反应。</p>
<!---more--->


<p><a href="/img/clipboard.png">记忆曲线</a><br><img src="/img/clipboard.png" ></p>
<p>6.感知模型：眼睛-大脑-相机<br>        按照一般人做白日梦的样子，闭上眼睛，想象你最喜欢的物体，在你心目中已经很清晰地记住其图像后，再做下列这些练习:<br>        在面前转动它<br>从顶部看它<br>从底部看它<br>改变它的颜色，至少3次。<br>把她移开，就好像在很远处看它一样。<br>再把它移回来。<br>把它变的极大。<br>把他变小。<br>完全改变它的形状。<br>让它消失。<br>再让它出来。<br>这些活动你做起来好不费事，可是相机的零件却完全无法做到。</p>
<p>思维导图_启动大脑  33页<br>—————————————-2014/10/27 00:03   ————————————————————————–</p>
<ol start="3">
<li><p>大脑受限制的原因</p>
</li>
<li><p>与承认失败相比，更多人会说”我们只是普通人”，这种说法不足以令人信服！我们必须学习大脑是如何工作的，以便充分发挥自身无限的潜力。</p>
<p>2.我们的表现与我们甚至最小潜力不相符的原因就是，我们对自己所拥有的内在潜力一无所知，更不用说如何去充分利用了。<br>3.一个普遍并且被严重误导的神话：人类本身就有不足之处，因此，这场灾难的责任应归结于人类本身的“缺陷”。</p>
<p>4.在全世界范围的教育系统内，人们之所以几乎没有花时间去学习如何学习，是因为我们对这台生物计算机的基本操作规则一无所知。</p>
<p>《启动大脑》 是第一本“大脑使用说明书”，它是专门用来帮助你了解、充实和保养你自己的“超级生物计算机”的，并教你如何释放你所拥有的自然且非凡的智能。</p>
</li>
<li><p>更快、更有效的阅读</p>
<p>   1.我阅读存在的问题</p>
<pre><code>       阅读速度慢，阅读后会忘记、阅读的时间不能保证、阅读后当时掌握回头就会忘记、阅读的时候有些不能很快的理解</code></pre>
<p>阅读定义:“从书中捕捉作者的意图”或“吸收所写文字的内容”。<br>阅读是个人与符号信息之间发生的全部相互联系；它通常是指学习的视觉方面，并包含下述7个步骤。</p>
<pre><code>       辨识、吸收、内部整合、外部整合、保持、回忆、交流</code></pre>
<p>4.3阅读问题存在的原因<br>   答案除了我们早先对大脑缺乏认识之外，主要是因为我们早期的阅读教育方法不当。</p>
<p>眼睛在阅读时，实际是以一系列的停顿和快速跳跃的方式移动的。</p>
<p>   提高速度</p>
<pre><code>   1.消除回读----90%的回跳和回读是因为担心不能对阅读材料完全理解而引起的。
   2.每次凝视的时间可减到最低的1/4秒，------人的眼睛可以在1/100秒的时间内摄入5个单词。
   3.凝视的间隔可扩展到一次摄入3~5个单词。</code></pre>
<p>快速阅读的好处<br>   快速阅读者的优势是他的眼睛在每一页上话费的物理运动较少，不会像慢速阅读者那样，每页紧张的聚焦凝视500多次。快速阅读者每页只凝视100次，其眼肌就不会疲劳。<br>   另一个好处：能有节奏、流畅的阅读和轻松愉快的领略文章的意思。<br>4.6  对阅读的误解<br>   1.一次只能看一个单词————错。人的凝视能力就可以扩展，我们阅读的目的不是理解单个的词，而是整体意思。<br>   2.阅读速度不可能超过每分钟500个单词—-错，每次凝视可以摄入6个单词，而且每秒钟可以凝视4次。这就意味着每分钟1000个单词的阅读速度是完全能达到的。<br>   3.快速阅读者没法欣赏文章———-错。因为快速阅读者能更多的理解所读的内容，能更专注地看材料，所以他有更多的时间去回顾他认为特别有趣的和重要的部分。<br>   4.速度越快注意力就越低——-错。读的越快，得到的刺激就越多，注意力就越集中。<br>   5.一般阅读速度更自然，因此也就最好——错。因为一般阅读速度并不自然。它是早期不完善的训练，加之缺乏眼睛和大脑能以各种可能的速度阅读等方面的知识所造成的。</p>
</li>
</ol>
<p>4.7.1 高级阅读技巧——快上加快<br>        我们要做的不是叫他们把手指从书本上拿开，而是让他们更快的移动手指。它在帮助养成流畅的阅读节奏方面有着不可估量的作用。<br>        用辅助物 阅读时阅读的速度更快。<br>4.7.2                  ———扩大焦点<br>        结合视觉辅助技巧，特别适用于阅读一些轻松的材料和用来预习和复习，还可以提高正常的阅读速度。<br>            很重要的一点是必须使用视觉导引物<br>                    试着采用如斜对角线、曲线和沿书页直线向下等各种视觉导引物。<br>4.7.3  快速理解<br>        尽快从一页浏览到下一页，并尽可能多看一些单词。这种训练可增加每次凝视时摄入更大范围的单词群的能力，也适用于练习纵览和预览技巧，并能把大脑调整到适应更快速、更有效的整体阅读练习状态。</p>
<p>4.8    动机训练<br>        计算每分钟阅读速度的公式：<br>            阅读速度=（所读页数*每页平均单词书）/阅读的分钟数<br>4.9    节拍训练<br>        调整到合理的节奏、即每一拍代表视觉引导物的一次移动的话，用这种方式可以保持一种稳定、连贯的节奏、并可克服阅读开始后不久出现的阅读速度下降的问题。一旦找到最佳的节奏，就可通过每分钟偶尔加一拍的方式提高你的阅读速度。<br>————2014/10/28 00:15——————-</p>
<p>5.3  记忆趋势：在学习期间的开头和结尾记得多；多次重复、易感知、有节奏的内容记得多；突出或独特的内容记得多———–冯-雷斯托夫效应，而学习期间的中间阶段所能机翼的内容却相当少。</p>
<pre><code> 要想保持在一个相当高的水准，必须找到记忆与理解最和谐的工作点。
在正常情况下，这一点出现在学习开始的20~50分钟之间。
学习期间的短暂间隔也常用于放松、消遣。可以使集中注意力学习时紧张的肌肉和神经得以放松。
学习后的回忆量最初是上升，之后才是下降，再后是一条逐渐下降的、以水平线结尾的凹形曲线。

    短暂上升的原因：在学习结束的瞬间，大脑没有足够的时间去整合刚学的新信息，尤其是最后的部分。它需要几分钟的时间将新材料之间的相关联系牢固地连接起来，即使之“沉淀下来”。
    小幅上升之后是一个陡峻的下降，在学习一个小时之后的24小时之内，至少有80%的细节被遗忘了。</code></pre>
<p>5.5 记忆–复习的技巧和理论<br>        安排有计划的复习，而且每次复习必须安排在回忆刚开始下降之前。<br>        eg:第一次复习应该在学习1小时之后的10分钟开始，复习时间以5分钟为宜。这样可以使记忆在高位保持1天左右，然后应该进行第二次复习，时间为2~4分钟。此后，记忆将保持一周左右，然后在一个月之后再次复习约2分钟。经过这最后一次复习，此项知识将被转为长期记忆。</p>
<pre><code>    如果已经做过笔记的话，第一次复习应该是对笔记的全面修订过程，这就意味着要取代原来的笔记的“最终版本”。而第二、三和四次复习则应采用下列方式:不看整理过的笔记，用一张纸概括记下所能回忆的一切，然后将其与整理后的笔记对照，再进行修改和补充。笔记和草稿都应做成思维导图。
    合理复习最重要的一个方面是作用于学习、思维和记忆等各方面的累计效应。

    每次接触新知识时，人们对已学知识的记忆处于低谷，原有知识间自动产生的连接会解体。这样，他对新知识的理解就不能达到应有的水平，效率和速度也必然很低。这种连续的消极过程会使人感到沮丧，最终对能学好的东西也失去了信心-----只要一学新东西就会忘记，一接触新东西心理上就会感到压抑。结果是很多人在完成了正式的考试之后，就很少甚至根本不再碰书本。


    失败的复习对整体记忆同样有害，如果忽略每条新信息的话，那么它将不再保持在意识层中，也不能形成新的记忆链接。由于记忆是一个以连接和联想为基础的过程，因而“记忆库”中的东西越少，其接纳和连接新知识的可能性就越小。
    相反，复习的好处是无穷的。</code></pre>
<p>2014/10/29 10:54<br>    使用某些方法使我们能利用记忆的连接和联想能力，来把这些事项与其对应的数字关联起来。<br>   最好的方法是数字-韵律法。</p>
<p>5.7记忆的“SMASHIN” SCOPE 法<br>        在这种方法中最重要的是要保证押韵字与所要记忆的单词必须全部准确的连接起来。<br>    1.通感/感官(Synaesthesia/Sensuality)<br>            通感，指的是多种感觉的融合。<br>            视觉、听觉、嗅觉、味觉、触觉、动觉—对身体在空间中的位置与运动的感觉。<br>    2.运动(Movenment)<br>            在任何记忆的形象中，运动可以极大的增加大脑连接和记住东西的可能性。—-这里指记忆的形象的运动性。<br>    3.联想(Association)<br>            确保使它与你的内省的某些稳定不变的事物联想或连接起来。衣钩法：1=面包。<br>    4.性(Sexuality)<br>            要加以利用!<br>    5.幽默(Humour)<br>            想象越有趣、越荒谬、越愚蠢、超越现实，就越容易被记住。<br>    6.想象(Imagination)<br>            爱因斯坦说：“想象比知识更重要，因为知识是有限的，而想象却能包容全世界、促进进步、孕育革新。”<br>            在记忆中应用的想象越多，记忆就会越好。<br>    7.编号(Number)<br>            按数字编号使顺序及次序的规则更有针对性，更有效。<br>    8.符号(Symbolism)<br>            用丰富多彩的想象；可以用传统的符号，如休止符、灯泡。<br>    9.颜色(Color)<br>            在适当的地方尽可能使用各种颜色，可使你的想法色彩斑斓，更易于记忆。<br>    10.顺序和/或次序(Order and /or Seguence)<br>            结合其他规则，排列顺序和次序起到了更直接的参考作用，并增加了大脑“随机存取”的可能性。将排列顺序和次序的应用加以扩展，能使你开发记忆矩阵，如自我增强型记忆矩阵。<br>    11.“积极”的形象(Positive Images)<br>            积极愉快的形象更利于记忆，这使大脑乐于工作。<br>    12.夸张(Exageration)<br>            在所想象的情景中，夸大尺寸、形象和声音。</p>
<pre><code>    12个记忆要素很容易用它们的首字母组成的单词“SMASHIN” SCOPE 来记。</code></pre>
<p>5.8  数字–韵律法<br>        在形成头脑中的形象时，很重要的一点是,要在“心目”中看到清晰的图像。经常闭上眼睛，将想象的情景投影到你的眼脸内部，或投影到你大脑的屏幕上，并且去听、去感觉、去闻，或者用对你来说最有效的方式去体验。原书84页。<br>        所有方法中尤其有效的是基本记忆法。它能以“数字-韵律法”的方式记住1000条以上的信息，并且能给出记忆数字与日期的关键方法。“名字-面孔记忆法”能避免你在碰到曾经见过面的人时，避免尴尬。<br>5.9 不可能完成的任务<br>        记忆基本上是一个联想和连接的过程，而且很大程度上取决于关键字，以及用于恰当想象的关键概念。</p>
<p>6.思维导图–词汇与思维特征的介绍<br>6.1 练习与讨论蟋蟀</p>
<p>四象限法则<br>策略：<br>如果你总是有紧急又重要的事情要做，说明你在时间管理上存在问题，设法减少它。<br>尽可能地把时间花在重要但不紧急（第二象限）的事情上，这样才能减少第一象限的工作量。<br>对于紧急但不重要的事情的处理原则是授权，让别人去做。<br>不重要也不紧急的事情尽量少做。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库分享</title>
    <url>/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>Sharding-Sphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar这3款相互独立的产品组成。他们均提供标准化的数据分片、读写分离、柔性事务和数据治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p>
]]></content>
  </entry>
  <entry>
    <title>日常掉坑记</title>
    <url>/posts/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="日常掉坑记"><a href="#日常掉坑记" class="headerlink" title="日常掉坑记"></a>日常掉坑记</h2><h3 id="1-scrollIntoView"><a href="#1-scrollIntoView" class="headerlink" title="1. scrollIntoView"></a>1. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView">scrollIntoView</a></h3><p>该方法可以很好的解决页面内锚点跳转，不用在url里加<code>#锚点</code></p>
<p>在QQ浏览器下会无法滚动到指定锚点, 在有些版本的Chrome里也会遇到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">element.scrollIntoView(&#123;<span class="attr">behavior</span>: <span class="string">&quot;smooth&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>去掉<code>&#123;behavior: &quot;smooth&quot;&#125;</code>可以正常滚动</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>);</span><br><span class="line"><span class="built_in">window</span>.scrollTo(&#123;</span><br><span class="line">    top: button.offsetTop,</span><br><span class="line">    left: <span class="number">0</span>,</span><br><span class="line">    behavior: <span class="string">&#x27;smooth&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>经测试，在IE和UC中这个方法也不好使。<br>所以最终方案是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">element.scrollIntoView();</span><br></pre></td></tr></table></figure>

<p>缺点是没有动画效果。<br>可以根据兼容性要求来选择方案。</p>
<h2 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a><a href="https://github.com/zenorocha/clipboard.js">Clipboard</a></h2><p>  触发事件的元素一定要用button才能生效。</p>
<h2 id="视频播放到最后一帧黑屏"><a href="#视频播放到最后一帧黑屏" class="headerlink" title="视频播放到最后一帧黑屏"></a>视频播放到最后一帧黑屏</h2><p>经测试，是视频本身黑屏</p>
<p>浏览器用window.innerWidth 为1280，为何浏览器截图为1920，<br>因为电脑设置了显示比例。150%，所以会出现显示异常。</p>
<p>背景透明不要用opacity，要用rgba()<br>用opacity会导致背景透明文字也透明。</p>
<p>背景透明，文字也透明解决办法</p>
<p>设置z-index失效， 发现在容器中可用，position absolute离开容器后就看不到了，</p>
<p>原因： 父容器设置了overflow:hidden, 所以如果要移到合适的位置，需要把合适的位置也放到父容器中。</p>
<p>bootstrap每列之间没有间隔，看起来中间有间隔，点击的时候还是会触发点击事件，</p>
<p>解决办法： 把绑定事件加在每列中的内容区域，而不是col-md上。</p>
<p>form表单提交文字带图片</p>
<ol>
<li><p>如图片是单独的字段，没有问题{‘pic’:url, text: ‘’}</p>
</li>
<li><p>如果是富文本？文字图片混在一起，怎么处理。<br>答案：在富文本编辑器里，上传图片会要求配置上传图片路径，放入的图片会先上传返回图片地址。</p>
<p>2018-7-11 16:31:43</p>
</li>
</ol>
<p>滚动条吸顶效果经验总结</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menu= <span class="built_in">document</span>.getElementById(<span class="string">&quot;nav&quot;</span>);</span><br><span class="line"><span class="comment">//获取距离页面顶端的距离</span></span><br><span class="line"><span class="keyword">var</span> titleTop = menu.offsetTop;</span><br><span class="line"><span class="comment">//滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> btop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果滚动距离大于导航条据顶部的距离</span></span><br><span class="line">    <span class="keyword">if</span>(btop &gt; titleTop) &#123;</span><br><span class="line">        <span class="comment">//为导航条设置fix</span></span><br><span class="line">        $(<span class="string">&quot;.nav&quot;</span>).addClass(<span class="string">&quot;fixed&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//移除fixed</span></span><br><span class="line">        $(<span class="string">&quot;.nav&quot;</span>).removeClass(<span class="string">&quot;fixed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>为了减少页面重绘次数增加延时功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;scroll once..&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timeoutRef;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span> , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeoutRef)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutRef);</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutRef = <span class="built_in">setTimeout</span>(callback , <span class="number">50</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果要吸顶的元素在页面中间，会造成页面抖动，<br>需要吸顶的元素设置position:fixed后移到顶部造成页面高度发生变化重新触发scroll方法，</p>
<p>解决办法：<br> 将需要吸顶的元素父容器设定最小高度，即使位置发生移动，也有固定高度在，不会触发scroll方法。</p>
]]></content>
  </entry>
  <entry>
    <title>沟通技巧</title>
    <url>/posts/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="2-如何跟爸妈打电话—哄父母开心的三心技法"><a href="#2-如何跟爸妈打电话—哄父母开心的三心技法" class="headerlink" title="2. 如何跟爸妈打电话—哄父母开心的三心技法"></a>2. 如何跟爸妈打电话—哄父母开心的三心技法</h1><p>安心，舒心，开心， 我们才能放心</p>
<p>父母不知道说什么，我们也不知道说什么<br>提升跟父母的童话质量</p>
<a id="more"></a>

<h2 id="细节–安心"><a href="#细节–安心" class="headerlink" title="细节–安心"></a>细节–安心</h2><p>大而笼统的话越不放心<br>少操心，早睡早起，多吃饭，一切都好请放心–会觉得藏着掖着报喜不报忧</p>
<p>说细节，看了什么电影，电视剧，跟哪个朋友吃了饭</p>
<p>细节暗示比信誓旦旦更有效</p>
<h2 id="问题–舒心"><a href="#问题–舒心" class="headerlink" title="问题–舒心"></a>问题–舒心</h2><p>问题使他们舒心<br>经常在电话中向他们提问，最好问生活中他们得心应手的问题</p>
<ul>
<li>排骨汤怎么炖</li>
<li>衣服怎么洗好</li>
<li>夏天吃什么水果比较健康</li>
</ul>
<p>耐心听取答案，做出恍然大悟的回应</p>
<p>最好不要问工作中的问题</p>
<h2 id="拿对比使他们开心"><a href="#拿对比使他们开心" class="headerlink" title="拿对比使他们开心"></a>拿对比使他们开心</h2><p>父母们在儿女这个话题上要有发言权<br>让他们有值得骄傲和炫耀的话题点，实际成就并不重要，只需要多说说和同事朋友的八卦。</p>
<p>某同事没女朋友，某同事还没结婚，某同事没工作了。<br>让父母有谈资，舒缓父母社交压力</p>
<p>父母主动社交能力在不断下降，孩子承担起主动沟通的责任，并提供父母沟通的谈资</p>
<p>人的一生都是社交的一生</p>
<p>用细节让父母安心，意味着你要向他们呈现真实生活，把自己置于汇报者的地位<br>用问题让父母舒心，你要让他们感觉到他们对你的生活是有意义的，是能够提出指导意见的，是有权威的<br>用对比让他们开心，你要向他们证明你是值得他们炫耀的，是能够让他们在社交的时候特别有面子的。</p>
<p>这样的沟通技巧还能用在其他很多方面，开通脑筋，好好说话</p>
<h1 id="3-观冲突，该怎么聊"><a href="#3-观冲突，该怎么聊" class="headerlink" title="3. 观冲突，该怎么聊"></a>3. 观冲突，该怎么聊</h1>]]></content>
      <tags>
        <tag>沟通技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>百度小程序经验积累</title>
    <url>/posts/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="重启大法"><a href="#重启大法" class="headerlink" title="重启大法"></a>重启大法</h2><p>如果遇到以下问题，不要怀疑自己，请重启</p>
<ol>
<li>样式不生效</li>
<li>页面不能正常渲染</li>
<li>项目编译失败</li>
<li>写的新组件，引用后不生效</li>
</ol>
<h2 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h2><pre><code>开发者工具报一堆不是代码的错误，检查调试基础库的版本
查看项目信息-&gt; 调试基础库-&gt; 3.40.28</code></pre>
<a id="more"></a>

<h2 id="组件编写"><a href="#组件编写" class="headerlink" title="组件编写"></a>组件编写</h2><ol>
<li><p>新创建的文件夹在引用时不生效<br> 解决方案： 重启开发者工具</p>
</li>
<li><p>引用组件名称不能是驼峰写法(arrivalDialog)，必须用arrival-dialog</p>
</li>
<li><p>组件引用后，在页面出现两个相同的DOM<br> 原因: 组件中有语法错误</p>
</li>
<li><p>json文件</p>
<pre><code> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;component&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;popup&quot;</span>: <span class="string">&quot;/pages/components/popup/popup&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;btn-group&quot;</span>:<span class="string">&quot;../btngroup/index&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>子组件接收参数要在<code>properties</code>中定义</p>
<pre><code> <figure class="highlight"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">    dataSource: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        value: null,</span><br><span class="line">        observer: function(newVal, oldVal) &#123;</span><br><span class="line">            this.renderView();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p> 如果子组件里要根据父组件里传来的数据进行业务逻辑处理，需要在<code>observer</code>里重新<code>setData</code></p>
</li>
<li><p>组件的方法要写到<code>methods: &#123;&#125;</code>里</p>
</li>
</ol>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ol>
<li>在子组件调用父组件的方法，要<strong>逐级传递</strong>，不能漏掉其中一层</li>
</ol>
<p>子组件调用父组件的方法</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">closeModal</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.triggerEvent(<span class="string">&#x27;toggleReservationDialog&#x27;</span>, &#123;<span class="attr">isShow</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>引用子组件</p>
<pre><code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;order-dialog</span><br><span class="line">    bind:toggleReservationDialog = &quot;toggleReservationDialog&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></code></pre>
<p>事件传参</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.triggerEvent(<span class="string">&#x27;arrivalSubmit&#x27;</span>, &#123;<span class="attr">telephone</span>: input&#125;);</span><br></pre></td></tr></table></figure></code></pre>
<p>在父组件<code>arrivalSubmit</code>中，获取参数不能直接取到telephone这个对象<br>小程序会再包一层，用以下方式获取</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> telephone = e.detail.telephone;</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="小程序自身缺陷"><a href="#小程序自身缺陷" class="headerlink" title="小程序自身缺陷"></a>小程序自身缺陷</h2><ol>
<li><p>s-if中的表达式</p>
<pre><code> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无法识别，会报错 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;swan s-if=&quot;&#123;&#123;+res.code === 1&#125;&#125;&quot;&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">swan</span> <span class="attr">s-if</span>=<span class="string">&quot;&#123;&#123;res.code === 1&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">swan</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>表达式过于复杂，会导致DOM无法渲染</p>
</li>
<li><p>for循环无法一次循环两条数据，不能修改当前index. 解决办法: 先处理好数据结构再循环</p>
</li>
<li><p>css语法不能识别<code>color: var(--color-white);</code>(之前可以识别~~~)</p>
</li>
</ol>
<h2 id="React代码迁移到小程序经验"><a href="#React代码迁移到小程序经验" class="headerlink" title="React代码迁移到小程序经验"></a>React代码迁移到小程序经验</h2><p>html结构直接拷贝到swan文件</p>
<ol>
<li><p>div替换为view</p>
</li>
<li><p>p, h1-h6 等替换为view, 原来的标签样式替换为view后加class。如: <code>&lt;view class=&quot;h1&quot;&gt;&lt;/view</code></p>
</li>
<li><p>className替换为class</p>
</li>
<li><p>onClick替换为bindtap</p>
</li>
<li><p>onclick传参需要在js方法里传递，参数具体值可以用<code>data-</code>绑定到dom上，在js中通过<code>e.currentTarget.dataset.</code>获取, 如果当前组件只有一个data，不是数组类型的数据, 可以直接从<code>this.data</code>中获取</p>
</li>
<li><p>less通过转换工具转成css，px替换为rpx，数值都需要<code>*2</code>。如：<code>width:20px---&gt; width: 40rpx;</code></p>
</li>
<li><p>js <code>setState</code>替换为<code>setData</code></p>
</li>
<li><p>jsx中根据条件渲染的DOM可以根据具体情况看拆分成新组件还是通过<code>s-if, s-else</code>解决</p>
</li>
<li><p>想查看某个js变量的值，可以绑定到DOM上查看，如</p>
<pre><code> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swan</span> <span class="attr">item</span>=<span class="string">&quot;&#123;&#123;item&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">swan</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
</ol>
<h2 id="强制触发小程序页面渲染的方法"><a href="#强制触发小程序页面渲染的方法" class="headerlink" title="强制触发小程序页面渲染的方法"></a>强制触发小程序页面渲染的方法</h2><ol>
<li><p>在组件properties里定义变量名, 以及监听事件</p>
<pre><code> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        type: <span class="built_in">Object</span>,</span><br><span class="line">        value: &#123;&#125;,</span><br><span class="line">        <span class="function"><span class="title">observer</span>(<span class="params">newVal, oldVal</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.processData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>设置变量为null,再设值</p>
<pre><code> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    dataList: <span class="literal">null</span></span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">        dataList: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>强制销毁DOM, s-if设为false，再设为true<br>在设置style=<code>background-color: rgba(255, 255, 255, $&#123;opacity&#125;);</code>时, data已经发生变化，但页面没改变</p>
</li>
</ol>
<h2 id="样式问题"><a href="#样式问题" class="headerlink" title="样式问题"></a>样式问题</h2><p>在view里包一个image元素，如下</p>
<pre><code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;con&quot;</span>&gt;</span></span><br><span class="line">    &lt;image</span><br><span class="line">        src=&quot;https://cms-dumall.cdn.bcebos.com/cms_upload_pro/cms_1569467395902.jpg&quot;</span><br><span class="line">        mode=&quot;widthFix&quot;</span><br><span class="line">        class=&quot;image&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<p>css</p>
<pre><code><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.con</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.image</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">12</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这时候image会有多余的背景色出现, 原因是image元素为inline-block元素，通过设置`display: block;`解决</code></pre>
<h2 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h2><p>一些复杂的动画不能通过样式来实现，只能通过提供的<code>Animation</code> API来实现，非常麻烦~~~</p>
<h2 id="scroll-view高度必须固定"><a href="#scroll-view高度必须固定" class="headerlink" title="scroll-view高度必须固定"></a>scroll-view高度必须固定</h2><p>通过css设置height: 100vh;</p>
<p>解释：使用竖向滚动时，需要给定一个固定高度，可以通过css来设置height。</p>
<h2 id="终于支持async了啊，-真不容易2019-12-26-20-06-33"><a href="#终于支持async了啊，-真不容易2019-12-26-20-06-33" class="headerlink" title="终于支持async了啊， 真不容易2019-12-26 20:06:33"></a>终于支持async了啊， 真不容易2019-12-26 20:06:33</h2><h2 id="音频播放"><a href="#音频播放" class="headerlink" title="音频播放"></a>音频播放</h2><p>不要用audio组件，直接用API里的<code>innerAudioContext</code>开发。<br>拖动条用slider组件</p>
<p>跳到指定位置播放用<code>InnerAudioContext.seek</code></p>
<h2 id="音频播放器播放时控制slider问题"><a href="#音频播放器播放时控制slider问题" class="headerlink" title="音频播放器播放时控制slider问题"></a>音频播放器播放时控制slider问题</h2><p>播放会自动设置slider的值，<br>但是拖动时也会设置值，会有闪烁的效果</p>
<p>解决方法：</p>
<p>拖动时，暂停播放，结束后开始播放</p>
]]></content>
      <tags>
        <tag>经验积累</tag>
        <tag>小程序</tag>
        <tag>百度小程序</tag>
        <tag>React迁移到百度小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点</title>
    <url>/posts/%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>xss限制脚本执行方法 csp content script policy</p>
<p>setState多次调用，怎么执行，原理</p>
<p>css header固定，下面百分百布局</p>
<p>css画各种图形</p>
<p>组件添加自定义内容，</p>
<p>浏览器渲染页面过程</p>
<p>css动画不触发layout</p>
<p>react diff 算法</p>
<p>promise多级调用</p>
<p>字符串加减乘除类型的转二叉树执行结果</p>
<p>两个数组去重，这个里不包含那个里有的</p>
<p>异步用action，同步的请求怎么处理</p>
<p>Dispatch了action，是怎么识别这个action的</p>
<h2 id="redux流程，代码要写出来"><a href="#redux流程，代码要写出来" class="headerlink" title="redux流程，代码要写出来"></a>redux流程，代码要写出来</h2><p>action怎么定义，怎么dispatch到reducer中，<br>怎么触发dispatch 发送action</p>
<p>action怎么反馈到reducer</p>
<p>reducer处理数据的目的是什么</p>
<h1 id="webpack-清除缓存思路"><a href="#webpack-清除缓存思路" class="headerlink" title="webpack 清除缓存思路"></a>webpack 清除缓存思路</h1><p>hashchunk和chunk区别</p>
<h1 id="promise多次依赖异步调用手写代码"><a href="#promise多次依赖异步调用手写代码" class="headerlink" title="promise多次依赖异步调用手写代码"></a>promise多次依赖异步调用手写代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-then-then"><a href="#Promise-then-then" class="headerlink" title="Promise.then().then()"></a>Promise.then().then()</h1><p>多个promise.then().then()</p>
<p>如果前面的.then报错后，后面的还会执行吗</p>
<p>flex如何超出范围后出现滚动条？？？</p>
<p>Typeof还是要看的 √</p>
<p>对象后面跟数字，排序  sort  √</p>
<p>Vue的一些常用指令 √<br>显示Html v-html</p>
<p>Fouc， √</p>
<p>V-text</p>
<p>Watch深度监听 deep: true  √<br>Data和computed区别，缓存</p>
<p>Pop，push, 对应栈 在尾部删除添加<br>shift，unshift 对应列，在头部删除添加</p>
<p>React  vue生命周期结合路由钩子说明</p>
<p>Promise是什么√</p>
<p>Let和var的区别√</p>
<p>闭包，回调</p>
<p>事件委托</p>
<p>Redux的原理，流程</p>
<p>浏览器url包含什么  √</p>
<p>Jsonp缺点，原理√</p>
<p>Vue，react区别</p>
<p>Ajax是什么，状态码</p>
<p>Git回滚上一个版本√</p>
<p>Git  pull和rebase  merge√</p>
<p>左右布局方法</p>
<p>Audio</p>
<p>Promise实现异步队列</p>
<p>Map和set区别，怎么用<br>Set和array<br>set key不能重复<br>Map和foreach</p>
<p>Js数组转对象<br>用reduce实现map</p>
<p>jQuery扩展组件怎么写</p>
<p>Ajax有哪些参数</p>
<p>大文件怎么上传，<br>低版本浏览器怎么兼容</p>
<p>React同级组件传值</p>
<p>Clone方法克隆绑定事件</p>
<p>slice,splice<br>长连接实现方式</p>
<p>socket和websocket区别</p>
<p>轮询和长轮询区别</p>
<p>map和reduce，用map实现reduce</p>
<p>实现a().b().c()  定义{}，每个方法return this</p>
<p>for in for of 区别</p>
<p>可枚举和不可枚举的区别</p>
<p>上传文件方式，url-form，<br>formData是什么</p>
<p>浏览器中的缓存有哪几种，具体怎么工作的</p>
<p>强缓存和协商缓存</p>
<p>实现并发请求多次，依次返回结果。</p>
<p>如果第二个结果依赖第一个结果怎么写</p>
<p>nextTick, setImmediate, promise</p>
<p>require ,exports ,module.exports 区别</p>
<p>面试总结：<br>js:</p>
<ol>
<li>this指向，Promise this</li>
<li>闭包是什么，说出来， 写出来，能读懂程序</li>
<li>原型链 原型说出来，写出来，读懂。。。</li>
</ol>
<p>react和vue区别</p>
<p>设计模式</p>
<p>算法</p>
<p>个人项目中遇到哪些难处理的问题，怎么解决。</p>
<p>性能问题有哪些，怎么解决，</p>
<p>移动端有哪些兼容方案(rem)</p>
<p>Generator 是什么， Promise是什么</p>
<p>给一个数组，找出最大最小值，什么方法最快</p>
<p>测试的话有哪些边界值需要考虑，</p>
<p>状态码</p>
<p>深拷贝，浅拷贝 区别</p>
<p>react生命周期，每个生命周期都是什么，有哪些特殊用过的，</p>
<p>不用Promise怎么实现Promise.all</p>
<p>写个方法克隆js原始类型</p>
<p>CSS:</p>
<p>瀑布流原理 column</p>
<p>居中布局有哪些方法</p>
<h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><p>http协议理解</p>
<p>http是什么描述，<br>有哪些层，每层都有什么，</p>
<p>ip在哪一层</p>
<p>网络层是干嘛的</p>
<p>传输层有哪些协议，</p>
<p>tcp/ip协议</p>
<p>数据从http传过来，每一层都做什么处理</p>
<p>tcp和udp有什么区别</p>
<p>个人亮点是什么</p>
<p>有遇到什么特殊的经验</p>
<p>公司待遇，薪资福利 工作内容</p>
<p>因为状态不好<br>因为不自信</p>
<h3 id="面试态度，心态很重要啊，要微笑，面试之前微笑，给自己打气！释当缓和气氛，说话不要着急，不要抢答，慢条斯理说出自己知道的，不知道的猜猜，猜不出来微笑大胆承认不知道，把谈话的氛围搞好很重要，即使不会，也让面试官觉得你是暂时忘了，演技要上线"><a href="#面试态度，心态很重要啊，要微笑，面试之前微笑，给自己打气！释当缓和气氛，说话不要着急，不要抢答，慢条斯理说出自己知道的，不知道的猜猜，猜不出来微笑大胆承认不知道，把谈话的氛围搞好很重要，即使不会，也让面试官觉得你是暂时忘了，演技要上线" class="headerlink" title="面试态度，心态很重要啊，要微笑，面试之前微笑，给自己打气！释当缓和气氛，说话不要着急，不要抢答，慢条斯理说出自己知道的，不知道的猜猜，猜不出来微笑大胆承认不知道，把谈话的氛围搞好很重要，即使不会，也让面试官觉得你是暂时忘了，演技要上线"></a>面试态度，心态很重要啊，要微笑，面试之前微笑，给自己打气！释当缓和气氛，说话不要着急，不要抢答，慢条斯理说出自己知道的，不知道的猜猜，猜不出来微笑大胆承认不知道，把谈话的氛围搞好很重要，即使不会，也让面试官觉得你是暂时忘了，演技要上线</h3><p>不能大意失荆州，一些基础的css样式要完全正确手写出来！！！</p>
<p>学习知识要全面，了解了异步不能不知道同步该怎么写，</p>
<ol>
<li><p>判断两个元素是否为包含关系<br> contain, indexOf</p>
</li>
<li><p>css flex 模型</p>
</li>
<li><p>一个元素 如div 从top为0 移动到top 任意 的动画效果 原生代码</p>
</li>
<li><p>52张牌 平均 随机分给4个人</p>
</li>
<li><p>快速排序</p>
</li>
<li><p>10进制转64进制</p>
</li>
<li><p>轮播导航：慢滑无惯性滑动效果，快滑要惯性滑动 原生</p>
</li>
<li><p>给你一个网站 如何分析它的性能 以及 说说 优化策略</p>
</li>
<li><p>vue angularjs 实现数据绑定的原理</p>
</li>
<li><p>react 虚拟dom原理</p>
</li>
<li><p>用过哪些h5的api</p>
</li>
<li><p>localStorage 使用有什么想法 好处 缺点 你怎么用的</p>
</li>
<li><p>如何用js获取一个元素的宽 和 高</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">#box&#123;</span><br><span class="line">    background-color: lightgrey;</span><br><span class="line">    width: 300px;</span><br><span class="line">    border: 25px solid green;</span><br><span class="line">    padding: 25px;</span><br><span class="line">    margin: 25px;</span><br><span class="line">    height:60px;</span><br><span class="line">&#125;</span><br><span class="line">//获取盒子的内容高度，内容高度也可用用box.clientHeight获取，内容高度不包括边框和外边距和滚动条</span><br><span class="line">var box = document.getElementById(&quot;box&quot;)</span><br><span class="line">var contentHeight = window.getComputedStyle(box).height //输出 &#x27;60px&#x27;</span><br><span class="line"></span><br><span class="line">//获取盒子客户端的高度</span><br><span class="line">box.clientHeight //输出110 (内容高度+padding * 2)</span><br><span class="line"></span><br><span class="line">//获取盒子自身实际高度</span><br><span class="line">box.offsetHeight //输出160 (内容高度 + 内边距*2 +边框*2)</span><br><span class="line"></span><br><span class="line">如果box的父容器没有设置定位，则box.offsetLeft是相对body而言，否则是根据离它最近且有设置定位的父容器而言</span><br><span class="line">box.offsetLeft //获取box盒子相对它的父容器水平的偏移</span><br><span class="line">box.offsetTop //获取box盒子相对它的父容器垂直的偏移</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>盒子模型有几种</li>
<li>行内元素 块元素 有哪些 区别有哪些</li>
<li>实现 左边定宽 右边自适应布局</li>
<li>字符串反转</li>
<li>递归和循环 互相转换</li>
<li>性能调优策略</li>
<li>事件模型</li>
<li>原型链 以及 如何判断一个属性 是属于该对象 还是继承自原型链</li>
<li>单页应用你怎么理解 做过吗 聊聊</li>
<li>你常用什么设计模式 聊聊</li>
<li>跨域解决策略和原理</li>
<li>浏览器渲染过程</li>
<li>有哪几浏览器内核</li>
<li>css 动画</li>
<li>用过哪些模块加载工具 聊聊</li>
<li>写出几个常见的块级元素和行内元素 如何转换这两种标签的行为</li>
<li>请写出”me” “you” 所在元素的实际行高</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size:14px;line-height:3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size:2em&quot;</span>&gt;</span>you</span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-size:3em;line-height:3em;&quot;</span>&gt;</span>me<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>列举5种 触发ie hasLayout的属性及其值</p>
</li>
<li><p>画出css盒子模型</p>
</li>
<li><p>请写出至少3个css3种新添加的样式属性</p>
</li>
<li><p>实现以下方法（与标准一致）<br>a.Element.prototype.getElementsByClassName<br>b.Function.prototype.bind<br>c.Array.prototype.every<br>d.Object.create</p>
</li>
<li><p>写出javascript有几种基本数据类型 以及如何判断一个变量是数组</p>
</li>
<li><p>编写一个方法 去掉一个数组的重复元素</p>
</li>
<li><p>写出以下程序的计算结果<br>var str = “hello”;<br>var fn1 = function(){<br>console.log(str); //hello<br>}<br>var fn2 = function(){<br>var str = “world”;<br>fn1();<br>}<br>fn2()//结果</p>
</li>
<li><p>编写一个方法shuffle得到一个数组的随机副本<br>要求<br>var arr1 = [2,5,3,1,7,12,57,234]<br>var arr2 = shuffle(arr1);// arr2 =&gt; [234,2,3,1,7,57,12,5]</p>
</li>
<li><p>写一个判断 传入的字符串是数字的 方法 说出思路 （isNaN）</p>
</li>
<li><p>用过数组的哪些api</p>
</li>
<li><p>处理兼容性问题有哪些hack</p>
</li>
<li><p>考事件委托：如果你有一个列表,需求是 原生来写 点击li要触发一些行为，但是这个列表是动态的，比如我可能下拉刷新 新加载上5条数据 那么这个事件怎么绑定</p>
</li>
<li><p>css 布局如何实现垂直居中 都有哪些方法</p>
</li>
<li><p>怎么看一个css动画 是否流畅</p>
</li>
<li><p>重绘和重排 ，什么情况引起重绘 什么情况引起重排 怎么避免；重绘能引起重排吗 重排能引起重绘吗</p>
</li>
<li><p>考察闭包：写一个函数 作用是 第一次执行输出1 第二次输出2 第三次输出3</p>
</li>
<li><p>考察算法： 比如你有一个广告点击的排名列表 从高到底 ，现在你有一个广告 点击次数500 如何快速从这个列表里 返回这个广告的位置</p>
</li>
<li><p>jsonp的原理和缺陷</p>
</li>
<li><p>为什么<script>通常放在<body>后面</p>
</li>
<li><p>有没有什么情况<script>必须放在head里，script标签中async 和 defer的作用</p>
</li>
<li><p>除了 做雪碧图 、 压缩混淆js 还有什么提升网页加载速度的方法</p>
</li>
<li><p>前端安全 有哪些了解</p>
</li>
<li><p>javascript的作用域分析</p>
</li>
<li><p>cookies sessionstorge 和 localstorage的区别</p>
</li>
<li><p>分析给出的代码<br>localstorage.setItem(“test”,{a:”1”,b:”2”})<br>localstorage.getItem(“test”) //拿出来的是什么<br>//“[object Object]”</p>
</li>
<li><p>用到了哪些css3的东西</p>
</li>
<li><p>通过 循环每个列表里的元素 来跟 目标元素做对比 ，找到这个元素的时间复杂度是多少</p>
</li>
<li><p>写一个判断正整数、小数、负数的正则</p>
</li>
<li><p>http 通信的四个方法 delete get post pull 都干嘛的 get和delete的区别</p>
</li>
<li><p>实现$.ready()</p>
</li>
<li><p>几种模块加载工具的对比 amd cmd规范</p>
</li>
<li><p>构建工具用过哪些</p>
</li>
<li><p>你做过技术选型吗 聊聊</p>
</li>
<li><p>ajax原理，状态码，阶段值（需要能够当场手写原生XMLHttpRequest 实现get post）</p>
</li>
<li><p>写过node吗 回调金字塔 你如何理解的 如何应对（想考promise 聊聊promise的理念和api 异常处理方法）</p>
</li>
<li><p>setTimeout 和setInterval 可靠吗<br>如果回答可靠 考官会给你写一段代码 问你执行情况<br>如果回答不可靠 考官会问你 为毛不可靠</p>
</li>
<li><p>聊聊css定位 （如果你想加分 可以说fixed情况下的坑）</p>
</li>
<li><p>移动端开发经验 写过视觉差效果咩 怎么写的</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/posts/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="十大经典排序算法总结（JavaScript描述）"><a href="#十大经典排序算法总结（JavaScript描述）" class="headerlink" title="十大经典排序算法总结（JavaScript描述）"></a>十大经典排序算法总结（JavaScript描述）</h2><p><a href="https://juejin.im/post/57dcd394a22b9d00610c5ec8">链接</a></p>
<p><a href="http://www.cnblogs.com/zichi/p/5556633.html">冒泡排序 &amp; 选择排序 &amp; 插入排序 &amp; 希尔排序 JavaScript 实现</a></p>
<h2 id="递归，while遍历树结构"><a href="#递归，while遍历树结构" class="headerlink" title="递归，while遍历树结构"></a>递归，while遍历树结构</h2><h2 id="8个苹果一个坏的，外形与其他相同，只有重量不同有个天平，用2次把坏的找出来，怎么称"><a href="#8个苹果一个坏的，外形与其他相同，只有重量不同有个天平，用2次把坏的找出来，怎么称" class="headerlink" title="8个苹果一个坏的，外形与其他相同，只有重量不同有个天平，用2次把坏的找出来，怎么称"></a>8个苹果一个坏的，外形与其他相同，只有重量不同有个天平，用2次把坏的找出来，怎么称</h2><a id="more"></a>

<p>答案： (3,3)+ (1,1)两次</p>
<p>首先我们来确定一件事,就是坏的苹果应该是比其他的要轻.<br>第一步,把苹果分为3+3+1+1;<br>第二步,称重;</p>
<ol>
<li>3+3 放到天平两端,如果平等   再放1+1,也就是两边各放一个,倾斜,向上端,最后放的是坏的.</li>
<li>3+3 放到天平两端,如果倾斜, 取向上端3个苹果,分为1+1+1,两边一边一个随便放,如果平衡,没放的一个是坏的,如果倾斜,向上的是坏的.<br>没有其他情况了,两次就可以称出.</li>
</ol>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>平均情况：T(n) = O(n^2) 复杂度<br>时间复杂度：平均时间复杂度O(n<em>n) 、最好情况O(n)、最差情况O(n</em>n)<br>空间复杂度： O(1)<br>稳定性：稳定<br>关键：<br>两次循环</p>
<pre><code>i=0,i&lt;len;  j=0, j&lt;len-1-i  j 和j+1置换

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的len-1-i, 如果写len-1也是可以的，但是会有多余的内层循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>最佳情况：T(n) = O(n²)<br>最差情况：T(n) = O(n²)<br>平均情况：T(n) = O(n²)</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(selectionSort(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">&#x27;插入排序耗时：&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> key = array[i];</span><br><span class="line">            <span class="keyword">var</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">                array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + <span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;插入排序耗时：&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;array is not an Array!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.快速排序（Quick Sort）</p>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p>(3)算法分析</p>
<p>最佳情况：T(n) = O(nlogn)</p>
<p>最差情况：T(n) = O(n2)</p>
<p>平均情况：T(n) = O(nlogn)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Javascript代码实现：</span><br><span class="line"><span class="comment">/*方法说明：快速排序</span></span><br><span class="line"><span class="comment">@param  array 待排序数组*/</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;1.快速排序耗时&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(array).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> left === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> right === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">var</span> x = array[right], i = left - <span class="number">1</span>, temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = left; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt;= x) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    temp = array[i];</span><br><span class="line">                    array[i] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            quickSort(array, left, i - <span class="number">1</span>);</span><br><span class="line">            quickSort(array, i + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;1.快速排序耗时&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;array is not an Array or left or right is not a number!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">var</span> quickSort2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;2.快速排序耗时&#x27;</span>);</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;2.快速排序耗时&#x27;</span>);</span><br><span class="line">　　<span class="keyword">return</span> quickSort2(left).concat([pivot], quickSort2(right));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line"><span class="built_in">console</span>.log(quickSort2(arr));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line"></span><br><span class="line">作者：Damonare</span><br><span class="line">链接：https:<span class="comment">//juejin.im/post/57dcd394a22b9d00610c5ec8</span></span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="讲的好的算法"><a href="#讲的好的算法" class="headerlink" title="讲的好的算法"></a>讲的好的算法</h2><p><a href="https://www.cnblogs.com/zichi/p/4788953.html">快速链接</a></p>
<h3 id="阮一峰快速排序"><a href="#阮一峰快速排序" class="headerlink" title="阮一峰快速排序"></a>阮一峰快速排序</h3><p><a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html">链接</a></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><a href="https://github.com/twinkle77/play-with-algorithm">js算法目录</a></p>
<h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><p>二叉树节点定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct BinaryTreeNode</span><br><span class="line">&#123;</span><br><span class="line">    int m_nValue;</span><br><span class="line">    BinaryTreeNode* m_pLeft;</span><br><span class="line">    BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>一个深度为k，节点个数为 2^k - 1 的二叉树为满二叉树（完全二叉树）</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>二叉树的性质一：在二叉树的第i层上至多有2^(i-1)个结点(i&gt;=1)</p>
<p>二叉树的性质二：深度为k的二叉树至多有2^k-1个结点(k&gt;=1)</p>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>lchild data  rchild</p>
<p>data为根节点， lchild为左子树，rchild为右子树</p>
<h4 id="二叉树的遍历有三种方式，如下"><a href="#二叉树的遍历有三种方式，如下" class="headerlink" title="二叉树的遍历有三种方式，如下"></a>二叉树的遍历有三种方式，如下</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）前序遍历（DLR），</span><br><span class="line">    首先访问根结点，然后遍历左子树，最后遍历右子树。</span><br><span class="line">    简记根-左-右。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）中序遍历（LDR），</span><br><span class="line">    首先遍历左子树，然后访问根结点，最后遍历右子树。</span><br><span class="line">    简记左-根-右。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）后序遍历（LRD），</span><br><span class="line">    首先遍历左子树，然后遍历右子树，最后访问根结点。</span><br><span class="line">    简记左-右-根。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(node.value);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归方式实现中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)&#123;</span><br><span class="line">        inOrder(node.left);<span class="comment">//先访问左子树</span></span><br><span class="line">        <span class="built_in">console</span>.log(node.value);</span><br><span class="line">        inOrder(node.right);<span class="comment">//最后访问右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)&#123;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        <span class="built_in">console</span>.log(node.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在一个已排序的数组seq中，使用二分查找 v (要查找的元素)，<br>假如这个数组的范围是[low…high]，我们要的v就在这个范围里。</p>
<p>查找的方法是拿low到high的正中间的值，我们假设是m，来跟v相比，如果m&gt;v，说明我们要查找的v在前数组seq的前半部，否则就在后半部。无论是在前半部还是后半部，将那部分再次折半查找，重复这个过程，知道查找到v值所在的地方。<br>实现二分查找可以用循环，也可以递归，先给出两种方式的伪代码。</p>
<p>Java版<br>使用循环实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> v, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (v == seq[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; seq[mid]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用递归实现</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> v, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (v == seq[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; seq[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> search2(seq, v, mid + <span class="number">1</span>, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> search2(seq, v, low, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JS 版本</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归算法</span></span><br><span class="line">    <span class="function">function <span class="title">binary_search</span><span class="params">(arr, key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> low = <span class="number">0</span>,</span><br><span class="line">            high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">var</span> mid = parseInt((high + low) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(key == arr[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span>  mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; arr[mid])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; arr[mid])&#123;</span><br><span class="line">                high = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">44</span>,<span class="number">86</span>];</span><br><span class="line">    <span class="keyword">var</span> result = binary_search(arr,<span class="number">10</span>);</span><br><span class="line">    alert(result); <span class="comment">// 9 返回目标元素的索引值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归算法</span></span><br><span class="line">    <span class="function">function <span class="title">binary_search</span><span class="params">(arr,low, high, key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> mid = parseInt((high + low) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> binary_search(arr, low, high, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">44</span>,<span class="number">86</span>];</span><br><span class="line">    <span class="keyword">var</span> result = binary_search(arr, <span class="number">0</span>, <span class="number">13</span>, <span class="number">10</span>);</span><br><span class="line">    alert(result); <span class="comment">// 9 返回目标元素的索引值  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>线上问题追查通用方法</title>
    <url>/posts/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E8%BF%BD%E6%9F%A5%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="处理原则"><a href="#处理原则" class="headerlink" title="处理原则"></a>处理原则</h1><ol>
<li><p>止损原则</p>
</li>
<li><p>及时通告</p>
</li>
</ol>
<h1 id="逻辑方法"><a href="#逻辑方法" class="headerlink" title="逻辑方法"></a>逻辑方法</h1><ul>
<li>分维度，判定影响面，缩小范围</li>
</ul>
<h1 id="有胆有识"><a href="#有胆有识" class="headerlink" title="有胆有识"></a>有胆有识</h1><ol>
<li><p>心态准备<br>迅速精准，–脚本功底，信心<br>大胆假设，–思路清晰开放，没有SOP<br>止损意识 —无损判断<br>质疑所有 —各个数据、结论(监控系统)有效性<br>有的放矢 —逻辑思维</p>
</li>
<li><p>知识准备<br>日志—各字段意义要非常熟悉<br>配置—尤其是调度相关的要了然于胸<br>细节—每次更细一点<br>命令—基本功(linux每个命令，每个参数)</p>
</li>
</ol>
<h1 id="知识积累-演进过程"><a href="#知识积累-演进过程" class="headerlink" title="知识积累 演进过程"></a>知识积累 演进过程</h1>]]></content>
      <tags>
        <tag>处理问题</tag>
        <tag>线上事故</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器掉坑记</title>
    <url>/posts/%E7%BC%96%E8%BE%91%E5%99%A8%E6%8E%89%E5%9D%91%E8%AE%B0/</url>
    <content><![CDATA[<p>最近项目经常遇到定制化开发上传视频的需求，现在一些通用的视频基本不满足需求。</p>
<p>这篇文字记录一下遇到的问题和学到的知识。</p>
<p>前端常见的编辑器一般都不支持上传视频</p>
<blockquote>
<p><a href="https://github.com/fex-team/ueditor">ueditor</a>除外,但现在还没看到ueEditor在React项目中使用。</p>
</blockquote>
<h1 id="插入视频解决方案："><a href="#插入视频解决方案：" class="headerlink" title="插入视频解决方案："></a>插入视频解决方案：</h1><p>在编辑器值中插入html的video标签<br>poster用于设置视频封面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="插入自定义内容"><a href="#插入自定义内容" class="headerlink" title="插入自定义内容"></a>插入自定义内容</h1><p>比如插入一段HTML</p>
<p>原理，先拼装好html，调用编辑器API将HTML插入。</p>
<p>本质是执行了<code>document.execCommand</code>(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand">MDN链接</a>)</p>
<p>其中的参数可以设置包括加粗(bold), 插入图片(insertImage)</p>
<p>自定义内容的话，<code>insertHTML</code>可以插入HTML。</p>
<p>之前还考虑过将一段html复制到剪切板，通过<code>paste</code>命令将自定义的一段HTML拷贝到编辑器中。</p>
<p><strong>关键问题</strong>，插入后，怎么作为整体处理，删除一起删除，按回车会(或不会)生成同一个相同的块.</p>
<p>考虑将插入的一段HTML最外层设置成contentEditable=false，可以使整段插入的HTML不能编辑。<br>但在回车或删除时，会遇到无法删除等问题。</p>
<blockquote>
<p>现在的编辑器机制都是通过修改div的contentEditable=true来实现插入HTML。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>网站搭建</title>
    <url>/posts/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="网站创建历程"><a href="#网站创建历程" class="headerlink" title="网站创建历程"></a>网站创建历程</h2><h2 id="1-买域名"><a href="#1-买域名" class="headerlink" title="1. 买域名"></a>1. 买域名</h2><pre><code>https://wanwang.aliyun.com/domain/searchresult/

先要起名字，找到合适的域名。
找好后直接付款支付就ok了。</code></pre>
<h3 id="1-1-实名制"><a href="#1-1-实名制" class="headerlink" title="1.1  实名制"></a>1.1  实名制</h3><pre><code>需要身份证照片。
直接拍照，上传，ok，等2个工作日。</code></pre>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p> <a href="https://cn.aliyun.com/easybuy?spm=5176.8142029.418687.2.QpC6Vr">购买地址</a></p>
<p>云服务器ECS（包年包月）<br>地域: 华北 1<br>可用区: 华北 1 可用区 B<br>I/O 优化实例: 非 I/O 优化实例<br>实例规格: 1 核 2GB<br>网络类型: 经典网络<br>带宽: 1Mbps（按固定带宽）<br>操作系统: CentOS 7.2 64位<br>系统盘: 40GB 普通云盘<br>密码: 已设置<br>实例名称: oriht</p>
<p>linux学习：<br><a href="http://wiki.jikexueyuan.com/project/linux-command/chap03.html">http://wiki.jikexueyuan.com/project/linux-command/chap03.html</a></p>
<p>登陆的操作：<br>ssh root@ip</p>
<p>三：连接数据库：mysql -uroot -proot //p</p>
<p>还有就是遇到死链接的问题需要</p>
<p>配置路由：‘URL_MODEL’=2;<br>或者配置为0 和3 这里需要仔细查看TP手册部署那里。</p>
<p>直接写路径就可以</p>
<p>3。chkconfig –level 35 vsftpd on4.yum -y install vsftpd;5 cd /home/wwwroot/default/6 chmod 777 /home/wwwroot/default/chmod 777 /home/wwwroot/default/ -R<br>这里要注意的是权限问题：你要把application目录权限-777例如：chmod 777 /home/wwwroot/default/ -Rchmod -R 777 /home/wwwroot/default/</p>
<p><a href="http://www.centoscn.com/image-text/install/2014/0514/2972.html">在centos上安装git</a></p>
<h2 id="备案流程"><a href="#备案流程" class="headerlink" title="备案流程"></a>备案流程</h2><p> 网站备案信息真实性核验单 [查看样例] 请打印3份，按照样例分别填写并全部邮寄</p>
<p> 申请邮寄幕布 您自行拍照后上传</p>
<h2 id="远程拷贝"><a href="#远程拷贝" class="headerlink" title="远程拷贝"></a>远程拷贝</h2><p>拷贝远程服务器的文件到本地:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r -P 端口号 用户名@IP地址:/usr/<span class="built_in">local</span>/tomcat_airc/webapps/  /tmp/kyj/</span><br></pre></td></tr></table></figure></code></pre>
<p>拷贝本地文件到远程服务器:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /tmp/kyj/sys.war 用户名@IP地址:/usr/<span class="built_in">local</span>/tomcat_airc/webapps/</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h2><p> php的默认端口是8080<br> nginx的默认端口改成80</p>
<h2 id="https配置"><a href="#https配置" class="headerlink" title="https配置"></a>https配置</h2><p> 在阿里云买好证书，</p>
<ol>
<li><p>在nginx安装目录下新建cert目录<br>cd /usr/local/nginx<br>mkdir cert</p>
</li>
<li><p>将证书下载下来，复制到cert目录下<br> scp -r 本地文件目录 root@(ip):/usr/local/nginx/cert/<br> 这里有123.pem 和123.key,两个都要传到远程服务器</p>
</li>
<li><p>配置后不生效</p>
</li>
<li><p>curl -l <a href="http://oriht.com/">http://oriht.com</a></p>
</li>
<li><p>wget <a href="http://oriht.com/">http://oriht.com</a></p>
</li>
<li><p>需要进入阿里云服务器的实例里，找到安全组规则，配置443访问权限。才能访问https的端口</p>
</li>
<li><p>nginx no input file specified 查看nginx error.log, 发现是nginx之前的配置找不到路径之类的问题，先将所有的其他配置注释掉，mv **.conf **.conf.bak</p>
</li>
<li><p>又报502 Bad Gateway 说是nginx-fpm的占用内存太多，默认进程数太少</p>
</li>
</ol>
<p>1、查看php fastcgi的进程数（max_children值）</p>
<p><code>netstat -anop | grep php-cgi | wc -l</code><br>1、查看php fastcgi的进程数（max_children值）</p>
<p><code>netstat -anop | grep php-cgi | wc -l</code></p>
<p>3、调整/usr/local/php/etc/php-fpm.conf 的相关设置</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm.max_children &#x3D; 5</span><br><span class="line">request_terminate_timeout &#x3D; 60</span><br></pre></td></tr></table></figure></code></pre>
<p>部分PHP程序的执行时间超过了Nginx的等待时间，可以适当增加nginx.conf配置文件中FastCGI的timeout时间，例如：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">fastcgi_connect_timeout 300;</span><br><span class="line">fastcgi_send_timeout 300;</span><br><span class="line">fastcgi_read_timeout 300;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>羽毛球速成</title>
    <url>/posts/%E7%BE%BD%E6%AF%9B%E7%90%83%E9%80%9F%E6%88%90/</url>
    <content><![CDATA[<p>握球拍的手势</p>
<p>时刻保持主动出击状态， 不要打完一个球后，就定住不动站着看，等球再过来就没有时间启动身体反应了</p>
<p>网前挑球时对手是轻打过来的，要使劲打到后场</p>
<p>如果对手轻挑过来，你再轻挑，球的弹力不够很难过网</p>
<p>后场球挥拍扣杀姿势要好好练</p>
<p>练好扣球才能得分赢球</p>
<p>打球姿势要录视频看是否正确，可能自己觉得正确，实际是错的。</p>
<p><strong>握拍手势和挥拍姿势是基础！！！</strong></p>
<p>要有刚有柔, 才能对球控制自如。</p>
]]></content>
  </entry>
  <entry>
    <title>自动格式化-md,js,css,html等</title>
    <url>/posts/%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96-md-js-css-html%E7%AD%89/</url>
    <content><![CDATA[<h2 id="自动格式化md文档"><a href="#自动格式化md文档" class="headerlink" title="自动格式化md文档"></a>自动格式化md文档</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">文档链接</a></p>
<p>用VSCode编辑器安装<code>markdownlint</code>扩展</p>
<p>保存时自动格式化需要在settings.json中配置</p>
<blockquote>
<p>打开setting.json方法<br>按command+p,输入settings.json</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">    &quot;source.fixAll.markdownlint&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即可生效</p>
<a id="more"></a>

<h2 id="js文件自动格式化"><a href="#js文件自动格式化" class="headerlink" title="js文件自动格式化"></a>js文件自动格式化</h2><p>尝试了用<code>Prettier</code>, 发现配置项没有直接用<code>ESLint</code>多，改用<code>ESLint</code></p>
<h3 id="ESLint趟坑"><a href="#ESLint趟坑" class="headerlink" title="ESLint趟坑"></a>ESLint趟坑</h3><ul>
<li><a href="https://eslint.org/">官方文档</a></li>
<li><a href="https://cn.eslint.org/">中文文档</a></li>
</ul>
<blockquote>
<p>习惯用VSCode扩展的用户，默认会先在扩展市场直接搜索插件，然后再settings.json中修改配置项来使插件生效。<br>这样的思维惯性导致了ESLint插件的初始化工作直接被忽略掉，一直不生效。</p>
</blockquote>
<ol>
<li><p>首先需要要按照ESLint的文档来初始化</p>
<p> <a href="https://cn.eslint.org/docs/user-guide/getting-started">对应文档指南</a></p>
<p> 先决条件：Node.js (&gt;=6.14), npm version 3+。</p>
<p> 你可以使用 npm 安装 ESLint：</p>
<p> 在项目根目录运行</p>
<p> <code>npm install eslint --save-dev</code></p>
<p> 紧接着你应该设置一个配置文件：</p>
<p> <code>./node_modules/.bin/eslint --init</code><br> 或<code>npx --init</code></p>
<p> 这个命令执行完后会自动生成<code>eslintrc.js</code>文件</p>
<p> 之后，你可以在任何文件或目录上运行ESLint如下：</p>
<p> <code>./node_modules/.bin/eslint yourfile.js</code></p>
<p> 以上初始化工作就完成了。</p>
</li>
<li><p>接下来开始自动格式化的各种配置</p>
<p> 在VSCode中如下配置(<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">配置说明</a>)</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;eslint.autoFixOnSave&quot;: true,</span><br><span class="line">&quot;eslint.alwaysShowStatus&quot;: true,</span><br><span class="line">&quot;eslint.run&quot;: &quot;onSave&quot;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置自己的代码风格</p>
</li>
</ol>
<p><a href="https://cn.eslint.org/docs/rules/">规则列表</a></p>
<p>因为公司有自己的代码格式校验，所以这里的配置是和公司代码风格一致的，不同的配置可以按照规则自己配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@file</span>: file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: believeZJP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">&#x27;env&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;browser&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;commonjs&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;es6&#x27;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;extends&#x27;</span>: <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;globals&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Component&#x27;</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;swan&#x27;</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Page&#x27;</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;getApp&#x27;</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Atomics&#x27;</span>: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;SharedArrayBuffer&#x27;</span>: <span class="string">&#x27;readonly&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;parserOptions&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ecmaVersion&#x27;</span>: <span class="number">2018</span>,</span><br><span class="line">        <span class="string">&#x27;sourceType&#x27;</span>: <span class="string">&#x27;module&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;rules&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;semi&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">        <span class="comment">// 操作符在行首</span></span><br><span class="line">        <span class="string">&#x27;operator-linebreak&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;before&#x27;</span>],</span><br><span class="line">        <span class="comment">// 删除最后一个逗号</span></span><br><span class="line">        <span class="string">&#x27;comma-dangle&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">        <span class="comment">// 对象两边加空格</span></span><br><span class="line">        <span class="string">&#x27;object-curly-spacing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">        <span class="comment">// 数组类型左右不加空格</span></span><br><span class="line">        <span class="string">&#x27;array-bracket-spacing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">        <span class="comment">// 计算属性类型加空格，同上</span></span><br><span class="line">        <span class="string">&#x27;computed-property-spacing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">        <span class="comment">// 操作符加空格</span></span><br><span class="line">        <span class="string">&#x27;space-infix-ops&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="string">&#x27;int32Hint&#x27;</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        <span class="comment">// 删除多余空格和空行</span></span><br><span class="line">        <span class="string">&#x27;no-multi-spaces&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        <span class="comment">// 禁止行尾空格</span></span><br><span class="line">        <span class="string">&#x27;no-trailing-spaces&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        <span class="comment">// 方法参数是单个是不加括号</span></span><br><span class="line">        <span class="string">&#x27;arrow-parens&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;as-needed&#x27;</span>],</span><br><span class="line">        <span class="comment">// console警告</span></span><br><span class="line">        <span class="string">&#x27;no-console&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="attr">allow</span>: [<span class="string">&#x27;warn&#x27;</span>] &#125;],</span><br><span class="line">        <span class="comment">// 要求使用 === 和 !== (eqeqeq)</span></span><br><span class="line">        <span class="string">&#x27;eqeqeq&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">        <span class="comment">// 函数圆括号之前有一个空格</span></span><br><span class="line">        <span class="string">&#x27;space-before-function-paren&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;never&#x27;</span>],</span><br><span class="line">        <span class="comment">// 大括号之前有空格</span></span><br><span class="line">        <span class="string">&#x27;block-spacing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">        <span class="comment">// 语句块之前的空格</span></span><br><span class="line">        <span class="string">&#x27;space-before-blocks&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">        <span class="comment">// 对象字面量的键和值之间使用一致的空格</span></span><br><span class="line">        <span class="string">&#x27;key-spacing&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="string">&#x27;afterColon&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;beforeColon&#x27;</span>: <span class="literal">false</span> &#125;],</span><br><span class="line">        <span class="comment">// 使用骆驼拼写法</span></span><br><span class="line">        <span class="string">&#x27;camelcase&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="attr">allow</span>: [<span class="string">&#x27;Component&#x27;</span>] &#125;],</span><br><span class="line">        <span class="comment">// 文件末尾保留一行空行</span></span><br><span class="line">        <span class="string">&#x27;eol-last&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;always&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;no-multiple-empty-lines&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="string">&#x27;max&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;maxEOF&#x27;</span>: <span class="number">1</span> &#125;],</span><br><span class="line">        <span class="comment">// 单引号</span></span><br><span class="line">        <span class="string">&#x27;quotes&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;single&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明:<br>globals: 是为了忽略一些全局变量没有定义的报错<br>rules: 是对应的详细规则，有些规则查不到的可以先查询报错信息再找对应的配置会容易点，官网的规则解释不是很清楚</p>
<p>如上配置，即可自动格式化大部分代码错误</p>
<p>但语法错误什么的需要手动解决</p>
<p>看到有的人用<a href="https://github.com/typicode/husky#readme">husky</a>+<a href="https://github.com/okonet/lint-staged#readme">lint-staged</a></p>
<p>但这个是在提交代码之前校验，因为这里已经在onSave时格式化了，所以没必要加这步.(当然，加了可以强制校验提交的代码)</p>
<p>新项目可以尝试，旧项目因为历史遗留代码就没必要了。</p>
<p>发布为npm包</p>
<p>在项目的eslintrc.js中引用<br><code>extends: lint-4bd</code></p>
<h2 id="自动加文件头部注释"><a href="#自动加文件头部注释" class="headerlink" title="自动加文件头部注释"></a>自动加文件头部注释</h2><p>公司要求js文件必须加文件头，所以这里用插件解决</p>
<p>插件名: <a href="https://github.com/OBKoro1/koro1FileHeader">koro1FileHeader</a></p>
<p>在VSCode扩展市场搜索直接安装<br><strong>要注意，搜索名字是<code>koroFileHeader</code>没有1</strong><br>配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;fileheader.customMade&quot;: &#123;</span><br><span class="line">        &quot;file&quot;: &quot;file&quot;,</span><br><span class="line">        &quot;author&quot;: &quot;believeZJP&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;fileheader.configObj&quot;: &#123;</span><br><span class="line">        &quot;autoAdd&quot;: false,</span><br><span class="line">        &quot;language&quot;: &#123;</span><br><span class="line">        &quot;js&quot;: &#123;</span><br><span class="line">            &quot;head&quot;: &quot;/**&quot;,</span><br><span class="line">            &quot;middle&quot;: &quot; * @&quot;,</span><br><span class="line">            &quot;end&quot;: &quot; */&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>配置自定义时发现对全局修改不生效，必须指定语言进行修改，如上的<code>js</code>。</p>
<p><code>autoAdd</code>设成<code>false</code>比较好，这个插件不能自动识别文件里是否已经存在注释，会添加多个</p>
<p>需要注意的是，每次修改settings.json后要重启VSCode</p>
]]></content>
  </entry>
  <entry>
    <title>自己实现EventBus</title>
    <url>/posts/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0EventBus/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>行业术语</title>
    <url>/posts/%E8%A1%8C%E4%B8%9A%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="软件行业术语"><a href="#软件行业术语" class="headerlink" title="软件行业术语"></a>软件行业术语</h2><ul>
<li><p>软件开发中遇到的所有问题都可以通过增加一层抽象而得以解决。</p>
</li>
<li><p>过早的优化并不是一件好事。</p>
</li>
<li><p>代码开发中, 难点有时不是实现的思路， 而是细节的处理</p>
</li>
<li><p>常数变易法<br>  小步走，及时反馈<br>  人类的思考习惯是从具体到抽象<br>  可以从某个具体的情况入手，把所有变化的要素都固定下来</p>
<p>  从最简单的情况入手，再逐步扩展到复杂情况<br>  抛开变化</p>
<pre><code>  变化会干扰我们的思路，先把变的东西固定死，写出应对死数据的处理过程</code></pre>
<p>  找规律  从对死数据的处理过程中找规律，有时可以通过适当变换使得规律一致<br>  代换 把常量代换为变量，并保持程序执行的结果</p>
</li>
<li><p>会多语言的好处，可以根据不同的场景和要求来决定使用哪种语言实现某些功能。</p>
</li>
</ul>
<p>读书千遍其义自见</p>
<p>简化知识点–读书读目录</p>
<p>多读书， 看不懂也要看完，知识是递归结构</p>
]]></content>
  </entry>
  <entry>
    <title>计算机小知识</title>
    <url>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="零宽字体"><a href="#零宽字体" class="headerlink" title="零宽字体"></a>零宽字体</h2><p><a href="http://www.fileformat.info/info/unicode/category/Mn/list.htm">列表</a></p>
<p>找到空的字符</p>
<p>找到空字符的编码, 如<code>U+034F</code></p>
<p>将<code>U+</code>换成<code>\u</code></p>
<p>在浏览器控制台执行 <code>copy(&#39;\u034F&#39;)</code></p>
<p>即可粘贴到聊天输入框</p>
<h2 id="火狐最新版"><a href="#火狐最新版" class="headerlink" title="火狐最新版"></a>火狐最新版</h2><p>完整安装包：<a href="http://download.firefox.com.cn/releases/full/zh-CN/Firefox-full-latest.exe">http://download.firefox.com.cn/releases/full/zh-CN/Firefox-full-latest.exe</a></p>
]]></content>
  </entry>
  <entry>
    <title>调试经验</title>
    <url>/posts/%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="微信里访问页面出错，浏览器访问没错"><a href="#微信里访问页面出错，浏览器访问没错" class="headerlink" title="微信里访问页面出错，浏览器访问没错"></a>微信里访问页面出错，浏览器访问没错</h2><p>在微信开发者工具中打开该链接，可以模拟微信访问链接</p>
<h2 id="手机访问本地服务"><a href="#手机访问本地服务" class="headerlink" title="手机访问本地服务"></a>手机访问本地服务</h2><p>设置 手机–无线局域网–选择链接的wifi–配置DNS–改为手动，添加本地机器的IP。</p>
<p>用手机访问本机IP加服务地址即可访问本地服务.</p>
<h2 id="在页面中加调试工具"><a href="#在页面中加调试工具" class="headerlink" title="在页面中加调试工具"></a>在页面中加调试工具</h2><p><a href="https://github.com/Tencent/vConsole">vConsole 一个轻量、可拓展、针对手机网页的前端开发者调试面板。</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vConsole/3.2.0/vconsole.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// init vConsole</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>出错要看异常错误码, 302 Not Found 为请求链接未找到。会导致异常</p>
]]></content>
  </entry>
  <entry>
    <title>跑步训练及经验</title>
    <url>/posts/%E8%B7%91%E6%AD%A5%E8%AE%AD%E7%BB%83%E5%8F%8A%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="跑步姿势"><a href="#跑步姿势" class="headerlink" title="跑步姿势"></a>跑步姿势</h2><p>身体微微前倾，双臂尽可能贴近身体，前后摆动</p>
<p>身体直立，重心稍向前，保持身体稳定</p>
<h2 id="摆臂技术"><a href="#摆臂技术" class="headerlink" title="摆臂技术"></a>摆臂技术</h2><ul>
<li>前不漏肘后不漏手 ， 短跑可以大幅度，长跑小幅度</li>
<li>大臂小臂呈90度或小于90度</li>
<li>不能耸肩</li>
<li>不要左右摆臂</li>
</ul>
<h2 id="三个基础练习"><a href="#三个基础练习" class="headerlink" title="三个基础练习"></a>三个基础练习</h2><p>降低受伤几率，保证安全健康跑步</p>
<h2 id="练习一，-提踵"><a href="#练习一，-提踵" class="headerlink" title="练习一， 提踵"></a>练习一， 提踵</h2><p>提高小腿肌肉力量及跟腱强度</p>
<p>抬脚后跟，尽可能提到最高幅度，双腿加紧</p>
<p>鞋子前面的线呈一字型</p>
<p>注意事项：</p>
<ol>
<li>动作标准性</li>
<li>速度一定要慢，足下支撑力量不足会导致腱鞘炎</li>
</ol>
<p>一定要做正确，不然不如不做</p>
<h2 id="练习二、弓步上下起"><a href="#练习二、弓步上下起" class="headerlink" title="练习二、弓步上下起"></a>练习二、弓步上下起</h2><p>加强膝盖力量和大腿股四头肌力量，避免跑步时的膝盖伤害</p>
<p>弓步上下运动，身体直立，小腿几乎不动，靠大腿上下浮动，速度要慢，</p>
<p>每次动态做完做一次静力，感觉腿很酸胀才有效果</p>
<h2 id="练习三、髋部练习三部曲"><a href="#练习三、髋部练习三部曲" class="headerlink" title="练习三、髋部练习三部曲"></a>练习三、髋部练习三部曲</h2><p>增加腰部力量。髋部没有力量，只能用大腿拖着跑，会造成腿粗。</p>
<p>正起正踢，身体直立</p>
<p>往前踢，身体不要后仰，中间不可以落地，</p>
<p>身体不要歪，中间腿不要落地</p>
<p>前，侧，后</p>
<p><strong>三个练习两个月后，跑步会非常轻松~~~~~</strong></p>
<h2 id="参赛"><a href="#参赛" class="headerlink" title="参赛"></a>参赛</h2><p>跑步训练一年以上，每周训练量超过半马30公里，全马60公里</p>
<p>具备2到3次，35到38公里</p>
<p>训练计划</p>
<h2 id="比赛注意事项"><a href="#比赛注意事项" class="headerlink" title="比赛注意事项"></a>比赛注意事项</h2><ul>
<li>频繁抽筋</li>
<li>突然觉得很累，直接坐到路边</li>
<li>冲刺之后立即休息</li>
</ul>
<h2 id="摆腿动作"><a href="#摆腿动作" class="headerlink" title="摆腿动作"></a>摆腿动作</h2><p>后收前摆连贯</p>
<p>步幅慢小快大</p>
<p>前摆到位，膝盖上提</p>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><p>送髋–？？？</p>
]]></content>
      <tags>
        <tag>运动</tag>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/posts/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表节点定义-Node</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.el = el;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表-LinkedList</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function"><span class="title">insert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从链表的头节点开始遍历</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>(currentNode &amp;&amp; currentNode.el !== item) &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">el, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el);</span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(item);</span><br><span class="line">    <span class="comment">// 将当前节点的next给了新节点的next</span></span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除节点</p>
<p>删除当前节点要找到当前节点的上一个节点。<br>将上一个节点的next指向下一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPre</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>(node.next !== <span class="literal">null</span> &amp;&amp; node.next.el !== item) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> preNode = <span class="built_in">this</span>.findPre(item);</span><br><span class="line">    <span class="keyword">if</span> (preNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指向下一个元素，这行代码很关键</span></span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义单个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.el = el;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于查找</span></span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (node !== <span class="literal">null</span> &amp;&amp; node.el !== item) &#123;</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">findPrev</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (node.next !== <span class="literal">null</span> &amp;&amp; node.next.el !== item) &#123;</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">el, item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el);</span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(item);</span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prevNode = <span class="built_in">this</span>.findPrev(item);</span><br><span class="line">    <span class="keyword">if</span> (prevNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 指向下一个元素，这行代码很关键</span></span><br><span class="line">      prevNode.next = prevNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>定义节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>() </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.el = el;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找同单向链表</p>
<p>插入节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">el, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el);</span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(item);</span><br><span class="line">    <span class="comment">// 先将新节点的指针指向对应位置</span></span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    newNode.prev = currentNode;</span><br><span class="line">    <span class="comment">// 将当前节点的next指针指向新节点</span></span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">    <span class="comment">// 当前节点的next节点的prev指针指向新节点</span></span><br><span class="line">    currentNode.next.prev = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="built_in">this</span>.find(item);</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">    node.prev = <span class="literal">null</span>;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>项目使用standard规范并用eslint自动格式化代码</title>
    <url>/posts/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8standard%E8%A7%84%E8%8C%83%E5%B9%B6%E7%94%A8eslint%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在vscode插件中安装<code>standard</code>插件</p>
<p>先禁用，再在工作区启用，即可只在当前工作区生效</p>
<p>在项目中安装<code>standard</code>和<code>eslint</code><br><code>npm i eslint standard -D</code></p>
<p>在命令行执行<code>eslint --init</code>初始化生成<code>.eslintrc.js</code>文件</p>
<p>生成过程中根据自己需求选择即可</p>
<p>在vsCode配置中(setting.json)增加如下配置, 即可自动格式化</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;standard.run&quot;: &quot;onSave&quot;,</span><br><span class="line">&quot;standard.autoFixOnSave&quot;: true,</span><br><span class="line">&quot;javascript.validate.enable&quot;: false</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>驾照学习</title>
    <url>/posts/%E9%A9%BE%E7%85%A7%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ol>
<li>优选海淀驾校</li>
</ol>
<ul>
<li>好处：练车不缺场地</li>
<li>考试通过率高</li>
<li>考前有一次免费的集训</li>
</ul>
<p>经验：</p>
<pre><code>1. 不要完美心态：
只要能倒进库不压线，
不出库就行，方向正不正无所谓

2. 离合一定要时刻压好，手刹没拉好，
档位不在空挡，刹车没踩紧
，都不能松离合！！！！
3. 车速一定要慢
4. 千万不能熄火
，一熄火就完了
5. 一挡，二灯，三喇叭，四看镜，
五离合，六手刹。
6. 松手刹诀窍： 松之前，往上拉一点，按下按钮
，下压到底，如果按不动按钮，
就往上拉一点，就可以了。
7. 偶尔挂不上倒挡： 不要太快
，靠到最右侧，使劲往后侧压，
8. 到点后打方向盘一定要快。</code></pre>
<p>科二：<br>上车三要素：</p>
<pre><code>1. 调座位，要领：能将离合器踩到底。
双手伸出，手腕正好超过方向盘。
2. 调后视镜 要领：门把手上的小黑点正好在镜子上沿。
车身占镜子的1/3

左侧后视镜要能看到后车轮，右侧的看不到。
3. 系安全带！！！</code></pre>
<p>倒车入库：</p>
<pre><code>1. 入库标准。左侧后视镜的下沿稍微
超过库口的白线即可停车。
2. 出库 车头到7米线时立刻打方向盘。
3. 进库前准备：
    1. 身体与库线平行，右打一圈
    2. 左后视镜进入库区
    ，左后视镜最外沿进入白线，左打两圈
    3. 待车身与库平行，回正（右打一圈）</code></pre>
<p>右倒库口诀：</p>
<pre><code>1. 向右1圈半，  开车到7米线，    
2. 向左一圈半   到右侧的白线--超过后视镜一指宽的距离
3. 向右一圈半   后视镜底部与右侧白线重合
4. 向左一圈   右侧库直角距车身30公分（白线宽10公分，大约是两倍白线宽时立马    打方向盘）
5. 向右一圈     右侧库角从后视镜消失
6. 向左两圈     车身回正
7. 停车         左侧后视镜稍微超过白线一点</code></pre>
<p>左倒库口诀：</p>
<pre><code>1. 向左一圈半   开车到7米线
2. 向右一圈半   到左侧的白线超过后视镜一指宽的距离
3. 向左一圈半   后视镜底部与右侧白线重合
4. 向右一圈     左侧直角距车身30公分（这里的30公分和左侧的不同，角刚出来点    就立刻左回一圈）
5. 向左一圈     左侧库角从左侧后视镜消失
6. 向右两圈     车身回正
7. 停车         左侧后视镜稍微超过白线一点</code></pre>
<p>直角转弯口诀：</p>
<pre><code>1.进入直角前，方向盘，
车座和路中间的直角转弯提示线成一条直线，
2. 待方向盘与直角转弯的线平行时，
左打死，一圈半，
3. 车身与路平行时，回正。</code></pre>
<p>曲线行驶口诀：</p>
<pre><code>1.保证车始终在路中间，这个没有固定的口诀，
需要根据不同的曲线具体确定什么时候动方向盘
，无论如何确保车身不出弯道</code></pre>
<p>侧方停车口诀：</p>
<pre><code>1. 方向盘与路中的直行箭头在一条直线，打右灯（！！！），
2. 车头刚好过白线时，停车，
3. 倒车，右侧后视镜的虚线消失时，立刻右打死，（右一圈半）
4. 左侧 里边的库角刚出现时，回正（左一圈半）
5. 左侧 后车轮触碰到，注意不是压到库口虚线，左打死（左一圈半）这是关键点，打晚了会导致进太多！！
6. 车身与库平行，停车，不回正！！！
7. 打左灯（！！！），挂一档
8. 左车角与白线重合，回正(右一圈半)
9. 车头在白线中间，右一圈，（这个与8步时间间隔很短）
10. 车身与白线平行，左一圈回正。</code></pre>
<p>坡道定点起步口诀：</p>
<pre><code>1. 进入坡道，方向盘，与指示箭头在一条线上，打右灯（！！！）
2. 上坡前松开离合，快到白线区，压离合，放慢车速
3. 左侧后视镜下沿与黄线重合，踩死刹车，停车。
4. 拉手刹（！！！），松开刹车，打左灯（！！！），不用动档（！！！）
5. 踩油门，松离合，看车头抬起，保持油门和离合位置不动（！！！）
6. 松开手刹，微抬离合，（可以不抬，保持不动），如果起步缓慢的话，轰油门，    待到坡顶后，松油门，微踩刹车</code></pre>
]]></content>
  </entry>
  <entry>
    <title>面试积累</title>
    <url>/posts/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h2 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h2><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>OS、数据结构与算法、网络这几块内容是必须要掌握的基础的，这些基础不扎实，天花板势必不高。</p>
<p>基础不好虽然也同样能干活，但是天花板不高会导致你的技术成长会随着年龄增长变得越来越低，最后结果也基本是停留于二三线公司。</p>
<p>大部分人问基础知识点还是能够说出来的，但是仅限于知道。对于如何将多个知识点串联起来或者知识点的更深层次的问题就很少有人能够答好。</p>
<p>建议学好计算机基础</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>学习框架前，我觉得你应该先打好基础，而不是好高骛远的先使用框架。再者，几大热门的框架底层的思想都是一致的，并没有哪个好哪个差之分。</p>
<p>学习一件事物，熟练使用它是基本，在熟练使用以后，应该转而去学习他底层的原理机制，<strong>甚至自己去实现一个类似的东西</strong>。<br>当你这样去做的时候，永远不需要担心自己是否会淘汰，因为你已经领先所有只会用 API 的人了，这部分绝对是最多的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>想在面试中获得好的结果的人来说，都应该做到以下几点：</p>
<ul>
<li>夯实自己的基础，基础决定了大楼的高度</li>
<li>有深入挖掘知识的思想，对于每个知识点都应该考虑一下这玩意怎么实现的，为什么要有这玩意</li>
<li>不要做框架 API 的熟练工，尽量去了解框架底层的原理机制</li>
</ul>
<h2 id="4、面试是一种输出"><a href="#4、面试是一种输出" class="headerlink" title="4、面试是一种输出"></a>4、面试是一种输出</h2><p>学习是一种输入，但面试是一种输出。</p>
<p>面试需要的不是你懂，而是要让面试官知道你懂，你必须有能力将考点中的要点联系起来，连贯的说出来，这并不是看过一次就能达到的。但不少人以为看过这类文章，知道这个点，就可以了。事实上，只是“知道”远远不够。</p>
<p>这种问题，根本上，是对技术点的不够深入，不够熟悉，没有形成自己的理解。我也经历过这一过程，你知道这些概念，自己也能分清，但难以向别人讲明白。简单测试一个CSS问题：什么是BFC？ 你肯定知道叫块级格式化上下文，问题是，怎么向面试官解释这个东西？</p>
<p><strong>为了解决这个问题，首先，学习过程注重理解而不是记忆。</strong></p>
<p>第二，一个知识点，需要通过多篇文章学习，重复学习，加深理解，总结出自己的答案和看法。</p>
<p>第三，刻意练习。如果你有伙伴，可以相互提问。如果没有，也可以自问自答。</p>
<h2 id="5、注重表达逻辑"><a href="#5、注重表达逻辑" class="headerlink" title="5、注重表达逻辑"></a>5、注重表达逻辑</h2><p>如果上一点是说能正确回答问题，这点则是能更好的回答问题。一个逻辑清晰的回答，能让面试官感受到，面试者不仅熟悉这个问题，还有比较优秀的语言能力和逻辑能力。</p>
<p>比如，常见问题：说说 <code>var, let/const</code> 的区别。大部分人都能罗列出它们的区别和注意点，但这很难给面试官留下什么印象。但是，如果你添加几句联系性的语句，效果就不一样了：</p>
<blockquote>
<p><code>var</code>是 <code>ES5</code> 之前的变量声明方式，存在很多容易产生误解的缺陷，具体体现在：……（罗列 <code>var</code> 的一些不足）, 针对这些问题，ES6 提出了 <code>let/const</code> 的变量声明方式，它们具有一些新的特性：……（罗列 <code>let/const</code> 特性）。</p>
</blockquote>
<p>这几句简单的连接，让整个回答从一个简单的要点堆砌变成关系密切的表达。</p>
<p>然而，这并非易事。前提是必须要有较好的逻辑思维。</p>
<p>在学习每一个技术点的时候，都要注意一些问题：是什么？为了解决什么问题？如何实现的，有没有更深的原理？如何使用？使用的时候需要注意什么？有哪些应用的场景？有什么不足？这些不足能否避免？ 这些问题能让你更加全面地体会各个问题的联系。</p>
<p>需要指出一点，写博客对这方面有很大的帮助。</p>
<p>即使你没有写过博客，建议在备考的时候，使用思维导图等工具，并且经常整理已学知识的联系。</p>
<p>可能有人跟我一样面试会紧张，一紧张就容易脑子空白。我的方法是，把面试官假想成是来请教我问题的同学，不得不说这种效果真的很好。</p>
<h2 id="6、扬长避短，但尽量争取"><a href="#6、扬长避短，但尽量争取" class="headerlink" title="6、扬长避短，但尽量争取"></a>6、扬长避短，但尽量争取</h2><p>对于那些每个应聘者必备的技能，必须要熟悉再熟悉，不要让基础成为自己的短板。而对于其它技能，深入学习其中的几个，然后想办法引导面试官提问这些方面的问题。</p>
<p>最有效最常见的引导方式是简历。简历信息往往是面试官出题的依据，所以简历一定不要写自己没接触过的技术，即使招聘信息有这项要求，如果面试官提问简历上的内容，发现你根本不会，那么，你简历上的所有技能点，面试官都会打个问号。对于你有深入学习的方面，可以单点列出，比如，熟悉 JavaScript，能熟练操作 DOM，尽管 JavaScript 包含了 DOM，但你依然可以强调一下。<br>面试官往往会根据应聘者的回答来决定下一个问题，我们也可以利用这点，在面试回答中引导。在回答开放性问题时，这种方法十分有效，但切记点到为止，不要过分深入导致偏题。比如，面试官提问：对一个已有的网站，你哪些的性能优化方案？ 当你阐述性能改进提议之后，末了，加一句“除了性能，一个网站考虑还可以从安全性和 SEO 这些方面进行优化”。 如果面试官 Web 安全和 SEO 感兴趣，那他就中套了。</p>
<p>如果面试官抛出了一个你稍有了解但不熟悉的问题。不要慌，先思考片刻。整合自己知道的，做一些合理的推测。然后在回答的时候，先表明自己不是很熟悉，但在学习其他知识的时候有接触过，简单说说自己的了解和推断。不少面试官会故意提出一些稍微超出面试者能力的问题，考量面试者的临场能力和迁移学习能力。</p>
<p>万一，明确面试官问题后，发现自己丝毫不会，直接表明，把面试官的注意力转移到下一道题，停留的时候长了，可能会放大这道题的影响。从容应对接下来的题目，面试官不会因为一两道题淘汰一个各方面都很优秀的面试者。</p>
]]></content>
      <tags>
        <tag>日常积累</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 知识点</title>
    <url>/posts/CSS-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>参考链接</p>
<ul>
<li><a href="http://caibaojian.com/70-expert-ideas-for-better-css-coding.html">写好CSS代码的70个专业建议</a></li>
</ul>
<h2 id="项目统一样式"><a href="#项目统一样式" class="headerlink" title="项目统一样式"></a>项目统一样式</h2><p>为了解决浏览器默认样式不统一的问题。</p>
<p>一般有两个库</p>
<ul>
<li><a href="http://necolas.github.io/normalize.css/">Normalize.css</a></li>
<li><a href="https://meyerweb.com/eric/tools/css/reset/">Reset CSS</a></li>
</ul>
<p>还可以根据自己需求定制初始化样式.</p>
<p>好处：</p>
<ul>
<li><strong>保护有用的浏览器默认样式</strong>而不是完全去掉它们</li>
<li><strong>一般化的样式</strong>：为大部分HTML元素提供</li>
<li><strong>修复浏览器自身的bug</strong>并保证各浏览器的一致性</li>
<li><strong>优化CSS可用性</strong>：用一些小技巧</li>
<li><strong>解释代码</strong>：用注释和详细的文档来</li>
</ul>
<a id="more"></a>

<p>用<code>overflow: auto</code> 必须给容器指定高度<code>height: 固定值</code></p>
<h2 id="页面首次加载动画展示"><a href="#页面首次加载动画展示" class="headerlink" title="页面首次加载动画展示"></a>页面首次加载动画展示</h2><ul>
<li><p><a href="https://github.com/matthieua/WOW">WOW中文文档</a></p>
</li>
<li><p>进入和离开屏幕时动画<a href="https://github.com/jlmakes/scrollreveal.js">scrollreveal</a></p>
</li>
<li><p><a href="https://daneden.github.io/animate.css/">Animate.css</a></p>
</li>
</ul>
<h2 id="常见布局方案整理"><a href="#常见布局方案整理" class="headerlink" title="常见布局方案整理"></a>常见布局方案整理</h2><ul>
<li><p><a href="https://segmentfault.com/a/1190000010989110">CSS布局方案</a></p>
</li>
<li><p><a href="https://juejin.im/entry/591dc015da2f60005d25e6b0">经典布局</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000012275086">使用 flex 实现 5 种常用布局</a></p>
</li>
<li><p><a href="http://caibaojian.com/flexbox-guide.html">flex布局详解</a></p>
</li>
<li><p><a href="http://www.admin10000.com/document/9351.html">css负margin运用</a></p>
</li>
</ul>
<h2 id="CSS3实现动画功能主要通过两个属性"><a href="#CSS3实现动画功能主要通过两个属性" class="headerlink" title="CSS3实现动画功能主要通过两个属性"></a>CSS3实现动画功能主要通过两个属性</h2><p>1.transition<br>2.animation</p>
<p>transition:&lt;过渡属性名称&gt; &lt;过渡时间&gt;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">color</span> 1<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">height</span> 3<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">color</span>;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure>

<p>多个属性的过渡效果<br><code>-webkit-transition:&lt;属性1&gt; &lt;时间1&gt;,&lt;属性2&gt; &lt;时间2&gt;,&lt;属性3&gt; &lt;时间3&gt;;</code></p>
<p>第三个属性值：<br>transition:&lt;过渡属性名称&gt; &lt;过渡时间&gt; &lt;过渡模式&gt;<br>transition-timing-function<br>值:  ease   缓慢开始，缓慢结束<br>    liner        匀速<br>    ease-in    缓慢开始<br>    ease-out    缓慢结束<br>    ease-in-out    缓慢开始，缓慢结束（和ease稍有区别）</p>
<h2 id="CSS3创建3D场景"><a href="#CSS3创建3D场景" class="headerlink" title="CSS3创建3D场景"></a>CSS3创建3D场景</h2><ol>
<li><p>属性介绍<br>perspective:800    平面距离三维中方框的距离<br>perspective-origin:50% 50%</p>
</li>
<li><p>transform属性<br> –translete :位移操作<br> translateX(X px)<br> translateY(Y px)<br> translateZ(Z px)</p>
<p> –rotate：旋转操作<br> rotateX(X deg)<br> rotateY(Y deg)<br> rotateZ(Z deg)</p>
</li>
<li><p>设置3D</p>
<p> transform-style:preserve-3d;</p>
</li>
</ol>
<h2 id="如何通过css使div-实现全屏效果"><a href="#如何通过css使div-实现全屏效果" class="headerlink" title="如何通过css使div 实现全屏效果"></a>如何通过css使div 实现全屏效果</h2><p>–全屏要素：<br>    1.全屏的元素及其父元素都要设置为height:100%,<br>    2.将html,body标签设置为height100%,<br>注：height:100%是跟随其父元素高度变化而变化的</p>
<h2 id="css中-link-和-import-区别"><a href="#css中-link-和-import-区别" class="headerlink" title="css中 link 和 @import 区别"></a>css中 link 和 @import 区别</h2><p>@import 指令 会阻止浏览并行下载。<br>link 加载外部样式表不会阻止并行下载。</p>
<h2 id="px-em-rem的区别"><a href="#px-em-rem的区别" class="headerlink" title="px,em,rem的区别"></a>px,em,rem的区别</h2><ul>
<li>PX特点</li>
</ul>
<ol>
<li>IE无法调整那些使用px作为单位的字体大小;</li>
<li>国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位;</li>
<li>Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。<br>px像素(Pixel)。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册)<br>em是相对长度单位。<br>相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)<br>任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</li>
</ol>
<ul>
<li>EM特点</li>
</ul>
<ol>
<li><p>em的值并不是固定的;</p>
</li>
<li><p>em会继承父级元素的字体大小。<br>所以我们在写CSS的时候，需要注意两点：</p>
<ol>
<li>body选择器中声明Font-size=62.5%;</li>
<li>将你的原来的px数值除以10，然后换上em作为单位;</li>
<li>重新计算那些被放大的字体的em数值。避免字体大小的重复声明。<br>也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。</li>
</ol>
</li>
</ol>
<ul>
<li>rem特点<br>rem是CSS3新增的一个相对单位(root em，根em)，这个单位引起了广泛关注。这个单位与em有什么区别呢?区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。<br>一个例子：<br>p {font-size:14px; font-size:.875rem;}</li>
</ul>
<h2 id="CSS3-动画性能问题"><a href="#CSS3-动画性能问题" class="headerlink" title="CSS3 动画性能问题"></a>CSS3 动画性能问题</h2><p><a href="https://www.cnblogs.com/shytong/p/5419565.html">https://www.cnblogs.com/shytong/p/5419565.html</a><br>a、是否导致layout<br>如果是，尽可能将动画元素absolute或者fixed化以避免影响文档树，以减少重排.<br>b、是否启用硬件加速<br>“用到了CSS3动画”和“开启了硬件加速”是两件事情，虽然前者有可能导致后者。<br>开启硬件加速在webkit中有神奇的万金油：opacity: 1;或者-webkit-backface-visibility: hidden;。<br>c、是否是有高消耗的属性（css shadow、gradients、background-attachment: fixed等）<br>有的话，图片也是一种选择。这算得上是用空间换时间的优化了。<br>d、repaint的面积<br>如果是，只好缩小动画面积了。这一步的优化有限;<br>e、尽量使用 transform 生成动画，避免使用 height,width,margin,padding 等；<br>transform 动画由GPU控制，支持硬件加速，并不需要软件方面的渲染<br>为动画DOM元素添加 CSS3 样式<br> -webkit-transform:transition3d(0,0,0) 或 -webkit-transform:translateZ(0); ，<br>这两个属性都会开启 GPU硬件加速 模式，从而让浏览器在渲染动画时从CPU转向GPU，</p>
<h2 id="字体加粗用哪个"><a href="#字体加粗用哪个" class="headerlink" title="字体加粗用哪个"></a>字体加粗用哪个</h2><p><code>&lt;b&gt;&lt;/b&gt;</code>标签的加粗只是为了加粗<br><code>&lt;strong&gt;&lt;/strong&gt;</code>标签加粗是为了突出重点<br>在网页中使用<code>&lt;strong&gt;&lt;/strong&gt;</code>突出的内容更容易被网页搜索蜘蛛搜索到。<br>盲人朋友使用阅读设备阅读网络时：<code>&lt;strong&gt;</code>会重读，<code>&lt;b&gt;</code>不会</p>
<h2 id="CSS优先级算法如何计算"><a href="#CSS优先级算法如何计算" class="headerlink" title="CSS优先级算法如何计算"></a>CSS优先级算法如何计算</h2><ul>
<li>元素选择符： 1</li>
<li>class选择符： 10</li>
<li>id选择符：100</li>
<li>元素标签：1000</li>
<li>!important声明的样式优先级最高，如果冲突再进行计算。</li>
</ul>
<p>如果优先级相同，则选择最后出现的样式。<br>继承得到的样式的优先级最低。</p>
<h2 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h2><p>用来控制元素的盒子模型的解析模式，默认为content-box<br>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽<br>border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽<br>inherit:   应从父元素继承 box-sizing 属性的值</p>
<h2 id="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的"><a href="#介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的" class="headerlink" title="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的"></a>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的</h2><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin<br>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</p>
<h2 id="nth-child与nth-of-type区别"><a href="#nth-child与nth-of-type区别" class="headerlink" title="nth-child与nth-of-type区别"></a>nth-child与nth-of-type区别</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.product-list</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(2n)</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.product-list</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(2n+1)</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.product-list</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type(2n)</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.product-list</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type(2n+1)</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，<strong>不论元素的类型</strong>。<br>:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素.</p>
</blockquote>
<h2 id="justify-content设置居左"><a href="#justify-content设置居左" class="headerlink" title="justify-content设置居左"></a>justify-content设置居左</h2><p>CSS语法:<br><code>justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit;</code></p>
<p>默认值为flex-start, 如果要居左可以设置这个值，</p>
<blockquote>
<p>注意：设置left不生效，因为没有left这个值。</p>
</blockquote>
<h2 id="css换行"><a href="#css换行" class="headerlink" title="css换行"></a>css换行</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">word-break</span>: <span class="selector-tag">break-all</span>;</span><br><span class="line"><span class="selector-tag">word-break</span>: <span class="selector-tag">break-word</span>;</span><br></pre></td></tr></table></figure>

<h2 id="max-width-和-important"><a href="#max-width-和-important" class="headerlink" title="max-width 和 !important"></a>max-width 和 !important</h2><p>max-width在比width小时，即使width使用!important来加权，仍会max-width生效；</p>
<p>以下代码宽度为300px</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:480px!important; max-width: 300px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:480px!important; transform: scale(0.625, 1);&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>overflow 基本属性：<br>    visible （默认）<br>    hidden  超出的部分被隐藏<br>    scroll  两边都会出现<br>    auto  智能路线<br>    inherit(IE8+才支持)</p>
<p>兼容性：<br>    1.燕环肥瘦，各有春秋<br>    2.宽度设定机制<br>ie7中莫名出现滚动条，可能是设置了100%，做法是删除width:100%;  </p>
<p>作用的前提<br>1.非display:inline 水平~     display不能设置为inline<br>2.对应方位的尺寸限制。width/height/max-width/max-height/absolute拉伸<br>3.对于单元格td等，还需要设置table为table-layout:fixed;</p>
<p>overflow:visible妙用<br>    ie7下文字越多，按钮两侧padding留白就越大<br>给所有按钮添加css样式   overflow:visible</p>
<p>滚动条出现的条件<br>    1.overflow:auto,overflow:scroll   —自带html，textarea<br>    2.草窝藏不住凤凰，潜水困不住蛟龙    内容过多</p>
<p>body/html 与滚动条</p>
<p>无论什么浏览器，默认滚动条均来自<code>&lt;html&gt;</code>，而不是<code>&lt;body&gt;</code></p>
<p>ie7- html{overflow-y:scroll;}<br>ie8+  html{overflow:auto;}</p>
<p>想要去掉页面默认的滚动条<br>        html {overflow:hidden;}<br>html,body{overflow:hidden;} ——×</p>
<p>js与滚动高度<br>    chrome document.body.scrollTop<br>    其他：document.documentElement.scrollTop<br>标准写法：<br>    var st = document.body.scrollTop || document.documentElement.scrollTop;</p>
<p>overflow的padding-bottom缺失现象<br>    导致不一样的scrollHeight (元素内容高度)<br>滚动条的宽度机制<br>    滚动条会占用容器的可用高度或高度  宽度均为17px</p>
<p>1.怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。<br>2.IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。例如：<br>HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt; span&gt;div class=&quot;myDiv&quot;&lt;div&lt;</span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<p>.myDiv{<br>    width:100px;<br>    height:100px;<br>    border:1px solid #000;<br>    float:left;<br>    margin-left:30px;<br>}</p>
<p>IE6预览结果：<br>很明显的，在IE6中，margin-left:30px的边距翻倍成60px了。<br>解决问题：<br>设置display:inline：</p>
<p>.myDiv{<br>    width:100px;<br>    height:100px;<br>    border:1px solid #000;<br>    float:left;<br>    display:inline;<br>    margin-left:30px;<br>}</p>
<p>IE6预览结果：<br>3.上下margin重合：margin是个有点特殊的样式，相邻的margin-left和margin-right是不会重合的，但相邻的margin-top和margin-bottom会产生重合。不管IE还是Firefox都存在这问题。例如：<br>HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt; span&gt;div class=&quot;topDiv&quot;&lt;div&lt;</span><br><span class="line">&lt; span&gt;div class=&quot;bottomDiv&quot;&lt;div&lt;</span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<p>.topDiv{<br>    width:100px;<br>    height:100px;<br>    border:1px solid #000;<br>    margin-bottom:25px;<br>}<br>.bottomDiv{<br>    width:100px;<br>    height:100px;<br>    border:1px solid #000;<br>    margin-top:50px;<br>}</p>
<p>我们对上面的div设置了25px的下边距，对下方的div设置了50px的上边距。为了便于观察，这里将div的高度都设为100px。<br>浏览器预览结果：<br>可见，结果不是预期的上下div拉开75px的距离，而是拉开了半个div高度(50px)的距离。<br>解决问题：<br>统一使用margin-top或者margin-bottom，不要混合使用。这并不是技术上的必需，但却是个良好的习惯。<br>4.超链接访问后hover样式不出现：有时候我们同时设置了a:visited和a:hover样式，但一旦超链接访问后，hover的样式就不再出现，这是怎么回事呢？是因为将样式顺序放错了，调整为先a:visited再a:hover。关于a标签的四种状态的排序问题，有个简单好记的原则，叫做love hate原则，即i(link)ov(visited)e h(hover)a(active)e。<br>5.IE6、IE7的hasLayout问题：很多时候，CSS在IE下的解析十分奇怪，明明在Firefox中显示得非常正确，但到了IE下却出现了问题，有的时候，这些问题甚至表现得非常诡异。<br>例如一个比较经典的Bug就是设置border的时候，有时候border会断开，刷新页面或者拖下滚动条的时候，断掉的部分又会连接起来。<br>再比如在IE6&amp;IE7中对元素设置浮动后，其后的元素并未占据这部分空间，造成了IE6&amp;IE7中浮动元素未脱离文档流的假象。也就是说，实际上IE6&amp;IE7浮动元素也脱离了文档流，只是由于其后元素的hasLayout被自动触发而导致的。这里说的hasLayout被触发，即指元素的hasLayout属性为true。<br>下列元素默认hasLayout=”true”：<br>下列 CSS 属性和取值将会自动让一个元素的hasLayout=”true”：<br>position: absolute<br>绝对定位元素的包含区块(containing block)就会经常在这一方面出问题。<br>float: left|right<br>由于 layout 元素的特性，浮动模型会有很多怪异的表现。<br>display: inline-block<br>当一个内联级别的元素需要 layout 的时候往往就要用到它，这也可能也是这个 CSS 属性的唯一效果–让某个元素拥有 layout。”inline-block行为”在IE中是可以实现的，但是需要注意的是： IE/Win: inline-block and hasLayout 。<br>width: 除 “auto” 外的任意值<br>很多人遇到 layout 相关问题发生时，一般都会先尝试用这个来修复。<br>height: 除 “auto” 外的任意值<br>height: 1% 就在 Holly Hack 中用到。<br>zoom: 除 “normal” 外的任意值<br>IE专有属性。不过 zoom: 1 可以临时用做调试。<br>writing-mode: tb-rl<br>MS专有属性。<br>overflow: hidden|scroll|auto<br>在 IE7 中，overflow 也变成了一个 layout 触发器，这个属性在之前版本 IE 中没有触发 layout 的功能。<br>overflow-x|-y: hidden|scroll|auto<br>overflow-x 和 overflow-y 是 CSS3 盒模型中的属性，尚未得到浏览器的广泛支持。他们在之前版本IE中没有触发 layout 的功能。<br>另外 IE7 的荧幕上又新添了几个 haslayout 的演员，如果只从 hasLayout 这个方面考虑，min/max 和 width/height 的表现类似，position 的 fixed 和 absolute 也是一模一样。<br>position: fixed<br>min-width: 任意值<br>就算设为0也可以让该元素获得 layout。<br>max-width: 除 “none” 之外的任意值<br>min-height: 任意值。即使设为0也可以让该元素的 haslayout=true<br>max-height: 除 “none” 之外的任意值<br>如果BUG是由于hasLayout未触发所引起的，则可采用手动触发hasLayout来解决：办法是使用一个生僻的CSS属性zoom来触发，引用样式.zoom{zoom:1}。<br>如果BUG是hasLayout被自动触发而引起的，则要看触发是什么引起的，若这元素本身就会自动触发hasLayout，可以考虑换一个元素。若是对于这元素设置的某个CSS属性引起的，则可以考虑删除这属性，倘若这属性又是必要的，则就需要自己根据具体情况去编写CSS Hack，因为hasLayout是只读的，一旦hasLayout=”true”后，便不可逆转。<br>6.行内元素上下margin及padding不拉开元素间距的问题：行内元素的margin和padding属性很奇怪，水平方向的padding-left、padding-right、margin-left、margin-right都产生边距效果，但竖直方向的padding-top、padding-bottom、margin-top、margin-bottom却不会产生边距效果。例如：<br>HTML：</p>
<p>CSS:<br>div{background:gray;padding:20px;}<br>span{background:green;padding:20px;margin:20px;}<br>各浏览器预览结果：<br>可见竖直方向的padding、margin虽然增大了行内元素的面积，但并没有和相邻元素拉开距离，导致了元素重叠。<br>解决问题：<br>将行内元素display设置为block即可解决<br>修改后CSS：<br>span{background:green;padding:20px;margin:20px;display:block;}<br>各浏览器预览结果：<br>但由于块级元素与行内元素的默认样式不同，可能会因此书写额外的样式代码。比如width样式，因为块级元素默认占据整行。<br>7.IE6下select元素显示问题：浏览器解析页面时，会先判断元素的类型，如果是窗口类型的，会优先于非窗口类型的元素，显示在页面最顶端，如果同属于非窗口类型的，才会去判断z-index的大小。select元素在IE6下是以窗口形式显示的，这是IE6的一个Bug。导致的情况是往往想要弹出一个层，结果select元素出现在层上方。例如：<br>HTML：</p>
<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#CCDCEE</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IE6预览结果：<br>解决问题：<br>我们可以用一个和弹出层同样大小的iframe放在层下面，select上面，用iframe遮住select。比如设置弹出层的样式z-index:2，iframe的样式z-index:1，使iframe位于层下方。<br>修改后HTML：</p>
<p>修改后CSS：</p>
<p>div{<br>    position:absolute;<br>    background:#CCDCEE;<br>    top:0px;<br>    left:0px;<br>    width:300px;<br>    height:300px;<br>    border:1px solid #000;<br>    margin:5px;<br>    z-index:2;<br>}<br>iframe{<br>    position:absolute;<br>    top:0px;<br>    left:0px;<br>    width:300px;<br>    height:300px;<br>    margin:5px;<br>    z-index:1;<br>}</p>
<p>我们让iframe位于div下方，大小以及与浏览器的距离调整成与div一致。<br>IE6预览结果：<br>8.IE6对png的透明度支持问题：png格式因为其优秀的压缩算法和对透明度的完美支持，成为Web中最流行的图片格式之一。但它存在一个众所周知的头疼问题—IE6下对png的透明度支持并不好。本该是透明的地方，在IE6下会显示为浅蓝色。可以使用IE下私有的滤镜功能来解决问题，格式如下：filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=’png图片路径’,sizingMethod=’crop’)。<br>9.ul的不同表现：ul列表也是在IE与Firefox中容易发生问题的对象，主要源自浏览器对ul对象的默认值设置。在IE与Firefox中，一部分对象有默认的属性（比如h1~h6），他们本身就带有大字号、加粗样式以及一些边距效果。ul也是如此，默认情况下ul是有边距的。例如：<br>HTML：</p>
<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">layout</span>&#123;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>ul{list-style:none;}<br>代码非常简单，仅去除了ul的列表圆点。看下在IE和Firefox的预览效果：<br>IE预览结果：<br>Firefox预览结果：<br>显示都很正常，关键在于我们对ul接下来的设置：<br>修改后的CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">layout</span>&#123;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置ul左外边距为0后。<br>IE预览结果：</p>
<p>Firefox预览结果：</p>
<p>预览后发现问题出现了。IE中的ul已与div靠齐，而Firefox中的ul却丝毫不动。这是为什么？不妨把样式修改下再看看。<br>修改后的CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#layout</span>&#123;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">    <span class="attribute">padding-left</span>:<span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们把margin-left换成padding-left。再来看看预览结果。<br>IE预览结果：</p>
<p>Firefox预览结果：</p>
<p>可见效果正好相反，Firefox中实现了靠齐，而IE中丝毫未动。<br>通过以上例子我们发现：在IE中，ul的默认边距是margin，在Firefox中，ul的默认边距是padding。我们单独定义margin或padding时，自然不能在两个浏览器达到一致效果。这就是ul在不同浏览器下表现不同的问题所在。<br>解决问题：<br>可以用hack方法分别针对IE和Firefox单独写样式，但更好的做法是样式开头先统一ul边距，ul{padding:0px;margin:0px;}。<br>10.IE3px问题：3px问题不是经常被人发现，因为它的影响只产生3px的位移。如果是精确到像素级的设计，3px的影响可谓不小。先来看下例子：<br>HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左浮动div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mydiv&quot;</span>&gt;</span>段落div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mydiv</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#f66</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">130px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="left是引发Bug的一个浮动div，同时设置了边框便于观察"><a href="#left是引发Bug的一个浮动div，同时设置了边框便于观察" class="headerlink" title="left是引发Bug的一个浮动div，同时设置了边框便于观察"></a>left是引发Bug的一个浮动div，同时设置了边框便于观察</h2><p>IE预览结果：</p>
<p>Firefox预览结果：</p>
<p>从理论上讲，我们还没有设置#mydiv的padding，它们理所当然是紧贴边框的。但在IE中，“段落”文字并未紧紧贴住#left。在实际中可能会因此导致内部元素宽度超出外部div固定宽度而引发布局问题。<br>解决问题：<br>是把#mydiv设置为display:inline-block。<br>修改后CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mydiv</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#f66</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">130px</span>;</span><br><span class="line">    +display:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用hack方法为IE单独设置display:inline-block后。<br>IE各版本预览结果：</p>
<p>结果与Firefox一致。<br>11.高度不适应问题：高度不适应指的是，当内层对象的高度发生变化时，外层对象的高度不能自动扩展，特别是当内层对象使用padding或margin之后。高度不适应问题不是IE的专利，Firefox也出现这种问题。先来看看例子：<br>HTML：<br>CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看代码做了什么，除了背景之外，#box仅是一个没有任何样式的div，而p加了2个关键属性margin-top:20px，margin-bottom:20px;，即上下外边距都是20px，p对象的高度应当是20+20+文字高度，即应当在40px以上。理论上#box这个div的高度会被挤开，至少达到40px以上。我们看看预览效果。<br>浏览器预览结果：</p>
<p>似乎并非预想的结果，看上去带背景的#box还是和文字一样高，并没有超过40px，这是为什么呢？为了验证一些事情，我们在html前后加上一个带背景的div。<br>修改后的HTML：<br>修改后的CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看下预览结果：<br>浏览器预览结果：</p>
<p>可以看到上下两个div并没有紧贴#box对象，而是有一定的间距。测量下会发现，这个间距刚好是p对象的margin上下各20px。这个测验证明了一个问题，就是#box对象并没有因其中的p对象的margin变化而改变自身的高度。而p对象的margin高度的确在整个页面中占据了一定的空间。相当于#box不动，而p把自己撑到了#box外面去了。<br>无论是IE还是Firefox，测试中都会发现这个问题。<br>解决问题：<br>经过一些测试，我们发现对#box定义padding或者border，就会迫使#box重新计算自己的高度，从而使自身能够适应内容的高度变化。但如果强制给对象设置了边距又会带来位移。我们需要找到一个新方法，不再从对象本身的属性入手，而是在对象的内部进行修复。我们可以在对象上下增加2个高度为0的空div，并强制内容不显示。<br>修改后的HTML：</p>
<p>这2个div只充当了占位符的角色，而不发生实际的占位。而对它的外层对象而言，由于其中多了一些逻辑占位对象使得它会重新计算高度，从而实现高度的自适应。<br>预览效果：</p>
<p>12.IE6断头台问题：断头台问题是国外的CSS设计者给这个问题起的一个非常形象的名字，与之相反的，被切断的不是对象的头部，而是对象的底部。先来看下例子：<br>HTML：</p>
<p>XHTML代码有三部分组成，一个是主对象#layout，主框架中有#left为左浮动对象，右侧为普通的4个链接，类似于左右分栏的布局。<br>CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">layout</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>:<span class="number">5px</span> solid <span class="number">#35BB0C</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#F2F2F2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">left</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>:<span class="number">5px</span> solid <span class="number">#D4CA25</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在CSS代码部分，主要设置了链接的背景色，#left的左浮动，以便于我们观察的粗边框效果。先通过浏览器看看问题是如何发生的，见下图：<br>IE6预览效果：</p>
<p>这里列出了IE6网页效果的2个状态，当网页被打开时，页面正常显示，与CSS编码指定样式一致。当鼠标右侧的“链接4”时，问题出现了，主对象#layout下面被切掉了，而剩下的高度正好是4个链接的高度。而当鼠标移到“链接1”或“链接2”时，#layout对象的高度又恢复正常。这便是IE6断头台问题。<br>这个问题的主要原因在于链接上，去除链接的a:hover{background-color:#fff}样式后，一切正常。经测试发现，不仅仅是background-color的变化，如果改变hover状态下链接的其他属性，也会引发同样的问题。例如设置padding、border、加粗、斜体等，都会引发断头台问题。<br>值得注意的是，在#layout中，#left是个浮动对象，而右测是若干链接对象。对于未指定高度的对象而言，IE6会根据其中的内容（不管浮动与否）来计算高度的大小，而当例子中的链接对象是个非浮动对象，并具有hover改变border,background及padding属性时，IE6会认为这些属性同时会改变#layout的高度，因此它重新计算对象高度。而令人失望的是，IE6的这种自以为是的行为并没有达到预期目的，它会把非浮动对象的总高度作为高度给了#layout，从而切断了#left的内容。基于这类问题的产生原因，解决方案可以有多种。<br>解决问题：<br>根据问题产生的原因，我们可以做出多套解决方案。我们知道因为非浮动对象与浮动对象都在#layout中，所以我们可以从浮动方式入手，把非浮动对象改为浮动对象，这样便可以解决问题。例如对XHTML修改如下：</p>
<p>对链接加上个div，并设置浮动#right{float:left}。这样使得两个对象都成为浮动对象，不会引发问题。<br>也可以在#layout底部增加一个div来强制IE浏览器重新计算高度<br>，这个清除浮动内容的div会帮助浏览器重新找到合适的高度，从而解决断头台问题。<br>13.容器不扩展问题：容器不扩展问题是我们经常遇到的。比如我们创建了一个div嵌套结构:<br>HTML：</p>
<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">divGroup</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">a</span>,<span class="selector-id">#b</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> solid <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IE预览结果：</p>
<p>Firefox预览结果：</p>
<p>可见外层的高度并没有随着子容器的高度自动扩展，却是形成了一条线。这是因为当子容器成为浮动元素后，并脱离了文档流。因此父容器认为自己内容为空，从而造成了这样的结果。<br>解决问题：<br>解决方案是在容器的末尾加入个清理浮动的div。<br>修改后的HTML：</p>
<p>如果还想防止这个元素占据父元素的高度，可以进一步优化成</p>
<p>，这样这个清除浮动的容器被认为是个不占任何高度的空格字符。在网页中的任何地方，当遇到容器不扩展时，只需加入此段便能修复问题。<br>14.IE8和FireFox父子元素上下margin叠加问题：<br>先看下效果：<br>&lt; span&gt;div class=”gray”&lt;<br>&lt; span&gt;div class=”blue”&lt;div&lt;&lt; span&gt;div class=”black”&lt;div&lt;div&lt;</p>
<p>.gray{    background:gray;    width:200px;    margin:20px;}.blue{    background:blue;    width:100px;    height:100px;    margin:20px;}.black{    background:black;    width:100px;    height:100px;    margin:20px;}</p>
<p>上图中，蓝色div和黑色div是灰色div的子元素，三个div的margin都是20，但是我们看到蓝色div与其父元素的上边界并没有20px的间隙，黑色div与其父元素的下边界也没有20px的间隙，也就是说蓝色div的上外边距与其父元素的上外边距叠加在了一起，就好像是蓝色div的上外边距跑出去了一样。黑色div也是同理。这就是父元素与子元素的边距叠加效果，叠加后的取值取的是两者中较大的那个。经测试，只要父元素有border或padding，就不会触发这个问题。然而刻意给父元素设置border或padding又会带来位移。可采用如下方法来根本解决问题：<br>解决问题：给父元素设置overflow:hidden;即可解决。<br>再来预览下：<br>IE8：</p>
<p>解决了。<br>FireFox：</p>
<p>也解决了。<br>15.IE6高度不固定问题：<br>典型BUG1：IE6下，即使给父元素设了固定高度，子元素还是会将其撑开。<br>典型BUG2：如果一个元素没有子元素，而这个元素设置的length又小于div默认高度，则这个元素在IE6里显示的高度仍然是div的默认高度。<br>引发以上2个BUG的原因在于length属性在IE6里被当作min-length（最小高度）解析了，（换句话说，你压根在IE6中就没设置过固定高度，因为你设置的是最小高度）<br>解决办法是再给父元素设置overflow:hidden;<br>16.IE6设置了最小高度并撑满父元素高度：<br>默认情况下如果对IE6设置了最小高度200px，那么如果实际内容有250px，则只会显示250px的高度。也就是高度会跟随着内容显示。如果此时希望无论里面内容有多少，都让其填充满父元素高度，则要这么设置：<br>height:auto!important;<br>height:200px;<br>min-height:200px;<br>17.IE6、IE7下浮动元素未脱离文档流假象的问题：<br>对元素设置浮动后，在IE6&amp;IE7下预览，会产生元素未脱离文档流的假象的现象。其实元素脱离文档流了，这问题其实是其后的元素引起的。由于其后的元素因某些原因造成hasLayout被触发而导致的它未去占据浮动元素的空间（这问题说起来话长，你就这么理解好了：这个大概追朔到表格布局的年代，由于单元格都是有hasLayout的，而后面单元格里的元素肯定不会跑前面的单元格里去的）。关于hasLayout，在第5条里有详细说明，这里单独提出来作为一条来说明，仅因为这个浮动未脱离文档流假象的问题比较典型。<br>18.全屏遮罩后居中显示一个对话层：<br>下面是遮罩层：绝对定位，宽高都100%，并且半透明</p>
<p>.over{    position:absolute;    width:100%;    height:100%;    top:0px;    left:0px;    background-color:#7E9898;    filter:alpha(opacity=50);    -moz-opacity:0.5;    -khtml-opacity:0.5;    opacity:0.5;}</p>
<p>下面是对话层：也是绝对定位：</p>
<p>.confirm{    position:absolute;    width:400px;     height:300px;      background:#FFFFFF;    top:300px;    left:0px;}</p>
<p>这里的提示层不要嵌套在遮罩层里面，否则也会受影响，变成半透明的了。要让提示层跟遮罩层并列。<br>这里还有2个问题：<br>1.单单对遮罩层使用height:100%，只有IE6会达到效果，而其他浏览器一旦只会是当前可见区域遮上了，如果拖动纵向滚动条，发现下方还有没遮盖上。<br>2.用户电脑分辨率不同，而绝对定位的提示层使用margin:300px auto也无效。<br>为了达到各浏览器网页可见区域全部遮盖的效果，这里用了下jquery脚本，解决以上2个问题：<br>$(document).ready(function(){     $(“div[class=’cover’]”).height($(document).height());//将可见区域都遮罩起来      $(“div[class=’confirm’]”).css(“left”,($(document).width()-($(“div[class=’confirm’]”).width()))/2+”px”);//提示层居中});<br>最佳实践：<br>1.写DTD声明：<br><code>&lt;!DOCTYPE html&gt;</code><br>2.引入base.css重置各浏览器默认属性值：</p>
<p>html,body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td{margin:0px;padding:0px;}table{border-collapse:collapse;border-spacing:0px;}fieldset,img,abbr,acronym{border:0px;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}ol,ul{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:’’;}</p>
<p>3.同时为一个元素写float和margin-left（margin-right）的时候，习惯性地想到IE6会双倍边距，用display:inline解决。<br>4.为子元素写margin-top或margin-bottom的时候，习惯性的去思考父元素是否有padding或border属性，从而断定是否会在IE6&amp;IE7上产生上下外边距重合问题。如果有问题用overflow:hidden;解决。<br>5.给元素设了固定高度后，习惯性地再设个overflow:hidden;从而避免IE6上高度继续扩展的问题。<br>6.必要时候要clear，<br>。<br>7.对于文本，在使用margin-left、padding-left、margin-top、padding-top之前优先考虑是否可用text-indent和line-height代替。因为计算尺寸的代价相对来说要大些。<br>如能做到以上几点，就已经避免了90%的浏览器兼容性问题。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>前端</tag>
        <tag>理论知识</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新语法积累</title>
    <url>/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="es6强制让一个函数有一个默认值"><a href="#es6强制让一个函数有一个默认值" class="headerlink" title="es6强制让一个函数有一个默认值"></a>es6强制让一个函数有一个默认值</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;cuowu&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p><a href="http://liubin.org/promises-book/">Promise迷你书</a></p>
<a id="more"></a>

<h1 id="js中Map和Set区别"><a href="#js中Map和Set区别" class="headerlink" title="js中Map和Set区别"></a>js中Map和Set区别</h1><p>Set 对象类似于数组，且成员的值都是唯一的</p>
<p>Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是对象</p>
<p>set中存储无序并且不可重复的元素。<br>map存储的是键值对。key=&gt;VALUE</p>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<p>Map：键值对集合，对应于 Object，ES6 中map的key 可以是对象<br>List：有序可重复的列表，对应于 Array<br>Set：无序且不可重复的列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> set.add(item))</span><br><span class="line"><span class="built_in">console</span>.log(set) <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br><span class="line"></span><br><span class="line">重复元素在<span class="built_in">Set</span>中自动被过滤：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br><span class="line">注意数字<span class="number">3</span>和字符串<span class="string">&#x27;3&#x27;</span>是不同的元素。</span><br><span class="line"></span><br><span class="line">通过add(key)方法可以添加元素到<span class="built_in">Set</span>中，可以重复添加，但不会有效果：</span><br><span class="line"></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组快速去重</span></span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;小缘&#x27;</span>, <span class="attr">age</span>: <span class="number">14</span> &#125;</span><br><span class="line"></span><br><span class="line">map.set(obj, <span class="string">&#x27;小缘喵&#x27;</span>)</span><br><span class="line">map.get(obj) <span class="comment">// 小缘喵</span></span><br><span class="line"></span><br><span class="line">map.has(obj) <span class="comment">// true</span></span><br><span class="line">map.delete(obj) <span class="comment">// true</span></span><br><span class="line">map.has(obj) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h1><p>使用${variable}插入变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fName &#x3D; &#39;Peter&#39;, sName &#x3D; &#39;Smith&#39;, age &#x3D; 43, job &#x3D; &#39;photographer&#39;;</span><br><span class="line">var a &#x3D; &#39;Hi, I\&#39;m &#39; + fName + &#39; &#39; + sName + &#39;, I\&#39;m &#39; + age + &#39; and work as a &#39; + job + &#39;.&#39;;</span><br><span class="line">var b &#x3D; &#96;Hi, I&#39;m $&#123; fName &#125; $&#123; sName &#125;, I&#39;m $&#123; age &#125; and work as a $&#123; job &#125;.&#96;;</span><br></pre></td></tr></table></figure>

<h1 id="块级作用域-let-const"><a href="#块级作用域-let-const" class="headerlink" title="块级作用域 let const"></a>块级作用域 let const</h1><p>JavaScript 本身一直是函数式作用域，这就是我们经常将整个 JavaScript 文件封装在一个空的立即调用函数表达式（IIFE）中的原因。这样做是为了隔离文件中的所有变量，因此全局中就不会存在变量名冲突。</p>
<p>ES5 中如果你想限制变量 tmp 的作用范围仅在某一块代码中有效，你不得不使用一个叫 IIFE(Immediately-Invoked Function Expression，立即执行函数表达式) 的模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// IIFE 开始</span></span><br><span class="line">    <span class="keyword">var</span> tmp = ···;</span><br><span class="line">    ···</span><br><span class="line">&#125;());  <span class="comment">// IIFE 结束</span></span><br><span class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="comment">// ECMAScript 6 中可以简单地使用块和 let 申明(或 const 申明)：</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 块起始</span></span><br><span class="line">    <span class="keyword">let</span> tmp = ···;</span><br><span class="line">    ···</span><br><span class="line">&#125;  <span class="comment">// 块结束</span></span><br><span class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let 声明的变量具有块级作用域，所以可以在不影响外部变量的情况下声明具有相同名称的新局部（内部）变量。<br>==同一个块级作用域不能申明同一个变量==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; &#39;car&#39; ;</span><br><span class="line">&#123;</span><br><span class="line">    let a &#x3D; 5;</span><br><span class="line">    console.log(a) &#x2F;&#x2F; 5</span><br><span class="line">    let a &#x3D; 6 &#x2F;&#x2F; Identifier &#39;a&#39; has already been declared</span><br><span class="line">&#125;</span><br><span class="line">console.log(a) &#x2F;&#x2F; car</span><br></pre></td></tr></table></figure>

<p>var和let之间的另一个区别是let不会像var一样被提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    console.log(a); &#x2F;&#x2F; undefined</span><br><span class="line">    console.log(b); &#x2F;&#x2F; ReferenceError</span><br><span class="line">    var a &#x3D; &#39;car&#39;;</span><br><span class="line">    let b &#x3D; 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典面试题  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i &#x3D; 1; i &lt; 5; i++) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123; console.log(i); &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p>JavaScript 中声明一个常量变量，那么惯例是将变量命名大写。然而，这并不能保证它是一个常量 - 它只是让其他开发人员知道这是一个常量，不应该改变。</p>
<p>==<strong>const 不会使变量不可变，只是锁定它的赋值。 如果你有一个复杂的赋值（对象或数组），那么该值仍然可以修改。</strong>==</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="string">&quot;tree&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);  <span class="comment">// tree</span></span><br><span class="line">    c = <span class="number">46</span>;  <span class="comment">// TypeError!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">const</span> dave = &#123; <span class="attr">name</span>: <span class="string">&#x27;David Jones&#x27;</span>, <span class="attr">age</span>: <span class="number">32</span>&#125;;</span><br><span class="line">    d.push(<span class="number">5</span>);</span><br><span class="line">    dave.job = <span class="string">&quot;salesman&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(d);  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">    <span class="built_in">console</span>.log(dave);  <span class="comment">// &#123; age: 32, job: &quot;salesman&quot;, name: &#x27;David Jones&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的方式给const赋值不报错，</span></span><br><span class="line"></span><br><span class="line">    直接给<span class="keyword">const</span>赋值，报错。</span><br><span class="line">    dave = &#123;<span class="attr">name</span>: <span class="string">&#x27;salesman&#x27;</span>&#125;   <span class="comment">//  Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="块级作用域函数问题"><a href="#块级作用域函数问题" class="headerlink" title="块级作用域函数问题"></a>块级作用域函数问题</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数声明现在被指定为必须绑定到块级作用域。</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    bar(); &#x2F;&#x2F; works</span><br><span class="line">    function bar() &#123; &#x2F;* do something *&#x2F; &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar();  &#x2F;&#x2F; doesn&#39;t work</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if ( something) &#123;</span><br><span class="line">    function baz() &#123; console.log(&#39;I passed&#39;) &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    function baz() &#123; console.log(&#39;I didn\&#39;t pass&#39;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">baz();</span><br><span class="line">在 ES6 之前，这两个函数声明都会被提升，\</span><br><span class="line">结果就是 ‘I didn\’t pass’，不管something 是什么东西。</span><br><span class="line"></span><br><span class="line">现在我们会得到 ‘ReferenceError’，因为baz()总是受到块范围的约束。</span><br></pre></td></tr></table></figure>

<p>建议：</p>
<ul>
<li>首选 const。所有不会改变值的变量都可以使用它。</li>
<li>其它的使用 let，用于值会被改变的变量。</li>
<li>避免使用 var。</li>
</ul>
<h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><p>…运算符，它被称为“扩展运算符”。</p>
<p>它有两个主要用途：将数组或对象分散到新的数组或对象中，并将多个参数合并到一个数组中。</p>
<p>… 运算符的另一个特点是它创建一个新的数组或对象。</p>
<p>将变量一起收集到一个数组中。 当你不知道有多少变量传递给函数时，这非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, ...a, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = &#123; <span class="attr">type</span>: <span class="string">&#x27;vehicle &#x27;</span>, <span class="attr">wheels</span>: <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fordGt = &#123; <span class="attr">make</span>: <span class="string">&#x27;Ford&#x27;</span>, ...car, <span class="attr">model</span>: <span class="string">&#x27;GT&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fordGt); <span class="comment">// &#123;make: &#x27;Ford&#x27;, model: &#x27;GT&#x27;, type: &#x27;vehicle&#x27;, wheels: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [ ...a ];</span><br><span class="line"><span class="keyword">let</span> c = a;</span><br><span class="line">b.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// [1, 2, 3, 4] referencing different arrays</span></span><br><span class="line">c.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// [1, 2, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// [1, 2, 3, 5] referencing the same array</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="string">&#x27;car&#x27;</span>, <span class="number">54</span>, <span class="string">&#x27;tree&#x27;</span>);  <span class="comment">//  [ &#x27;car&#x27;, 54, &#x27;tree&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h1><p>以使用默认参数定义函数。缺少或未定义的值将使用默认值进行初始化。只要小心 - 因为空值和假值会被强制为0。</p>
<p>默认值可以不仅仅是值 - 它们也可以是表达式或函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> a = <span class="number">5</span>, b = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a + b);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 15</span></span><br><span class="line">foo( <span class="number">7</span>, <span class="number">12</span> );  <span class="comment">// 19</span></span><br><span class="line">foo( <span class="literal">undefined</span>, <span class="number">8</span> ); <span class="comment">// 13</span></span><br><span class="line">foo( <span class="number">8</span> ); <span class="comment">// 18</span></span><br><span class="line">foo( <span class="literal">null</span> ); <span class="comment">// 10 as null is coerced to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值为函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> a </span>) </span>&#123; <span class="keyword">return</span> a * <span class="number">4</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"> x = <span class="number">2</span>, y = x + <span class="number">4</span>, z = foo(x)</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([ x, y, z ]);</span><br><span class="line">&#125;</span><br><span class="line">bar();  <span class="comment">// [ 2, 6, 8 ]</span></span><br><span class="line">bar( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ); <span class="comment">//[ 1, 2, 3 ]</span></span><br><span class="line">bar( <span class="number">10</span>, <span class="literal">undefined</span>, <span class="number">3</span> );  <span class="comment">// [ 10, 14, 3 ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>解构是拆分等号左侧的数组或对象的过程。数组或对象可以来自变量，函数或等式。</p>
<p>有时，你想取值，将它们分配给一个新的变量。 这是通过在等号左边的 key: variable 配对完成的。</p>
<p>对象解构允许的另一件事是为多个变量赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [ a, b, c ] = [ <span class="number">6</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a=<span class="subst">$&#123;a&#125;</span>, b=<span class="subst">$&#123;b&#125;</span>, c=<span class="subst">$&#123;c&#125;</span>`</span>); <span class="comment">//a=6, b=2, c=9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> [<span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="number">6</span> ]; &#125;</span><br><span class="line"><span class="keyword">let</span> [ x, y, z ] = foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`x=<span class="subst">$&#123;x&#125;</span>, y=<span class="subst">$&#123;y&#125;</span>, z=<span class="subst">$&#123;z&#125;</span>`</span>);  <span class="comment">// x=car, y=dog, z=6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        x: <span class="string">&#x27;car&#x27;</span>,</span><br><span class="line">        y: <span class="string">&#x27;London&#x27;</span>,</span><br><span class="line">        z: &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: vehicle, <span class="attr">y</span>: city, <span class="attr">z</span>: &#123; <span class="attr">name</span>: driver &#125; &#125; = baz();</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`I&#x27;m going to <span class="subst">$&#123;city&#125;</span> with <span class="subst">$&#123;driver&#125;</span> in their <span class="subst">$&#123;vehicle&#125;</span>.`</span></span><br><span class="line">); <span class="comment">// I&#x27;m going to London with John in their car.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: first, <span class="attr">x</span>: second &#125; = &#123; <span class="attr">x</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log( first, second ); <span class="comment">// 4, 4</span></span><br></pre></td></tr></table></figure>

<h1 id="对象字面量和简明参数"><a href="#对象字面量和简明参数" class="headerlink" title="对象字面量和简明参数"></a>对象字面量和简明参数</h1><p>当您从变量创建对象字面量时，ES6 允许您在与 key 与变量名称相同的情况下省略 key 名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 4, b &#x3D; 7;</span><br><span class="line">let c &#x3D; &#123; a: a, b: b &#125;;</span><br><span class="line">let concise &#x3D; &#123; a, b &#125;;</span><br><span class="line">console.log(c, concise) &#x2F;&#x2F; &#123;a: 4, b: 7&#125;, &#123;a: 4, b: 7&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态属性名称"><a href="#动态属性名称" class="headerlink" title="动态属性名称"></a>动态属性名称</h1><p>使用动态分配的 key 创建或添加属性的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let  city&#x3D; &#39;sheffield_&#39;;</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    [ city + &#39;population&#39; ]: 350000</span><br><span class="line">&#125;;</span><br><span class="line">a[ city + &#39;county&#39; ] &#x3D; &#39;South Yorkshire&#39;;</span><br><span class="line">console.log(a); &#x2F;&#x2F; &#123;sheffield_population: 350000, sheffield_county: &#39;South Yorkshire&#39; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数有两个主要方面：结构和this绑定。</p>
<p>不需要功能关键字，并且它们自动返回箭头之后的任何内容。</p>
<p>如果函数需要的不仅仅是一个简单的计算，可以使用大括号，并且该函数会返回花括号块范围返回的任何内容。</p>
<p>对于箭头函数最有用的地方之一是在map()，forEach()或sort()之类的数组函数中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; function( a, b ) &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line">let bar &#x3D; ( a, b ) &#x3D;&gt; a * b;</span><br></pre></td></tr></table></figure>

<h1 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h1><p>ES5 代码很好地处理了十进制和十六进制数字格式，但未指定八进制格式。事实上，它在严格的模式下被禁止。</p>
<p>ES6添加了一种新格式，在最初的 0 之后添加一个 o （注意是字母）以将该数字声明为八进制数。ES6 还添加了二进制格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number( 29 )  &#x2F;&#x2F; 29</span><br><span class="line">Number( 035 ) &#x2F;&#x2F; 35 in old octal form.</span><br><span class="line">Number( 0o35 ) &#x2F;&#x2F; 29 in new octal form</span><br><span class="line">Number( 0x1d ) &#x2F;&#x2F; 29 in hexadecimal</span><br><span class="line">Number( 0b11101 ) &#x2F;&#x2F; 29 in binary form</span><br></pre></td></tr></table></figure>

<h1 id="静态方法（Static-Methods）"><a href="#静态方法（Static-Methods）" class="headerlink" title="静态方法（Static Methods）"></a>静态方法（Static Methods）</h1><p>在类中，我们可以使用static关键字来声明静态方法。类的实例无法访问静态方法，因为声明静态方法的类属于类对象（class object）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Repo&#123;</span><br><span class="line">  static getName() &#123;</span><br><span class="line">    return &quot;Repo name is modern-js-cheatsheet&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Note that we did not have to create an instance of the Repo class</span><br><span class="line">console.log(Repo.getName()) &#x2F;&#x2F; Repo name is modern-js-cheatsheet</span><br><span class="line"></span><br><span class="line">let r &#x3D; new Repo();</span><br><span class="line">console.log(r.getName()) &#x2F;&#x2F; Uncaught TypeError: repo.getName is not a function</span><br></pre></td></tr></table></figure>

<p>通过使用this关键字，静态方法可以调用另一个静态方法，但这不适用于非静态方法（non-static methods）。非静态方法不能直接使用this关键词访问静态方法。</p>
<h4 id="静态方法调用另一个静态方法"><a href="#静态方法调用另一个静态方法" class="headerlink" title="静态方法调用另一个静态方法"></a>静态方法调用另一个静态方法</h4><p>要想静态方法调用另一个静态方法，可以这样使用this关键字;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Repo&#123;</span><br><span class="line">  static getName() &#123;</span><br><span class="line">    return &quot;Repo name is modern-js-cheatsheet&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static modifyName()&#123;</span><br><span class="line">    return this.getName() + &#39;-added-this&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Repo.modifyName()) &#x2F;&#x2F; Repo name is modern-js-cheatsheet-added-this</span><br></pre></td></tr></table></figure>

<h4 id="非静态方法调用静态方法"><a href="#非静态方法调用静态方法" class="headerlink" title="非静态方法调用静态方法"></a>非静态方法调用静态方法</h4><p>非静态方法可以通过这两种方式调用静态方法;</p>
<ol>
<li>使用类名称。</li>
</ol>
<p>为了在非静态方法里访问静态方法，我们使用类名称（class name）并像属性一样调用静态方法。例如ClassName.StaticMethodName</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repo</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Repo name is modern-js-cheatsheet&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">useName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Repo.getName() + <span class="string">&#x27; and it contains some really important stuff&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we need to instantiate the class to use non-static methods</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Repo()</span><br><span class="line"><span class="built_in">console</span>.log(r.useName()) <span class="comment">// Repo name is modern-js-cheatsheet and it contains some really important stuff</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用构造函数</li>
</ol>
<p>静态方法可以作为构造函数对象（constructor object）的属性来调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repo</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Repo name is modern-js-cheatsheet&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">useName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Calls the static method as a property of the constructor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.constructor.getName() + <span class="string">&#x27; and it contains some really important stuff&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we need to instantiate the class to use non-static methods</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Repo()</span><br><span class="line"><span class="built_in">console</span>.log(r.useName()) <span class="comment">// Repo name is modern-js-cheatsheet and it contains some really important stuff</span></span><br></pre></td></tr></table></figure>

<h1 id="新对象替换老对象"><a href="#新对象替换老对象" class="headerlink" title="新对象替换老对象"></a>新对象替换老对象</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state.obj &#x3D; &#123;...state.obj, newProp: 123&#125;</span><br><span class="line"></span><br><span class="line">oldObj &#x3D; Object.assign(&#123;&#125;, newObj)</span><br><span class="line"></span><br><span class="line">oldObj &#x3D; JSON.parse(JSON.stringify(newObj))</span><br></pre></td></tr></table></figure>

<h1 id="在对象上添加新属性"><a href="#在对象上添加新属性" class="headerlink" title="在对象上添加新属性"></a>在对象上添加新属性</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.set(obj, &#39;newProp&#39;, 123)</span><br></pre></td></tr></table></figure>

<h1 id="let-1"><a href="#let-1" class="headerlink" title="let"></a>let</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]();</span><br></pre></td></tr></table></figure>

<p> 不存在变量提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>不允许重复声明<br>不能在函数内部重新声明参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">块级作用域的不合理场景</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 内层变量可能会覆盖外层变量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(tmp);</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用来计数的循环变量泄露为全局变量<br> 循环结束后，i并没有消失，泄露成了全局变量。</li>
</ol>
<p>块级作用域：<br>    可以任意嵌套<br>    块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<ol>
<li><p>改变常量的值会报错。</p>
<p> const PI = 3.1415;<br> PI // 3.1415</p>
<p> PI = 3;<br> // TypeError: Assignment to constant variable.</p>
</li>
<li><p>只声明不赋值，报错</p>
<p> const foo;<br> // SyntaxError: Missing initializer in const declaration</p>
</li>
<li><p>作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
<p> if (true) {<br>   const MAX = 5;<br> }</p>
<p> MAX // Uncaught ReferenceError: MAX is not defined</p>
</li>
<li><p>声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<p> if (true) {<br>   console.log(MAX); // ReferenceError<br>   const MAX = 5;<br> }</p>
</li>
<li><p>声明的常量，也与let一样不可重复声明。</p>
<p> let age = 25;<br> var message = “Hello!”;</p>
<p> // 以下两行都会报错<br> const message = “Goodbye!”;<br> const age = 30;</p>
</li>
</ol>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>ES6 声明变量的六种方法<br>var命令和function命令，let和const命令，import命令和class命令。</p>
<hr>
<p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<hr>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
  </entry>
  <entry>
    <title>Git 经验积累</title>
    <url>/posts/Git-%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h2 id="客户端推荐"><a href="#客户端推荐" class="headerlink" title="客户端推荐"></a>客户端推荐</h2><ul>
<li><a href="https://www.syntevo.com/smartgit/">SmartGit</a>✨✨✨(开始用的，后来放弃)</li>
<li><a href="https://www.sourcetreeapp.com/">Sourcetree</a>✨✨✨✨✨(现在用的这个，需要翻墙注册)</li>
<li><a href="https://www.gitkraken.com/">GitKraken</a> 很好用，可以替代SourceTree, 全平台免费(也开始收费了)</li>
</ul>
<a id="more"></a>

<h2 id="github-contributions-展示问题"><a href="#github-contributions-展示问题" class="headerlink" title="github contributions 展示问题"></a>github contributions 展示问题</h2><p>正常情况下会将每天的提交记录展示到图表中。<br>有天突然发现之前好多提交记录没展示，查看原因发现是提交账号和github的账号不一致的原因导致的。</p>
<p>GitHub默认只有账号绑定的邮箱提交的commits才会展示.</p>
<p>解决办法:</p>
<ul>
<li><p>将公司邮箱加到GitHub账户下–<a href="https://github.com/settings/emails">链接</a></p>
</li>
<li><p>将当前项目的提交设置为个人邮箱</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="centos安装git"><a href="#centos安装git" class="headerlink" title="centos安装git"></a>centos安装git</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>yum install -y git</p>
<h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><p>git –version</p>
<h3 id="生成公钥并复制到服务器上"><a href="#生成公钥并复制到服务器上" class="headerlink" title="生成公钥并复制到服务器上"></a>生成公钥并复制到服务器上</h3><h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><p>ssh-keygen -t rsa</p>
<h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><p>cat ~/.ssh/id_rsa.pub</p>
<p>mac中直接复制到剪贴板</p>
<p>pbcopy &lt; ~/.ssh/id_rsa.pub</p>
<h3 id="复制id-rsa-pub里的公钥到服务器上的authorized-keys文件"><a href="#复制id-rsa-pub里的公钥到服务器上的authorized-keys文件" class="headerlink" title="复制id_rsa.pub里的公钥到服务器上的authorized_keys文件"></a>复制id_rsa.pub里的公钥到服务器上的authorized_keys文件</h3><p>拷贝，复制到github.com的settings的SSH and GPG keys中</p>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>参考：<a href="https://nodejs.org/">https://nodejs.org/</a></p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>yum remove nodejs -y</p>
<h2 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h2><p>1.确保系统下 g++ 版本在 4.6 以上，python 版本在 2.6 以上。</p>
<p>2.从 nodejs.org 下载 tar.gz 后缀的 NodeJS 最新版源代码包并解压到某个位置。</p>
<p><code>wget https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz</code></p>
<p>3.进入解压到的目录，使用以下命令编译和安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zvxf node-v4.5.0.tar.gz</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="git提交commit后，想撤回重新commit"><a href="#git提交commit后，想撤回重新commit" class="headerlink" title="git提交commit后，想撤回重新commit"></a>git提交commit后，想撤回重新commit</h2><p><code>git reset --soft HEAD^</code></p>
<p>这样就成功的撤销了你的commit<br>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p>
<p><code>--hard</code><br>会删除本地修改代码，回到上次commit状态</p>
<p>查看分支 <code>git branch -a</code> (可以查看所有分支)<br>创建分支 <code>git branch name</code><br>切换分支 <code>git checkout name</code><br>创建并切换 <code>git checkout -b name</code><br>合并某分支到当前分支 <code>git merge name</code> 用于合并指定分支到当前分支<br>删除分支 <code>git branch -d name</code></p>
<p>注，合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支记录，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。<br>9.团队多人开发协作</p>
<p>1).查看远程仓库分支<br>查看远程仓库的信息 git remote命令可以查看远程仓库，加-v选项可以查看详细信息。</p>
<p>2).分支推送</p>
<p>首先，可以试图用git push origin branch-name推送自己的修改如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并如果合并有冲突，则解决冲突，并在本地提交没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p>
<p>git 创建tag<br>用 -a （译注：取 annotated 的首字母）<br>git tag -a v0.1 -m ‘sidebar is ok’</p>
<p>git tag :  查看tag列表<br>git show v1.4 ： 查看tag的具体信息</p>
<p>git tag -l ‘v0.1.*’ # 搜索符合模式的Tag</p>
<p>给指定的commit打Tag<br> git tag -a v1.2 9fceb02</p>
<p>切换到Tag<br>与切换分支命令相同，用git checkout [tagname]<br>删除Tag<br>误打或需要修改Tag时，需要先将Tag删除，再打新Tag。<br>$ git tag -d v0.1.2 # 删除Tag</p>
<p>分享标签<br>Tag推送到服务器<br> git push origin v1.5</p>
<p>一次推送所有本地新增的标签上去，可以使用 –tags 选项：<br>git push origin –tags</p>
<p>注意：如果想看之前某个Tag状态下的文件，可以这样操作<br>1.git tag 查看当前分支下的Tag<br>2.git checkout v0.21 此时会指向打v0.21 Tag时的代码状态，（但现在处于一个空的分支上）</p>
<p>git pull origin master</p>
<p>/<strong>修改提交用到的命令**<em>/<br>git push origin gitcafe-pages  //提交到远端的服务器上<br>git commit -m ‘gitabc first commit’   //在本地创建一个版本<br>git add -A<br>/**修改提交用到的命令</em></strong>/<br>git add -A</p>
<p>添加多个文件及文件夹</p>
<p>进入某个文件夹路径：<br>cd D:/gitCafe     即可进入D:\gitCafe<br>cd believeZJP     即可进入 D:\gitCafe\believeZJP</p>
<p>git log常用命令以及技巧<br>1.git log<br>如果不带任何参数，它会列出所有历史记录，最近的排在最上方，显示提交对象的哈希值，作者、提交日期、和提交说明。如果记录过多，则按Page Up、Page Down、↓、↑来控制显示；按q退出历史记录列表。</p>
<p>当git出现</p>
<blockquote>
<p>Please enter a commit message to explain why this merge is necessary<br> especially if it merges an updated upstream into a topic branch<br> Lines starting with ‘#’ will be ignored, and an empty message aborts<br> the commit<br>~<br>“.git/MERGE_MSG” 7L, 293C<br>这个画面时：</p>
</blockquote>
<p>type i to insert a comment then press esc and type :wq</p>
<p>vi编辑模式：<br>进入：<br>vi test.txt<br>从插入模式切换为命令行模式</p>
<p>　　按「ESC」键。<br>按esc退出编辑模式<br>退出vi及保存文件</p>
<p>别忘了wq前面的:<br>:w   保存文件但不退出vi<br>:w file 将修改另外保存到file中，不退出vi<br>:w!   强制保存，不推出vi<br>:wq  保存文件并退出vi<br>:wq! 强制保存文件，并退出vi<br>q:  不保存文件，退出vi<br>:q! 不保存文件，强制退出vi<br>:e! 放弃所有修改，从上次保存文件开始再编辑<br>cat test.txt   //查看文件内容</p>
<p>配置SSH KEYS<br>步骤严格按照<a href="https://help.github.com/articles/generating-ssh-keys/">https://help.github.com/articles/generating-ssh-keys/</a> 是可以成功的。</p>
<p>转 push本地代码到github出错<br>刚创建的github版本库，在push代码时出错：</p>
<p>$ git push -u origin master</p>
<p>解决办法：<br>    2.push前先将远程repository修改pull下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>添加公钥:<br>    应将id_rsa.pub中的内容拷贝到文本框中，而不是id_rsa中的！！！！！！！！！！！！！！</p>
<p>git 合并：<br>    1.先git pull 将远程的文件更新过来<br>    2.有冲突的，会在文件中有</p>
<p>这样的提示，解决冲突，<br>    3.git add ，然后再commit<br>    4.git push origin master</p>
<p>git add -A<br>git commit -m ‘dd’<br>git push origin master</p>
<p>github 提交时，多次要求输入用户名密码的解决方法</p>
<p>git生成ssh key<br>    ssh-keygen.exe<br>    vim ~/.ssh/id_rsa.pub<br>将ssh key 复制到添加页面</p>
<p>git diff 以后，按q 退出<br>git 强制覆盖本地某个文件<br>git checkout  – file</p>
<p>git切换分支：<br>    git checkout 分支名称<br>git 只添加文件夹，<br>   用git status 是不会检测到添加的文件夹，(多级文件夹也无法检测到)<br>    只有文件夹中有文件，才会检测到，</p>
<h3 id="给本次存储加个备注，以防时间久了忘了"><a href="#给本次存储加个备注，以防时间久了忘了" class="headerlink" title="给本次存储加个备注，以防时间久了忘了"></a>给本次存储加个备注，以防时间久了忘了</h3><p><code>git stash save &quot;存储&quot;</code></p>
<p>git stash 经验，<br>当遇到本地已经commit后，发现忘记了git pull 时，此时，git pull会提示：you have unstaged changes.<br>可以先git stash ，将本地的状态存起来，<br>然后就可以git pull,<br>再从本地恢复之前的状态，<br>git stash pop</p>
<p>git stash list   可以查看本地有哪些状态，<br>git stash pop stash@{0}    可以将原先保存的状态还原。<br>直接git stash pop 也可以。<br>此时再git commit -m “”，git push<br>就可以正常提交了。<br>回退到某个版本<br> sudo git reset –hard 3943d5c74a08a8f6ad113e63ed191ecb4f48b053<br>git强制覆盖本地所有修改：<br>git fetch –all<br>git reset –hard origin/master</p>
<p>error: cannot lock ref ‘refs/remotes/origin/master’: unable to resolve reference refs/remotes/origin/master: Invalid argument<br>发生原因：<br>git push origin master 写成了git push origin/master</p>
<p>解决办法：<br>rm .git/refs/remotes/origin/master<br>git fetch</p>
<p>修复bug的流程<br>说明：从生产环境的分支上修改，再逐渐改到测试环境，dev环境<br>操作步骤：<br>    1.在主分支master拉一个分支branch1出来，修改，<br>    2.将branch1合并到master,并提交，git push<br>    3.切换到test分支，git merge branch1,并提交，git push<br>    4.切换到dev分支，git merge branch1 并提交，git push<br>    5.登录到每个环境的服务器中，分别git pull，即可看到更改的结果。</p>
<hr>
<p>让某个分支和另外一个分支一样的话，直接将另一个分支merge过来。</p>
<p> Read-Search-Ask methodology</p>
<p>git pull的时候遇到这样的问题：<br>The following untracked working tree files would be overwritten by merge balabala…<br>解决办法：<br>git clean -d -fx<br>备注：会删除掉没有add到仓库的文件，操作记得慎重，以免改动文件的丢失。本质上就是操作仓库中没有被追踪的本地文件<br>$ git clean -f -n         # 1<br>$ git clean -f            # 2<br>$ git clean -fd           # 3<br>$ git clean -fX           # 4<br>$ git clean -fx           # 5<br>(1): 选项-n将显示执行（2）时将会移除哪些文件。<br>(2): 该命令会移除所有命令（1）中显示的文件。<br>(3): 如果你还想移除文件件，请使用选项-d。<br>(4): 如果你只想移除已被忽略的文件，请使用选项-X。<br>(5): 如果你想移除已被忽略和未被忽略的文件，请使用选项-x。</p>
<p>mkdir learngit<br>cd learngit<br>pwd<br>git init<br>git add readme.txt<br>git commit -m “wrote a readme file”<br>git status<br> git diff readme.txt //查看文件的区别<br>git log  历史记录<br>git log –pretty=oneline   一行显示<br> git reset –hard HEAD^   回退上一个版本<br>上上一个版本就是HEAD^^   写成HEAD~100  上100个版本<br>git reset –hard 3628164  指定回到未来的某个版本。版本号没必要写全，前几位就可以了，Git会自动去找<br>gitreflog   记录每一次命令<br>git diff //查看修改的内容<br>git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别<br>git checkout – readme.txt    丢弃工作区的修改</p>
<p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：<br>    一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>    一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>    总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>–很重要，没有–，就变成了“切换到另一个分支”的命令，<br>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。<br>git reset HEAD readme.txt   可以把暂存区的修改撤销掉（unstage），重新放回工作区：<br>    小结：<br>        场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。<br>        场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git rese            t HEAD file，就回到了场景1，第二步按场景1操作。<br>        场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库                    。<br>—–删除文件—-<br>rm test.txt   直接在文件管理器中把没用的文件删了，或者用rm命令删了：—相当于从文件管理器删除<br> git rm test.txt   从版本库中删除该文件，那就用命令git rm删掉，并且git commit：<br>git commit -m “remove test.txt”<br>            文件就从版本库中被删除了。<br>———–远程关联————<br>git remote add origin git@server-name:path/repo-name.git；<br>      eg:  $ git remote add origin <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#109;">&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#109;</a>:michaelliao/learngit.git<br>git push -u origin master第一次推送master分支的所有内容；<br>每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；<br>git remote -v   看有没有权限推送</p>
<p>————用命令克隆一个远程库—————-<br>git clone <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;">&#103;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:michaelliao/gitskills.git      用命令git clone克隆一个本地库：<br><a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>/believeZJP/believeZJP.github.io.git</p>
<p><a href="https://gitcafe.com/believeZJP/believeZJP.git">https://gitcafe.com/believeZJP/believeZJP.git</a></p>
<p>git 只克隆一个分支<br> <code>git clone -b &lt;branch&gt; &lt;remote_repo&gt;</code><br> eg:      git clone -b gitcafe-pages  <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x63;&#x61;&#102;&#101;&#x2e;&#x63;&#111;&#109;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#x63;&#x61;&#102;&#101;&#x2e;&#x63;&#111;&#109;</a>:believeZJP/believeZJP.git</p>
<p>————–切换分支————-<br>git checkout -b dev   checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br>git branch dev<br>git checkout dev<br>git branch   查看当前分支：会列出所有分支，当前分支前面会标一个*号<br>git checkout master         切换回master分支：<br> git merge dev                把dev分支的工作成果合并到master分支上<br>git branch -d dev            删除dev分支了<br>git branch -D feature-vulcan  强行删除分支</p>
<p>小结<br>Git鼓励大量使用分支：<br>查看分支：git branch     //  git branch -a<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name><br>删除分支：git branch -d <name></p>
<p> git log –graph –pretty=oneline –abbrev-commit   分支的合并情况：</p>
<p>git merge –no-ff -m “merge with no-ff” dev        请注意–no-ff参数，表示禁用Fast forward：<br>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。<br>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<p>————–从远程获取文件——————-<br>将修改的文件推送到远程<br>git push origin master<br>git push origin dev</p>
<p>———Bug分支—————–<br>git stash            把当前工作现场“储藏”起来，等以后恢复现场后继续工作：<br>git stash list        查看工作现场</p>
<p>Git把stash内容存在某个地方，需要恢复，有两个办法：<br>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；<br>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p>
<p>可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：<br>$ git stash apply stash@{0}<br>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<p>—————–多人协作——————–<br>小结<br>查看远程库信息，使用git remote -v；<br>本地新建的分支如果不推送到远程，对其他人就是不可见的；<br>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；<br>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；<br>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；<br>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<p>—————创建标签—————<br>git tag v1.0                默认标签是打在最新提交的commit上<br>git tag                    查看所有标签<br>git tag v0.96224937         打标签到某一个commit上<br> git show v0.9                查看标签信息<br>git tag -a v0.1 -m “version 0.1 released”3628164        创建带有说明的标签，用-a指定标签名，-m指定说明文字<br>git tag -s <tagname> -m “blablabla…”可以用PGP签名标签；<br>git tag -d v0.1               删除标签<br>git push origin v1.0            推送某个标签到远程<br> git push origin –tags            一次性推送全部尚未推送到远程的本地标签<br>git push origin :refs/tags/v0.9<br>签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：从远程删除。删除命令也是push，但是格式如下：<br>git push origin :refs/tags/v0.9<br>// To <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#99;&#111;&#x6d;</a>:michaelliao/learngit.git   不知道有没有这个</p>
<p>小结<br>命令git push origin <tagname>可以推送一个本地标签；<br>命令git push origin –tags可以推送全部未推送过的本地标签；<br>命令git tag -d <tagname>可以删除一个本地标签；<br>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</p>
<p>———-使用GitHub———————<br>小结<br>在GitHub上，可以任意Fork开源仓库；<br>自己拥有Fork后的仓库的读写权限；<br>可以推送pull request给官方仓库来贡献代码。</p>
<p>——————自定义Git————————<br>git config –global color.ui true                让Git显示颜色，会让命令输出看起来更醒目<br>——————配置别名—————————–</p>
<p>git config –global alias.st status<br>git config –global alias.co checkout<br>git config –global alias.ci commit<br>git config –global alias.br branch<br>以后st就表示status    co表示checkout，ci表示commit，br表示branch</p>
<p>–global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用</p>
<p>git config –global alias.unstage ‘reset HEAD’<br>        当你敲入命令：$ git unstage test.py   实际上Git执行的是：   $ git reset HEAD test.py<br>git config –global alias.last ‘log -1’        让其显示最后一次提交信息</p>
<p>git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”<br>git lg</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：<br>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。<br>当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：</p>
<p>…or create a new repository on the command line<br>echo “# node-server” &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m “first commit”<br>git remote add origin <a href="https://github.com/believeZJP/node-server.git">https://github.com/believeZJP/node-server.git</a><br>git push -u origin master</p>
<p>…or push an existing repository from the command line<br>git remote add origin <a href="https://github.com/believeZJP/node-server.git">https://github.com/believeZJP/node-server.git</a><br>git push -u origin master</p>
<p>git远程有分支，本地没有，解决办法<br>git fetch 命令会更新 remote 索引。</p>
<p>git fetch origin</p>
<h2 id="git存储"><a href="#git存储" class="headerlink" title="git存储"></a>git存储</h2><h3 id="git分区"><a href="#git分区" class="headerlink" title="git分区"></a>git分区</h3><p>git存储分成四个部分</p>
<ul>
<li>workspace：工作空间（我们的开发代码目录）</li>
<li>index： 暂存区，.git目录下的index文件</li>
<li>Repository：本地仓库，通过git clone将远程的代码下载到本地；代码库的元数据信息在根目录下的.git目录下</li>
<li>Remote：远程仓库（比如GitHub就是一个远程仓库）</li>
</ul>
<p>整个过程就是：</p>
<ol>
<li><p>工作区–git add–暂存区–git commit–本地仓库– git push–远程仓库</p>
</li>
<li><p>远程仓库区–-fetch–-使用refs\remotes下对应分支文件记录远程分支末端commit_id 和 本地仓库区 –merge–-工作区</p>
</li>
<li><p>远程仓库区–-pull–-使用refs\remotes下对应分支文件记录远程分支末端commit_id and 本地仓库区 and 工作区</p>
</li>
</ol>
<h3 id="git-fetch和git-pull的区别"><a href="#git-fetch和git-pull的区别" class="headerlink" title="git fetch和git pull的区别"></a>git fetch和git pull的区别</h3><p>git fetch: 是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。具体操作如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git  fetch origin master:temp</span><br><span class="line">//本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支</span><br><span class="line">git diff temp</span><br><span class="line">//比较远程代码与本地代码的区别</span><br><span class="line">git merge temp</span><br><span class="line">//将temp分支合并到本地master分支</span><br><span class="line">git branch -d temp</span><br><span class="line">//如果不想保留分支，可以将其删除</span><br></pre></td></tr></table></figure>

<p>git pull: 基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD与远程仓库的版本号，然后git fetch获得当前的远程分支的后续版本的数据，然后利用git merge将其与本地的分支合并，可以认为是git pull是git fetch和git merge两个步骤的合并。<br>实际的git pull过程可以理解为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin master  //将远端的master分支拉取最新内容</span><br><span class="line">git merge FETCH_HEAD //将拉取的最新内容与当前分支合并</span><br></pre></td></tr></table></figure>

<p> git pull用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt;  &lt;远程分支名&gt;:&lt;本地分支名&gt;`</span><br><span class="line">// 将远程主机的某个分支，与本地的指定分支合并</span><br></pre></td></tr></table></figure>

<p> git pull合并后可能会出现冲突，需要手动解决冲突。<br>出现的错误提示如下</p>
<blockquote>
<p>error: Your local changes to the following files would be overwritten by merge:<br>Please commit your changes or stash them before you merge.<br>// 更新的代码与本地的修改代码有冲突，先提交你的改变或者先将本地修改暂存起来</p>
</blockquote>
<p>解决冲突的方式：先将本地的代码暂存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash //先将本地修改暂存起来</span><br><span class="line">git stash list  //查看保存信息</span><br><span class="line">git pull     //拉取内容</span><br><span class="line">git stash pop   //还原暂存的内容</span><br></pre></td></tr></table></figure>

<h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><ol>
<li>Changes to be committed：代表被add的文件，被加载到了暂存区</li>
<li>Changes not staged for commit：代表在当前分支中被修改的文件，还没有被add，存储在工作区</li>
</ol>
<h3 id="git内部存储"><a href="#git内部存储" class="headerlink" title="git内部存储"></a>git内部存储</h3><p>本地git项目里面的.git目录下的文件如下：</p>
<ol>
<li>refs：存储git各种引用的目录，包含分支、远程分支和标签</li>
<li>objects：是存储git各种对象及备用的对象库，包含正常的压缩和压缩后的</li>
<li>info：存储git信息的目录，比如判处特定后缀的文件</li>
<li>index：暂存区</li>
<li>hooks：存储git钩子的目录，钩子只在特定事件发生时触的脚本，比如：提交之前，提交之后</li>
<li>description：项目描述</li>
<li>config：代码库几倍的配置文件</li>
<li>ORIG_HEAD：针对某些 危险操作 ，Git通过记录HEAD指针的上次所在的位置 ORIG_HEAD提供了回退的功能。当你发现某些操作失误了，比如错误的reset到了一个很早很早的版本，可以使用 git reset –hard ORIG_HEAD回退到上一次reset之前。</li>
<li>HEAD：代码库当前分支的指向</li>
<li>FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</li>
<li>COMMIT_EDITMSG：commit编辑</li>
</ol>
<p>git 常用插件</p>
<ol>
<li><a href="https://github.com/commitizen/cz-cli">commitizen</a> 规范commit message</li>
</ol>
<p><code>git show</code><br>在当前分支，运行<code>git show &lt;其他分支名&gt;</code> k可以查看当前分支与其他分支的diff</p>
<p><code>git diff master f_tmp</code></p>
<p>可以查看master和f_tmp分支的区别</p>
]]></content>
      <tags>
        <tag>Git</tag>
        <tag>SmartGit</tag>
        <tag>GitKraken</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 小知识</title>
    <url>/posts/HTML-%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>1.设置input 语法检查<br><code>spellcheck=&quot;false/true&quot;</code></p>
<p>2.设置input是否自动补全<br><code>autocomplete=&quot;off/on&quot;</code></p>
<p>3.页面加载时，自动获取焦点<br><code>autofocus=&quot;autofocus&quot;</code></p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的意思是，让布局视口的宽度等于理想视口的宽度，页面的初始缩放比例以及最大缩放比例都为1，且不允许用户对页面进行缩放操作。</p>
<h3 id="input标签只能输入数字js实现-且不能输入e或者其他各种符号"><a href="#input标签只能输入数字js实现-且不能输入e或者其他各种符号" class="headerlink" title="input标签只能输入数字js实现(且不能输入e或者其他各种符号)"></a>input标签只能输入数字js实现(且不能输入e或者其他各种符号)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">onKeypress</span>=<span class="string">&quot;return (/[\d]/.test(String.fromCharCode(event.keyCode)))&quot;</span> <span class="attr">style</span>=<span class="string">&quot;ime-mode: Disabled&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>ime-mode的语法解释如下：</p>
<p>ime-mode : auto | active | inactive | disabled</p>
<p>取值：</p>
<p>auto  : 默认值。不影响IME的状态。与不指定 ime-mode 属性时相同</p>
<p>active  : 指定所有使用IME输入的字符。即激活本地语言输入法。用户仍可以撤销激活IME</p>
<p>inactive  : 指定所有不使用IME输入的字符。即激活非本地语言。用户仍可以撤销激活IME</p>
<p>disabled  : 完全禁用IME。对于有焦点的控件(如输入框)，用户不可以激活IME</p>
<p>IME 是指 Input Method Editors 输入法编辑器</p>
<p>慕课网学习</p>
<h2 id="1-html基础"><a href="#1-html基础" class="headerlink" title="1.html基础"></a>1.html基础</h2><p>  em标签：强调，斜体；strong:强调<br> <code>&lt;address&gt;</code>斜体，用于显示地址<br><code>&lt;q&gt;</code>标签的真正关键点不是它的默认样式双引号，而是它的语义：引用别人的话。</p>
<p><code>&lt;blockquote&gt;</code>的作用也是引用别人的文本。但它是对长文本的引用，如在文章中引入大段某知名作家的文字，这时需要这个标签。</p>
<p>html4.01版本 <code>&lt;hr&gt;    &lt;br&gt;</code><br>xhtml1.0版本 <code>&lt;hr /&gt;  &lt;br/&gt;</code></p>
<p>显示代码段<br>   一行—<code>&lt;code&gt;&lt;/code&gt;</code><br>   多行—-<code>&lt;pre&gt;&lt;/pre&gt;</code><br>select 多选<br>    <code>&lt;select multiple=&quot;multiple&quot;&gt;</code><br>Label中的for事件<br>label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该 label标签相关连的表单控件上）。<br>placeholder属性<br><code>&lt;input type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Enter email&quot;&gt;</code></p>
<h2 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h2><p>三种样式是有优先级的，记住他们的优先级：内联式 &gt; 嵌入式 &gt; 外部式</p>
<p>类选择器和id选择器的相同、不同点</p>
<p>相同点和不同点：<br>相同点：可以应用于任何元素</p>
<p>不同点：<br>1、ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。<br>2、可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。</p>
<p>子选择器<br>还有一个比较有用的选择器子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。如右侧代码编辑器中的代码：<br><code>.food&gt;li&#123;border:1px solid red;&#125;</code></p>
<p>包含(后代)选择器<br>包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如右侧代码编辑器中的代码：<br><code>.first  span&#123;color:red;&#125;</code><br>请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过“&gt;”进行选择。</p>
<p>总结：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。</p>
<p>通用选择器  *</p>
<p>伪类选择符<br>更有趣的是伪类选择符，为什么叫做伪类选择符，它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：<br><code>a:hover&#123;color:red;&#125;</code></p>
<p>分组选择符<br>当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码为右侧代码编辑器中的h1、span标签同时设置字体颜色为红色：<br><code>h1,span&#123;color:red;&#125;</code></p>
<p>继承<br>CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于p标签，这个颜色设置不仅应用p标签，还应用于p标签中的所有子元素文本，这里子元素为span标签。<br><code>p&#123;color:red;&#125;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>三年级时，我还是一个<span class="tag">&lt;<span class="name">span</span>&gt;</span>胆小如鼠<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的小女孩。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">可见右侧结果窗口中p中的文本与span中的文本都设置为了红色。但注意有一些css样式是不具有继承性的。如border:1px solid red;</span><br><span class="line">p&#123;border:1px solid red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>三年级时，我还是一个<span class="tag">&lt;<span class="name">span</span>&gt;</span>胆小如鼠<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的小女孩。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>特殊性<br>根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。<br>下面是权值的规则：<br>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*权值为1*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:green;&#125; <span class="comment">/*权值为1+1=2*/</span></span><br><span class="line"><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:white;&#125; <span class="comment">/*权值为10*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:purple;&#125; <span class="comment">/*权值为1+1+10=12*/</span></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">footer</span> <span class="selector-class">.note</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:yellow;&#125; <span class="comment">/*权值为100+10+1=111*/</span></span><br></pre></td></tr></table></figure>

<p>注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。</p>
<p>层叠<br>内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</p>
<p>重要性</p>
<p>样式优先级为：浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。</p>
<p>现在一般网页喜欢设置“微软雅黑”，如下代码：<br><code>body&#123;font-family:&quot;Microsoft Yahei&quot;;&#125;</code></p>
<p>文字排版–斜体<br>以下代码可以实现文字以斜体样式在浏览器中显示：<br><code>p a&#123;font-style:italic;&#125;</code></p>
<p>文字排版–下划线<br>有些情况下想为文字设置为下划线样式，这样可以在视觉上强调文字，可以使用下面代码来实现：<br><code>p a&#123;text-decoration:underline;&#125;</code><br>删除线使用下面代码就可以实现：<br><code>.oldPrice&#123;text-decoration:line-through;&#125;</code></p>
<p>段落排版–缩进<br>中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：<br><code>p&#123;text-indent:2em;&#125;</code><br>注意：2em的意思就是文字的2倍大小</p>
<p>段落排版–行间距<br>这一小节我们来学习一下另一个在段落排版中起重要作用的行间距属性（line-height），如下代码实现设置段落行间距为1.5倍。<br><code>p&#123;line-height:1.5em;&#125;</code></p>
<p>段落排版–字间距、字母间距<br>文字间隔、字母间隔设置：<br>如果想在网页排版中设置文字间隔或者字母间隔就可以使用    letter-spacing来实现，如下面代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。<br>单词间距设置：<br>如果我想设置英文单词之间的间距呢？可以使用word-spacing来实现。如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">word-spacing</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>段落排版–对齐<br>想为块状元素中的文本、图片设置居中样式吗？可以使用text-align样式代码，如下代码可实现文本居中显示。(那么什么是块状元素呢？在后面的11-1、11-2小节中会讲到。)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">    text-align:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h2><p>在讲解CSS布局之前，我们需要提前知道一些知识，在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。<br>常用的块状元素有：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">h1</span>&gt;</span>...<span class="tag">&lt;<span class="name">h6</span>&gt;</span>、<span class="tag">&lt;<span class="name">ol</span>&gt;</span>、<span class="tag">&lt;<span class="name">ul</span>&gt;</span>、<span class="tag">&lt;<span class="name">dl</span>&gt;</span>、<span class="tag">&lt;<span class="name">table</span>&gt;</span>、<span class="tag">&lt;<span class="name">address</span>&gt;</span>、<span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>、<span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>常用的内联元素有：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">span</span>&gt;</span>、<span class="tag">&lt;<span class="name">br</span>&gt;</span>、<span class="tag">&lt;<span class="name">i</span>&gt;</span>、<span class="tag">&lt;<span class="name">em</span>&gt;</span>、<span class="tag">&lt;<span class="name">strong</span>&gt;</span>、<span class="tag">&lt;<span class="name">label</span>&gt;</span>、<span class="tag">&lt;<span class="name">q</span>&gt;</span>、<span class="tag">&lt;<span class="name">var</span>&gt;</span>、<span class="tag">&lt;<span class="name">cite</span>&gt;</span>、<span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>常用的内联块状元素有：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>、<span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>元素分类–块级元素<br>什么是块级元素？在html中<code>&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;</code>就是块级元素。设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。<br><code>a&#123;display:block;&#125;</code><br>块级元素特点：<br>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）<br>2、元素的高度、宽度、行高以及顶和底边距都可设置。<br>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p>
</li>
<li><p>元素分类–内联元素<br>在html中，<code>&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、&lt;input&gt;、 &lt;img&gt;、 &lt;strong&gt; 和&lt;em&gt;</code>就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码display:inline将元素设置为内联元素。如下代码就是将块状元素div转换为内联元素，从页使用div元素具有内联元素特点。<br>内联元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高及顶部和底部边距不可设置；<br>3、元素的宽度就是它包含的文字或图片的宽度，不可改变。<br>小伙伴们你们观查一下右侧代码段，有没有发现一个问题，内联元素之间有一个间距问题，这个问题在本小节的wiki中有介绍，感兴趣的小伙伴可以去查看。<br>解决行内元素间隙bug问题<br>行内元素之间会产生间隙bug问题的场景：<br>1、当行内元素之间有“回车”、“tab”、“空格”时就会出现间隙。<br>如下代码：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>33333<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>44444<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">em</span>&gt;</span>555555<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解决方法：<br>1、写在一行，之间不要有空格之类的符号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>33333<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>44444<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>555555<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、使用<code>font-size:0</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">font-size</span>:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">span</span>,<span class="selector-tag">em</span>&#123;<span class="attribute">font-size</span>:<span class="number">16px</span>;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素分类–内联块状元素<br>内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。(css2.1新增)，<code>&lt;img&gt;、&lt;input&gt;</code>标签就是这种内联块状标签。</li>
</ul>
<p>inline-block元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>内联块状元素<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">a&#123;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span><span class="selector-pseudo">:inline-block</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="css"> <span class="selector-tag">width</span><span class="selector-pseudo">:20px</span>;<span class="comment">/*在默认情况下宽度不起作用*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="css"> <span class="selector-tag">height</span><span class="selector-pseudo">:20px</span>;<span class="comment">/*在默认情况下高度不起作用*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="css"> <span class="selector-tag">background</span><span class="selector-pseudo">:pink</span>;<span class="comment">/*设置背景颜色为粉色*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="css"> <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>; <span class="comment">/*设置文本居中显示*/</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="内填充，外边距，边框"><a href="#内填充，外边距，边框" class="headerlink" title="内填充，外边距，边框"></a>内填充，外边距，边框</h2><p>盒模型–边框（一）<br>盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span>  solid  red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是border代码的缩写形式，可以分开写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<br>1、border-style（边框样式）常见样式有：<br>dashed（虚线）| dotted（点线）| solid（实线）。<br>2、border-color（边框颜色）中的颜色可设置为十六进制颜色，如:<br>border-color:#888;//前面的井号不要忘掉。<br>3、border-width（边框宽度）中的宽度也可以设置为：<br>thin | medium | thick（但不是很常用），最常还是用象素（px）。<br>盒模型–宽度和高度<br>盒模型宽度和高度和我们平常所说的物体的宽度和高度理解是不一样的，css内定义的宽（width）和高（height），指的是填充以里的内容范围。</p>
<p>因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</p>
<p>元素的高度也是同理。<br>盒模型–填充<br>元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。如下代码：<br><code>div&#123;padding:20px 10px 15px 30px;&#125;</code><br>顺序一定不要搞混。可以分开写上面代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">padding-top</span>:<span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">padding-right</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">padding-bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">padding-left</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上、右、下、左的填充都为10px;可以这么写<br><code>div&#123;padding:10px;&#125;</code><br>如果上下填充一样为10px，左右一样为20px，可以这么写：<br><code>div&#123;padding:10px 20px;&#125;</code><br>盒模型–边界<br>元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。如下代码：<br><code>div&#123;margin:20px 10px 15px 30px;&#125;</code><br>也可以分开写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">   <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">margin-right</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">margin-left</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上右下左的边界都为10px;可以这么写：<br><code>div&#123; margin:10px;&#125;</code><br>如果上下边界一样为10px，左右一样为20px，可以这么写：<br><code>div&#123; margin:10px 20px;&#125;</code><br>总结一下：padding和margin的区别，padding在边框里，margin在边框外。</p>
<h2 id="12-1-CSS布局模型"><a href="#12-1-CSS布局模型" class="headerlink" title="12-1 CSS布局模型"></a>12-1 CSS布局模型</h2><p>css布局模型<br>清楚了CSS 盒模型的基本概念、 盒模型类型，<br>我们就可以深入探讨网页布局的基本模型了。布局模型与盒模型一样都是 CSS 最基本、 最核心的概念。<br>但布局模型是建立在盒模型基础之上，又不同于我们常说的 CSS 布局样式或 CSS 布局模板。如果说布局模型是本，那么 CSS<br>布局模板就是末了，是外在的表现形式。<br>CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。<br>在网页中，元素有三种布局模型：<br>1、流动模型（Flow）<br>2、浮动模型 (Float)<br>3、层模型（Layer）<br>s流动模型（一）<br>先来说一说流动模型，流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。<br>流动布局模型具有2个比较典型的特征：<br>第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。<br>块状元素的特点：“在默认状态下，块状元素的宽度都为100%”。</p>
<p>12-3  流动模型二</p>
<p>流动模型（二）</p>
<p>第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</p>
<p>右侧代码编辑器中内联元素标签a、span、em、strong都是内联元素。<br>内联元素的特点：“包含元素内从左到右水平分布显示”</p>
<p>12-4  浮动模型</p>
<p>浮动模型</p>
<p>块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。任何元素在默认情况下是不能浮动的，但可以用CSS定义为浮动，如div、p、table、img等元素都可以被定义为浮动。<br>float  浮动</p>
<p>12-5<br>什么是层模型？</p>
<p>什么是层布局模型？层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能<br>一样，每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧。但是在网页上局部使用层布局还是有其方便之处的。下面我<br>们来学习一下html中的层布局。</p>
<p>如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作。CSS定义了一组定位（positioning）属性来支持层布局模型。</p>
<p>层模型有三种形式：</p>
<p>1、绝对定位(position: absolute)</p>
<p>2、相对定位(position: relative)</p>
<p>3、固定定位(position: fixed)</p>
<p>12-6<br>层模型–绝对定位<br>如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。<br>12-7<br>层元素相对定位<br>层模型–相对定位</p>
<p>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p>
<p>如下代码实现相对于以前位置向下移动50px，向右移动100px;</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">div1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>什么叫做“偏移前的位置保留不动”呢？</p>
<p>大家可以做一个实验，在右侧代码编辑器的19行div标签的后面加入一个span标签，在标并在span标签中写入一些文字。如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>偏移前的位置还保留不动，覆盖不了前面的div没有偏移前的位置<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p>从效果图中可以明显的看出，虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。</p>
<p>12-8<br>层模型–固定定位</p>
<p>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）<br>本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定<br>位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下<br>代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。</p>
<p>12-9<br>Relative与Absolute组合使用</p>
<p>小伙伴们学习了12-6小节的绝对定位的方法：使用position:absolute可以实现被设置元素相对于浏览器（body）设置定位以后，大家有没有想过可不可以相对于其它元素进行定位呢？答案是肯定的，当然可以。使用position:relative来帮忙，但是必须遵守下面规范：</p>
<p>1、参照定位的元素必须是相对定位元素的前辈元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="comment">&lt;!--参照定位的元素--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>相对参照元素进行定位<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--相对定位元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出box1是box2的父元素（父元素当然也是前辈元素了）。</p>
<p>2、参照定位的元素必须加入position:relative;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">box1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">box2</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样box2就可以相对于父元素box1定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。</p>
<p>13.1<br>盒模型代码简写</p>
<p>还记得在讲盒模型时外边距(margin)、内边距(padding)和边框(border)设置上下左右四个方向的边距是按照顺时针方向设置的：上右下左。具体应用在margin和padding的例子如下：</p>
<p>margin:10px 15px 12px 14px;/<em>上设置为10px、右设置为15px、下设置为12px、左设置为14px</em>/</p>
<p>通常有下面三种缩写方法:</p>
<p>1、如果top、right、bottom、left的值相同，如下面代码：</p>
<p>margin:10px 10px 10px 10px;</p>
<p>可缩写为：</p>
<p>margin:10px;</p>
<p>2、如果top和bottom值相同、left和 right的值相同，如下面代码：</p>
<p>margin:10px 20px 10px 20px;</p>
<p>可缩写为：</p>
<p>margin:10px 20px;</p>
<p>3、如果left和right的值相同，如下面代码：</p>
<p>margin:10px 20px 30px 20px;</p>
<p>可缩写为：</p>
<p>margin:10px 20px 30px;</p>
<p>注意：padding、border的缩写方法和margin是一致的。</p>
<p>13-2<br>颜色值缩写</p>
<p>关于颜色的css样式也是可以缩写的，当你设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。</p>
<p>例子1：</p>
<p>p{color:#000000;}</p>
<p>可以缩写为：</p>
<p>p{color: #000;}</p>
<p>例子2：</p>
<p>p{color: #336699;}</p>
<p>可以缩写为：</p>
<p>p{color: #369;}</p>
<p>13-3<br>字体缩写</p>
<p>网页中的字体css样式代码也有他自己的缩写方式，下面是给网页设置字体的代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-style</span>:italic;</span><br><span class="line">    <span class="attribute">font-variant</span>:small-caps;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">1.5em</span>;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">&quot;宋体&quot;</span>,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么多行的代码其实可以缩写为一句：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>:italic  small-caps  bold  <span class="number">12px</span>/<span class="number">1.5em</span>  <span class="string">&quot;宋体&quot;</span>,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-varient、line-height)如未指定将自动使用默认值。</p>
<p>2、在缩写时 font-size 与 line-height 中间要加入“/”斜扛。</p>
<p>一般情况下因为对于中文网站，英文还是比较少的，所以下面缩写代码比较常用：</p>
<p>body{<br>    font:12px/1.5em  “宋体”,sans-serif;<br>}</p>
<p>只是有字号、行间距、中文字体、英文字体设置。</p>
<p>第二阶段</p>
<p>网页设计特点，<br>宽度可以自适应，长度无限制</p>
<p>2-1一列布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.main&#123;width:800px;height:300px;margin:0 auto;background:#ccc;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>三列布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123; <span class="attribute">width</span>:<span class="number">200px</span>; <span class="attribute">height</span>:<span class="number">600px</span>; <span class="attribute">background</span>:<span class="number">#ccc</span>; <span class="attribute">position</span>:absolute; <span class="attribute">left</span>:<span class="number">0</span>; <span class="attribute">top</span>:<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span>&#123; <span class="attribute">height</span>:<span class="number">600px</span>; <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">200px</span>; <span class="attribute">background</span>:<span class="number">#9CF</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span>&#123; <span class="attribute">height</span>:<span class="number">600px</span>; <span class="attribute">width</span>:<span class="number">200px</span>; <span class="attribute">position</span>:absolute; <span class="attribute">top</span>:<span class="number">0</span>; <span class="attribute">position</span>:absolute;<span class="attribute">right</span>:<span class="number">0</span>; <span class="attribute">background</span>:<span class="number">#FCC</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>w3c倡导<br>倡导结构、样式、行为分离</p>
<p>css中，存在3中定位机制<br>标准文档流(Normal flow)<br>浮动 (Floats)<br>绝对定位(Absolute positioning)</p>
<p>标准文档流<br>特点：从上到下、从左到右、输出文档内容<br>由块级标签和行级标签组成</p>
<p>块级 特点<br>从左到右撑满页面，独占一行；触碰到页面边缘时，会自动换行<br>div,ul,li,dl,dt,p…</p>
<p>行级元素<br>特点：能在同一行内显示，不会改变html文档结构<br>span,strong,img,input</p>
<p>块级元素和行级元素都是盒子模型</p>
<p>如果想让页面自动居中，当设置margin属性为auto时，不能再设置浮动或绝对定位属性</p>
<p>float属性：left,right,none;<br>当元素没有设置宽度值，而设置了浮动属性，元素的宽度随内容的变化而变化。</p>
<p>清除浮动的常用方法<br>clear:both;或clear:left;或clear:right;</p>
<p>同时设置width:100%(或固定高度)+overflow:hidden;<br>清除浮动时，只设置宽度不行，必须设置overflow:hidden;才能实现清除浮动的效果</p>
<p>横向两列布局<br>主要应用技能<br>    float:使纵向排列的块级元素，横向排列<br>    margin属性，设置两列之间的间距<br>当父块包含块2缩成一条时，用clear:both清除浮动无效，它一般用于紧邻后面的元素的清除浮动</p>
<p>position属性</p>
<p>拥有3种定位方式 1.静态定位 2.相对定位  3.绝对定位<br>可以设置4个属性值<br> static （静态定位）<br>    relative （相对定位）<br>    absolute（绝对定位）<br>    fixed（固定定位）</p>
<p>相对定位  特点：相对于自身原有位置进行定位，仍处于标准文档流中，随即拥有偏移属性和z-index属性</p>
<p>  相对于自己本来应该在的位置进行偏移，设置top,left,right,bottom属性。</p>
<p>绝对定位： 特点：建立了以包含块为基准的定位，完全脱离了标准文档流，随即拥有偏移属性和z-inde属性</p>
<p>未设置偏移量<br>特点 无论是否存在已定位祖先元素，都保持在原始位置  脱离了标准文档流</p>
<p>设置偏移量<br> 偏移参照基准<br>        无定位祖先元素，以<code>&lt;html&gt;</code>为偏移参照标准<br>        有已定位祖先元素，以距其最近的已定位祖先元素为偏移参照基准</p>
<p>使用absolute实现横向两列布局<br>        –常用于一列固定长度，另一列宽度自适应的情况<br>  主要技能<br>        relative  氟元素相对定位<br>        absolute  自适应元素绝对定位</p>
<p>   注意 ：固定宽度列的高度&gt;自适应宽度的列</p>
<p> 不设置长宽，用absolute 绝对定位本身就是自适应宽度</p>
<p>网页简单布局之结构与表现</p>
<p>html  css  javascript<br>结构  表现  行为</p>
<p>先按照结构和语义编写代码，然后进行css样式设置，减少html和css的契合度</p>
<p>1/1. 在网页制作中，面对设计图，网页制作人员一般要遵循的原则是什么？<br>C先考虑设计图中的文字内容和内容模块之间的关系，重点放在编写html结构和语义化，然后考虑布局和表现形式。</p>
<p>第二步  案例实现</p>
<p>按钮特效<br>1.1幽灵按钮 透明按钮<br>  css3关键技术点<br>    transform<br>    transition<br>    box-sizing<br>    border-radius</p>
<p>transfrom属性向元素应用2D或3D转换。该元素允许我们对元素进行旋转、缩放、移动或倾斜。</p>
<p>css 雪碧效果</p>
<p>1.原则：<br>1.静态图片，不随用户信息变化而变化</p>
<p>2.小图片，图片容量比较小</p>
<p>一些大图不建议拼成雪碧图</p>
<p>2.目的<br>1.减少 http请求数量</p>
<p>2.加速内容显示</p>
<p>实现原理  background-position</p>
<p>控制一个层，可显示的区域范围大小，</p>
<p>通过一个窗口，进行背景图的滑动</p>
<p>实现方式  1.ps手动拼图，<br>           2.使用sprite工具自动生成</p>
<p>工具  ：cssgaga</p>
<p>css圆角设计<br>    使用css2.0+html标签模拟圆角优缺点分析<br>    1.代码量少，不需要增加http请求<br>    2.后期维护性好，但是圆角像素的增加<br>    3.无意义代码将成倍增加<br>    4.实现的圆角局限性<br>    5.只能实现纯色圆角</p>
<p>css3.0圆角属性<br>border-radius<br>    属性值：表示圆角半径，可使用长度单位px,或百分比<br>    简写属性:border-radius<br>    分量属性：border-top-left-radius(上左)、border-top-right-radius(上右)<br>        border-bottom-right-radius(下右)、border-bottom-left-radius(下左)</p>
<p>属性值设置,与margin相同。<br>    1个，四个角半径相同。2个，互为对角。</p>
<p>浏览器私有前缀</p>
<p>解决浏览器显示差异，针对浏览器写私有前缀<br>       IE内核：-ms-<br>        Firefox内核：-moz-<br>        谷歌浏览器、safari内核:-webkit-</p>
<p>使用dl,dt,dd的原因<br>    语义化，使一些内容在一个dl内，而ul，li做不到un</p>
<p>响应式设计优缺点:<br>    优点：解决了设备之间的差异化展示<br>    缺点:兼容性代码多，工作量大，加载速度受影响<br>        对原有网站布局产生影响，用户判断未必精确<br>设计原则：</p>
<p>移动优先：在设计的初期就要考虑页面如何在多终端展示<br>    渐进增强:充分发挥硬件设备的最大功能<br>如何实现:响应式布局<br>    css3-Media query 最简单的方式<br>    原生javascript  成本高，不推荐使用<br>    第三方开源框架  可以很好的支持浏览器响应式布局</p>
<p>css3-Media Query<br>        常见的属性：<br>            device-width,deivce-height—屏幕宽高<br>            width,height —渲染窗口，展示页面的宽高<br>            orientation —设备方向<br>            resolution—设备分辨率</p>
<h2 id="Yahoo军规"><a href="#Yahoo军规" class="headerlink" title="Yahoo军规"></a>Yahoo军规</h2><p>1.尽可能减少http请求数量<br>2.使用CDN 内容分发网络<br>    在离你最近的地方，放置一台性能好链接顺畅<br>    的副本服务器，让你能够以最近的距离，最快的速度<br>    获取内容。<br>靠money解决问题<br>3.添加expire/Cache-Control头<br>    expire头的内容是一个时间值，<br>    值就是资源在本地的过期时间、存在本地。<br>    在本地缓存阶段，找到一个对应的资源值，<br>    当前时间还没超过资源的过期时间，就直接使用这一个资源，不会发送http请求。<br>    cache-control<br>    是http协议中常用的头部之一，<br>    负责控制页面的缓存机制<br>4.启用Gzip压缩<br>    把文件先放在服务器压缩再传输<br>    html,php,js,css,xml,css<br>5.将css放在页面最上面<br>    放在head中，先进行加载和渲染<br>6.将script放在页面最下面<br>    首先将页面呈现出来，这样页面不会等太久<br>7.避免在css中使用Expressions<br>    css Expressions:css表达式–javascript<br>    页面显示缩放，页面滚动，移动鼠标都会重新计算<br>8.把js和css放到外部文件中<br>        单独提取：<br>            提高了js和css的复用性<br>            减小页面体积<br>            提高了js和css的可维护性<br>    写在页面里<br>            减少页面请求<br>            提升页面渲染速度<br>    写在页面内的情况：<br>        样式只应用于一个页面<br>        不经常被访问到<br>        脚本和样式很少（不多于20行）<br>9.减少dns查询<br>    当缓存时间长时：减少dns的重复查找，节省时间<br>    当缓存时间短时：及时检测网站服务器的变化，保证正确性。<br>    多域，单域<br>10.压缩javascript和css<br>     去除不必要的空白符，格式符，注释符<br>        简写方法名，参数名压缩js脚本<br>11.避免重定向<br>    原始请求被重新转向到了其他请求<br>    301 被移动到了另外的位置(永久重定向)<br>    302 用户所请求的页面找到了，但不在原始位置（临时重定向）<br>  301更智能<br> 12.移除重复脚本<br>  13.配置实体标签(ETag)??<br>14.使用ajax缓存<br>    post每次都执行，不被缓存<br>    get同一地址不重复执行，可以被缓存</p>
<p>14.yslow工具简介<br>    对网站进行分析，给一些建议，规则，<br>    一步步优化网站<br>使用：<br>    按f12会出现在console之后</p>
]]></content>
  </entry>
  <entry>
    <title>Javascript设计模式与开发实践-读书笔记</title>
    <url>/posts/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>读《JavaScript设计模式与开发实践》笔记摘要</p>
<h2 id="设计模式定义"><a href="#设计模式定义" class="headerlink" title="设计模式定义"></a>设计模式定义</h2><p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。<br>通俗的说：<br>设计模式是在某种场合下对某个问题的一种解决方案。<br>设计模式是给面向对象软件开发中的一些好的设计取的名字。</p>
<p>在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。<br>熟悉这些模式 的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到 某种模式作为解决方案。</p>
<a id="more"></a>

<h2 id="设计模式的主题总是把不变的事物和变化的事物分离开"><a href="#设计模式的主题总是把不变的事物和变化的事物分离开" class="headerlink" title="设计模式的主题总是把不变的事物和变化的事物分离开"></a>设计模式的主题总是把不变的事物和变化的事物分离开</h2><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>让人们写出可复用和可维护性高的程序.</p>
<p>所有设计模式都遵循一条原则，即’找出程序中变化的地方，并将变化封装起来’。<br>一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部 分封装起来，那么剩下的就是不变和稳定的部分。<br>这些不变和稳定的部分是非常容易复用的。这 也是设计模式为什么描写的是可复用面向对象软件基础的原因。</p>
<p>设计模式被人误解的一个重要原因是人们对它的误用和滥用，比如将一些模式用在了错误的 场景中，或者说在不该使用模式的地方刻意使用模式。</p>
<h2 id="分辨模式的关键是意图而不是结构"><a href="#分辨模式的关键是意图而不是结构" class="headerlink" title="分辨模式的关键是意图而不是结构"></a>分辨模式的关键是意图而不是结构</h2><p>在设计模式的学习中，有人经常发出这样的疑问:<br>代理模式和装饰者模式，策略模式和状态 模式，策略模式和智能命令模式，这些模式的类图看起来几乎一模一样，它们到底有什么区别?</p>
<p>辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题。</p>
<h2 id="对JavaScript设计模式的误解"><a href="#对JavaScript设计模式的误解" class="headerlink" title="对JavaScript设计模式的误解"></a>对JavaScript设计模式的误解</h2><p>一些资料中对JavaScript模式存在的两个问题:</p>
<ol>
<li><p>第一个问题是习惯把静态类型语言的设计模式照搬到JavaScript中.</p>
<p> 比如有人为了模拟 JavaScript版本的工厂方法(Factory Method)模式，而生硬地把创建对象的步骤延迟到子类中。<br> 实际上，在Java等静态类型语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依赖倒置原则(DIP)。<br> 在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。<br> 而在JavaScript这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另外一个类。<br> JavaScript不存在类型耦合的问题，自然也没有必要刻意去把对象“延迟”到子类创建，也就是说，JavaScript实际上是不需要工厂方法模式的。<br> 模式的存在首先是能为我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既难懂又没什么用处。</p>
</li>
<li><p>另一个问题是习惯根据模式的名字去臆测该模式的一切。</p>
<p> 比如命令模式本意是把请求封装到对象中，利用命令模式可以解开请求发送者和请求接受者之间的耦合关系。<br> 但命令模式经常被人误解为只是一个名为execute的普通方法调用。这个方法除了叫作execute之外，其实并没有看出其他用处。<br> 所以许多人会误会命令模式的意图，以为它其实没什么用处，从而联想到其他设计模式 也没有用处。</p>
</li>
</ol>
<p>这些误解都影响了设计模式在JavaScript语言中的发展。</p>
<p>JavaScript中的原型继承</p>
<ol>
<li><p>所有的数据都是对象</p>
</li>
<li><p>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它<br> JavaScript的根对象是Object.prototype对象。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj1) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj2) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript对象会记住它的原型</p>
</li>
<li><p>如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型</p>
</li>
</ol>
<h2 id="工厂模式列表"><a href="#工厂模式列表" class="headerlink" title="工厂模式列表"></a>工厂模式列表</h2><ol>
<li>抽象工厂模式（Abstract Factory）<br> 定义: 提供一个创建一系列相关或相互依赖对象的接口，而无需制定它们具体的类。<br> 本质: 选择产品簇的实现。</li>
<li>生成器模式（Builder）<br> 定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br> 本质：<pre><code> 分离整体构建算法和部件构造。
 生成器模式的重心在于分离整体构建算法和部件构造，而分步骤构建对象不过是整体构建算法的一个简单实现，或者说是一个附带产物。</code></pre>
</li>
</ol>
<p>生成器模式与抽象工厂模式</p>
<p>这两个模式既相似又有区别，也可以组合使用。<br>    区别：抽象工厂模式的主要目的是创建产品簇，这个产品簇里面的单个产品就相当于是构成一个复杂对象的部件对象，抽象工厂对象创建完成后就立即返回整个产品簇；而生成器模式的主要目的是按照构造算法，一步一步来构建一个复杂的产品对象，桐城要等到整个构建过程结束以后没才会得到最终的产品对象。</p>
<p>组合使用：在生成器模式的Builder实现中，需要创建各个部件对象，而这些部件对象是有关联的，通常是构成一个复杂对象的部件对象。也就是说，Builder实现中，需要获取构成一个复杂对象的产品簇，就可以使用抽象工厂模式来实现。有抽象工厂模式负责部件对象创建，Builder实现里面则主要负责产品对象整体的构建了。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line">    <span class="string">&quot;S&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;B&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">level, salary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strategies[level](salary);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(calculateBonus(<span class="string">&#x27;S&#x27;</span>, <span class="number">20000</span>));</span><br><span class="line"><span class="built_in">console</span>.log(calculateBonus(<span class="string">&#x27;A&#x27;</span>, <span class="number">10000</span>));</span><br><span class="line"><span class="comment">// 输出:80000 // 输出:30000</span></span><br></pre></td></tr></table></figure>

<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。<br>在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。</p>
<p>优点：</p>
<p>一为时间上的解耦<br>二为对象之间的解耦。<br>还可以用来帮助实现一些别的设计模式，比如中介者模式。</p>
<p>缺点:</p>
<p>创建订阅者本身要消耗一定的时间和内存.<br>发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。<br>特别是有多个发布者和订阅者嵌套到一 起的时候，要跟踪一个 bug 不是件轻松的事情。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式: 用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更 小的“孙对象”构成的。</p>
<p>组合对象和叶对象会各自做自己正确的事情。–组合模式最重要的能力</p>
<p>使用场景：<br>    1. 代表对象的部分-整体层次结构。<br>    2. 对树中所有对象统一对待</p>
<p>组合模式可以让我们使用树形方式创建对象的结构，把相同的操作应用在组合对象和单个对象上。大多数情况下可以忽略掉两者的差别，用一致的方式来处理。</p>
<p>缺点：</p>
<p>每个对象看你起来与其他对象差不多，但区别会在运行时显现出来，会让代码难以理解；<br>    如果组合模式创建的对象太多，可能让系统负担不起。</p>
<h2 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式(Template Method)"></a>模板方法模式(Template Method)</h2><p>模板方法模式是一种只需使用继承就可以实现的非常简单的模式。</p>
<p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。<br>通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。<br>子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>
<p>如果子类未实现父类要求实现的方法，可以<code>throw new Error(&#39;子类必须重写xxx方法&#39;)</code>来做检查。</p>
<p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> brew = param.brew || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">&#x27;必须传递 brew 方法&#x27;</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架， 程序员继承框架的结构之后，负责往里面填空，</p>
<p>钩子方法(hook)用来解决一些特殊的子类，不符合父类的执行顺序等。</p>
<h2 id="享元模式-flyweight"><a href="#享元模式-flyweight" class="headerlink" title="享元模式(flyweight)"></a>享元模式(flyweight)</h2><p>是一种用时间换空间的优化模式，为解决性能而生</p>
<p>核心: 运用共享技术来有效支持大量细粒度的对象</p>
<p>目标: 尽量减少共享对象的数量</p>
<p>享元模式要求将对象的属性分为内部状态和外部状态。划分内外部状态规则：</p>
<ul>
<li>内部状态存储于对象内部</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景，通常不会变</li>
<li>外部状态取决于具体的场景，根据场景而变，外部状态不能共享</li>
</ul>
<p>使用场景：</p>
<ul>
<li>一个程序中使用了大量的相似对象</li>
<li>由于使用了大量的相似对象，造成很大的内存开销</li>
<li>对象的大多数状态都可以变为外部状态</li>
<li>剥离出对象的外部状态后，可以用相对较少的共享对象取代大量对象</li>
</ul>
<p>思考：</p>
<p>创建出的共享对象在每次绑定事件后会执行自己的绑定时间还是会覆盖</p>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>定义: 使多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，<br>连着这条链传递该请求，直到有一个对象处理它为止。</p>
<p>把大函数拆成小函数，去掉许多嵌套的条件分支语句</p>
<p>此外 Chain 的 prototype 中还有两个函数，它们的作用如下所示: // Chain.prototype.setNextSuccessor 指定在链中的下一个节点<br>// Chain.prototype.passRequest 传递请求给某个节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Chain = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fn = fn;</span><br><span class="line">    <span class="built_in">this</span>.successor = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params"> successor </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="built_in">this</span>.fn.apply( <span class="built_in">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="keyword">if</span> ( ret === <span class="string">&#x27;nextSuccessor&#x27;</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.successor &amp;&amp; <span class="built_in">this</span>.successor.passRequest.apply( <span class="built_in">this</span>.successor, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> chainOrder500 = <span class="keyword">new</span> Chain( order500 );</span><br><span class="line"><span class="keyword">var</span> chainOrder200 = <span class="keyword">new</span> Chain( order200 );</span><br><span class="line"><span class="keyword">var</span> chainOrderNormal = <span class="keyword">new</span> Chain( orderNormal );</span><br><span class="line"></span><br><span class="line">chainOrder500.setNextSuccessor( chainOrder200 );</span><br><span class="line">chainOrder200.setNextSuccessor( chainOrderNormal);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li><p>解耦了请求发送者和N个接收者之间的复杂关系</p>
</li>
<li><p>链中的节点可以灵活的拆分重组</p>
</li>
<li><p>可以手动指定起始节点</p>
</li>
<li><p>可以在链尾增加一个保底的接受者节点处理前面无法处理的请求</p>
</li>
</ul>
<p>要避免过长的职责链带来的性能损耗</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>通过增加一个中介者对象，所有相关的对象都通过中介者来通信，而不是互相引用。当一个对象发生改变，只需通知中介者。</p>
<p>使网状的多对多关系变成相对简单的一对多关系</p>
<p><strong>作用</strong><br>    解除对象与对象之间的紧耦合关系。</p>
<p><strong>缺点</strong><br>    系统会增加一个中介者对象。对象之间复杂的交互性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身就是一个难以维护的对象。</p>
<p><strong>总结</strong><br>中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>动态的给某个对象添加一些额外的职责，而不会影响这个类中派生的其他对象。</p>
<p>装饰者能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。</p>
<p>传统语言中，给对象添加功能常用继承方式，但继承会带来以下问题:<br>    1. 导致子类和超类之间存在强耦合性， 超类改变，子类也随之改变<br>    2. 继承的复用方式是白箱复用，超类的内部细节对子类可见。继承常常被认为破坏了封装性。<br>    3. 完成功能复用时，有可能创造出大量的子类。</p>
<p>装饰者模式跟继承者模式相比更轻便灵活。</p>
<p>代理者模式和装饰者模式区别</p>
<p>在于他们的意图和设计目的</p>
<p>代理模式的目的是直接访问本体不方便或不需要时，提供一个替代者，本体定义了关键功能。代理者模式强调一种关系(proxy和它本体之间的关系), 这种关系可以静态的表达。这种关系一开始就可以确定。<br>而装饰器模式用于一开始不能确定对象的全部功能时。</p>
<p>代理模式通常只有一层代理-本体的引用，装饰者模式会形成一条长长的链条。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p><strong>定义</strong><br>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
<p>我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。<br>第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这 个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。</p>
<p>状态模式的关键是区分事物内部的状态，事物内部状态的改变，往往会带来事物行为的改变。</p>
<p>把事物的每个状态都封装成单独的类，跟此种状态有关的行为都封装在这个类的内部。<br>要修改时，把请求委托给当前的状态对象即可，该状态对象负责执行相应的方法。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。</li>
<li>避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过 5 多的条件分支。</li>
<li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</li>
<li>Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>会在系统中定义许多状态类，系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>管理 state 对象的创建和销毁。</p>
<p>第一种是仅当 state 对象被需要时才创建并随后销毁，<br>另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。<br>如果 state 对象比较庞大，可以用第一种方式来节省内存，<br>这样可以避免创建一些不会用到的对象并及时地回收它们。</p>
<h3 id="状态模式和策略模式区别"><a href="#状态模式和策略模式区别" class="headerlink" title="状态模式和策略模式区别"></a>状态模式和策略模式区别</h3><p>相同点</p>
<p>它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。</p>
<p>区别</p>
<p>策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， 所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法;而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。<br>两种解决办法，第一种是修改原来的接口实现。<br>第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。</p>
<h3 id="适配器作用"><a href="#适配器作用" class="headerlink" title="适配器作用"></a>适配器作用</h3><p>解决两个软件间的接口不兼容的问题。</p>
<h3 id="适配器和其他模式的区别"><a href="#适配器和其他模式的区别" class="headerlink" title="适配器和其他模式的区别"></a>适配器和其他模式的区别</h3><p>关键仍然是模式的意图</p>
<ul>
<li>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</li>
<li>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</li>
<li>外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外 观模式最显著的特点是定义了一个新的接口。</li>
</ul>
<h2 id="设计原则和编程技巧"><a href="#设计原则和编程技巧" class="headerlink" title="设计原则和编程技巧"></a>设计原则和编程技巧</h2><h2 id="单一职责原则SRP-Single-Responsibility-Principle"><a href="#单一职责原则SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则SRP(Single Responsibility Principle)"></a>单一职责原则SRP(Single Responsibility Principle)</h2><p>一个对象(方法)只做一件事情。</p>
<p>SRP 原则在很多设计模式中都有着广泛的运用，例如代理模式、迭代器模式、单例模式和装饰者模式。</p>
<p>要明确的是，并不是所有的职责都应该一一分离。<br>一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。</p>
<p>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。</p>
<p>在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而 是要取决于具体的应用环境。</p>
<h3 id="SRP-原则的优缺点"><a href="#SRP-原则的优缺点" class="headerlink" title="SRP 原则的优缺点"></a>SRP 原则的优缺点</h3><p>优点</p>
<p>降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度， 这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。</p>
<p>缺点</p>
<p>最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。</p>
<h2 id="最少知识原则-LKP"><a href="#最少知识原则-LKP" class="headerlink" title="最少知识原则(LKP)"></a>最少知识原则(LKP)</h2><p>一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
<p>例如：中介者模式和外观模式。</p>
<p>终结者模式：通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。</p>
<p>外观模式：为一组子系统提供一个简单便利的访问入口, 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。</p>
<p>封装：封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口 API 供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。</p>
<p>虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难 以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则， 要根据具体的环境来定。</p>
<h2 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则(OCP)"></a>开放封闭原则(OCP)</h2><p>当需要改变一个程序的功能或者给这个程序增加新功 能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。</p>
<h3 id="用对象的多态性消除条件分支"><a href="#用对象的多态性消除条件分支" class="headerlink" title="用对象的多态性消除条件分支"></a>用对象的多态性消除条件分支</h3><p>过多的条件分支语句是造成程序违反开放封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。把 if 换成 switch-case 是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。</p>
<p>利用对象的多态性来让程序遵守开放封闭原则，是一个常用的技巧。</p>
<p>找到一些让程序尽量遵守开放封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。</p>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><ol>
<li><p>放置挂钩(hook)<br> 在程序有可能发生变化的地方放置挂钩，挂钩返回的结果决定程序下一步走向。</p>
</li>
<li><p>使用回调函数<br> 策略模式和命令模式等都可以用回调函数轻松实现。</p>
</li>
</ol>
<!-- TODO -->

<h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><ol>
<li><p>提炼函数<br>函数要有良好的命名，函数体内包含的逻辑清晰明了。<br>好处</p>
<ul>
<li>避免出现超大函数。</li>
<li>独立出来的函数有助于代码复用。</li>
<li>独立出来的函数更容易被覆写。</li>
<li>独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。</li>
</ul>
</li>
<li><p>合并重复的条件片段</p>
</li>
<li><p>把条件分支语句提炼成函数</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span> )&#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提炼出来</span></span><br><span class="line"><span class="keyword">var</span> isSummer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSummer) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合理使用循环</p>
</li>
<li><p>提前让函数退出代替嵌套条件分支</p>
</li>
<li><p>传递对象参数代替过长的参数列表<br>可以把参数都放入一个对象内</p>
</li>
<li><p>尽量减少参数数量</p>
</li>
<li><p>少用三目运算符</p>
</li>
<li><p>少用三目运算符</p>
</li>
<li><p>分解大型类</p>
</li>
<li><p>用return退出多重循环</p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/tugenhua0707/p/5198407.html">链接</a></p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>简单的工厂模式可以理解为解决多个相似的问题;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.sex = sex;</span><br><span class="line">    obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> CreatePerson(<span class="string">&quot;longen&quot;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">&quot;tugenhua&quot;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name); <span class="comment">// longen</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age);  <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sex);  <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName()); <span class="comment">// longen</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p2.name);  <span class="comment">// tugenhua</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 27</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.sex);   <span class="comment">// 女</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.sayName()); <span class="comment">// tugenhua  </span></span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>只能被实例化(构造函数给实例添加属性与方法)一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单体模式</span></span><br><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取实例对象</span></span><br><span class="line"><span class="keyword">var</span> getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance) &#123;<span class="comment">//相当于一个一次性阀门,只能实例化一次</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 测试单体模式的实例,所以a===b</span></span><br><span class="line"><span class="keyword">var</span> a = getInstance(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = getInstance(<span class="string">&quot;bb&quot;</span>);  </span><br></pre></td></tr></table></figure>

<h2 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h2><p>将一些函数放到自执行函数里面,但要用闭包暴露接口,用变量接收暴露的接口,再调用里面的值,否则无法使用里面的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sandboxModel=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        sayName:sayName,</span><br><span class="line">        sayAge:sayAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="发布者订阅模式"><a href="#发布者订阅模式" class="headerlink" title="发布者订阅模式"></a>发布者订阅模式</h2><p>就例如如我们关注了某一个公众号,然后他对应的有新的消息就会给你推送,</p>
<p>代码实现逻辑是用数组存贮订阅者, 发布者回调函数里面通知的方式是遍历订阅者数组,并将发布者内容传入订阅者数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发布者与订阅模式</span></span><br><span class="line"><span class="keyword">var</span> shoeObj = &#123;&#125;; <span class="comment">// 定义发布者</span></span><br><span class="line">shoeObj.list = []; <span class="comment">// 缓存列表 存放订阅者回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加订阅者</span></span><br><span class="line">shoeObj.listen = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    shoeObj.list.push(fn); <span class="comment">// 订阅消息添加到缓存列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布消息</span></span><br><span class="line">shoeObj.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="built_in">this</span>.list[i++];) &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);<span class="comment">//第一个参数只是改变fn的this,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 小红订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color, size</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;颜色是：&quot;</span> + color);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;尺码是：&quot;</span> + size);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小花订阅如下消息</span></span><br><span class="line">shoeObj.listen(<span class="function"><span class="keyword">function</span>(<span class="params">color, size</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;再次打印颜色是：&quot;</span> + color);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;再次打印尺码是：&quot;</span> + size);</span><br><span class="line">&#125;);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;红色&quot;</span>, <span class="number">40</span>);</span><br><span class="line">shoeObj.trigger(<span class="string">&quot;黑色&quot;</span>, <span class="number">42</span>);  </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>Javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2 进阶</title>
    <url>/posts/Koa2-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<blockquote>
<p>Koa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。<br>使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。</p>
</blockquote>
<p>前置知识：<br>js,ES6,node ,npm</p>
<a id="more"></a>

<h2 id="第一节-Koa开发环境搭建"><a href="#第一节-Koa开发环境搭建" class="headerlink" title="第一节 Koa开发环境搭建"></a>第一节 Koa开发环境搭建</h2><ol>
<li><p>新建目录</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir koa2Tutorial</span><br><span class="line"><span class="built_in">cd</span> koa2Tutorial</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成package.json 文件</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装koa包</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save koa</span><br></pre></td></tr></table></figure>
</li>
<li><p>coding</p>
<p> 开始编写koa启动代码</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">ctx.body = <span class="string">&#x27;Hello Koa2&#x27;</span>  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
</li>
</ol>
<p>在命令行输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入： localhost:8040就能看到结果了</p>
<h2 id="第2节-async-await-使用方法"><a href="#第2节-async-await-使用方法" class="headerlink" title="第2节 async/await 使用方法"></a>第2节 async/await 使用方法</h2><p>什么是async和await</p>
<p>async是异步的简写</p>
<p>await这里是async await简写</p>
<p>async是声明一个方法是异步的，await是等待异步完成。</p>
<p>注意await必须是在async方法中才可以使用因为await访问本身会造成程序停止，所以必须在异步方法中才可以使用</p>
<h2 id="async-到底起什么作用"><a href="#async-到底起什么作用" class="headerlink" title="async 到底起什么作用"></a>async 到底起什么作用</h2><p>async是让方法变成异步，关键是他的返回值是什么，得到后如何处理？</p>
<p>看一下async方法的返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello Async&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = testAsync()</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p>在终端中运行node testAsync.js，发现返回的是Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node test.js</span><br><span class="line"><span class="built_in">Promise</span> &#123; <span class="string">&#x27;Hello async&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="await在等什么"><a href="#await在等什么" class="headerlink" title="await在等什么"></a>await在等什么</h2><p>await一般是在等async方法执行完毕。但其实await等待的只是一个表达式(Promise对象)，也可以接收普通值。看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;something&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello Async&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething()</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync()</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>上面代码一个是异步函数，一个是普通函数。</p>
<p>可以看到都是直接返回结果。</p>
<h2 id="async-await-同时使用"><a href="#async-await-同时使用" class="headerlink" title="async/await 同时使用"></a>async/await 同时使用</h2><p>通过前面两个例子，已经分别了解到async和await。现在做个虚假的例子，看下等待问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;long_time_value&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="keyword">await</span> takeLongTime()</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<h2 id="第3节-Get请求接收"><a href="#第3节-Get请求接收" class="headerlink" title="第3节 Get请求接收"></a>第3节 Get请求接收</h2><p>这节课看一下Koa如何处理get请求</p>
<h3 id="query和querystring区别"><a href="#query和querystring区别" class="headerlink" title="query和querystring区别"></a>query和querystring区别</h3><p>在Koa2中，Get请求通过request接收，但接收方法有两种：query和querystring。</p>
<ul>
<li>query： 返回的是格式化好的参数对象</li>
<li>querystring： 返回的是请求字符串</li>
</ul>
<p>写个简单的例子看下输出结果。</p>
<p>demo1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> url = ctx.url</span><br><span class="line"> <span class="keyword">let</span> request = ctx.request</span><br><span class="line"> <span class="keyword">let</span> req_query = ctx.request.query</span><br><span class="line"> <span class="keyword">let</span> req_querystring = ctx.request.querystring</span><br><span class="line">   ctx.body = &#123;</span><br><span class="line">    url,</span><br><span class="line">    req_query,</span><br><span class="line">    req_querystring</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码，在body中返回了从ctx中取到的url, request, requeststring.</p>
<p>在终端用node demo1.js启动服务，在浏览器输入查看页面效果</p>
<p><code>http://localhost:8040/?user=admin&amp;age=18</code></p>
<p>页面输出的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;url&quot;</span>:<span class="string">&quot;/?user=admin&amp;age=18&quot;</span>,<span class="string">&quot;req_query&quot;</span>:&#123;<span class="string">&quot;user&quot;</span>:<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>&#125;,<span class="string">&quot;req_querystring&quot;</span>:<span class="string">&quot;user=admin&amp;age=18&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接从ctx中获取Get请求"><a href="#直接从ctx中获取Get请求" class="headerlink" title="直接从ctx中获取Get请求"></a>直接从ctx中获取Get请求</h3><p>上面代码是在ctx.request中获取的request和requeststring，</p>
<p>还可以直接从ctx中得到Get请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> url = ctx.url</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 从 request 中获取GET请求</span></span><br><span class="line"> <span class="keyword">let</span> request = ctx.request</span><br><span class="line"> <span class="keyword">let</span> req_query = ctx.request.query</span><br><span class="line"> <span class="keyword">let</span> req_querystring = ctx.request.querystring</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 从上下文获取GET请求</span></span><br><span class="line"> <span class="keyword">let</span> ctx_query = ctx.query</span><br><span class="line"> <span class="keyword">let</span> ctx_querystring = ctx.querystring</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ctx.body = &#123;</span><br><span class="line">    url,</span><br><span class="line">    req_query,</span><br><span class="line">    req_querystring,</span><br><span class="line">    ctx_query,</span><br><span class="line">    ctx_querystring</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以在浏览器中看效果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>获取GET请求方式有两种</p>
<ol>
<li>从request获取</li>
<li>从ctx中获取。</li>
</ol>
</li>
<li><p>获取的格式也有两种</p>
<ol>
<li>request</li>
<li>requeststring</li>
</ol>
</li>
</ul>
<h2 id="第4节-POST请求如何接收-1"><a href="#第4节-POST请求如何接收-1" class="headerlink" title="第4节 POST请求如何接收(1)"></a>第4节 POST请求如何接收(1)</h2><p>这节学习POST请求的接收方法。</p>
<p>对于POST，Koa2没有封装方便的获取参数方法，需要通过解析上下文context中的原生node.js请求对象req来获取。</p>
<p>获取Post请求的步骤：</p>
<ol>
<li>解析上下文ctx中的原生node.js对象req</li>
<li>将post表单数据解析成query string 字符串。</li>
<li>将字符串转换成JSON</li>
</ol>
<p>ctx.request和ctx.req区别</p>
<ul>
<li>ctx.request:是Koa2中context经过封装的请求对象，用起来更简单直观</li>
<li>ctx.req: 是context提供的node.js原生HTTP请求对象。可以得到更多的内容。</li>
</ul>
<h2 id="ctx-mothed得到的请求类型"><a href="#ctx-mothed得到的请求类型" class="headerlink" title="ctx.mothed得到的请求类型"></a>ctx.mothed得到的请求类型</h2><p>Koa2提供了ctx.method属性，来获取请求类型。根据不同类型编写不同的响应。在工作中很常用。</p>
<p>先做个小例子。根据请求类型获取不同的页面内容。GET请求时得到表单填写页面，POST请求时，得到POST处理页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当请求是get时，显示表单让用户填写</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;form method=&quot;POST&quot;  action=&quot;/&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;input name=&quot;userName&quot; /&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;age&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;input name=&quot;age&quot; /&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;input name=&#x27;webSite&#x27; /&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">        ctx.body = html</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        ctx.body = <span class="string">&#x27;接收到的请求&#x27;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;h1&gt;404&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>写完执行node index.js，在浏览器中输入<code>http://localhost:8040/</code>，第一次展现的是表单页面，点击提交后，返回接收到的请求。输入其他地址，返回404.</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结-4"></a>总结-4</h2><p>这节课理论上学习了如何获取POST请求参数。<br>学习了如何获取请求类型，ctx.method,并编写了一个小案例。</p>
<h2 id="第5节-POST请求如何接收参数-2"><a href="#第5节-POST请求如何接收参数-2" class="headerlink" title="第5节 POST请求如何接收参数(2)"></a>第5节 POST请求如何接收参数(2)</h2><p>这节课具体学习怎么解析POST参数。</p>
<h3 id="解析Node原生POST参数"><a href="#解析Node原生POST参数" class="headerlink" title="解析Node原生POST参数"></a>解析Node原生POST参数</h3><p>先声明一个对象，用Promise对象解析。这里使用ctx.req.on接收事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePostData</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> postData = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            ctx.req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                postData += data</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            ctx.req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                resolve(postData)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改上节接收POST请求的处理方法，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ctx.body = &#x27;接收到的请求&#x27;</span></span><br><span class="line"><span class="keyword">let</span> postData = <span class="keyword">await</span> parsePostData(ctx)</span><br><span class="line">ctx.body = postData</span><br></pre></td></tr></table></figure>

<p>现在，点击提交可以看到返回字符串</p>
<h3 id="POST字符串解析成JSON对象"><a href="#POST字符串解析成JSON对象" class="headerlink" title="POST字符串解析成JSON对象"></a>POST字符串解析成JSON对象</h3><p>上面返回的是字符串，这里写一个封装JSON对象的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseQueryStr</span>(<span class="params">queryStr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queryData = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> queryStrList = queryStr.split(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(queryStrList)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [index, queryStr] <span class="keyword">of</span> queryStrList.entries()) &#123;</span><br><span class="line">        <span class="keyword">let</span> itemList = queryStr.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(itemList, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line">        queryData[itemList[<span class="number">0</span>]] = <span class="built_in">decodeURIComponent</span>(itemList[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queryData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改parsePostData中resolve返回前的调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理post参数，合并为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePostData</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> postData = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            ctx.req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                postData += data</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            ctx.req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> parseData = parseQueryStr(postData)</span><br><span class="line">                resolve(parseData)</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在返回的是json对象。</p>
<h2 id="第6节-koa-bodyparser中间件"><a href="#第6节-koa-bodyparser中间件" class="headerlink" title="第6节 koa-bodyparser中间件"></a>第6节 koa-bodyparser中间件</h2><p>上面已经学会如何自己编写代码接收并解析POST请求。有现成的工具可以直接使用，koa-bodyparser.</p>
<p>这种轮子叫做中间件。对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文呢的formData数据解析到ctx.request.body中</p>
<ol>
<li><p>安装中间件</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save koa-bodyparser</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(bodyParser)</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接用ctx.request.body获取POST请求参数，中间件自动做了解析</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use(bodyParser)  错误写法！！！！！！！！！！！！！！！！！</span></span><br><span class="line">app.use(bodyParser())</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当请求是get时，显示表单让用户填写</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;form method=&quot;POST&quot;  action=&quot;/&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;input name=&quot;userName&quot; /&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;age&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;input name=&quot;age&quot; /&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;input name=&#x27;webSite&#x27; /&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">                &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">        ctx.body = html</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// ctx.body = &#x27;接收到的请求&#x27;</span></span><br><span class="line">        <span class="comment">// 这里是新增的</span></span><br><span class="line">        <span class="keyword">let</span> postData = ctx.request.body</span><br><span class="line">        ctx.body = postData</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.body = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;h1&gt;404&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>注意在引用时，切记 ==app.use(bodyParser())== 中的括号，不写括号会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">koa-bodyparser ctx.onerror is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>

<h2 id="第7节-Koa2原生路由实现"><a href="#第7节-Koa2原生路由实现" class="headerlink" title="第7节 Koa2原生路由实现"></a>第7节 Koa2原生路由实现</h2><p>路由用来根据不同的url切换显示的页面内容。这节课不借助中间件，用原生方法实现简单路由。</p>
<h3 id="ctx-request-url"><a href="#ctx-request-url" class="headerlink" title="ctx.request.url"></a>ctx.request.url</h3><p>要实现路由，需要得到地址栏的请求路径。根据路径的不同进行跳转。</p>
<p>通过一个简单的例子，了解如何通过ctx.request.url来获取访问路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser())</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> url = ctx.request.url</span><br><span class="line">    ctx.body = url</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>)</span><br></pre></td></tr></table></figure>

<p>这时，访问<code>http://localhost:8040/demo</code>,页面输出/demo。</p>
<p>根据这个，可以获取到不同的请求链接。</p>
<h3 id="原生路由实现"><a href="#原生路由实现" class="headerlink" title="原生路由实现"></a>原生路由实现</h3><p>大体思路：</p>
<ol>
<li>根据传入的url，选择对应的页面名称</li>
<li>调用fs读取文件，将文件内容传给ctx.body。</li>
<li>页面显示</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>case中写选项时，要注意url的全路径，刚开始写的’todo’, ‘404’ 这是不生效的，<br>要写成’/todo’, ‘/404’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> url = ctx.request.url</span><br><span class="line"></span><br><span class="line">    ctx.body = <span class="keyword">await</span> router(url)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">router</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> page = <span class="string">&#x27;404.html&#x27;</span></span><br><span class="line">    <span class="keyword">switch</span>(url) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            page = <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/index&#x27;</span>:</span><br><span class="line">            page = <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/todo&#x27;</span>:</span><br><span class="line">            page = <span class="string">&#x27;todo.html&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/404&#x27;</span>:</span><br><span class="line">            page = <span class="string">&#x27;404.html&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用异步来接收html，防止页面卡死</span></span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> render(page)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> pageUrl = <span class="string">`./page/<span class="subst">$&#123;page&#125;</span>`</span></span><br><span class="line">        fs.readFile(pageUrl, <span class="string">&#x27;UTF-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结-7"></a>总结-7</h2><p>这节课了解了如何原生实现路由。</p>
<h2 id="第8节-Koa-router中间件入门-1"><a href="#第8节-Koa-router中间件入门-1" class="headerlink" title="第8节 Koa-router中间件入门(1)"></a>第8节 Koa-router中间件入门(1)</h2><p>上节写的路由只是很简单的例子，实际项目中都会用开源的中间件来完成路由配置。</p>
<p>这节课用koa-router来实现。</p>
<h2 id="1-安装koa-router"><a href="#1-安装koa-router" class="headerlink" title="1. 安装koa-router"></a>1. 安装koa-router</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save koa-router</span><br></pre></td></tr></table></figure>

<h2 id="2-koa-router基础案例"><a href="#2-koa-router基础案例" class="headerlink" title="2. koa-router基础案例"></a>2. koa-router基础案例</h2><p>先写一个最简单的koa-router例子。</p>
<ol>
<li>引入</li>
<li>新建一个实例</li>
<li>不同路由配置</li>
<li>use</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello Koa2&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes())</span><br><span class="line">    .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="多页面配置"><a href="#多页面配置" class="headerlink" title="多页面配置"></a>多页面配置</h3><p>多页面配置，只需要加get,post即可。现在增加一个todo页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello Koa2&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="string">&#x27;/todo&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Todo Page&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(router.routes())</span><br><span class="line">    .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分别访问<code>http://localhost:8040</code> 和<code>http://localhost:8040/todo</code>，可以看到不同的结果。</p>
<h2 id="第9节-Koa-router中间件-层级-2"><a href="#第9节-Koa-router中间件-层级-2" class="headerlink" title="第9节 Koa-router中间件 层级(2)"></a>第9节 Koa-router中间件 层级(2)</h2><h3 id="设置前缀"><a href="#设置前缀" class="headerlink" title="设置前缀"></a>设置前缀</h3><p>有时需要把所有路径前加一个层级，例如， <code>http://localhost:8040/todo</code> 加一个demo层级，变成<code>http://localhost:8040/demo/todo</code>.</p>
<p>路由在创建时可以指定一个前缀。这个前缀会被添加到路由最顶层。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    prefix: <span class="string">&#x27;/demo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问：</p>
<p><code>http://localhost:8040/demo/todo</code></p>
<p><code>http://localhost:8040/demo</code></p>
<p>可以看到页面，访问原来的路径，会提示Not Found</p>
<h3 id="路由层级"><a href="#路由层级" class="headerlink" title="路由层级"></a>路由层级</h3><p>上面是为全局设置层级，这里为单个页面设置层级，只要在use时，使用路径就可以了。</p>
<p>这里演示两个不同层级的路由设置。一个是home,一个是page,通过use赋予不同的前层级。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用koa-router</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个单独的路由</span></span><br><span class="line"><span class="keyword">let</span> home = <span class="keyword">new</span> Router()</span><br><span class="line">home.get(<span class="string">&#x27;/koa&#x27;</span>, <span class="keyword">async</span>(ctx) =&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello Koa&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="string">&#x27;/todo&#x27;</span>, <span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;learning Koa&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> page = <span class="keyword">new</span> Router()</span><br><span class="line">page.get(<span class="string">&#x27;/koa&#x27;</span>, <span class="keyword">async</span>(ctx) =&gt;&#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello Koa Page&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.get(<span class="string">&#x27;/todo&#x27;</span>, <span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;learning Koa Page&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载所有子路由</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router()</span><br><span class="line">router.use(<span class="string">&#x27;/home&#x27;</span>, home.routes(), home.allowedMethods())</span><br><span class="line">router.use(<span class="string">&#x27;/page&#x27;</span>, page.routes(), page.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载路由中间件</span></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>分别访问<code>/home/todo</code>,<code>/home/koa</code>,<code>/page/todo</code>, <code>/page/koa</code>可以看到结果。</p>
<h2 id="第10节-Koa-router-中间件参数-3"><a href="#第10节-Koa-router-中间件参数-3" class="headerlink" title="第10节 Koa-router 中间件参数 (3)"></a>第10节 Koa-router 中间件参数 (3)</h2><p>这节学习如何传参</p>
<p>用ctx.query接收参数</p>
<h2 id="第11节-Koa中使用Cookie"><a href="#第11节-Koa中使用Cookie" class="headerlink" title="第11节 Koa中使用Cookie"></a>第11节 Koa中使用Cookie</h2><p>这节学习操作cookie。</p>
<p>Koa的上下文(ctx)直接提供了读取和写入的方法。</p>
<ul>
<li>ctx.cookies.get(name, [options]): 读取cookie</li>
<li>ctx.cookies.set(name, value, [options]): 写入cookie</li>
</ul>
<p>这里的cookie是写入浏览器中了</p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作cookie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.url === <span class="string">&#x27;/index&#x27;</span>)&#123;</span><br><span class="line">        ctx.cookies.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Hello Koa&#x27;</span>)</span><br><span class="line">        ctx.body = <span class="string">&#x27;cookie is set.&#x27;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ctx.body = <span class="string">&#x27;Hello Koa&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8040</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8040/index</code> ，按F12可以看到cookies</p>
<h3 id="Cookie选项"><a href="#Cookie选项" class="headerlink" title="Cookie选项"></a>Cookie选项</h3><p>一些配置项</p>
<ul>
<li>domain: cookie所在域名</li>
<li>path: 所在路径</li>
<li>maxAge: 最大有效时长</li>
<li>expires: cookie失效时间</li>
<li>httpOnly: 是否只从http请求中获取</li>
<li>overwrite: 是否允许重写</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.cookies.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Hello Koa&#x27;</span>,&#123;</span><br><span class="line">    domain:<span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 写cookie所在的域名</span></span><br><span class="line">    path:<span class="string">&#x27;/index&#x27;</span>,       <span class="comment">// 写cookie所在的路径</span></span><br><span class="line">    maxAge:<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>,   <span class="comment">// cookie有效时长</span></span><br><span class="line">    expires:<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2018-12-31&#x27;</span>), <span class="comment">// cookie失效时间</span></span><br><span class="line">    httpOnly:<span class="literal">false</span>,  <span class="comment">// 是否只用于http请求中获取</span></span><br><span class="line">    overwrite:<span class="literal">false</span>  <span class="comment">// 是否允许重写</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h3><p>用ctx.cookies.get()来读取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ctx.cookies.get(<span class="string">&#x27;name&#x27;</span>))&#123;</span><br><span class="line">    ctx.body = ctx.cookies.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;No cookie is set~~&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果上面的path设置的是index的话，访问localhost:8040是获取不到name这个cookie的,<br>需要将path设为’’</p>
<h2 id="第12节-Koa2-的模板初识-ejs"><a href="#第12节-Koa2-的模板初识-ejs" class="headerlink" title="第12节 Koa2 的模板初识 (ejs)"></a>第12节 Koa2 的模板初识 (ejs)</h2><p>开发不可能把所有的html代码全加载到JS里，也没办法完成大型web开发。必须借用模板来帮助我们开发。</p>
<p>这节简单了解一下Koa2的模板机制。需要靠中间件来完成开发。</p>
<h3 id="安装中间件"><a href="#安装中间件" class="headerlink" title="安装中间件"></a>安装中间件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save koa-views</span><br></pre></td></tr></table></figure>

<h3 id="安装-ejs-模板引擎"><a href="#安装-ejs-模板引擎" class="headerlink" title="安装 ejs 模板引擎"></a>安装 ejs 模板引擎</h3><p>ejs是著名并且强大的模板引擎，可以单独安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save ejs</span><br></pre></td></tr></table></figure>

<h3 id="编写模板"><a href="#编写模板" class="headerlink" title="编写模板"></a>编写模板</h3><p>为了模板统一管理，新建一个view文件夹，并新建index.ejs文件</p>
<p>views/index.ejs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 引用ejs模板</span><br><span class="line"></span><br><span class="line">const Koa = require(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line">const views = require(<span class="string">&#x27;koa-views&#x27;</span>)</span><br><span class="line">const path = require(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">app.use(views(path.join(__dirname, <span class="string">&#x27;./views&#x27;</span>), &#123;</span><br><span class="line">    extension: <span class="string">&#x27;ejs&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use(async(ctx)=&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> title = <span class="string">&#x27;Hello Koa2&#x27;</span></span><br><span class="line">    await ctx.render(<span class="string">&#x27;index&#x27;</span>, &#123;</span><br><span class="line">        title</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(8040, ()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结-12"></a>总结-12</h2><p>这里只是简单的讲解了koa2的模板机制。</p>
<h2 id="第13节：-koa-static静态资源中间件"><a href="#第13节：-koa-static静态资源中间件" class="headerlink" title="第13节： koa-static静态资源中间件"></a>第13节： koa-static静态资源中间件</h2><p>开发中不只要处理业务逻辑请求，也会有很多静态资源请求，如js, css, jpg, png 这些静态请求。有时候也会访问静态资源路径</p>
<p>用koa可以直接访问这些静态文件，但代码会冗长，这节课利用 koa-static 来实现静态资源访问。</p>
<h3 id="安装koa-static"><a href="#安装koa-static" class="headerlink" title="安装koa-static"></a>安装koa-static</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save koa-static</span><br></pre></td></tr></table></figure>

<h3 id="新建-static-文件夹"><a href="#新建-static-文件夹" class="headerlink" title="新建 static 文件夹"></a>新建 static 文件夹</h3><p>在static文件夹中放js, css, img<br>koa.png, test.js, style.css</p>
<h3 id="使用koa-static"><a href="#使用koa-static" class="headerlink" title="使用koa-static"></a>使用koa-static</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用静态资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">&#x27;./static&#x27;</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">static</span>(path.join(__dirname, staticPath)))</span><br><span class="line"></span><br><span class="line">app.use( <span class="keyword">async</span> ( ctx ) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;访问静态资源试试 koa.png, test.js, style.css&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">app.listen(<span class="number">8040</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start quick is starting at port 8040&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问：</p>
<p><code>&lt;http://localhost:8040/style.css&gt;</code></p>
<p><code>&lt;http://localhost:8040/test.js&gt;</code></p>
<p><code>&lt;http://localhost:8040/koa.png&gt;</code></p>
]]></content>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native入门</title>
    <url>/posts/React%20Native%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><ul>
<li>Android studio</li>
<li>python2</li>
<li>java sdk 并配置java环境变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g react-native</span><br><span class="line">npm install -g react-native-cli</span><br></pre></td></tr></table></figure>

<!---more--->

<h2 id="启动虚拟器"><a href="#启动虚拟器" class="headerlink" title="启动虚拟器"></a>启动虚拟器</h2><p>avd 是灰色 无法点击<br>配置AndroidSDK tools到path变量<br>删除.android文件，重新导入，即可</p>
<h2 id="如果打包失败报错"><a href="#如果打包失败报错" class="headerlink" title="如果打包失败报错"></a>如果打包失败报错</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Error</span>:Execution failed <span class="keyword">for</span> task <span class="string">&#x27;:app:transformClassesWithInstantRunForAcproductionDebug&#x27;</span>.</span><br><span class="line">&gt; Invalid signature file digest <span class="keyword">for</span> Manifest main attributes</span><br></pre></td></tr></table></figure>

<p>在android studio中的settings搜instant run，将enable instant run to hot swap关闭，取消选中。</p>
<h2 id="调试js"><a href="#调试js" class="headerlink" title="调试js"></a>调试js</h2><p>打开模拟器后，按Ctrl+M,（ios按ctrl+D）</p>
<p>选择debug remote js.</p>
<p>浏览器会自动打开一个窗口，在那个窗口中按ctrl+shift+J ，在console窗口会看到打印出来的信息。</p>
<p>选择 Enable Hot Reloading,可以开启热加载</p>
<p>按(r,r) 刷新，（ios按command+r）</p>
<h2 id="如果android模拟器无法连接本地服务"><a href="#如果android模拟器无法连接本地服务" class="headerlink" title="如果android模拟器无法连接本地服务"></a>如果android模拟器无法连接本地服务</h2><p>按ctrl+ M dev Setting</p>
<p>Debug server host &amp; port for device</p>
<p>设置IP:8081</p>
<h2 id="联调硬件"><a href="#联调硬件" class="headerlink" title="联调硬件"></a>联调硬件</h2><ol>
<li>先要给设备配网(按中间的按钮 5s)</li>
<li>然后绑定设备</li>
</ol>
<h2 id="react-native-绑定事件"><a href="#react-native-绑定事件" class="headerlink" title="react native 绑定事件"></a>react native 绑定事件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">onPressSwitch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;changed&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> status =  <span class="built_in">this</span>.props.powerStatus</span><br><span class="line">    status == <span class="string">&#x27;off&#x27;</span> ? status = <span class="string">&#x27;on&#x27;</span> : status = <span class="string">&#x27;off&#x27;</span></span><br><span class="line">     <span class="built_in">this</span>.props.callbackPowerChanged(status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--之前的绑定事件是要用bind的 --&gt;</span><br><span class="line"></span><br><span class="line"> &lt;TouchableOpacity onPress=&#123;<span class="built_in">this</span>.onPressSwitch.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">        &lt;Image  source=&#123;<span class="built_in">require</span>(<span class="string">&#x27;../../assets/light-close.png&#x27;</span>)&#125;/&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.switchInfo&#125;&gt;轻触开启&lt;/Text&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure>

<p>用es6的箭头函数之后，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--这里是箭头函数--&gt;</span><br><span class="line">onPressSwitch = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;changed&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> status =  <span class="built_in">this</span>.props.powerStatus</span><br><span class="line">    status == <span class="string">&#x27;off&#x27;</span> ? status = <span class="string">&#x27;on&#x27;</span> : status = <span class="string">&#x27;off&#x27;</span></span><br><span class="line">     <span class="built_in">this</span>.props.callbackPowerChanged(status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是用新的绑定 ，不要bind ，==[正确的写法]==</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> &lt;TouchableOpacity onPress=&#123;<span class="built_in">this</span>.onPressSwitch&#125;&gt;</span><br><span class="line">        &lt;Image  source=&#123;<span class="built_in">require</span>(<span class="string">&#x27;../../assets/light-close.png&#x27;</span>)&#125;/&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.switchInfo&#125;&gt;轻触开启&lt;/Text&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure>

<p>需要传参的写法 ==[传参的写法]==</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;TouchableOpacity onPress=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.onPressSwitch(item)&#125;&gt;</span><br><span class="line">    &lt;Image  source=&#123;getPicture(<span class="string">&#x27;switch-&#x27;</span>+item.status)&#125;/&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure>

<p>如果不传参的话，不能写为空如下：  ==[错误的写法]==</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;TouchableOpacity onPress=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.onPressSwitch&#125;&gt;</span><br><span class="line">    &lt;Image  source=&#123;getPicture(<span class="string">&#x27;switch-&#x27;</span>+item.status)&#125;/&gt;</span><br><span class="line">&lt;/TouchableOpacity&gt;</span><br></pre></td></tr></table></figure>

<p>这样会无法进入点击事件！！！！！</p>
<p>解决办法就是不用() =&gt; {}</p>
<p>改用[正确的写法]</p>
<h2 id="setState-语法"><a href="#setState-语法" class="headerlink" title="setState 语法"></a>setState 语法</h2><p>setState括号里必须是个对象，不是会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="string">&#x27;item&#x27;</span>: newItem&#125;)</span><br></pre></td></tr></table></figure>

<p>报错信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setState(...): takes an object <span class="keyword">of</span> state variables to update or a <span class="function"><span class="keyword">function</span> <span class="title">which</span> <span class="title">returns</span> <span class="title">an</span> <span class="title">object</span> <span class="title">of</span> <span class="title">state</span> <span class="title">variables</span>.</span></span><br></pre></td></tr></table></figure>

<h2 id="父与子组件传值"><a href="#父与子组件传值" class="headerlink" title="父与子组件传值"></a>父与子组件传值</h2><p>在父组件中定义props。通过props传入子组件中。</p>
<h3 id="父组件传给子组件"><a href="#父组件传给子组件" class="headerlink" title="父组件传给子组件"></a>父组件传给子组件</h3><p>父组件调用子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ControlArea powerStatus=&#123;<span class="built_in">this</span>.state.powerStatus&#125; callbackPowerChanged=&#123;<span class="built_in">this</span>.changePowerStatus.bind(<span class="built_in">this</span>)&#125;&gt;&lt;/ControlArea&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中powerSatatus是props，callbackPowerChanged是供子组件调用的方法。<br>changePowerStatus是在父组件中供子组件调用时执行的方法。</p>
<h3 id="子组件调用父组件"><a href="#子组件调用父组件" class="headerlink" title="子组件调用父组件"></a>子组件调用父组件</h3><p>子组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onPressSwitch = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;changed&#x27;</span>)</span><br><span class="line">   <span class="keyword">let</span> status =  <span class="built_in">this</span>.props.powerStatus</span><br><span class="line">   status == <span class="string">&#x27;off&#x27;</span> ? status = <span class="string">&#x27;on&#x27;</span> : status = <span class="string">&#x27;off&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;!--这个是调用父组件的方法。把修改后的状态值传给父组件，供父组件修改状态，父组件修改状态后，子组件会自动根据状态值更新页面。--&gt;</span><br><span class="line">    <span class="built_in">this</span>.props.callbackPowerChanged(status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>有些数据既可以放在pros，又可以放在state中，那么建议不要放在state中，</p>
<p>子组件修改props需调用父组件的方法，体现了从上至下的数据流</p>
<h2 id="根据数组，循环生成dom"><a href="#根据数组，循环生成dom" class="headerlink" title="根据数组，循环生成dom"></a>根据数组，循环生成dom</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View style=&#123;[styles.topCon]&#125;&gt;</span><br><span class="line">    &#123;<span class="built_in">this</span>.props.dataList.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;TouchableOpacity key=&#123;index&#125; onPress=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.onPressSwitch(item)&#125;&gt;</span><br><span class="line">            &lt;Image  source=&#123;getPicture(<span class="string">&#x27;switch-&#x27;</span>+item.status)&#125;/&gt;</span><br><span class="line">            &lt;Text style=&#123;styles.itemText&#125;&gt;&#123;item.name&#125;&gt;&lt;/Text&gt;</span><br><span class="line">        &lt;/TouchableOpacity&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">&lt;/View&gt;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>this.props.dataList是父组件传给子组件的数据。</p>
</li>
<li><p>循环数据用的map</p>
</li>
<li><p>一定要有key键值，否则报错</p>
</li>
<li><p>注意绑定事件的写法，会将当前循环的元素传给事件。注意箭头函数写法。</p>
</li>
</ul>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>使用的是v0.50,官方推荐使用React Navigation</p>
<p>如果之前用的是其他路由，没有办法，只能全部换成这个了。</p>
<h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>如果一时半会看不明白的话，可以先照着官网和其他人的示例先做一个简单的出来，然后照着改项目里的代码。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><h4 id="1-初始化导航后，需要给初始的组件传值"><a href="#1-初始化导航后，需要给初始的组件传值" class="headerlink" title="1. 初始化导航后，需要给初始的组件传值"></a>1. 初始化导航后，需要给初始的组件传值</h4><p>看文档好不容易找到了screenProps.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;SimpleApp</span><br><span class="line">  screenProps=&#123;&#123;<span class="attr">tintColor</span>: <span class="string">&#x27;blue&#x27;</span>&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>在组件内取值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;</span><br><span class="line">    <span class="comment">// deviceInfo: JSON.parse(this.props.deviceInfoStr), 其他路由的取值</span></span><br><span class="line">    pageConfig: <span class="built_in">JSON</span>.parse(<span class="built_in">this</span>.props.screenProps.pageConfigStr),</span><br><span class="line">    deviceInfo: <span class="built_in">JSON</span>.parse(<span class="built_in">this</span>.props.screenProps.deviceInfoStr),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-路由跳转"><a href="#2-路由跳转" class="headerlink" title="2. 路由跳转"></a>2. 路由跳转</h4><p>目前测试只能这样写，将navigate提取出来好像不可以。以后需做测试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; navigate &#125; = <span class="built_in">this</span>.props.navigation;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;Hello, Chat App!&lt;/Text&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            onPress=&#123;<span class="function">() =&gt;</span> navigate(<span class="string">&#x27;Chat&#x27;</span>)&#125;</span><br><span class="line">            title=<span class="string">&quot;Chat with Lucy&quot;</span></span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-导航跳转到的组件是父页面，-而子页面中想用导航的navigation，此时是无法用的，-需要在父组件中将navigation传给子组件，这样，子组件就可以用父组件的navigation"><a href="#3-导航跳转到的组件是父页面，-而子页面中想用导航的navigation，此时是无法用的，-需要在父组件中将navigation传给子组件，这样，子组件就可以用父组件的navigation" class="headerlink" title="3. 导航跳转到的组件是父页面， 而子页面中想用导航的navigation，此时是无法用的，    需要在父组件中将navigation传给子组件，这样，子组件就可以用父组件的navigation"></a>3. 导航跳转到的组件是父页面， 而子页面中想用导航的navigation，此时是无法用的，    需要在父组件中将navigation传给子组件，这样，子组件就可以用父组件的navigation</h4><p>父组件中调用子组件，并把navigation传给子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Content pageConfig=&#123;<span class="built_in">this</span>.state.pageConfig&#125;</span><br><span class="line">    navigation = &#123;<span class="built_in">this</span>.state.navigation&#125;</span><br><span class="line">    callbackPowerChanged=&#123;<span class="built_in">this</span>.changePowerStatus.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>在子组件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; navigate &#125; = <span class="built_in">this</span>.props.navigation</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;View style=&#123;[styles.container]&#125;&gt;</span><br><span class="line">            &lt;TouchableOpacity onPress=&#123;<span class="function">() =&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.props, <span class="string">&#x27;click&#x27;</span>); navigate(<span class="string">&#x27;Detail&#x27;</span>, &#123;<span class="attr">info</span>: <span class="string">&#x27;这是传入的参数&#x27;</span>&#125;)&#125;&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.itemText&#125;&gt;啊啊&lt;/Text&gt;</span><br><span class="line">            &lt;/TouchableOpacity&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-返回上一级"><a href="#4-返回上一级" class="headerlink" title="4. 返回上一级"></a>4. 返回上一级</h4><p>注意，用之前确保有navigation这个属性，没有的话看上面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">goBack = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.navigation.goBack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在按钮上加事件</span></span><br><span class="line">onPress=&#123;<span class="built_in">this</span>.goBack&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-无关组件间传值"><a href="#3-无关组件间传值" class="headerlink" title="3.无关组件间传值"></a>3.无关组件间传值</h2><p>官方文档只找到这句话：</p>
<p>JavaScript模块可以通过使用DeviceEventEmitter模块来监听事件：</p>
<ol>
<li><p>引用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; View, DeviceEventEmitter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>监听事件</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subSwitchEmitter = DeviceEventEmitter.addListener(<span class="string">&#x27;subSwitch&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.changePowerStatus(e.item)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 修改子页面名称用</span></span><br><span class="line">    <span class="built_in">this</span>.modifyItemEmitter = DeviceEventEmitter.addListener(<span class="string">&#x27;modifyItemProp&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.modifyItemProp(e.item)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发监听事件，发出通知</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DeviceEventEmitter.emit(<span class="string">&#x27;subSwitch&#x27;</span>, &#123;<span class="attr">item</span>: <span class="built_in">this</span>.state.item&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除监听</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 移除所有的事件</span></span><br><span class="line">    DeviceEventEmitter.remove();</span><br><span class="line">    <span class="comment">// 单个移除</span></span><br><span class="line">    <span class="built_in">this</span>.subSwitchEmitter.remove();</span><br><span class="line">    <span class="built_in">this</span>.modifyItemEmitter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ref的使用"><a href="#ref的使用" class="headerlink" title="ref的使用"></a>ref的使用</h2><ol>
<li>父传子，通过ref</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义ref</span></span><br><span class="line">&lt;SonCompoent ref=<span class="string">&quot;son&quot;</span> /&gt;</span><br><span class="line"><span class="comment">// 获取子组件，执行指定方法，方法参数中传值</span></span><br><span class="line"><span class="built_in">this</span>.refs.son.receiveMoney(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>Ref 使用场景</p>
<ol>
<li>触发焦点，文本选择，媒体播放</li>
<li>触发强制性动画</li>
<li>集成第三方DOM库</li>
</ol>
<p>给DOM 添加Refs,</p>
<p><a href="https://www.jianshu.com/p/e5edfedc57a9">参考</a></p>
<h2 id="弹框"><a href="#弹框" class="headerlink" title="弹框"></a>弹框</h2><p>用Modal组件</p>
<h2 id="mac配置连接windows的服务"><a href="#mac配置连接windows的服务" class="headerlink" title="mac配置连接windows的服务"></a>mac配置连接windows的服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSURL *jsCodeLocation;</span><br><span class="line"></span><br><span class="line">[[RCTBundleURLProvider sharedSettings] setDefaults];</span><br><span class="line">#if DEBUG</span><br><span class="line">[[RCTBundleURLProvider sharedSettings] setJsLocation:@&quot;192.168.1.101&quot;];</span><br><span class="line">#endif</span><br><span class="line">jsCodeLocation &#x3D; [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil];</span><br></pre></td></tr></table></figure>

<h2 id="reactnative-有的按钮点击事件无法触发"><a href="#reactnative-有的按钮点击事件无法触发" class="headerlink" title="reactnative 有的按钮点击事件无法触发"></a>reactnative 有的按钮点击事件无法触发</h2><p>可能原因是布局问题，先给要点击的元素加边框，看所在位置，</p>
<p>再确认有没有其他元素占用了他的位置，遮挡在他上面了，导致无法点击。</p>
<h2 id="ios调试一直报无法连接package-server，其实packageserver已经启动"><a href="#ios调试一直报无法连接package-server，其实packageserver已经启动" class="headerlink" title="ios调试一直报无法连接package server，其实packageserver已经启动"></a><code>ios</code>调试一直报无法连接<code>package server</code>，其实packageserver已经启动</h2><p>解决办法： 重新安装APP.</p>
<h2 id="setState设置状态后，直接console-log获取到的还是旧数据"><a href="#setState设置状态后，直接console-log获取到的还是旧数据" class="headerlink" title="setState设置状态后，直接console.log获取到的还是旧数据"></a>setState设置状态后，直接console.log获取到的还是旧数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="attr">data</span>:data&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.state.data);</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<p>setstate后，获取的数据还是旧的<br>原因：</p>
<p>1.setState异步调用<br>2. 批量处理 并不是调用一次就会更新一次render</p>
<p>setState之后，需要走完RN生命周期，也就是走到render时，state的值才会变成setState的值，要立即使用state的值，需要在回调中使用</p>
<p>正确写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(state,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;<span class="string">&#x27;dataList&#x27;</span>: <span class="built_in">this</span>.state.lastStatus&#125;, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.dataList, <span class="string">&#x27;回调&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.changeBgColor();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第二种办法"><a href="#第二种办法" class="headerlink" title="第二种办法"></a>第二种办法</h3><p>在store中定义，根据action请求返回的值 ，根据逻辑处理需要显示的值</p>
<h2 id="mac调试总是提示：Xcode-Error输出"><a href="#mac调试总是提示：Xcode-Error输出" class="headerlink" title="mac调试总是提示：Xcode Error输出"></a>mac调试总是提示：Xcode Error输出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Runtime is not ready <span class="keyword">for</span> debugging. Make sure Packager server is running.</span><br></pre></td></tr></table></figure>

<p>解决办法</p>
<p>在RCTWebSocketExecutor.m文件中，把localhost修改为与AppDelegate.m中相同的IP地址(一般为电脑IP).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *host &#x3D; [[_bridge bundleURL] host] ?: @&quot;localhost;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *host &#x3D; [[_bridge bundleURL] host] ?: @&quot;172.16.126.97&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="http://www.jianshu.com/p/90ceb04da552">http://www.jianshu.com/p/90ceb04da552</a></p>
<h3 id="上行-下行"><a href="#上行-下行" class="headerlink" title="上行 下行"></a>上行 下行</h3><p>设备发给云端 设备上报 上行</p>
<p>app或者云端给设备发消息属于下行</p>
<h2 id="修改为redux后，思路整理"><a href="#修改为redux后，思路整理" class="headerlink" title="修改为redux后，思路整理"></a>修改为redux后，思路整理</h2><p>我有一个state(deviceData),设备端有个对应的state,<br>deviceProperty 也有个对应的state,</p>
<p>然后三者要统一。</p>
<p>先在deviceProperty中根据设备返回的设置一模一样的参数，<br>，然后等上报以后根据不同的值，再整理值放到state中。</p>
<p>页面渲染，根据deviceProperty进行渲染。</p>
<p>最终结果，都放到了deviceProperty中了。</p>
<h2 id="引入Redux后数据处理逻辑"><a href="#引入Redux后数据处理逻辑" class="headerlink" title="引入Redux后数据处理逻辑"></a>引入Redux后数据处理逻辑</h2><h3 id="原来用父子组件处理state"><a href="#原来用父子组件处理state" class="headerlink" title="原来用父子组件处理state"></a>原来用父子组件处理state</h3><ol>
<li>父组件中存有父组件相关的state, 子组件相关的state,</li>
<li>子组件用父组件中的state时，父组件通过prop传给子组件</li>
<li>子组件要修改父组件时，通过父组件传递过来的事件，调用父组件定义好的事件，由父组件更改状态， 子组件自动更新</li>
<li>子组件中可以有一套自己的state</li>
</ol>
<h2 id="redux的数据处理逻辑"><a href="#redux的数据处理逻辑" class="headerlink" title="redux的数据处理逻辑"></a>redux的数据处理逻辑</h2><ol>
<li><p>所有的数据都在store中定义好,可以有不同的对象</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    deviceInfo: &#123;</span><br><span class="line">        deviceId: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    deviceProperty: &#123;</span><br><span class="line">        id: <span class="number">0</span>,</span><br><span class="line">        timestamp: <span class="number">0</span>,</span><br><span class="line">        finalColor: <span class="string">&#x27;rgba(56,171,193,0.90)&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> initState</span><br></pre></td></tr></table></figure>

<p> 在store中引用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducers,</span><br><span class="line">    initState,</span><br><span class="line">    applyMiddleware(</span><br><span class="line">        thunk,</span><br><span class="line">        createPromise(),</span><br><span class="line">        createLogger()</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
</li>
<li><p>要更改store中的数据，都通过action去调用事件触发</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> powerOn = <span class="function">(<span class="params">subDomainName, physicalDeviceId, command</span>) =&gt;</span> (&#123;</span><br><span class="line">    type: types.powerOn,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        promise: BindManager.sendDevice(</span><br><span class="line">            subDomainName,</span><br><span class="line">            physicalDeviceId,</span><br><span class="line">            &#123;</span><br><span class="line">                code: command.code,</span><br><span class="line">                content: <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(command.content)</span><br><span class="line">            &#125;</span><br><span class="line">        ),</span><br><span class="line">        data: &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>action请求回调返回结果，根据返回成功失败，在reducer中分别处理store中的数据。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">`<span class="subst">$&#123;types.powerOn&#125;</span>_PENDING`</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        isFetching: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">`<span class="subst">$&#123;types.powerOn&#125;</span>_FULFILLED`</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        powerStatus: <span class="string">&#x27;on&#x27;</span>,</span><br><span class="line">        lineStart: state.finalColor,</span><br><span class="line">        lineEnd: state.finalColor,</span><br><span class="line">        isFetching: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">`<span class="subst">$&#123;types.powerOn&#125;</span>_REJECTED`</span>:</span><br><span class="line">    <span class="keyword">if</span>(action.payload.errorCode)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(getInfoByCode(action.payload.errorCode), <span class="string">&#x27;信息&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        isFetching: <span class="literal">false</span>,</span><br><span class="line">        toastTip: &#123;</span><br><span class="line">            showNum: state.toastTip.showNum + <span class="number">1</span>,</span><br><span class="line">            text: <span class="string">&#x27;开启失败.&#x27;</span>+action.payload</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="开关逻辑修改"><a href="#开关逻辑修改" class="headerlink" title="开关逻辑修改"></a>开关逻辑修改</h3><p>设备只要传 id，对应的开关值，0,1 就行。</p>
<p>对应到代码：</p>
<p>发送command时，需要组合好开关id，状态。</p>
<p>指令发送成功需要根据开关id和值改变store中的值。</p>
<p>还要进行背景颜色的判断。</p>
<p>尼玛，修改名称找谁改。—干掉了</p>
<h2 id="子页面的开关控制逻辑修改"><a href="#子页面的开关控制逻辑修改" class="headerlink" title="子页面的开关控制逻辑修改"></a>子页面的开关控制逻辑修改</h2><p>之前是用的navigation将当前点击的item传入子页面</p>
<p>传入后根据事件监听触发修改，<br>用的是 ==DeviceEventEmitter== ,</p>
<p>改成redux后，</p>
<p>直接在store中读取props的属性根据传入item 的id找到当前的item,根据不同的状态值，</p>
<p>(注意，此处传入也是通过navigation传入的。)</p>
<p>再子页面中直接发送action，</p>
<p>reducer修改store中的数据后，</p>
<p>在子页面中用 ==componentWillReceiveProps== 来监听数据的变化，并根据相应的值，来切换状态。</p>
<h2 id="国际化插件react-native-i18n"><a href="#国际化插件react-native-i18n" class="headerlink" title="国际化插件react-native-i18n"></a>国际化插件<a href="https://www.npmjs.com/package/react-native-i18n">react-native-i18n</a></h2><p>这个插件需要改动android和iOS 的代码！！！！</p>
<ol>
<li><p>安装<br> <code>npm install react-native-i18n --save</code></p>
</li>
<li><p>关联android<br> react-native link</p>
<p> 注意： 这里执行命令后，android测试会报错。</p>
<p> 根据文档挨个检查对应的文件夹，看哪个没有添加，添加对应的调用语句即可。</p>
<p> ./android/settings.gradle</p>
<p> ./android/app/build.gradle</p>
<p> (我这里↑没有自动添加，手动添加的)</p>
<p> ./android/app/src/main/java/your/bundle/MainApplication.java</p>
</li>
<li><p>IOS还没有测试</p>
</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="1-封装一个单独的js出来"><a href="#1-封装一个单独的js出来" class="headerlink" title="1. 封装一个单独的js出来"></a>1. 封装一个单独的js出来</h3><p>新建一个文件夹i18n</p>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">&#x27;react-native-i18n&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> translations  <span class="keyword">from</span> <span class="string">&#x27;./translations&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个为默认，的如果没有找到对应的语言，则为默认的。</span></span><br><span class="line">i18n.defaultLocale = <span class="string">&#x27;en&#x27;</span>;</span><br><span class="line"></span><br><span class="line">i18n.fallbacks = <span class="literal">true</span>;</span><br><span class="line">i18n.translations = &#123;</span><br><span class="line">    en: translations.en,</span><br><span class="line">    zh: translations.zh,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-translations为中英文对应的文字信息"><a href="#2-translations为中英文对应的文字信息" class="headerlink" title="2. translations为中英文对应的文字信息"></a>2. translations为中英文对应的文字信息</h3><p>translations.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    en: &#123;</span><br><span class="line">        greeting: <span class="string">&#x27;Greeting in en&#x27;</span>,</span><br><span class="line">        exit: <span class="string">&#x27;exit?&#x27;</span>,</span><br><span class="line">        tapSwitch: <span class="string">&#x27;Tap to switch&#x27;</span>,</span><br><span class="line">        Switch: <span class="string">&#x27;Switch&#x27;</span>,</span><br><span class="line">        Timing: <span class="string">&#x27;Timing&#x27;</span>,</span><br><span class="line">        Countdown: <span class="string">&#x27;Countdown&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    zh: &#123;</span><br><span class="line">        greeting: <span class="string">&#x27;欢迎欢迎热烈欢迎&#x27;</span>,</span><br><span class="line">        exit: <span class="string">&#x27;是否退出?&#x27;</span>,</span><br><span class="line">        tapSwitch: <span class="string">&#x27;轻触可开关&#x27;</span>,</span><br><span class="line">        Switch: <span class="string">&#x27;开关&#x27;</span>,</span><br><span class="line">        Timing: <span class="string">&#x27;定时&#x27;</span>,</span><br><span class="line">        Countdown: <span class="string">&#x27;倒计时&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，这里的中英文可以单独出来，做成两个单独的文件。<br>zh.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    greeting: <span class="string">&#x27;欢迎欢迎热烈欢迎&#x27;</span>,</span><br><span class="line">    exit: <span class="string">&#x27;是否退出?&#x27;</span>,</span><br><span class="line">    tapSwitch: <span class="string">&#x27;轻触可开关&#x27;</span>,</span><br><span class="line">    Switch: <span class="string">&#x27;开关&#x27;</span>,</span><br><span class="line">    Timing: <span class="string">&#x27;定时&#x27;</span>,</span><br><span class="line">    Countdown: <span class="string">&#x27;倒计时&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>en.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    greeting: <span class="string">&#x27;Greeting in en&#x27;</span>,</span><br><span class="line">    exit: <span class="string">&#x27;exit?&#x27;</span>,</span><br><span class="line">    tapSwitch: <span class="string">&#x27;Tap to switch&#x27;</span>,</span><br><span class="line">    Switch: <span class="string">&#x27;Switch&#x27;</span>,</span><br><span class="line">    Timing: <span class="string">&#x27;Timing&#x27;</span>,</span><br><span class="line">    Countdown: <span class="string">&#x27;Countdown&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在单独引入文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">&#x27;react-native-i18n&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> en <span class="keyword">from</span> <span class="string">&#x27;./en&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> zh <span class="keyword">from</span> <span class="string">&#x27;./zh&#x27;</span>;</span><br><span class="line"></span><br><span class="line">i18n.defaultLocale = <span class="string">&#x27;en&#x27;</span>;</span><br><span class="line">i18n.fallbacks = <span class="literal">true</span>;</span><br><span class="line">i18n.translations = &#123;</span><br><span class="line">    en,</span><br><span class="line">    zh,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n;</span><br></pre></td></tr></table></figure>

<h2 id="3-业务层调用"><a href="#3-业务层调用" class="headerlink" title="3. 业务层调用"></a>3. 业务层调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;i18n&#125; <span class="keyword">from</span> <span class="string">&#x27;你预设的index的目录&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">i18n.t(<span class="string">&#x27;Timing&#x27;</span>)</span><br><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;Text style=&#123;styles.text&#125;&gt;&#123;i18n.t(<span class="string">&#x27;Timing&#x27;</span>)&#125;&lt;/Text&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先Native那里获取本手机的LocaleList然后格式化取第一个元素交由I18n.js处理，</p>
<p>然后I18n.js根据key选用一套有效的语言规则，</p>
<p>再之后流程就和使用时候的顺序一样了。</p>
<h2 id="toast插件-react-native-easy-toast"><a href="#toast插件-react-native-easy-toast" class="headerlink" title="toast插件 react-native-easy-toast"></a>toast插件 <a href="https://www.npmjs.com/package/react-native-easy-toast">react-native-easy-toast</a></h2><p>这个插件不需要改动android和ios代码</p>
<ol>
<li><p>安装</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i react-native-easy-toast --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast, &#123;DURATION&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native-easy-toast&#x27;</span></span><br></pre></td></tr></table></figure>

<p> 在html中需要写在View底部引用</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Toast ref=<span class="string">&quot;toast&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>js调用显示</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认250ms消失</span></span><br><span class="line"><span class="built_in">this</span>.refs.toast.show(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不消失</span></span><br><span class="line"><span class="built_in">this</span>.refs.toast.show(<span class="string">&#x27;hello world!&#x27;</span>, DURATION.FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认2s消失</span></span><br><span class="line"><span class="built_in">this</span>.refs.toast.show(<span class="string">&#x27;hello world!&#x27;</span>, DURATION.LENGTH_LONG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义时间消失</span></span><br><span class="line"><span class="built_in">this</span>.refs.toast.show(<span class="string">&#x27;hello world!&#x27;</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在position设置为居中时，是去掉导航栏以外的区域居中的，所以感觉整体偏下，<br>可以改源码里的position为center时，减去positionValue的值。</p>
<p>但打包时怎么办，好像看到有的demo里是居中的，也有可能是自己代码css问题。</p>
<h2 id="硬件APP开发功能点"><a href="#硬件APP开发功能点" class="headerlink" title="硬件APP开发功能点"></a>硬件APP开发功能点</h2><ol>
<li>第一次打开APP获取设备状态，所有属性值都要</li>
<li>设备不在线时对页面遮罩，禁用所有功能，</li>
<li>设备上报获取所有属性，并根据不同值重置页面</li>
<li>设备发送指令，成功后，修改APP状态</li>
<li>失败后，提示信息显示，不能更改APP状态</li>
</ol>
<h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><p>在编写组件时，希望每个地方都能用到，但别人怎么用，就不知道了。<br>所以需要制定一些规则，比如必须传什么参数，参数是什么类型的。</p>
<p>因为JavaScript语言特点，这种情况下，页面虽显示不正常，但不会报错。很难找到bug位置。</p>
<p>react提供了一种类型检测机制，用来确保接收到的参数是有效的。</p>
<p>例如，我们可以使用PropTypes.string 语句。当给 prop 传递了一个不正确的值时，JavaScript控制台将会显示一条警告。出于性能的原因，propTypes 仅在开发模式中检测。</p>
<p>首先，要安装react提供的第三方库 prop-types：(貌似只针对15.5.0之后的版本，公司项目15.4.2 并不需要install， 直接用就行了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save prop-types</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;<span class="built_in">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Greeting.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>React.PropTypes.element.isRequired，可以为组件指定必须项</li>
<li>defaultProps：为props指定一个默认值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Greeting.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Stranger&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>adb.exe<br>目录<br>C:\Users\z\AppData\Local\Android\Sdk\platform-tools<br>添加到系统环境变量，可以直接执行adb命令</p>
<p><code>adb install -r name.apk</code><br>用命令行安装apk</p>
<h2 id="js用switch-case实现区间"><a href="#js用switch-case实现区间" class="headerlink" title="js用switch case实现区间"></a>js用switch case实现区间</h2><p>重点是switch(true){}</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAQIDegree</span>(<span class="params">jq</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> jq&lt;<span class="number">51</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;优&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> jq&lt;<span class="number">101</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;良&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> jq&lt;<span class="number">151</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;轻度污染&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> jq&lt;<span class="number">201</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;中度污染&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> jq&lt;<span class="number">301</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;重度污染&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">300</span>&lt;jq:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;严重污染&#x27;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React SSR 梳理</title>
    <url>/posts/React-SSR-%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>什么是服务器端渲染？什么是客户端渲染？什么是同构？</p>
<ol>
<li>客户端渲染 CSR<br>页面初始加载的HTML中无网页展示内容，需要加载JavaScript中的React代码,通过JavaScript渲染生成页面，<br>同时，JavaScript代码会完成页面交互事件的绑定。</li>
</ol>
<a id="more"></a>

<p>流程如下：</p>
<ol>
<li><p>服务端返回HTML到浏览器</p>
</li>
<li><p>浏览器下载JS</p>
</li>
<li><p>浏览器执行js, React——-在这之前都是loading(包括3)</p>
</li>
<li><p>页面显示，可交互</p>
</li>
<li><p>服务器渲染<br>用户请求服务器，服务器上直接生成HTML内容并返回浏览器。页面内容直接由Server端生成。<br>服务器端渲染的页面交互能力有限，要实现复杂交互，还是要通过引入JavaScript文件来辅助实现。</p>
</li>
<li><p>同构SSR<br>这个概念存在于Vue， React这些新型的前端框架中，同构实际是客户端渲染和服务器渲染的一个整合。<br>把页面的展示内容和交互写在一起，让代码执行两次。服务器端执行一次，用于实现服务器端渲染，<br>客户端再执行一次，用于接管页面交互。</p>
</li>
</ol>
<p>流程如下：</p>
<ol>
<li>服务器发送已经渲染好的HTML到浏览器—-仅在这一过程页面loading</li>
<li>浏览器渲染页面,页面显示，开始下载JS</li>
<li>浏览器执行JS/React</li>
<li>页面可交互</li>
</ol>
<h1 id="为什么使用SSR技术"><a href="#为什么使用SSR技术" class="headerlink" title="为什么使用SSR技术"></a>为什么使用SSR技术</h1><p>主要因素：</p>
<ol>
<li>CSR项目的TTFP(Time To First Page)时间较长。加载HTML，下载JavaScript，JavaScript渲染生成页面。<br>在这个渲染过程中至少涉及到两个HTTP请求周期，所以会有一定的耗时。这也是为什么低俗网络下，初始页面会有白屏的原因。</li>
<li>CSR项目的SEO能力极弱。搜索引擎主要识别的内容还是HTML，对JavaScript文件内容的识别都还比较弱。</li>
<li>减少API请求次数</li>
</ol>
<p>SSR的产生，主要就是为了解决上面两个问题。在React中使用SSR，让React在服务器端先执行一次，使得用户下载的HTML<br>已经包含了所有的页面展示内容，这样页面展示的过程只需经历一个HTTP请求周期，TTFP时间得到一倍以上缩减。同时HTML<br>中已经包含了网页的所有内容，SEO效果也会变得非常好。</p>
<p>之后React在客户端再次执行，为HTML中的内容添加数据及事件的绑定，页面就具备了React的各种交互能力。</p>
<blockquote>
<p>主要区别：客户端从无到有的渲染，服务端是先在服务端渲染一部分，在再客户端渲染一小部分。</p>
</blockquote>
<h1 id="SSR技术架构图"><a href="#SSR技术架构图" class="headerlink" title="SSR技术架构图"></a>SSR技术架构图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端(浏览器)          Node服务器                    API服务器</span><br><span class="line">访问地址---------      1.接收请求</span><br><span class="line">                      2.路由分析获取即将展示的组件信息</span><br><span class="line">                      3. 获取组件所需数据-----------  4.接收请求，返回接口数据</span><br><span class="line">6.显示HTML,            5.渲染组件，返回渲染后的HTML</span><br><span class="line">加载需要的bundle.js     (服务端渲染完成)                 </span><br><span class="line">7.获取bundle.js文件    8.接收请求</span><br><span class="line">                      9.返回bundle.js                    </span><br><span class="line">10. 加载运行bundle.js</span><br><span class="line">进行客户端渲染</span><br><span class="line">11. bundle.js发送请求   12.收到请求，代理到业务接口    13. 接受请求，返回接口数据</span><br><span class="line">                       14.获取到数据返回</span><br><span class="line">15.获取到请求数据，</span><br><span class="line">完成客户端渲染</span><br></pre></td></tr></table></figure>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>使用SSR使得原本简单的React项目变得非常复杂，项目的可维护性降低，代码追溯变得困难。<br>有时这些副作用比起优势要大得多。一般除非特别依赖搜索引擎流量，或对首屏时间有特殊要求，不建议使用SSR。<br>只有NodeJS环境可以SSR：若后端使用python或是ruby等语言，处理React SSR就要多开一台NodeJS Render Server，多了维护上的麻烦。</p>
<h1 id="SSR技术难点剖析"><a href="#SSR技术难点剖析" class="headerlink" title="SSR技术难点剖析"></a>SSR技术难点剖析</h1><h2 id="虚拟DOM和SSR的关系"><a href="#虚拟DOM和SSR的关系" class="headerlink" title="虚拟DOM和SSR的关系"></a>虚拟DOM和SSR的关系</h2><p><strong>SSR之所以能实现，本质上上因为虚拟DOM的存在</strong></p>
<p>SSR的工程中，React代码会在客户端和服务端各执行一次。如果React代码中存在直接操作DOM的代码，那么就无法实现SSR<br>这种技术。因为在node环境中，没有DOM这个概念存在。所以这些代码在node环境下会报错。</p>
<p>虚拟DOM是真实DOM的一个JavaScript对象映射。React在做页面操作时，实际上不是直接操作DOM，而是操作虚拟DOM，<br>也就是操作普通JavaScript对象，这就使得SSR成为了可能。</p>
<p>在服务端，可以操作JavaScript对象，判断环境是服务器环境，把虚拟DOM映射成字符串输出；<br>在客户端，操作JavaScript对象，判断是客户端环境，将虚拟DOM映射成真实DOM，完成页面挂载。</p>
<h2 id="细说流程图"><a href="#细说流程图" class="headerlink" title="细说流程图"></a>细说流程图</h2><p>第3步：服务器要根据请求地址，判断展示什么页面。这一步叫做服务器端路由。<br>第10步：客户端接收到JavaScript文件后，要根据当前路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，<br>这时，还要经历一次客户端路由(前端路由)</p>
<h3 id="SSR中客户端渲染与服务端渲染路由代码差异"><a href="#SSR中客户端渲染与服务端渲染路由代码差异" class="headerlink" title="SSR中客户端渲染与服务端渲染路由代码差异"></a>SSR中客户端渲染与服务端渲染路由代码差异</h3><p>实现React的SSR架构，需要让相同的React代码在客户端和服务端各执行一次。<br>这里说的相同的React代码，指的是各种组件代码，所以在同构中，只有组件代码是可以共用的。<br>而路由这样的代码是没有办法公用的。</p>
<p>原因：<br>服务端需要通过请求路径，找到路由组件；在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制。<br>所以这部分代码肯定无法公用。</p>
<p>代码示例：<br>客户端路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&#x27;/&#x27;</span> component=&#123;Home&#125;&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">      &lt;/BrowserRouter&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>服务端路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&#x27;/&#x27;</span> component=&#123;Home&#125;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/StaticRouter&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ReactDom.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>)</span><br></pre></td></tr></table></figure>
<p>服务端路由代码相对复杂点，需要把location(当前请求路径)传递给StaticRouter组件，这样StaticRouter才能根据<br>路径分析出当前所需要的组件是哪个。</p>
<blockquote>
<p>StaticRouter是React-Router针对服务端渲染专门提供的一个路由组件</p>
</blockquote>
<p>BrowerRouter能够匹配到浏览器即将显示的路由组件，对浏览器来说，需要将组件转化成DOM，用ReactDom.render进行DOM挂载。</p>
<p>StaticRouter能够在服务器端匹配到将要显示的组件，对服务端来说，需要将组件转化成字符串，用ReactDom.renderToString方法，就可以及时得到App组件对应的HTML字符串</p>
<p>对一个React应用来说，路由一般是整个程序的执行入口，在SSR中，服务端的路由和客户端的路由不一样，<br>意味着服务端的入口代码和客户端的入口代码是不同的。</p>
<p>所以，针对代码运行环境的不同，要进行有区别的webpack打包。</p>
<h3 id="服务端和客户端代码的打包差异"><a href="#服务端和客户端代码的打包差异" class="headerlink" title="服务端和客户端代码的打包差异"></a>服务端和客户端代码的打包差异</h3><p>客户端webpack配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/client/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;public&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">      loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, &#123;</span><br><span class="line">        loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">        options: &#123;<span class="attr">modules</span>: <span class="literal">true</span>&#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)?$/</span>,</span><br><span class="line">      loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">8000</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="服务端webpack配置"><a href="#服务端webpack配置" class="headerlink" title="服务端webpack配置"></a>服务端webpack配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里不同</span></span><br><span class="line">  target: <span class="string">&#x27;node&#x27;</span>,</span><br><span class="line"><span class="comment">//   entry不同</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/server/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出路径不同</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">//   这里不同</span></span><br><span class="line">  externals: [nodeExternals()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">      loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      <span class="comment">// 这里不同</span></span><br><span class="line">      use: [<span class="string">&#x27;isomorphic-style-loader&#x27;</span>, &#123;</span><br><span class="line">        loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">        options: &#123;<span class="attr">modules</span>: <span class="literal">true</span>&#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)?$/</span>,</span><br><span class="line">      loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">8000</span>,</span><br><span class="line">        <span class="comment">// 这里不同</span></span><br><span class="line">        outputPath: <span class="string">&#x27;../public/&#x27;</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，服务端渲染和客户端配置是有差异的。</p>
<ul>
<li><p>node核心模块: 在服务端运行的代码，需要引入Node的一些核心模块。在模块打包时，需要Webpack识别出类似的核心模块，<br>一旦发现是核心模块，不必把模块的代码合并到最终生成的代码中。<br>解决这个问题，只需在服务端webpack中加入<code>target: node</code>。</p>
</li>
<li><p>第三方模块: 服务端渲染的代码，如果加载第三方模块，这些模块不用打包到最终源码中，因为Node环境下通过NPM已经<br>安装了这些包，直接引用就行，不需要额外再打包到代码里。<br>解决这个问题，可以使用<a href="https://www.npmjs.com/package/webpack-node-externals">webpack-node-externals插件</a></p>
</li>
<li><p>CSS样式饮用: React代码中引入CSS样式代码，服务端打包的过程会处理一遍CSS，客户端又会处理一遍。<br>解决：服务端使用<a href="https://www.npmjs.com/package/isomorphic-style-loader">isomorphic-style-loader</a><br>它处理CSS时，只在对应的DOM元素上生成class类，返回生成的CSS样式代码。</p>
<pre><code>          ---看文档有点没懂，还要改组件代码?需要测一下</code></pre>
</li>
<li><p>图片引入: 图片等类型文件的引入，url-loader会在服务端和客户端打包的过程中分别打包。上述配置无论服务端还是<br>客户端打包，都把打包生成的文件存储在public目录下，这样虽然打包出来两遍，但后打包的会覆盖之前文件，看起来只有<br>一份文件。<br>这样做性能优雅性不高，可以让图片大打包只进行一次，借助webpack的插件或自己写loader。</p>
</li>
</ul>
<hr>
<p><strong>如果React的应用中没有一部数据的获取。单纯的做静态展示。经过上面配置，简单的SSR应用就可以实现了</strong></p>
<hr>
<h1 id="异步数据获取-Redux使用"><a href="#异步数据获取-Redux使用" class="headerlink" title="异步数据获取 + Redux使用"></a>异步数据获取 + Redux使用</h1><p>客户端渲染，异步数据结合Redux的使用方式遵循下面的流程(对应上面12步):</p>
<ol>
<li>创建Store</li>
<li>根据路由显示组件</li>
<li>派发Action获取数据</li>
<li>更新Store中的数据</li>
<li>组件Rerender</li>
</ol>
<p>服务端，页面一旦确定，就没法Rerender了，这就要求组件显示时，把Store的数据都准备好。<br>所以服务端流程如下(对应第4步)：</p>
<ol>
<li>创建Store</li>
<li>根据路由分析Store中需要的数据</li>
<li>派发Action</li>
<li>更新Store中的数据</li>
<li>结合数据和组件生成HTML，一次性返回</li>
</ol>
<h2 id="分析服务端渲染流程"><a href="#分析服务端渲染流程" class="headerlink" title="分析服务端渲染流程"></a>分析服务端渲染流程</h2><ul>
<li><p>创建Store: 客户端渲染中，用户浏览器中永远只存在一个Store，所以代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer, defaultState)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>而在服务端的Store是所有用户共用的。如果如上创建Store，Store变成一个单例，所有用户共享Store，显示就有问题了。<br>所以在服务端渲染中，Store创建如下，返回一个函数，每个用户访问时，这个函数重新执行，为每个用户提供独立的Store：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getStore = <span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(reducer, defaultState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getStore;</span><br></pre></td></tr></table></figure></li>
<li><p>根据路由分析Store中需要的数据<br>在服务端，需要分析当前路由要加载的所有组件，借助第三方包，比如<a href="https://www.npmjs.com/package/react-router-config">react-router-config</a>.(所有路由path都要改为绝对路径)<br>这个包会根据传入服务的请求路径，分析出这个路径下要展示的所有组件。</p>
</li>
<li><p>派发Action获取数据<br>在<strong>每个组件</strong>上增加一个获取数据的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Home.loadData = <span class="function">(<span class="params">store</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(getHomeList())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要将服务端渲染的Store传进来，它的作用就是帮助服务端的Store获取到这个组件所需的数据。所以组件有了这样的方法，<br>同时我们也有当前路由所需要的所有组件，依次调用各个组件上的loadData方法，就能获取到路由所需的所有数据内容.</p>
</li>
<li><p>更新Store中的数据<br>需要在生成HTML之前，保证所有的数据都获取完毕。怎么处理？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// matchedRoutes 是当前路由对应的所有需要显示的组件集合</span></span><br><span class="line">matchedRoutes.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.route.loadData) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      item.route.loadData(store).then(resolve).catch(resolve);</span><br><span class="line">    &#125;)</span><br><span class="line">    promises.push(promise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生成 HTML 逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>构建Promise队列，等待所有Promise都执行结束后，再生成HTML。</p>
</li>
</ul>
<hr>
<p>到此，就结合实现了Redux实现了SSR流程</p>
<hr>
<p>服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，<br>因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，<br>但是如果经过 react-router 路由跳转道第二个页面，<br>那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。——-不都是通过React-router跳转的吗</p>
<p>客户端获取数据在componentDidMount阶段，这个阶段服务端不会执行，所以不必担心和loadData冲突。<br>这也是为什么数据的获取应该放到componentDidMount阶段，可以避免服务端和客户端获取数据冲突。</p>
<h1 id="Node只是一个中间层"><a href="#Node只是一个中间层" class="headerlink" title="Node只是一个中间层"></a>Node只是一个中间层</h1><p>在SSR架构中，一般node只是一个中间层，用来做React代码的服务端渲染，而node需要的数据通常由API服务器单独提供。</p>
<p>一是为了解耦，而是规避Node服务器的一些计算性能问题。</p>
<p>服务端直接请求API服务没问题，但在客户端，可能存在跨越问题。通过请求node服务器，经过代理转发，拿到API的数据。<br>可以通过<a href="https://www.npmjs.com/package/express-http-proxy">express-http-proxy</a>这样的工具搭建proxy<br>代理功能，需要注意，让代理不服不仅转发请求，还要携带cookie，避免权限校验问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node 代理功能实现代码</span></span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, proxy(<span class="string">&#x27;http://apiServer.com&#x27;</span>, &#123;</span><br><span class="line">  proxyReqPathResolver: <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/ssr&#x27;</span> + req.url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个SSR流程体系中的关键知识点和原理就讲完了。当然还有很多细节的处理。比如不同页面配置不同title和description来提示SEO，可以用<a href="https://www.npmjs.com/package/react-helmet">react-helmet</a>等工具，还要工程目录的设计，404，301重定向的处理等等。需要在实践中各个击破~~</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>React16.X中的SSR</p>
<ol>
<li>hydrate<br>React在客户端渲染的render基础上，增加了新的方法hydrate.<br>如果尽在客户端呈现内容，使用render方法就已经够用了，如果客户端要在服务端的基础上渲染，用hydrate。使用方法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;hydrate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line">hydrate(<span class="xml"><span class="tag">&lt;<span class="name">HomePage</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>));</span><br></pre></td></tr></table></figure>
运行后会提示之后版本会移除render，完全用hydrate代替。</li>
</ol>
<p>hydrate解决的是如何复用server端，ReactDOMServer的结果。</p>
<ol start="2">
<li>stream</li>
</ol>
<p>针对renderToString和renderToStaticMarkUp提供了stream方法</p>
<ul>
<li><p>renderToNodeStream</p>
</li>
<li><p>renderStaticNodeStream</p>
</li>
</ul>
<p>这两个方法同样接收的参数为react element，但返回的不是HTML字符串，而是一个可读流。</p>
<p>React16之前用renderToString，和renderToNodeStream区别：<br>renderToNodeStream支持直接渲染到节点流，渲染到流可以减少TTFB时间，在文档的下一部分生成之前，将文档的开头至结尾发送到浏览器。当内容从服务器流式传输时，浏览器开始解析HTML。速度是renderToString的3倍(官方)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderToStaticMarkup,renderToNodeStream&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span></span><br><span class="line"><span class="keyword">const</span> root = (<span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line">                    &lt;StaticRouter</span><br><span class="line">                      location=&#123;req.url&#125;</span><br><span class="line">                      context=&#123;context&#125;</span><br><span class="line">                      &gt;</span><br><span class="line">                        &lt;App&gt;&lt;/App&gt;</span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">StaticRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>)</span><br><span class="line">    <span class="keyword">const</span> markupStream = renderToNodeStream(root)</span><br><span class="line">    markupStream.pipe(res,&#123;<span class="attr">end</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    markupStream.on(<span class="string">&#x27;end&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>必须包括可选参数 {end:false}告诉流当渲染完成不自动结束响应。这允许我们完成HTML主体，并在流完全写入响应后结束响应。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>尽量避免使用window等客户端变量<br>Server端没有window对象，如果需要使用从window开始逐级判断</li>
<li>客户端对象的判断用typeof<br><code>if(window &amp;&amp; window.autoScroll) =&gt; if(typeof window != &quot;undefined&quot; &amp;&amp; window.autoScroll)</code></li>
<li>避免往window等全局对象挂载定时器<br>可能内存泄漏</li>
<li>避免random()等不确定性输出(输出结果可预期，不依赖于环境等)<br>可能造成server端和web端DOM匹配检验不成功</li>
<li>避免使用第三方非react库<br>用react包装一个jQuery写的富文本编辑器</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://www.yuque.com/es2049/blog/zy0eq0">React 中同构（SSR）原理脉络梳理</a></li>
</ul>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>React全家桶视频教程</title>
    <url>/posts/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a><a href="http://jspang.com/2017/08/15/react_basic/">学习网址</a></h2><p><a href="http://jspang.com/2017/10/22/react-all-01/">全家桶</a></p>
<h2 id="第一节-React-简介"><a href="#第一节-React-简介" class="headerlink" title="第一节 React 简介"></a>第一节 React 简介</h2><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React起源于Facebook的内部项目，该公司积极尝试引入HTML5技术用来架设Instagram网站，开发中发现HTML5的性能下降明显，达不到预期的效果。他们就自己开发了React框架。</p>
<p><a href="https://facebook.github.io/react/">ReactJS官方地址</a></p>
<p><a href="https://github.com/facebook/react">GitHub地址</a></p>
<a id="more"></a>

<h3 id="react-特点"><a href="#react-特点" class="headerlink" title="react 特点"></a>react 特点</h3><ul>
<li>虚拟DOM: React也是以数据驱动的，每次数据变化React都会扫码整个虚拟DOM树，自动计算与上次虚拟DOM的差异变化，然后针对需要变化的部分进行实际的浏览器DOM更新。</li>
<li>组件化： React可以从功能角度横向划分，将UI分解成不同组件，各组件都独立封装，整个UI是由一个个小组件构成的一个大组件，每个组件只关系自身的逻辑，彼此独立。</li>
<li>单项数据流：React设计者认为数据双向绑定虽然便捷，但在复杂场景下副作用也是很明显，所以React更倾向于单向的数据流动-从父节点传递到子节点。（使用ReactLink也可以实现双向绑定，但不建议使用）</li>
</ul>
<h2 id="第二节-构建：create-react-app-快速脚手架-官网"><a href="#第二节-构建：create-react-app-快速脚手架-官网" class="headerlink" title="第二节 构建：create-react-app 快速脚手架 官网"></a>第二节 构建：create-react-app 快速脚手架 <a href="https://github.com/facebookincubator/create-react-app">官网</a></h2><h3 id="creat-react-app优点"><a href="#creat-react-app优点" class="headerlink" title="creat-react-app优点"></a>creat-react-app优点</h3><ul>
<li>无需配置：官方的配置堪称完美，几乎不用你再配置任何东西，就可以上手开发项目。</li>
<li>高集成性：集成了对React，JSX，ES6和Flow的支持。</li>
<li>自带服务：集成了开发服务器，你可以实现开发预览一体化。</li>
<li>热更新：保存自动更新，让你的开发更简单。</li>
<li>全兼容性：自动处理CSS的兼容问题，无需添加-webkit前缀。</li>
<li>自动发布：集成好了发布成品功能，编译后直接发布，并且包含了sourcemaps功能。</li>
</ul>
<h2 id="create-react-app安装"><a href="#create-react-app安装" class="headerlink" title="create-react-app安装"></a>create-react-app安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure>

<h3 id="创建React项目"><a href="#创建React项目" class="headerlink" title="创建React项目"></a>创建React项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create-react-app react-app</span><br></pre></td></tr></table></figure>

<p>注意： 目录名不要使用大小写。因为Linux下是严格区分大小写的。</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>注意： 听懂不等于学会，一定要动手做一做。</p>
<h2 id="第二节-构建工具-generator-react-webpack"><a href="#第二节-构建工具-generator-react-webpack" class="headerlink" title="第二节 构建工具 generator-react-webpack"></a>第二节 构建工具 generator-react-webpack</h2><p>这也是个构建工具，需要yeoman支持。</p>
<h3 id="优点介绍"><a href="#优点介绍" class="headerlink" title="优点介绍"></a>优点介绍</h3><ul>
<li>基于webpack构建，可以很容易的配置自己需要的webpack。</li>
<li>支持ES6，集成了Babel-Loader。</li>
<li>支持不同风格的CSS（sass，less，stylus）。</li>
<li>支持PostCSS转换样式。</li>
<li>集成了esLint功能。</li>
<li>可以轻松配置单元测试，比如Karma和Mocha</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>需要先安装yeoman</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g yo</span><br><span class="line">npm install -g generator-react-webpack</span><br></pre></td></tr></table></figure>

<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir new-react-demo</span><br></pre></td></tr></table></figure>

<p>进入文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> new-react-demo</span><br></pre></td></tr></table></figure>

<p>用生成器生成项目目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yo react-webpack</span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>

<h2 id="第三节-构建：-webpack一步一步构建01"><a href="#第三节-构建：-webpack一步一步构建01" class="headerlink" title="第三节 构建： webpack一步一步构建01"></a>第三节 构建： webpack一步一步构建01</h2><p>从头开始自己构建一个简单的React开发环境。</p>
<p>建立文件夹,进入文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir react-webpack</span><br><span class="line"><span class="built_in">cd</span> react-webpack</span><br></pre></td></tr></table></figure>

<p>对webpack初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>如果感觉一直回车麻烦，可以加-y参数，这样npm就直接生成了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>初始化后，可以安装webpack了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure>

<h3 id="配置webpack-config-js"><a href="#配置webpack-config-js" class="headerlink" title="配置webpack.config.js"></a>配置webpack.config.js</h3><p>在根目录建立webpack.config.js , 建立基本的入口出口文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    entry: <span class="string">&#x27;./app/index.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 出口文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件配置好后， 要根据文件的结构改造项目目录。在根目录下新建app和dist文件夹，<br>在app文件夹里新建index.js文件</p>
<h3 id="新建index-html"><a href="#新建index-html" class="headerlink" title="新建index.html"></a>新建index.html</h3><p>在根目录新建index.html， 并引入webpack设置中的出口文件，代码如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>React全家桶<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入出口文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="新建index-js"><a href="#新建index-js" class="headerlink" title="新建index.js"></a>新建index.js</h3><p>在/app/index.js中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    element.innerHTML = <span class="string">&#x27;Hello React&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(component())</span><br></pre></td></tr></table></figure>

<h3 id="加入打包命令"><a href="#加入打包命令" class="headerlink" title="加入打包命令"></a>加入打包命令</h3><p>在package.json中，scripts属性加入build命令</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在终端中输入npm run build ，就可以看到打包结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里为止，我们正确安装了webpack，进行了出入口配置，也看到了webpack的输出效果。</p>
<h3 id="开发服务器配置"><a href="#开发服务器配置" class="headerlink" title="开发服务器配置"></a>开发服务器配置</h3><p>添加实时更新的服务</p>
<h3 id="安装webpack-dev-server"><a href="#安装webpack-dev-server" class="headerlink" title="安装webpack-dev-server"></a>安装webpack-dev-server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>安装完成后配置webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    host: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">1717</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好后，在package.json里增加scripts命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>–open是自动打开浏览器，都配置完成后可以在终端输入npm run server 看效果</p>
<h3 id="自动刷新浏览器"><a href="#自动刷新浏览器" class="headerlink" title="自动刷新浏览器"></a>自动刷新浏览器</h3><p>修改代码时，并不能自动刷新浏览器，查看最新效果。而是要再次npm run build才可以。<br>只要在出口文件配置中增加一个publicPath: ‘dist/‘</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    publicPath: <span class="string">&#x27;dist/&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在index.html中引入js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./dist/index.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结-3"></a>总结-3</h2><p>这节课主要配置webpack的基本配置。</p>
<h2 id="第4节-构建：-webpack一步一步构建02"><a href="#第4节-构建：-webpack一步一步构建02" class="headerlink" title="第4节 构建： webpack一步一步构建02"></a>第4节 构建： webpack一步一步构建02</h2><p>上节对webpack进行基础配置，已经能打包到页面中。这节主要针对ES6和React配置。<br>学习之前需确保上节配置完成。</p>
<h3 id="Babel安装配置"><a href="#Babel安装配置" class="headerlink" title="Babel安装配置"></a>Babel安装配置</h3><p>webpack配置Babel需要先加入babel-loader，还需要支持es2015,React，所以安装4个包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</span><br></pre></td></tr></table></figure>

<p>安装完成后，会在package.json中看到这些包和版本信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^7.1.2&quot;,</span><br><span class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^3.8.1&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^2.9.4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置module"><a href="#配置module" class="headerlink" title="配置module"></a>配置module</h3><p>在webpack.config.js中配置module，即loader。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            loaders: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            query: &#123;</span><br><span class="line">                presets: [<span class="string">&#x27;es2015&#x27;</span>, <span class="string">&#x27;react&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写React"><a href="#编写React" class="headerlink" title="编写React"></a>编写React</h3><p>webpakc已经配置完成。 这里写一个React文件来测试一下。</p>
<p>先安装React和React-dom这两个包。</p>
<h3 id="安装React和React-dom"><a href="#安装React和React-dom" class="headerlink" title="安装React和React-dom"></a>安装React和React-dom</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save react react-dom</span><br></pre></td></tr></table></figure>

<p>安装完成后，将app/index.js中的原生js代码改写成React代码。</p>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;div&gt;Hello Webpack&lt;/div&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里增加了#app的div，在index.html中添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，npm run server可以看到效果。接下来就可以愉快的开发了</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结-4"></a>总结-4</h2><p>其实自己配置React开发环境在实际工作中并不多。因为我们的配置不是很成熟，而且支持较少。</p>
<p>这里学习只是为了更好的掌握React构建过程和设置参数，实际工作中尽量使用合适的脚手架工具。</p>
<h2 id="第5节-路由：-Hello-React路由"><a href="#第5节-路由：-Hello-React路由" class="headerlink" title="第5节 路由： Hello React路由"></a>第5节 路由： Hello React路由</h2><p>通过前面4节课已经可以顺利的构建React的基本开发环境了。</p>
<p>这节课开始用几节课的时间全面了解一下React Router。 路由在开发过程中都会用到。它是SPA(单页应用)的基础，可以说不会路由系统就无法使用React进行编程。</p>
<p>其实路由可以简单的看作我们平时访问的网址或地址。这样有助于理解，但并不正确。</p>
<h3 id="router包安装"><a href="#router包安装" class="headerlink" title="router包安装"></a>router包安装</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save react-router react-router-dom</span><br></pre></td></tr></table></figure>

<ul>
<li>react-router: 是基本的router包，里面含的内容较多，但是在网页开发中有很多用不到，现在市面上的课程简单基本都是这个包的教程。</li>
<li>react-router-dom: 随着React生态环境的壮大，后出现的包。这个包比react-router轻巧许多。</li>
</ul>
<p><strong>注意：</strong></p>
<p>安装了react-router就不用安装react-router-dom包了，这里只是为了讲课方便，所以安装了两个包。在实际开发中，请跟进需要进行安装。</p>
<p>安装时，使用–save，因为在生产环境中也要使用。</p>
<h3 id="复习component"><a href="#复习component" class="headerlink" title="复习component"></a>复习component</h3><p>之前学过React组件如何编写，这里简单复习一下。</p>
<p>做一个A页面的组件</p>
<p>在app文件夹下新建componentA.js，引入React包，并编写A页面的组件，代码如下：</p>
<p>componentA.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">componentA</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;A默认组件&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用了ES6语法，这也是React现在推荐的，如果使用老语法会出现警告</p>
<p>在index.js中引入A组件，并改写渲染代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Componenta <span class="keyword">from</span> <span class="string">&#x27;./componentA&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Componenta/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>预览看效果</p>
<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><blockquote>
<p>之前写的时候是 <code>&lt;componentA/&gt;</code>, 会报两个错误</p>
</blockquote>
<p>Warning: <code>&lt;componentA /&gt;</code> is using uppercase HTML. Always use lowercase HTML tags in React.<br>警告： html标签一定要用小写</p>
<p>Warning: The tag <code>&lt;componentA&gt;</code> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.<br>警告：标签<code>&lt;componentA&gt;</code>作为组件，首字母要大写</p>
<h2 id="以上就是一个组件的开发和引用"><a href="#以上就是一个组件的开发和引用" class="headerlink" title="以上就是一个组件的开发和引用"></a>以上就是一个组件的开发和引用</h2><p>接下来仿照上面的方法开发两个新组件，ComponentB， ComponentC。代码如下</p>
<p>ComponentB.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">componentB</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;这是B组件&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ComponentC.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">componentC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;这是C组件&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写完后引入到index.js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Componenta <span class="keyword">from</span> <span class="string">&#x27;./componentA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Componentb <span class="keyword">from</span> <span class="string">&#x27;./componentb&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Componentc <span class="keyword">from</span> <span class="string">&#x27;./componentc&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引入和书写路由"><a href="#引入和书写路由" class="headerlink" title="引入和书写路由"></a>引入和书写路由</h2><p>页面制作好后，需要路由来切换。先引入路由包，这里用到两个模块Router，route。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改写文件，增加路由设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=<span class="string">&quot;&#123;Componenta&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=<span class="string">&quot;&#123;Componentb&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentc&quot;</span> component=<span class="string">&quot;&#123;Componentc&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意：这里是错误的，不能加引号，正确如下"><a href="#注意：这里是错误的，不能加引号，正确如下" class="headerlink" title="注意：这里是错误的，不能加引号，正确如下"></a>注意：这里是错误的，不能加引号，正确如下</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentc&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这里的exact是精确匹配的意思，如果有多层路由嵌套时，exact可以帮助我们精确匹配到想要跳转的路由</p>
<p>路由设置完毕还不能切换，需要做一个切换的组件。命名为&lt;nav/&gt;</p>
<h3 id="开发Nav组件"><a href="#开发Nav组件" class="headerlink" title="开发Nav组件"></a>开发Nav组件</h3><p>在app文件夹下新建一个nav.js，引入React和React-router-dom</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;NavLink&#125; <span class="keyword">from</span> <span class="string">&#x27;raect-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NavBar = <span class="function">() =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;NavLink exact to=<span class="string">&quot;/&quot;</span>&gt;ComponentA&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br><span class="line">            &lt;NavLink to=<span class="string">&quot;/componentb&quot;</span>&gt;ComponentB&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br><span class="line">            &lt;NavLink to=<span class="string">&quot;/componentc&quot;</span>&gt;ComponentC&lt;/NavLink&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> NavBar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件编写完成后，引入index.js，并添加&lt;Nav/&gt;标签到代码里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Nav/&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentc&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里，就可以进行预览了，也可以顺利的切换页面内容，说明路由已经起作用了。<br>当然这只是路由最简单的写法。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这里编写代码的时候遇到点问题：</p>
<ol>
<li><p>大小写要注意</p>
<p> html标签一定要用小写</p>
<p> 标签<code>&lt;componentA&gt;</code>作为组件，首字母要大写，改为<code>&lt;Componenta/&gt;</code></p>
</li>
<li><p>有的地方是不需要引号的</p>
</li>
</ol>
<h2 id="第6节-路由：-NavLink中常用选项"><a href="#第6节-路由：-NavLink中常用选项" class="headerlink" title="第6节 路由： NavLink中常用选项"></a>第6节 路由： NavLink中常用选项</h2><p>上节初识了React路由，并制作了小案例。这节学习NavLink标签上的选项</p>
<h2 id="Route和NavLink的exact选项"><a href="#Route和NavLink的exact选项" class="headerlink" title="Route和NavLink的exact选项"></a>Route和NavLink的exact选项</h2><p>exact 精确匹配，一般而言，React会匹配所有能匹配的路由组件，exact可以使我们的匹配更精确。</p>
<p>exact的值为boolean, 为true表示严格匹配，为false表示正常匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br><span class="line"><span class="comment">// 这种情况，访问/componentb，会把component组件也显示出来</span></span><br></pre></td></tr></table></figure>

<p>所以，用exact来解决这个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>在多层(路由)路由嵌套时也会出现这个问题，要多用exact来解决精确匹配问题</strong></p>
</blockquote>
<h2 id="NavLink使用样式"><a href="#NavLink使用样式" class="headerlink" title="NavLink使用样式"></a>NavLink使用样式</h2><p>怎样给NavLink添加样式呢，要先配置一下webpack.config.js文件。</p>
<p>先写一个css,和nav.js放在一个文件夹下，命名为nav.css</p>
<p>nav.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blue</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在nav.js中引入css</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./nav.css&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这时，会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module parse failed: Unexpected token (<span class="number">1</span>:<span class="number">0</span>)</span><br><span class="line">You may need an appropriate loader to handle <span class="built_in">this</span> file type.</span><br></pre></td></tr></table></figure>

<p> 因为webpack还不能对css文件进行正确的解析，需要加入css的loader。先用npm安装style-loader和css-loader</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>

<p> 安装好后，在webpack.config.js里配置css的loader。如下</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    loader: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 配置好后，需要重启一下服务器，才可以正确解析。<br> 这时候，就可以在NavLink上加ClassName指定css类了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink exact to=<span class="string">&quot;/&quot;</span> className=<span class="string">&quot;blue&quot;</span>&gt;ComponentA&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="直接在NavLink上写样式"><a href="#直接在NavLink上写样式" class="headerlink" title="直接在NavLink上写样式"></a>直接在NavLink上写样式</h3><p>除了用css文件这种方式，还可以更直接，在NavLink上写样式，看下面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">&quot;/componentb&quot;</span> style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,<span class="attr">fontSize</span>:<span class="string">&#x27;30px&#x27;</span>&#125;&#125;&gt;ComponentB&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种写法虽然只管好用，但是不建议在实际开发中使用，这增加了代码耦合度，不是一种好的编程方式。<br><strong>注意，跟原生写法完全不一样</strong> 下面是我直接写的。错误↓↓↓↓↓↓</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">&quot;/componentb&quot;</span> style=<span class="string">&quot;&#123;&#123;color:red;font-size:30px;&#125;&#125;&quot;</span>&gt;ComponentB&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>style后面的不能用引号引用，是个大对象</li>
</ol>
</li>
<li><ol start="2">
<li>里面是key-value形式的，一个属性结束不是用分号</li>
</ol>
</li>
<li><ol start="3">
<li>每个属性后面都要用引号引起来。</li>
</ol>
</li>
</ul>
<h3 id="activeClassName"><a href="#activeClassName" class="headerlink" title="activeClassName"></a>activeClassName</h3><p>作为一个链接，是有激活状态的。它接受一个类名。现在我们在nav.css定义一个active的类，把字体设为红色</p>
<p>.nav.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blue</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改NavLink标签</p>
<p>nav.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;NavLink&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./nav.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NavBar = <span class="function">() =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;NavLink exact to=<span class="string">&quot;/&quot;</span> className=<span class="string">&quot;blue&quot;</span>&gt;ComponentA&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br><span class="line">            &lt;NavLink to=<span class="string">&quot;/componentb&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span> style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;#2BAB40&#x27;</span>,<span class="attr">fontSize</span>:<span class="string">&#x27;14px&#x27;</span>&#125;&#125;&gt;ComponentB&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br><span class="line">            &lt;NavLink to=<span class="string">&quot;/componentc&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span>&gt;ComponentC&lt;/NavLink&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> NavBar</span><br></pre></td></tr></table></figure>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结-6"></a>总结-6</h2><p>这节课虽然简单，但都是实际工作中常用到的小技巧，例如activeClassName，className，还有webpack配置也是必须掌握的。</p>
<p>一定要注意原生和React语法区别~~~~</p>
<h2 id="第7节-路由：-404设置和跳转"><a href="#第7节-路由：-404设置和跳转" class="headerlink" title="第7节 路由： 404设置和跳转"></a>第7节 路由： 404设置和跳转</h2><p>项目中都要设置404页面，即路由不存在时跳转的页面。React中的404主要是靠Switch组件来完成的。</p>
<p>这节来学习Switch组件相关知识和跳转的相关知识。</p>
<h3 id="Switch组件的使用"><a href="#Switch组件的使用" class="headerlink" title="Switch组件的使用"></a>Switch组件的使用</h3><ol>
<li><p>在index.js页面中，在引入路由的地方，引入Switch。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Switch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写404页面<br> 在app文件夹下新建error.js, 封装成组件，方便路由调用</p>
<p> error.js</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">error</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;h2&gt;<span class="number">404</span>页面&lt;/h2&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在nav.js中加入一个不存在的链接NavLink，以便错误时跳转到404页面</p>
<p> nav.js</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">&quot;/notfound&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span>&gt;<span class="number">404</span>&lt;/NavLink&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Switch登场，改写index.js页面，如下：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Switch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Componenta <span class="keyword">from</span> <span class="string">&#x27;./componentA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Componentb <span class="keyword">from</span> <span class="string">&#x27;./componentB&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Componentc <span class="keyword">from</span> <span class="string">&#x27;./componentC&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Nav <span class="keyword">from</span> <span class="string">&#x27;./nav&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Error</span> <span class="keyword">from</span> <span class="string">&#x27;./error&#x27;</span> <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Nav/&gt;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/redirect&quot;</span> to=<span class="string">&quot;/componentb&quot;</span>/&gt;</span><br><span class="line">                &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/componentc&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br><span class="line">                &lt;Route component=&#123;<span class="built_in">Error</span>&#125;/&gt; <span class="comment">//新增</span></span><br><span class="line">            &lt;/Switch&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>==注意==：Switch要将Route包括在里面</strong></p>
</blockquote>
<p>在浏览器中点击404 ，会跳转到error.js页面，这里的链接是随便写的，但是成功的跳到了错误页面。</p>
<p>注意顺序： 404应该在最后。</p>
<h3 id="Redirect组件使用"><a href="#Redirect组件使用" class="headerlink" title="Redirect组件使用"></a>Redirect组件使用</h3><p>开发中有时需要在程序中根据业务逻辑进行跳转，或点击一个链接直接跳转到其他链接，这时，可以用Redirect组件来解决。</p>
<ol>
<li><p>引入Redirect组件</p>
<p> 在index.js中引入Redirect 组件</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Switch, Redirect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>加入跳转链接</p>
<p> 在nav.js里加入一个准备跳转的链接，如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">&quot;/redirect&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span>&gt;redirect&lt;/NavLink&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 这时候点击链接会跳转到404页面，但我们希望跳转到componentB页面。</p>
</li>
<li><p>加入<code>&lt;Redirect&gt;</code> 标签</p>
</li>
</ol>
<p>在index.js中加入<code>&lt;Redirect&gt;</code>标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Nav/&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/redirect&quot;</span> to=<span class="string">&quot;/componentb&quot;</span>/&gt;</span><br><span class="line">            &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br><span class="line">            <span class="comment">// 新增</span></span><br><span class="line">            &lt;Route path=<span class="string">&quot;/componentc&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br><span class="line">            &lt;Route component=&#123;<span class="built_in">Error</span>&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>from: 表示来自于什么链接，也就是当前链接是redirect时，触发跳转命令</li>
<li>to: 表示要跳转到的链接，这里跳转到componentb组件。</li>
</ul>
<p>写完后，就可以在浏览器中查看跳转效果了。</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结-7"></a>总结-7</h2><p>设置404和跳转都要先加入Switch的支持，在制作404时，一定要把404的Route设置到所有路由的后面。</p>
<p>跳转时使用Redirect标签，这个很容易实现。</p>
<h2 id="第8节：-路由-通过路由传值的方法"><a href="#第8节：-路由-通过路由传值的方法" class="headerlink" title="第8节： 路由: 通过路由传值的方法"></a>第8节： 路由: 通过路由传值的方法</h2><p>开发中路由传值是必不可少的，虽然React有更优雅的方式，这里还是来学习一下路由如何传值。</p>
<h2 id="最常见的传值"><a href="#最常见的传值" class="headerlink" title="最常见的传值"></a>最常见的传值</h2><p>传值是比较简单的，主要依靠props接收。</p>
<p>基础课程中已经学了组件之间的传值方法。路由和页面之间的传值也类似。</p>
<ol>
<li><p>在nav.js页面传值，如下</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink exact to=<span class="string">&quot;/componentc/ILoveWeb&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span> className=<span class="string">&quot;blue&quot;</span>&gt;ComponentC传值&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 在路由后面跟了个ILoveWeb作为值传递给组件</p>
</li>
<li><p>Route中的设置， 用冒号来通知路由</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/componentc/:param&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在componentc组件中获取<br> 现在Componentc组件的生命周期中看一下props里有什么值。<br> componentC.js</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">componentC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.props)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;这是C组件&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在console中可以看到match.params里有值了。</p>
</li>
<li><p>在页面中显示传递的参数<br> componentC.js</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">componentC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.props)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="comment">// 新增</span></span><br><span class="line">            &lt;div&gt;这是C组件：参数：&#123;<span class="built_in">this</span>.props.match.params.param&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递2个值<br>nav.js</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;NavLink exact to=<span class="string">&quot;/componentc/ILoveWeb/HelloReact&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span> className=<span class="string">&quot;blue&quot;</span>&gt;ComponentC传值&lt;<span class="regexp">/NavLink&gt;&lt;br/</span>&gt;</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/componentc/:param/:a&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>componentC.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;这是C组件：参数：&#123;<span class="built_in">this</span>.props.match.params.param&#125;, &#123;<span class="built_in">this</span>.props.match.params.a&#125;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第9节-路由：-Router中的属性和路由模式"><a href="#第9节-路由：-Router中的属性和路由模式" class="headerlink" title="第9节 路由： Router中的属性和路由模式"></a>第9节 路由： Router中的属性和路由模式</h2><p>上节学习了React路由导航的基本方法，这节课学习标签上的属性和方法。还有一个重点是路由5种模式的讲解。</p>
<h3 id="basename属性"><a href="#basename属性" class="headerlink" title="basename属性"></a>basename属性</h3><p>basename是增加一级导航目录，如之前访问<a href="http://localhost:1717/componentb%EF%BC%8C%E7%8E%B0%E5%9C%A8%E8%AE%BF%E9%97%AE%E5%90%8C%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BD%86%E8%B7%AF%E5%BE%84%E6%98%AFhttp://localhost:1717/demo/componentb.%E8%BF%99%E6%97%B6%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8basename%E5%B1%9E%E6%80%A7%E6%9D%A5%E8%AE%BE%E7%BD%AE%E3%80%82">http://localhost:1717/componentb，现在访问同一个页面，但路径是http://localhost:1717/demo/componentb.这时，就可以使用basename属性来设置。</a></p>
<p>basename是放在<code>&lt;Router&gt;</code>标签中的</p>
<p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Router basename=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Nav/&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/redirect&quot;</span> to=<span class="string">&quot;/componentb&quot;</span>/&gt;</span><br><span class="line">                &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/componentc/:param/:a&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br><span class="line">                &lt;Route component=&#123;<span class="built_in">Error</span>&#125;/&gt;</span><br><span class="line">            &lt;/Switch&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时再点击导航，已经都加了/demo。</p>
<p>==注意：==<br>此时的设置是全局增加，如果是单个路由增加，需要特殊个性设置。</p>
<h3 id="forceRefresh-属性"><a href="#forceRefresh-属性" class="headerlink" title="forceRefresh 属性"></a>forceRefresh 属性</h3><p>这个属性是开启或关闭React Router，也就是说把forceRefresh 设为true，将关闭React路由系统，真实的去服务器端请求信息</p>
<p>现在把forceRefresh设为true，会发现路由已经不能使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">&lt;!--新增--&gt;</span><br><span class="line">    &lt;Router basename=<span class="string">&quot;demo&quot;</span> forceRefresh=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Nav/&gt;</span><br><span class="line">            &lt;Switch&gt;</span><br><span class="line">                &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/redirect&quot;</span> to=<span class="string">&quot;/componentb&quot;</span>/&gt;</span><br><span class="line">                &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Componenta&#125;/&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/componentb&quot;</span> component=&#123;Componentb&#125;/&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/componentc/:param/:a&quot;</span> component=&#123;Componentc&#125;/&gt;</span><br><span class="line">                &lt;Route component=&#123;<span class="built_in">Error</span>&#125;/&gt;</span><br><span class="line">            &lt;/Switch&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个操作经常在大项目中使用。在服务器跳转和ReactRouter切换时使用。比如做一个APP活动页，第一次请求时到服务器请求整个页面，将整个页面缓存。生成ReactRouter实现本地单页应用，设置forceRefresh为false，即可。</p>
<h2 id="5种路由方式"><a href="#5种路由方式" class="headerlink" title="5种路由方式"></a>5种路由方式</h2><p>我们一直用的是BrowserRouter，也就是浏览器的路由方式，其实React还有几种路由方式。</p>
<ul>
<li><h3 id="1-BrowserRouter"><a href="#1-BrowserRouter" class="headerlink" title="1.BrowserRouter"></a>1.BrowserRouter</h3><p>  浏览器的路由方式，也是我们一直学习的路由方式。开发中最常使用。</p>
</li>
<li><h3 id="2-HashRouter"><a href="#2-HashRouter" class="headerlink" title="2. HashRouter"></a>2. HashRouter</h3><p>  在路径钱加入#号称为一个哈希值。Hash模式的好处是，再也不会因为刷新而找不到对应路径。</p>
</li>
<li><h3 id="3-MemoryRouter"><a href="#3-MemoryRouter" class="headerlink" title="3.MemoryRouter"></a>3.MemoryRouter</h3><p>  不存储history，所有路由过程都存在内存中，不能前进后退，浏览器地址不会发生。</p>
</li>
<li><h3 id="4-NativeRouter"><a href="#4-NativeRouter" class="headerlink" title="4.NativeRouter"></a>4.NativeRouter</h3><p>  经常配合ReactNative使用，多用于移动端。</p>
</li>
<li><h3 id="5-StaticRouter"><a href="#5-StaticRouter" class="headerlink" title="5. StaticRouter"></a>5. StaticRouter</h3><p>  设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用。</p>
</li>
</ul>
<p>每中模式都有优缺点，根据项目的需求选择合适的使用即可。</p>
<h3 id="示例-使用HashRouter-或MemoryRouter模式"><a href="#示例-使用HashRouter-或MemoryRouter模式" class="headerlink" title="示例 使用HashRouter 或MemoryRouter模式"></a>示例 使用HashRouter 或MemoryRouter模式</h3><ol>
<li><p>引入</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router ,HashRouter,MemoryRouter, Route , Switch ,Redirect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置</p>
</li>
</ol>
<p>HashRouter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;HashRouter basename=<span class="string">&quot;demo&quot;</span> &gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Nav/&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route  exact  path=<span class="string">&quot;/&quot;</span>  component=&#123;Jspang&#125; /&gt;</span><br><span class="line">            &lt;Route  path=<span class="string">&quot;/Jspangb&quot;</span> component=&#123;Jspangb&#125; /&gt;</span><br><span class="line">            &lt;Route  path=<span class="string">&quot;/Jspangc/:param&quot;</span> component=&#123;Jspangc&#125; /&gt;</span><br><span class="line">            &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/redirect&quot;</span> to=<span class="string">&quot;/Jspangb&quot;</span> /&gt;</span><br><span class="line">            &lt;Route  component=&#123;<span class="built_in">Error</span>&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/HashRouter&gt;,</span><br></pre></td></tr></table></figure>

<p>MemoryRouter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;MemoryRouter basename=<span class="string">&quot;demo&quot;</span> &gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Nav/&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route  exact  path=<span class="string">&quot;/&quot;</span>  component=&#123;Jspang&#125; /&gt;</span><br><span class="line">            &lt;Route  path=<span class="string">&quot;/Jspangb&quot;</span> component=&#123;Jspangb&#125; /&gt;</span><br><span class="line">            &lt;Route  path=<span class="string">&quot;/Jspangc/:param&quot;</span> component=&#123;Jspangc&#125; /&gt;</span><br><span class="line">            &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/redirect&quot;</span> to=<span class="string">&quot;/Jspangb&quot;</span> /&gt;</span><br><span class="line">            &lt;Route  component=&#123;<span class="built_in">Error</span>&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/MemoryRouter&gt;,</span><br></pre></td></tr></table></figure>

<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结-9"></a>总结-9</h3><p>这节课重点是路由的方式。在项目开始时就应该根据需求选择好，也是要掌握的重点之一。上手项目容易遇到坑。</p>
<h2 id="第10节-路由-prompt用法详解"><a href="#第10节-路由-prompt用法详解" class="headerlink" title="第10节 路由 prompt用法详解"></a>第10节 路由 prompt用法详解</h2><p>在很多项目中，离开一个页面，都会弹出一个提示框。确定是否离开。React也有这样的组件，就是Prompt。</p>
<h2 id="lt-Prompt-gt-标签"><a href="#lt-Prompt-gt-标签" class="headerlink" title="&lt;Prompt&gt;标签"></a><code>&lt;Prompt&gt;</code>标签</h2><p>要使用<code>&lt;Prompt&gt;</code>标签要先引入。</p>
<p>componentB.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">import</span> &#123; Prompt &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">componentB</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                这是B组件</span><br><span class="line">                <span class="comment">// 新增</span></span><br><span class="line">                &lt;Prompt message=<span class="string">&quot;残忍离开?&quot;</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果使用MemoryRouter，<code>&lt;Prompt&gt;</code>不起作用。</p>
<h3 id="lt-Prompt-gt-有两个属性"><a href="#lt-Prompt-gt-有两个属性" class="headerlink" title="&lt;Prompt&gt;有两个属性"></a><code>&lt;Prompt&gt;</code>有两个属性</h3><ul>
<li>message: 用于显示提示的文本信息</li>
<li>when： 传递布尔值，相当于标签的开关，默认是true，设置为false，prompt失效。</li>
</ul>
<p>如何动态改变when的状态呢？做个小实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Prompt &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">componentB</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            power: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.changePower = <span class="built_in">this</span>.changePower.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    changePower () &#123;</span><br><span class="line">        alert(<span class="string">&#x27;已经开启&#x27;</span>)</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            power: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                这是B组件</span><br><span class="line">                &lt;Prompt message=<span class="string">&quot;残忍离开?&quot;</span>  when=&#123;<span class="built_in">this</span>.state.power&#125;/&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.changePower&#125;&gt;启用&lt;/button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Flux和Redux的学习建议在官网学习。</p>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://redux.js.org/">官方文档</a></h3><h3 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a><a href="http://cn.redux.js.org/">中文文档</a></h3><h3 id="经验-10"><a href="#经验-10" class="headerlink" title="经验-10"></a>经验-10</h3><p>移动端样式看起来大部分用flex就可以满足。<br>常用组件Text，View，TextInput，Image<br>Image src属性为source<br>样式的编写与原生区别</p>
]]></content>
  </entry>
  <entry>
    <title>TODO.md</title>
    <url>/posts/TODO/</url>
    <content><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="如何在-JS-循环中正确使用-async-与-await"><a href="#如何在-JS-循环中正确使用-async-与-await" class="headerlink" title="如何在 JS 循环中正确使用 async 与 await"></a>如何在 JS 循环中正确使用 async 与 await</h2><p><a href="https://juejin.im/post/5cf7042df265da1ba647d9d1#heading-5">参考</a><br>在循环中使用异步，请使用<code>for..of</code></p>
<h2 id="JS-精度问题"><a href="#JS-精度问题" class="headerlink" title="JS 精度问题"></a>JS 精度问题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2599.7</span> * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.3</span>？</span><br><span class="line">[从标准原理出发理解 JavaScript 数值精度](https:<span class="comment">//juejin.im/post/5c3db8b7e51d45515817bdeb)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><a href="https://www.cnblogs.com/xinggood/p/6639022.html">1</a><br>[math.js]</p>
<p><a href="https://blog.csdn.net/qq_39712029/article/details/81031458">解决办法</a></p>
<h2 id="无法实现的需求"><a href="#无法实现的需求" class="headerlink" title="无法实现的需求"></a>无法实现的需求</h2><h2 id="1-数字输入框只唤起数字键盘，不能输入汉字"><a href="#1-数字输入框只唤起数字键盘，不能输入汉字" class="headerlink" title="1. 数字输入框只唤起数字键盘，不能输入汉字"></a>1. 数字输入框只唤起数字键盘，不能输入汉字</h2><p><code>&lt;input type=&#39;number&#39;&gt;</code></p>
<p>在有的手机装了搜狗输入法或其他输入法后，唤起键盘输入法可以切换成其他输入法</p>
<p>有的机型没有装其他输入法，唤醒的不是数字键盘</p>
<h2 id="2-数字输入框获取不是数字的值"><a href="#2-数字输入框获取不是数字的值" class="headerlink" title="2. 数字输入框获取不是数字的值"></a>2. 数字输入框获取不是数字的值</h2><p>需求:</p>
<ul>
<li><p>输入<code>.</code>时, 在<code>.</code>前加0, 显示<code>0.</code></p>
</li>
<li><p>输入两个<code>..</code>时，去掉后一个</p>
</li>
</ul>
<p>在input为number类型时，输入 . ，但onchange 取不到 . ，取到的是空字符串</p>
<ul>
<li>相关知识点<br><code>input ime-mode: disabled</code><br><a href="https://blog.csdn.net/yctccg/article/details/52217988">[CSS]浏览器IME输入法控制禁止输入中文</a><br><a href="https://www.qcyoung.com/2015/09/01/type-number%E9%9D%9E%E6%B3%95%E5%80%BC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%A9%B6%E5%8F%8A%E6%8B%93%E5%B1%95/">关于表单input type=”number”非法值时的一些探究及拓展</a><br><a href="https://www.itread01.com/p/1000919.html">input type=number驗證問題Script</a></li>
</ul>
<p>React高阶</p>
<p><a href="https://github.com/dt-fe/weekly/blob/master/12.%E7%B2%BE%E8%AF%BB%20React%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.md">https://github.com/dt-fe/weekly/blob/master/12.%E7%B2%BE%E8%AF%BB%20React%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.md</a></p>
<p>很好的vue源码解析<br><a href="https://juejin.im/post/5abe5822f265da2373149276">https://juejin.im/post/5abe5822f265da2373149276</a></p>
<p>面试大全！！！！<br><a href="https://www.tuicool.com/articles/bInqieZ">https://www.tuicool.com/articles/bInqieZ</a></p>
<p>腾讯一面<br><a href="https://juejin.im/post/5ab8d9e06fb9a028c22ac36c">https://juejin.im/post/5ab8d9e06fb9a028c22ac36c</a></p>
<p>浏览器的缓存(1)<br><a href="https://segmentfault.com/a/1190000004486640">https://segmentfault.com/a/1190000004486640</a></p>
<p>前端思维导图<br><a href="https://github.com/qiu-deqing/FE-interview/blob/master/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.md?1520994177199">https://github.com/qiu-deqing/FE-interview/blob/master/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.md?1520994177199</a></p>
<p>排序<br><a href="https://juejin.im/post/57dcd394a22b9d00610c5ec8">https://juejin.im/post/57dcd394a22b9d00610c5ec8</a></p>
<p>  面试链接 还挺好的<br><a href="https://github.com/geekape/good-article/issues/2">https://github.com/geekape/good-article/issues/2</a><br>React中文官方文档<br><a href="https://doc.react-china.org/">https://doc.react-china.org/</a></p>
<p>React博客<br>React构建<br><a href="https://segmentfault.com/a/1190000007891318">https://segmentfault.com/a/1190000007891318</a><br><a href="https://taikongfeizhu.github.io/webpack3-in-action/index.html#16">https://taikongfeizhu.github.io/webpack3-in-action/index.html#16</a><br><a href="https://github.com/hujiulong/blog">https://github.com/hujiulong/blog</a></p>
<p>CSS<br><a href="http://caibaojian.com/30-seconds-of-css/">http://caibaojian.com/30-seconds-of-css/</a><br>es6常见新特性<br><a href="https://segmentfault.com/a/1190000010230939">https://segmentfault.com/a/1190000010230939</a></p>
<p><a href="https://segmentfault.com/a/1190000010204791">https://segmentfault.com/a/1190000010204791</a></p>
<p>闭包<br><a href="http://www.cnblogs.com/xxcanghai/p/4991870.html">http://www.cnblogs.com/xxcanghai/p/4991870.html</a></p>
<p>let和var的区别<br><a href="https://zhuanlan.zhihu.com/p/28140450">https://zhuanlan.zhihu.com/p/28140450</a></p>
<p>React生命周期<br><a href="https://www.cnblogs.com/lijie33402/p/6384080.html">https://www.cnblogs.com/lijie33402/p/6384080.html</a><br>HTTP协议<br><a href="https://zouhangwithsweet.github.io/">https://zouhangwithsweet.github.io/</a></p>
<p>简历制作网站<br><a href="http://www.500d.me/">http://www.500d.me/</a></p>
<p>会动的简历模板<br><a href="https://github.com/jirengu-inc/animating-resume">https://github.com/jirengu-inc/animating-resume</a></p>
<p><a href="https://segmentfault.com/a/1190000010868439">https://segmentfault.com/a/1190000010868439</a></p>
<p><a href="https://segmentfault.com/a/1190000010871559">https://segmentfault.com/a/1190000010871559</a>  webpack3</p>
<p>DOM操作成本到底高在哪儿？<br><a href="https://segmentfault.com/a/1190000014070240#articleHeader5">https://segmentfault.com/a/1190000014070240#articleHeader5</a></p>
<p>js 内存泄漏分析</p>
<p><a href="https://www.tuicool.com/articles/ErIR7rE">https://www.tuicool.com/articles/ErIR7rE?</a></p>
<p>不错的面试题</p>
<p><a href="https://github.com/WangXiZhu/frontend-interview-question">https://github.com/WangXiZhu/frontend-interview-question</a></p>
<p>大漠的学习笔记</p>
<p><a href="https://www.w3cplus.com/blogs/airen">https://www.w3cplus.com/blogs/airen</a></p>
<p>万物皆空之 JavaScript 原型<br><a href="https://www.tuicool.com/articles/BN7bi2F">https://www.tuicool.com/articles/BN7bi2F</a></p>
<p><a href="https://www.tuicool.com/articles/aEr22ue">https://www.tuicool.com/articles/aEr22ue</a></p>
<p>Vue.js最佳实践（五招让你成为Vue.js大师）<br><a href="https://segmentfault.com/a/1190000014085613">https://segmentfault.com/a/1190000014085613</a></p>
<p><a href="https://segmentfault.com/a/1190000013331105">https://segmentfault.com/a/1190000013331105</a></p>
<p><a href="https://github.com/qiu-deqing/FE-interview">https://github.com/qiu-deqing/FE-interview</a></p>
<p><a href="https://github.com/fouber/blog">https://github.com/fouber/blog</a></p>
<p>BFC 经典讲解<br><a href="https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html</a><br><a href="https://segmentfault.com/a/1190000013372963">https://segmentfault.com/a/1190000013372963</a></p>
<p>实践是最好的学习方式<br>js 最全<br><a href="https://github.com/mqyqingfeng/Blog">https://github.com/mqyqingfeng/Blog</a></p>
<p>爬虫专用网站：<a href="http://books.toscrape.com/">http://books.toscrape.com/</a></p>
<p>在服务器放打包好的文件的话，</p>
<p>先了解发起请求的本质：<br>在一个服务器（注意必须是服务器，有端口可以访问的）中，访问到一个页面</p>
<p>这个页面由 axios 之类的http请求服务接口</p>
<p>在没有配置ProxyTable时，直接请求会有跨域问题存在。</p>
<p>开发环境</p>
<p>但配置proxyTable后，可以解决跨域问题，请求得到服务返回的结果。</p>
<p>配置了proxyTable后，请求的路径 前面的<a href="http://域名端口都可以不用写,直接在proxytable的target里配置好,在axios里请求的url只需根据需要写后面的路径即可./">http://域名端口都可以不用写，直接在proxyTable的target里配置好，在axios里请求的url只需根据需要写后面的路径即可。</a></p>
<p>生产环境<br>在开发环境打包好的文件请求后端接口时是不带http和域名端口的，所以请求的是相对路径。<br>这个时候在后端起一个服务(比如node),</p>
<p>在这个node服务里发起请求的话，是要写全路径的，否则会找不到地址。</p>
<p>解决办法</p>
<p>在这个node服务中，封装一个axios的方法，在这个方法里写全路径，<br>这样之前打包好的文件是相对路径，放到这个node服务的目录下，就成了全路径访问服务。</p>
<p>还有一种方法是在打包文件中通过配置写请求路径，然后将请求后端的全路径，打包到生成的文件中。–这个还没试过</p>
<p>Docker说了这么多 最全的一篇在这里</p>
<p><a href="https://mp.weixin.qq.com/s/r6Zj9Umlc9v_rqplq8207A">https://mp.weixin.qq.com/s/r6Zj9Umlc9v_rqplq8207A</a></p>
<p>前端书籍</p>
<p><a href="https://github.com/wxyyxc1992/Web-Development-And-Engineering-Practices">https://github.com/wxyyxc1992/Web-Development-And-Engineering-Practices</a></p>
<p>android，<br>微信开发<br>angular.js<br>springmvc–上硅谷视频<br>rollup.js<br>Vue.js<br>React<br>ES6<br>node.js<br>sql<br>java<br>php<br>linux 命令行<br>nginx<br>ansible 自动化运维工具<br>fetch.js<br>pm2.js<br>bluebird.js</p>
<p>面试考察点：</p>
<ol>
<li>思路是否清晰；</li>
<li>基本语法是否有错；</li>
<li>手写代码的能力</li>
<li>算法</li>
</ol>
<p><a href="http://www.materialscss.com/grid">http://www.materialscss.com/grid</a></p>
<p>electron    <a href="https://github.com/electron/electron">https://github.com/electron/electron</a>   跨平台的GUI软件构建工具</p>
<p><a href="https://www.html5rocks.com/en/tutorials/file/filesystem/">https://www.html5rocks.com/en/tutorials/file/filesystem/</a> H5文件接口</p>
<p>Express   <a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a>   基于node。js的web框架<br>lodash <a href="http://lodashjs.com/docs/#_now">http://lodashjs.com/docs/#_now</a>   js库</p>
<p>write  a blog</p>
<p><a href="http://ssh.today/blog/something-about-js-timer">http://ssh.today/blog/something-about-js-timer</a></p>
<p>js 正则表达式<br><a href="https://segmentfault.com/a/1190000008812676#articleHeader1">https://segmentfault.com/a/1190000008812676#articleHeader1</a><br><a href="https://juejin.im/post/5965943ff265da6c30653879">https://juejin.im/post/5965943ff265da6c30653879</a></p>
<p>js 排序<br><a href="https://segmentfault.com/a/1190000008796659">https://segmentfault.com/a/1190000008796659</a></p>
<p>微信小程序<br><a href="https://github.com/lin-xin/wxapp-mall">https://github.com/lin-xin/wxapp-mall</a></p>
<p>前端面试题：<br><a href="https://juejin.im/post/59be99a0f265da0644289dde">https://juejin.im/post/59be99a0f265da0644289dde</a><br>前端程序员经常忽视的一个JavaScript面试题</p>
<p><a href="https://segmentfault.com/p/1210000008946418/read#top">https://segmentfault.com/p/1210000008946418/read#top</a></p>
<p>小菜鸟前端面试大作战<br><a href="https://huruji.github.io/FE-Interview/#/">https://huruji.github.io/FE-Interview/#/</a></p>
<p>妨碍进步的因素<br><a href="https://juejin.im/post/59bf2a1d51882531b730b718">https://juejin.im/post/59bf2a1d51882531b730b718</a></p>
<p>异步递归回调<br><a href="https://zhuanlan.zhihu.com/p/29534555">https://zhuanlan.zhihu.com/p/29534555</a><br>你不知道的 CSS</p>
<p><a href="https://mp.weixin.qq.com/s/GxtJTIbMbFteCEFnFB7waw">https://mp.weixin.qq.com/s/GxtJTIbMbFteCEFnFB7waw</a></p>
<p><a href="https://smohan.net/blog/6gr77h">https://smohan.net/blog/6gr77h</a></p>
<p>css 加载动画效果源码<br><a href="http://loading.awesomes.cn/">http://loading.awesomes.cn/</a></p>
<p>使用递归遍历并转换树形数据（以 TypeScript 为例）<br><a href="https://segmentfault.com/a/1190000011819279">https://segmentfault.com/a/1190000011819279</a></p>
<p>React:<br>一篇包含了react所有基本点的文章</p>
<p><a href="https://segmentfault.com/a/1190000011205580">https://segmentfault.com/a/1190000011205580</a><br>揭秘react全家桶(redux,react-redux,react-router)<br><a href="https://github.com/shen1992/blog/issues/2">https://github.com/shen1992/blog/issues/2</a><br>Node<br>饿了么Node.js教程<br><a href="https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn">https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn</a></p>
<p><a href="https://github.com/ElemeFE/node-practice">https://github.com/ElemeFE/node-practice</a></p>
<p>React 免费教程<br><a href="https://react-course.magicfun.ai/">https://react-course.magicfun.ai/</a></p>
<p>mac读取移动硬盘<br><a href="http://vip.zgyjzf.com/nfm/">http://vip.zgyjzf.com/nfm/</a></p>
<p>GitHub软件<br><a href="https://osxfuse.github.io/">https://osxfuse.github.io/</a></p>
<p><a href="http://www.cnblogs.com/macsoft/p/6835753.html">http://www.cnblogs.com/macsoft/p/6835753.html</a></p>
<p><a href="http://www.orsoon.com/Mac/150550.html">http://www.orsoon.com/Mac/150550.html</a></p>
<p><a href="http://wm.makeding.com/redirect/url?segment=axEJmc-ik43ina5LG-TZD5_vApJ8vMxEnzLuVBELJ7z1iJBTC25zxyiSookdjOflPQ-BBKfzOu8S0TT3T6H3sDYVMbITp52pODsN82VD8jrLwXt9uhTQFq_XOsbWm65NgbxaG6R8Mk6-AfLaZNWB9aeCYPbr_mq2VQMeCsKne_U-sXLaxRW9KmP7UG0SKEAwKUWVD2m8pkHSRF5N-2o1i79iLyUwl2pjDCB93P64q753lx_QCO28E9nH_8r7BI0hD9-dXEJp9dEZkU2NL__inFM1LFFdI_6h0GOU3fWoPescmS_HrDNHlvytmT4qrypAaB5Y0_-YzFIcq1TWs79zj-nJwyETD8zaEMC43M1rThHEPYncCvFLvP7F9S140X10&amp;utm_medium=wm&amp;utm_source=http://www.cnblogs.com/macsoft/p/6835753.html&amp;utm_content=Tuxera+NTFS--&amp;utm_campaign=LM_echo">http://wm.makeding.com/redirect/url?segment=axEJmc-ik43ina5LG-TZD5_vApJ8vMxEnzLuVBELJ7z1iJBTC25zxyiSookdjOflPQ-BBKfzOu8S0TT3T6H3sDYVMbITp52pODsN82VD8jrLwXt9uhTQFq_XOsbWm65NgbxaG6R8Mk6-AfLaZNWB9aeCYPbr_mq2VQMeCsKne_U-sXLaxRW9KmP7UG0SKEAwKUWVD2m8pkHSRF5N-2o1i79iLyUwl2pjDCB93P64q753lx_QCO28E9nH_8r7BI0hD9-dXEJp9dEZkU2NL__inFM1LFFdI_6h0GOU3fWoPescmS_HrDNHlvytmT4qrypAaB5Y0_-YzFIcq1TWs79zj-nJwyETD8zaEMC43M1rThHEPYncCvFLvP7F9S140X10&amp;utm_medium=wm&amp;utm_source=http%3A%2F%2Fwww.cnblogs.com%2Fmacsoft%2Fp%2F6835753.html&amp;utm_content=Tuxera+NTFS--&amp;utm_campaign=LM_echo</a></p>
<p>js事件绑定问题，<br>    对接高德导航服务，起点终点确定坐标。<br>   起点：输入内容，有下拉框，选择了下拉框的就有可确定坐标，没选下拉框，就要搜索，<br>   终点： 同上<br>  点击搜索路线。如果起点终点都确定坐标，直接搜索路线，<br>                            不确定起点终点，则先搜索结果。<br>    怎么判定这两个状态？<br>     我的思路，在下拉框中选择一个结果，则给输入框赋一个坐标的属性，<br>                        点击搜索路线，判断输入框是否有坐标属性，有直接搜路线，没有，查询结果。<br>                       onchange或onkeyup清除坐标属性</p>
<p>node 作为中间件搭建前段代理，中转请求到后端。<br><a href="https://segmentfault.com/a/1190000007992200">https://segmentfault.com/a/1190000007992200</a></p>
<ol>
<li><p>git book中文教程<br><a href="https://chenyitian.gitbooks.io/react-docs">https://chenyitian.gitbooks.io/react-docs</a></p>
</li>
<li><p>官网</p>
</li>
<li><p>不错的教程<br><a href="http://www.runoob.com/w3cnote/getting-started-with-react.html">http://www.runoob.com/w3cnote/getting-started-with-react.html</a></p>
</li>
<li><p>极客学院教程<br><a href="http://wiki.jikexueyuan.com/project/react-tutorial/">http://wiki.jikexueyuan.com/project/react-tutorial/</a></p>
</li>
<li><p>React启蒙（译）<br><a href="https://www.gitbook.com/book/zhangwang1990/reactenlightenment/details">https://www.gitbook.com/book/zhangwang1990/reactenlightenment/details</a><br>React中国<br><a href="https://tianxiangbing.github.io/react-cn/index.html">https://tianxiangbing.github.io/react-cn/index.html</a><br>React 入门教程<br><a href="https://hulufei.gitbooks.io/react-tutorial/content/component.html">https://hulufei.gitbooks.io/react-tutorial/content/component.html</a></p>
</li>
</ol>
<p>完美使用 React, Redux, and React-Router！最好用的脚手架<br><a href="https://github.com/bodyno/react-starter-kit">https://github.com/bodyno/react-starter-kit</a></p>
<p>react 中文网<br><a href="http://www.react-cn.com/">http://www.react-cn.com/</a><br><a href="https://segmentfault.com/blog/jasonnote">https://segmentfault.com/blog/jasonnote</a></p>
<p><a href="https://github.com/theJian/build-a-hn-front-page">https://github.com/theJian/build-a-hn-front-page</a><br>React技术栈+Express+Mongodb实现个人博客<br><a href="https://github.com/Nealyang/React-Express-Blog-Demo">https://github.com/Nealyang/React-Express-Blog-Demo</a></p>
<p>Vue<br>router文档：<br><a href="http://router.vuejs.org/zh-cn/">http://router.vuejs.org/zh-cn/</a></p>
<p>demo示例：<br><a href="https://github.com/cwsjoker/webpack-vue-spa-demo/tree/master">https://github.com/cwsjoker/webpack-vue-spa-demo/tree/master</a></p>
<p>中文文档；<br><a href="https://vuefe.cn/v2/guide/">https://vuefe.cn/v2/guide/</a></p>
<p>vue学习教程<br><a href="http://www.cnblogs.com/keepfool/p/5619070.html">http://www.cnblogs.com/keepfool/p/5619070.html</a></p>
<p>vue  vue-material框架<br><a href="https://vuematerial.github.io/">https://vuematerial.github.io</a></p>
<p>很全的vue资料 赞赞赞~~~~~~~~~~~~~<br><a href="https://github.com/opendigg/awesome-github-vue">https://github.com/opendigg/awesome-github-vue</a></p>
<p><a href="https://github.com/vuejs/awesome-vue">https://github.com/vuejs/awesome-vue</a></p>
<p>简单的后台管理系统<br><a href="https://github.com/monster1935/vue-element">https://github.com/monster1935/vue-element</a></p>
<p>很棒的后台管理系统<br><a href="http://panjiachen.github.io/vue-element-admin/#/introduction/index">http://panjiachen.github.io/vue-element-admin/#/introduction/index</a></p>
<p>这个也不错<br><a href="https://github.com/vue-bulma/vue-admin">https://github.com/vue-bulma/vue-admin</a></p>
<p>Vue项目中引用知乎API获取图片报403解决方案</p>
<ol>
<li>在html设置meta</li>
</ol>
<meta name="referrer" content="never">
链接
http://www.cnblogs.com/dongcanliang/archive/2017/04/01/6655061.html

<ol start="2">
<li>通过获取img src，用iframe去请求<br>链接：<br><a href="https://segmentfault.com/q/1010000002581983/a-1020000002592757">https://segmentfault.com/q/1010000002581983/a-1020000002592757</a></li>
</ol>
<p><a href="https://www.xiabingbao.com/vue/2017/07/10/vue-curd.html">https://www.xiabingbao.com/vue/2017/07/10/vue-curd.html</a></p>
<p><a href="https://www.xiabingbao.com/">https://www.xiabingbao.com</a></p>
<p>Vue 组件编写<br><a href="https://segmentfault.com/a/1190000011796898">https://segmentfault.com/a/1190000011796898</a><br>React<br>React 服务端渲染如此轻松 从零开始构建前后端应用<br><a href="https://segmentfault.com/a/1190000010260036">https://segmentfault.com/a/1190000010260036</a></p>
<p>Vue2.0—仿知乎日报总结</p>
<p><a href="https://segmentfault.com/a/1190000009305496">https://segmentfault.com/a/1190000009305496</a></p>
<p>VUE-WAS：一个基于Vue的Web App收集向项目</p>
<p><a href="https://segmentfault.com/a/1190000010330905">https://segmentfault.com/a/1190000010330905</a></p>
<p> Vue 与 iOS 的组件化.md<br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Vue/%E5%A4%A7%E8%AF%9D%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3(%E4%B8%80)%20%E2%80%94%E2%80%94%20Vue%20%E4%B8%8E%20iOS%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96.md">https://github.com/halfrost/Halfrost-Field/blob/master/contents/Vue/%E5%A4%A7%E8%AF%9D%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3(%E4%B8%80)%20%E2%80%94%E2%80%94%20Vue%20%E4%B8%8E%20iOS%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96.md</a></p>
<p>好的js博客<br><a href="https://zhuanlan.zhihu.com/dreawer?author=qiangdada520">https://zhuanlan.zhihu.com/dreawer?author=qiangdada520</a></p>
<p>天猫前端<br><a href="http://tmallfe.github.io/">http://tmallfe.github.io/</a></p>
<p>js 核心概念<br><a href="https://mp.weixin.qq.com/s/I7A1iC8Et6uOGZ234DsTlA">https://mp.weixin.qq.com/s/I7A1iC8Et6uOGZ234DsTlA</a></p>
<p>Vue mock<br><a href="http://www.jianshu.com/p/284590b5b717">http://www.jianshu.com/p/284590b5b717</a><br><a href="https://github.com/yanm1ng/vue-starter-kit">https://github.com/yanm1ng/vue-starter-kit</a></p>
<p>很好的面试题<br><a href="https://zhoukekestar.github.io/notes/2017/06/07/interview-answers.html">https://zhoukekestar.github.io/notes/2017/06/07/interview-answers.html</a></p>
<p>vue 很好的后台管理系统<br><a href="https://github.com/PanJiaChen/vue-element-admin">https://github.com/PanJiaChen/vue-element-admin</a><br><a href="https://github.com/PanJiaChen/vueAdmin-template">https://github.com/PanJiaChen/vueAdmin-template</a></p>
<p>Vue源码解析~~非常棒<br><a href="https://zhuanlan.zhihu.com/p/25869382">https://zhuanlan.zhihu.com/p/25869382</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28835709">https://zhuanlan.zhihu.com/p/28835709</a>  高阶函数</p>
<p>easy-mock<br><a href="https://easy-mock.com/">https://easy-mock.com/</a>    believezjp zhao110120</p>
<p>前端每周盘点半年清单系列</p>
<p><a href="https://segmentfault.com/a/1190000010769946">https://segmentfault.com/a/1190000010769946</a></p>
<p><a href="https://segmentfault.com/a/1190000010716195">https://segmentfault.com/a/1190000010716195</a></p>
<p>MVVM实现原理。<br><a href="https://segmentfault.com/a/1190000010744960">https://segmentfault.com/a/1190000010744960</a></p>
<p>React 学习教程<br><a href="https://segmentfault.com/a/1190000005136764">https://segmentfault.com/a/1190000005136764</a></p>
<p>Vue 脱坑记 - 查漏补缺(汇总下群里高频询问的xxx及给出不靠谱的解决方案)<br><a href="https://juejin.im/post/59fa9257f265da43062a1b0e">https://juejin.im/post/59fa9257f265da43062a1b0e</a></p>
<p>使用vscode 自动修复eslint的格式错误(空格多少，tab之类的)<br>vscode左下角，设置配置如下：<br>“eslint.validate”: [<br>        “javascript”,<br>        “javascriptreact”,<br>        {<br>            “language”: “vu             e”,<br>            “autoFix”: true<br>        }<br>    ]</p>
<p>把vue文件设为true,<br>想修复的时候，在vscode用ctrl+shift+p打开命令行，输入Fix  all  auto-fixable problems<br>即可自动修复所有的格式错误</p>
<p><a href="http://www.gbtags.com/">http://www.gbtags.com/</a></p>
<p>所有软件的书籍：</p>
<p><a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md">https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md</a></p>
<p>react 教程：<br><a href="https://fakefish.github.io/react-webpack-cookbook/">https://fakefish.github.io/react-webpack-cookbook/</a></p>
<p>FLEX<br>照着改造自己的flex 页面。<br><a href="https://zhuanlan.zhihu.com/p/25303493">https://zhuanlan.zhihu.com/p/25303493</a></p>
<p><a href="http://www.fgm.cc/learn/">http://www.fgm.cc/learn/</a>  各种实例<br>各种视频课程 <a href="http://www.stuq.org/">http://www.stuq.org/</a></p>
<p><a href="http://www.chengxuyuans.com/web_technology/ajax-jsonp.html">http://www.chengxuyuans.com/web_technology/ajax-jsonp.html</a> jsonp的讲解<br><a href="http://kb.cnblogs.com/page/159704/web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%8D%81%E6%97%A5%E8%B0%88">http://kb.cnblogs.com/page/159704/web前端开发十日谈</a><br><a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html">http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html</a></p>
<p><a href="https://github.com/FreeCodeCamp/FreeCodeCamp/blob/staging/CONTRIBUTING.md">https://github.com/FreeCodeCamp/FreeCodeCamp/blob/staging/CONTRIBUTING.md</a></p>
<p>线下课 &lt;&lt;前端工程师与测试工程师&gt;&gt;<br><a href="http://www.tudou.com/programs/view/NRpKuBbeZEg">http://www.tudou.com/programs/view/NRpKuBbeZEg</a><br>密码 ydxt2016</p>
<p>&lt;&lt;EcmaScript6编程风格上&gt;&gt;<br>链接: <a href="http://pan.baidu.com/s/1c1TfnUC">http://pan.baidu.com/s/1c1TfnUC</a> 密码: 945t</p>
<p>&lt;&lt;第一周考题&gt;&gt;你可以测验一下自己的水平。<br><a href="http://pan.baidu.com/s/1gf7BsUf">http://pan.baidu.com/s/1gf7BsUf</a> 密码ceuh<br>讲解 <a href="http://www.tudou.com/programs/view/epsKmGW-Nwg/">http://www.tudou.com/programs/view/epsKmGW-Nwg/</a><br>密码YDXTpass2016</p>
<p>Vue.js资源分享<br><a href="https://github.com/maidishike/FrontEnd-Wikis/blob/master/vuejs.md">https://github.com/maidishike/FrontEnd-Wikis/blob/master/vuejs.md</a></p>
<p>JavaScript 全栈工程师培训教程<br><a href="http://www.ruanyifeng.com/blog/2016/11/javascript.html">http://www.ruanyifeng.com/blog/2016/11/javascript.html</a></p>
<p>简书很棒的文章：<br><a href="http://www.jianshu.com/p/cc1cb9a5650c">http://www.jianshu.com/p/cc1cb9a5650c</a></p>
<p><a href="http://blog.phpfamily.org/">http://blog.phpfamily.org</a></p>
<p><a href="http://ued.party/#%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%89%8D%E7%AB%AF%E6%B2%A1%E6%9C%89%E5%89%8D%E9%80%94">http://ued.party/#序为什么前端没有前途</a></p>
<p><a href="https://www.shiyanlou.com/paths/web%E5%AE%9E%E9%AA%8C%E6%A5%BC">https://www.shiyanlou.com/paths/web实验楼</a></p>
<p>JavaScript设计模式之结构型设计模式<br><a href="https://segmentfault.com/a/1190000012585364">https://segmentfault.com/a/1190000012585364</a></p>
<p>JavaScript数据类型的存储<br><a href="http://axuebin.com/blog/2017/08/24/javascript-data-storage/">http://axuebin.com/blog/2017/08/24/javascript-data-storage/</a></p>
<p>jQuery 对应原生js怎么写~~~<br><a href="http://youmightnotneedjquery.com/">http://youmightnotneedjquery.com/</a></p>
<p><a href="https://github.com/oneuijs/You-Dont-Need-jQuery/blob/master/README.zh-CN.md">https://github.com/oneuijs/You-Dont-Need-jQuery/blob/master/README.zh-CN.md</a></p>
<p>JavaScript深入教程–必学！！<br><a href="https://github.com/mqyqingfeng/Blog">https://github.com/mqyqingfeng/Blog</a></p>
<h1 id="js专题"><a href="#js专题" class="headerlink" title="js专题"></a>js专题</h1><pre><code>https://segmentfault.com/blog/yayu-blog?tag=javascript%E4%B8%93%E9%A2%98%E7%B3%BB%E5%88%97</code></pre>
<p>vitual-dom原理与简单实现</p>
<p><a href="https://segmentfault.com/a/1190000012230659#articleHeader2">https://segmentfault.com/a/1190000012230659#articleHeader2</a></p>
<p>【JavaScript从入门到精通】<br><a href="http://www.igeekbar.com/igeekbar/mypost/113.htm">http://www.igeekbar.com/igeekbar/mypost/113.htm</a></p>
<p>前端PDF下载<br><a href="http://www.menvscode.com/list/ziyuan/webpdf/1">http://www.menvscode.com/list/ziyuan/webpdf/1</a></p>
<p>javascript组件化<br><a href="http://caibaojian.com/javascript-module-2.html">http://caibaojian.com/javascript-module-2.html</a></p>
<h2 id="从-for-of-聊到-Generator"><a href="#从-for-of-聊到-Generator" class="headerlink" title="从 for of 聊到 Generator"></a><a href="https://juejin.im/post/5c40484bf265da61171cfb4d">从 for of 聊到 Generator</a></h2><h2 id="深入理解-TypeScript"><a href="#深入理解-TypeScript" class="headerlink" title="深入理解 TypeScript"></a><a href="https://jkchao.github.io/typescript-book-chinese/project/modules.html">深入理解 TypeScript</a></h2><h2 id="MDN-javascript中高级教程"><a href="#MDN-javascript中高级教程" class="headerlink" title="MDN javascript中高级教程"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN javascript中高级教程</a></h2><h2 id="「中高级前端」高性能渲染十万条数据"><a href="#「中高级前端」高性能渲染十万条数据" class="headerlink" title="「中高级前端」高性能渲染十万条数据"></a>「中高级前端」高性能渲染十万条数据</h2><p><a href="https://juejin.im/post/5d76f469f265da039a28aff7">「中高级前端」高性能渲染十万条数据</a></p>
<h2 id="校园编程和职场编程的区别"><a href="#校园编程和职场编程的区别" class="headerlink" title="校园编程和职场编程的区别"></a>校园编程和职场编程的区别</h2><p>学校的程序解决的设计问题很少是险恶的，基本能从头到尾直线前进而设计。<br>基本完成作业就可以，很少会对程序改动。</p>
<p>而专业编程中代码的修改是每日可见的真实情景。</p>
<h2 id="读代码大全2笔记"><a href="#读代码大全2笔记" class="headerlink" title="读代码大全2笔记"></a>读代码大全2笔记</h2><p>软件开发的隐喻，到底什么词合适</p>
<p>先想到的是庖丁解牛，不过是相反的过程，缺少任何一个骨头肌肉都不能完整拼成。</p>
<p>但播种耕种更形象，播种直到丰收，每个细节都不能马虎，最终才能有秋后的果实。</p>
<p>大型的房屋建筑需要超出常规的规划和建设</p>
<p>组合各种隐喻</p>
<h3 id="软件开发金字塔"><a href="#软件开发金字塔" class="headerlink" title="软件开发金字塔"></a>软件开发金字塔</h3><ol>
<li>问题定义<br>只定义问题是什么，不涉及任何可能的解决方案。</li>
<li>需求<br>需求像水，冻结了才能在上面开展建设。</li>
</ol>
<p>管理复杂度的重要性</p>
<p>作为软件开发人员，不应该试着在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。<br>这么做的目的是尽量减少在任意时间索要考虑的程序量。</p>
<p>在软件架构层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。<br>2019-11-29 16:49:41 97页</p>
<p>代码整洁之道读完</p>
<p><a href="https://github.com/koala-coding/goodBlog/blob/master/docs/node/eventLoop.md">event loop</a></p>
]]></content>
  </entry>
  <entry>
    <title>Vue-cli教程</title>
    <url>/posts/Vue-cli%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>TODO</p>
<p>vue插件</p>
<p><a href="https://segmentfault.com/a/1190000012224638">https://segmentfault.com/a/1190000012224638</a></p>
<h1 id="第一节：-安装vue-cli"><a href="#第一节：-安装vue-cli" class="headerlink" title="第一节： 安装vue-cli"></a>第一节： 安装vue-cli</h1><p>前提是要安装node和npm。</p>
<p>可以在命令行输入npm -v，检测是否安装了npm和版本情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">5.4.2</span><br></pre></td></tr></table></figure>

<h2 id="用npm安装vue-cli"><a href="#用npm安装vue-cli" class="headerlink" title="用npm安装vue-cli"></a>用npm安装vue-cli</h2><p>确定npm安装成功后，在命令行全局安装vue-cli</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure>

<p>安装成功后，尝试输入vue -V(注意V是大写)，出现版本信息则安装成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vue -V</span><br><span class="line">2.9.1</span><br></pre></td></tr></table></figure>

<h4 id="mac电脑安装vue-lic失败"><a href="#mac电脑安装vue-lic失败" class="headerlink" title="mac电脑安装vue-lic失败"></a>mac电脑安装vue-lic失败</h4><p>npm install –global vue-cli<br>sudo npm install –global vue-cli 即可</p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>用命令vue init来初始化项目。语法介绍  <a href="https://github.com/vuejs/vue-cli">官网</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init &lt;template-name&gt; &lt;project-name&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>init：表示我要用vue-cli来初始化项目<br><template-name>：表示模板名称，vue-cli官方为我们提供了5种模板，</p>
</blockquote>
<ul>
<li>webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。</li>
<li>webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。</li>
<li>browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。</li>
<li>browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。</li>
<li>simple-一个最简单的单页应用模板。</li>
</ul>
<blockquote>
<p><project-name>：标识项目名称，这个你可以根据自己的项目来起名字。</p>
</blockquote>
<p>在实际开发过程中一般会使用webpack这个模板。这里也安装这个模板。</p>
<h4 id="在终端输入命令"><a href="#在终端输入命令" class="headerlink" title="在终端输入命令"></a>在终端输入命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack vue-tutorial</span><br></pre></td></tr></table></figure>

<p>输入命令后，会有提示信息，按照需要填写即可。</p>
<ul>
<li>Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写</li>
<li>Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。</li>
<li>Author：作者，如果你有配置git的作者，他会读取。</li>
<li>Install  vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y</li>
<li>Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里输入y，如果你是大型团队开发，最好是进行配置。</li>
<li>setup unit tests with  Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。</li>
<li>Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。</li>
</ul>
<p>可以看到提示信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">To get started:</span><br><span class="line"></span><br><span class="line">  cd vue-tutorial</span><br><span class="line">  npm install</span><br><span class="line">  npm run dev</span><br><span class="line"></span><br><span class="line">Documentation can be found at https:&#x2F;&#x2F;vuejs-templates.github.io&#x2F;webpack</span><br></pre></td></tr></table></figure>

<p>1、cd vuecliTest  进入我们的vue项目目录。</p>
<p>2、npm install  安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。</p>
<p>3、npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。</p>
<p>至此，已经安装成功，可以开始写vue代码啦。</p>
<h1 id="第二节：vue-cli项目结构讲解"><a href="#第二节：vue-cli项目结构讲解" class="headerlink" title="第二节：vue-cli项目结构讲解"></a>第二节：vue-cli项目结构讲解</h1><p>vue-cli为我们搭建了开发所需要的环境，省去了很多精力。有必要对这个环境进行熟悉，我们从项目的结构讲起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- build                            &#x2F;&#x2F; 项目构建(webpack)相关代码</span><br><span class="line">|   |-- build.js                     &#x2F;&#x2F; 生产环境构建代码</span><br><span class="line">|   |-- check-version.js             &#x2F;&#x2F; 检查node、npm等版本</span><br><span class="line">|   |-- dev-client.js                &#x2F;&#x2F; 热重载相关</span><br><span class="line">|   |-- dev-server.js                &#x2F;&#x2F; 构建本地服务器</span><br><span class="line">|   |-- utils.js                     &#x2F;&#x2F; 构建工具相关</span><br><span class="line">|   |-- webpack.base.conf.js         &#x2F;&#x2F; webpack基础配置</span><br><span class="line">|   |-- webpack.dev.conf.js          &#x2F;&#x2F; webpack开发环境配置</span><br><span class="line">|   |-- webpack.prod.conf.js         &#x2F;&#x2F; webpack生产环境配置</span><br><span class="line">|-- config                           &#x2F;&#x2F; 项目开发环境配置</span><br><span class="line">|   |-- dev.env.js                   &#x2F;&#x2F; 开发环境变量</span><br><span class="line">|   |-- index.js                     &#x2F;&#x2F; 项目一些配置变量</span><br><span class="line">|   |-- prod.env.js                  &#x2F;&#x2F; 生产环境变量</span><br><span class="line">|   |-- test.env.js                  &#x2F;&#x2F; 测试环境变量</span><br><span class="line">|-- src                              &#x2F;&#x2F; 源码目录</span><br><span class="line">|   |-- components                     &#x2F;&#x2F; vue公共组件</span><br><span class="line">|   |-- store                          &#x2F;&#x2F; vuex的状态管理</span><br><span class="line">|   |-- App.vue                        &#x2F;&#x2F; 页面入口文件</span><br><span class="line">|   |-- main.js                        &#x2F;&#x2F; 程序入口文件，加载各种公共组件</span><br><span class="line">|-- static                           &#x2F;&#x2F; 静态文件，比如一些图片，json数据等</span><br><span class="line">|   |-- data                           &#x2F;&#x2F; 群聊分析得到的数据用于数据可视化</span><br><span class="line">|-- .babelrc                         &#x2F;&#x2F; ES6语法编译配置</span><br><span class="line">|-- .editorconfig                    &#x2F;&#x2F; 定义代码格式</span><br><span class="line">|-- .gitignore                       &#x2F;&#x2F; git上传需要忽略的文件格式</span><br><span class="line">|-- README.md                        &#x2F;&#x2F; 项目说明</span><br><span class="line">|-- favicon.ico</span><br><span class="line">|-- index.html                       &#x2F;&#x2F; 入口页面</span><br><span class="line">|-- package.json                     &#x2F;&#x2F; 项目基本信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重点文件讲解"><a href="#重点文件讲解" class="headerlink" title="重点文件讲解"></a>重点文件讲解</h2><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。</p>
<p><strong>package.json 里的scripts字段</strong>，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js  .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;node build&#x2F;dev-server.js&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;node build&#x2F;build.js&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="dependencies字段和devDependencies字段"><a href="#dependencies字段和devDependencies字段" class="headerlink" title="dependencies字段和devDependencies字段"></a>dependencies字段和devDependencies字段</h4><ul>
<li>dependencies字段指项目运行时所依赖的模块；</li>
<li>devDependencies字段指定了项目开发时所依赖的模块；</li>
</ul>
<p>在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。</p>
<p>package.json还有很多相关配置，如果你想全面了解，可以专门去百度学习一下。</p>
<h2 id="webpack-配置相关"><a href="#webpack-配置相关" class="headerlink" title="webpack 配置相关"></a>webpack 配置相关</h2><p>我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。</p>
<h3 id="dev-server-js"><a href="#dev-server-js" class="headerlink" title="dev-server.js"></a>dev-server.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查 Node 和 npm 版本</span><br><span class="line">require(&#39;.&#x2F;check-versions&#39;)()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 config&#x2F;index.js 的默认配置</span><br><span class="line">var config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果 Node 的环境无法判断当前是 dev &#x2F; product 环境</span><br><span class="line">&#x2F;&#x2F; 使用 config.dev.env.NODE_ENV 作为当前的环境</span><br><span class="line"></span><br><span class="line">if (!process.env.NODE_ENV) process.env.NODE_ENV &#x3D; JSON.parse(config.dev.env.NODE_ENV)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 NodeJS 自带的文件路径工具</span><br><span class="line">var path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 express</span><br><span class="line">var express &#x3D; require(&#39;express&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 webpack</span><br><span class="line">var webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个可以强制打开浏览器并跳转到指定 url 的插件</span><br><span class="line">var opn &#x3D; require(&#39;opn&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 proxyTable</span><br><span class="line">var proxyMiddleware &#x3D; require(&#39;http-proxy-middleware&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 dev 环境的 webpack 配置</span><br><span class="line">var webpackConfig &#x3D; require(&#39;.&#x2F;webpack.dev.conf&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; default port where dev server listens for incoming traffic</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果没有指定运行端口，使用 config.dev.port 作为运行端口</span><br><span class="line">var port &#x3D; process.env.PORT || config.dev.port</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Define HTTP proxies to your custom API backend</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;chimurai&#x2F;http-proxy-middleware</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置</span><br><span class="line">var proxyTable &#x3D; config.dev.proxyTable</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 express 启动一个服务</span><br><span class="line">var app &#x3D; express()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动 webpack 进行编译</span><br><span class="line">var compiler &#x3D; webpack(webpackConfig)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中</span><br><span class="line">var devMiddleware &#x3D; require(&#39;webpack-dev-middleware&#39;)(compiler, &#123;</span><br><span class="line">  publicPath: webpackConfig.output.publicPath,</span><br><span class="line">  stats: &#123;</span><br><span class="line">    colors: true,</span><br><span class="line">    chunks: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload</span><br><span class="line">var hotMiddleware &#x3D; require(&#39;webpack-hot-middleware&#39;)(compiler)</span><br><span class="line">&#x2F;&#x2F; force page reload when html-webpack-plugin template changes</span><br><span class="line">compiler.plugin(&#39;compilation&#39;, function (compilation) &#123;</span><br><span class="line">  compilation.plugin(&#39;html-webpack-plugin-after-emit&#39;, function (data, cb) &#123;</span><br><span class="line">    hotMiddleware.publish(&#123; action: &#39;reload&#39; &#125;)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; proxy api requests</span><br><span class="line">&#x2F;&#x2F; 将 proxyTable 中的请求配置挂在到启动的 express 服务上</span><br><span class="line">Object.keys(proxyTable).forEach(function (context) &#123;</span><br><span class="line">  var options &#x3D; proxyTable[context]</span><br><span class="line">  if (typeof options &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    options &#x3D; &#123; target: options &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  app.use(proxyMiddleware(context, options))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; handle fallback for HTML5 history API</span><br><span class="line">&#x2F;&#x2F; 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址</span><br><span class="line">app.use(require(&#39;connect-history-api-fallback&#39;)())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; serve webpack bundle output</span><br><span class="line">&#x2F;&#x2F; 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上</span><br><span class="line">app.use(devMiddleware)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; enable hot-reload and state-preserving</span><br><span class="line">&#x2F;&#x2F; compilation error display</span><br><span class="line">&#x2F;&#x2F; 将 Hot-reload 挂在到 express 服务上</span><br><span class="line">app.use(hotMiddleware)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; serve pure static assets</span><br><span class="line">&#x2F;&#x2F; 拼接 static 文件夹的静态资源路径</span><br><span class="line">var staticPath &#x3D; path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)</span><br><span class="line">&#x2F;&#x2F; 为静态资源提供响应服务</span><br><span class="line">app.use(staticPath, express.static(&#39;.&#x2F;static&#39;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露</span><br><span class="line">module.exports &#x3D; app.listen(port, function (err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  var uri &#x3D; &#39;http:&#x2F;&#x2F;localhost:&#39; + port</span><br><span class="line">  console.log(&#39;Listening at &#39; + uri + &#39;\n&#39;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; when env is testing, don&#39;t need open it</span><br><span class="line">  &#x2F;&#x2F; 如果不是测试环境，自动打开浏览器并跳到我们的开发地址</span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;testing&#39;) &#123;</span><br><span class="line">    opn(uri)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="webpack-base-confg-js-webpack的基础配置文件"><a href="#webpack-base-confg-js-webpack的基础配置文件" class="headerlink" title="webpack.base.confg.js   webpack的基础配置文件"></a>webpack.base.confg.js   webpack的基础配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.export &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 编译入口文件</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; 编译输出路径</span><br><span class="line">    output: &#123;&#125;,</span><br><span class="line">    &#x2F;&#x2F; 一些解决方案配置</span><br><span class="line">    resolve: &#123;&#125;,</span><br><span class="line">    resolveLoader: &#123;&#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        &#x2F;&#x2F; 各种不同类型文件加载器配置</span><br><span class="line">        loaders: &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; js文件用babel转码</span><br><span class="line">        &#123;</span><br><span class="line">            test: &#x2F;\.js$&#x2F;,</span><br><span class="line">            loader: &#39;babel&#39;,</span><br><span class="line">            include: projectRoot,</span><br><span class="line">            &#x2F;&#x2F; 哪些文件不需要转码</span><br><span class="line">            exclude: &#x2F;node_modules&#x2F;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; vue文件一些相关配置</span><br><span class="line">    vue: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细的webpack知识可以在webpack里学习。</p>
<h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h2><p>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;设定转码规则</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123; &quot;modules&quot;: false &#125;],</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line">  &#x2F;&#x2F;转码用的插件</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;],</span><br><span class="line">  &quot;comments&quot;: false,</span><br><span class="line">  &#x2F;&#x2F;对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;],</span><br><span class="line">      &quot;plugins&quot;: [ &quot;istanbul&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h2><p>该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]    &#x2F;&#x2F; 对所有文件应用下面的规则</span><br><span class="line">charset &#x3D; utf-8                    &#x2F;&#x2F; 编码规则用utf-8</span><br><span class="line">indent_style &#x3D; space               &#x2F;&#x2F; 缩进用空格</span><br><span class="line">indent_size &#x3D; 2                    &#x2F;&#x2F; 缩进数量为2个空格</span><br><span class="line">end_of_line &#x3D; lf                   &#x2F;&#x2F; 换行符格式</span><br><span class="line">insert_final_newline &#x3D; true        &#x2F;&#x2F; 是否在文件的最后插入一个空行</span><br><span class="line">trim_trailing_whitespace &#x3D; true    &#x2F;&#x2F; 是否删除行尾的空格</span><br></pre></td></tr></table></figure>

<p>这是比较重要的关于vue-cli的配置文件，当然还有很多文件，我们会在以后的文章中讲解。</p>
<h1 id="第3节：-解读vue-cli模板"><a href="#第3节：-解读vue-cli模板" class="headerlink" title="第3节： 解读vue-cli模板"></a>第3节： 解读vue-cli模板</h1><p>我们通过两节课的讲解，你对vue-cli应该有了基本的了解，这节我们主要了解一下Vue-cli的模板操作，包括增加模板，修改模板，以及一个常规模板的基本结构。</p>
<h2 id="一、npm-run-build-命令"><a href="#一、npm-run-build-命令" class="headerlink" title="一、npm run build 命令"></a>一、npm run build 命令</h2><p>如何把写好的Vue网页放到服务器上，这里讲解一下，主要的命令就是要用到npm run build 命令。</p>
<p>我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。</p>
<p>在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js</p>
<p>在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。</p>
<p>dist文件夹下目录包括：</p>
<ul>
<li>index.html 主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。</li>
<li>static 静态资源文件夹：里边js、CSS和一些图片。</li>
</ul>
<h2 id="二、main-js文件解读"><a href="#二、main-js文件解读" class="headerlink" title="二、main.js文件解读"></a>二、main.js文件解读</h2><p>main.js是整个项目的入口文件,在src文件夹下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false   &#x2F;&#x2F;生产环境提示，这里设置成了false</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过代码可以看出这里引进了App的组件和<App/>的模板，它是通过 import App from ‘./App’这句代码引入的。</p>
<p>我们找到App.vue文件，打开查看。</p>
<h2 id="三、App-vue文件"><a href="#三、App-vue文件" class="headerlink" title="三、App.vue文件"></a>三、App.vue文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;app&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>app.vue文件我们可以分成三部分解读，</p>
<ul>
<li><strong><template></template>标签包裹的内容</strong>：这是模板的HTMLDom结构，里边引入了一张图片和<router-view></router-view>标签，<br><router-view>标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。</li>
<li><strong><script></script>标签包括的js内容</strong>：你可以在这里些一些页面的动态效果和Vue的逻辑代码。</li>
<li><strong><style></style>标签包裹的css内容</strong>：这里就是你平时写的CSS样式，对页面样子进行装饰用的，<br>  需要特别说明的是你==可以用<style scoped></style>来声明这些css样式只在本模板中起作用==。</li>
</ul>
<h1 id="四、router-index-js-路由文件"><a href="#四、router-index-js-路由文件" class="headerlink" title="四、router/index.js 路由文件"></a>四、router/index.js 路由文件</h1><p>在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import HelloWorld from &#39;@&#x2F;components&#x2F;HelloWorld&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      name: &#39;Hello&#39;,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。</p>
<h2 id="五、Hello-vue文件解读"><a href="#五、Hello-vue文件解读" class="headerlink" title="五、Hello.vue文件解读"></a>五、Hello.vue文件解读</h2><p>这个文件就是我们在第一节课看到的页面文件了。也是分为<template><script><style>三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Essential Links<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://vuejs.org&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Core Docs<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://forum.vuejs.org&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Forum<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://chat.vuejs.org&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Community Chat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://twitter.com/vuejs&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Twitter<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://vuejs-templates.github.io/webpack/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Docs for This Template<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Ecosystem<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://router.vuejs.org/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>vue-router<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://vuex.vuejs.org/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>vuex<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://vue-loader.vuejs.org/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>vue-loader<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/vuejs/awesome-vue&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>awesome-vue<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="line">      data () &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          msg: <span class="string">&#x27;Welcome to Your Vue.js App&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">    h1, h2 &#123;</span><br><span class="line">      font-weight: normal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ul &#123;</span><br><span class="line">      list-style-type: none;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    li &#123;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      margin: 0 10px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a &#123;</span><br><span class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-id">#42b983</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个教程只是带着你大概浏览和重点讲解了vue-cli的知识，如果你想完全弄明白vue-cli，我建议最好是有调理的阅读所有代码，这对你以后成为vue实际项目<br>的开发很有帮助。如果你是一个初学者，了解这些已经足够向下学习了。这篇教程结束后，学习vue-router的知识，vue-router是一个重点学习任务.</p>
]]></content>
  </entry>
  <entry>
    <title>VueX入门进阶</title>
    <url>/posts/VueX%20%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="Vuex简介"><a href="#Vuex简介" class="headerlink" title="Vuex简介"></a>Vuex简介</h2><blockquote>
<p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>状态管理data中的属性 需要共享给其他vue组件使用的部分，就叫做状态。简单的说就是data中需要共用的属性。<br>比如，用户的登录状态，用户名称等相关信息。如果不把这些属性设置为状态，每个页面遇到后，都会发送请求，从服务器端获取，再返回前端。在大型项目中会有很多共用的数据。所以提供了vuex.</p>
</blockquote>
<h2 id="第一节-初出茅庐，来个demo"><a href="#第一节-初出茅庐，来个demo" class="headerlink" title="第一节 初出茅庐，来个demo"></a>第一节 初出茅庐，来个demo</h2><p>这个教程是基于vue-cli的项目做的开发。所以确保vue-cli，vue开发环境是ok的。</p>
<h3 id="1-安装vuex"><a href="#1-安装vuex" class="headerlink" title="1. 安装vuex"></a>1. 安装vuex</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure>

<p>因为生产环境要用，所以是–save</p>
<h3 id="2-新建一个store文件夹，并在文件夹下新建index-js，文件中引入vue和vuex"><a href="#2-新建一个store文件夹，并在文件夹下新建index-js，文件中引入vue和vuex" class="headerlink" title="2. 新建一个store文件夹，并在文件夹下新建index.js，文件中引入vue和vuex"></a>2. 新建一个store文件夹，并在文件夹下新建index.js，文件中引入vue和vuex</h3><p>src/store/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<p>这样就算引用成功了，接下来就可以使用了。</p>
<h2 id="入门Demo"><a href="#入门Demo" class="headerlink" title="入门Demo"></a>入门Demo</h2><p>通过做一个计数器的demo来练习vuex的基本操作，并实现数据共享。</p>
<h3 id="1-在store-index-js中增加一个常量对象。–-state"><a href="#1-在store-index-js中增加一个常量对象。–-state" class="headerlink" title="1. 在store/index.js中增加一个常量对象。–==state=="></a>1. 在store/index.js中增加一个常量对象。–==state==</h3><p>store/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-用export-default封装代码，让外部可以引用"><a href="#2-用export-default封装代码，让外部可以引用" class="headerlink" title="2. 用export default封装代码，让外部可以引用"></a>2. 用export default封装代码，让外部可以引用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-新建一个vue模板，在components文件夹下，Count-vue-在模板中引入刚建的index-js-并在模板中用输出count的值"><a href="#3-新建一个vue模板，在components文件夹下，Count-vue-在模板中引入刚建的index-js-并在模板中用输出count的值" class="headerlink" title="3. 新建一个vue模板，在components文件夹下，Count.vue.在模板中引入刚建的index.js, 并在模板中用输出count的值"></a>3. 新建一个vue模板，在components文件夹下，Count.vue.在模板中引入刚建的index.js, 并在模板中用输出count的值</h3><p>components/Count.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;hr/&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;button @click=<span class="string">&quot;$store.commit(&#x27;add&#x27;)&quot;</span>&gt; 加分 &lt;/button&gt;</span><br><span class="line">      &lt;button @click=<span class="string">&quot;$store.commit(&#x27;reduce&#x27;)&quot;</span>&gt; 减分 &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                msg: <span class="string">&#x27;Hello Vuex&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        store</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-在store-index-js中加入两个改变state的方法–-mutation"><a href="#4-在store-index-js中加入两个改变state的方法–-mutation" class="headerlink" title="4. 在store/index.js中加入两个改变state的方法–==mutation=="></a>4. 在store/index.js中加入两个改变state的方法–==mutation==</h3><p>store/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    add (state) &#123;</span><br><span class="line">        state.count ++</span><br><span class="line">    &#125;,</span><br><span class="line">    reduce (state) &#123;</span><br><span class="line">        state.count --</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    mutations</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的mutations是固定的写法，稍后会细讲。只需要知道改变state数值的方法，必须写在mutations里。</p>
<h3 id="5-在Count-vue模板中加入两个按钮，并调用mutations中的方法"><a href="#5-在Count-vue模板中加入两个按钮，并调用mutations中的方法" class="headerlink" title="5. 在Count.vue模板中加入两个按钮，并调用mutations中的方法"></a>5. 在Count.vue模板中加入两个按钮，并调用mutations中的方法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;add&#x27;)&quot;</span>&gt;</span> 加分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;reduce&#x27;)&quot;</span>&gt;</span> 减分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要在路由中加入count，并可以跳转到count，这里不再赘述。</p>
<p>现在就可以对vuex中的count进行加减了。</p>
<h2 id="第二节-state访问状态对象"><a href="#第二节-state访问状态对象" class="headerlink" title="第二节 state访问状态对象"></a>第二节 state访问状态对象</h2><p>在第一节已经写了一个const state,这个就是我们说的访问状态对象，它就是我们SPA(单页应用程序)中共享值。</p>
<p>今天学习状态对象赋值给内部对象，也就是把store的值赋值给模板里的data中的值。</p>
<p>==<strong>（读取state的值）</strong>==</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>上一节中，在Count.vue组件中获取vuex的值是通过这种方式获取的，但这种方式并不优雅。这里用3种方式改写。</p>
<p>有3种赋值方式。</p>
<h3 id="1-通过computed计算属性直接赋值"><a href="#1-通过computed计算属性直接赋值" class="headerlink" title="1. 通过computed计算属性直接赋值"></a>1. 通过computed计算属性直接赋值</h3><p><a href="https://cn.vuejs.org/v2/guide/computed.html#%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90">computed属性</a>可以在属性输出前，对data中的值进行改变，现在就利用这种特性把store.js中的state值赋给模板中的data值</p>
<p>注意： computed的属性是在组件中的，不是在store中。</p>
<p>Count.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">&#x27;Hello Vuex&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，一定要写this,</p>
<p>在页面显示的地方替换为count</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h3&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-通过mapState的对象来赋值"><a href="#2-通过mapState的对象来赋值" class="headerlink" title="2. 通过mapState的对象来赋值"></a>2. 通过mapState的对象来赋值</h3><ol>
<li><p>引入mapState</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在computed计算属性里写如下代码</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState(&#123;</span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<p> 这里我们用ES6的箭头函数来给count赋值。</p>
</li>
</ol>
<h3 id="3-通过mapState的数组来赋值"><a href="#3-通过mapState的数组来赋值" class="headerlink" title="3. 通过mapState的数组来赋值"></a>3. 通过mapState的数组来赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState([<span class="string">&#x27;count&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>下面这种写法是错误的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState[<span class="string">&#x27;count&#x27;</span>],</span><br></pre></td></tr></table></figure>

<p>这个算是最简单的写法，在实际项目开发中也经常这样用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这就是三种赋值方式，虽然简单，但实际项目中经常使用。一定要多练习。</p>
<h2 id="第三节-mutations修改状态"><a href="#第三节-mutations修改状态" class="headerlink" title="第三节 mutations修改状态"></a>第三节 mutations修改状态</h2><p>mutations修改state的数据</p>
<p>上节学习了怎么读取state，这节学习 ==<strong>如何修改状态</strong>==。这个在第一节课已经碰到过，并进行了加减操作，这节具体学习如何操作mutations。</p>
<h3 id="store-commit"><a href="#store-commit" class="headerlink" title="$store.commit()"></a>$store.commit()</h3><p>vuex提供了commit方法来修改状态</p>
<p>回顾一下之前修改状态的方法</p>
<p>Count.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;add&#x27;)&quot;</span>&gt;</span> 加分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;reduce&#x27;)&quot;</span>&gt;</span> 减分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>store/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    add (state) &#123;</span><br><span class="line">        state.count ++</span><br><span class="line">    &#125;,</span><br><span class="line">    reduce (state) &#123;</span><br><span class="line">        state.count --</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><p>上面只是一个简单的修改状态操作。实际项目中常常需要在修改状态时传值。比如上边的例子每次只加1，现在要通过所传的值相加。</p>
<p>其实只需要在mutations里再加一个参数，并在commit的时候传递就可以了。如下</p>
<p>store/index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    add (state, n) &#123;</span><br><span class="line">        state.count += n</span><br><span class="line">    &#125;,</span><br><span class="line">    reduce (state) &#123;</span><br><span class="line">        state.count --</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Count.vue里修改按钮的commit()方法的参数，传10，即每次加10</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;add&#x27;, 10)&quot;</span>&gt;</span> 加分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;reduce&#x27;)&quot;</span>&gt;</span> 减分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样传值就可以看到效果了。</p>
<h3 id="模板获取mutations方法"><a href="#模板获取mutations方法" class="headerlink" title="模板获取mutations方法"></a>模板获取mutations方法</h3><p>实际开发中也不喜欢看到$store.commit()这样的方法出现，希望跟调用组件里的方法一样调用。</p>
<p>例如： @click=”reduce”, 就和没引用vuex插件一样。</p>
<p>要达到这种写法，只需要简单的两步</p>
<ol>
<li><p>在组件Count.vue里用import引入mapMutations</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在组件的script标签里添加methods属性，并加入mapMutations</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">&#x27;Hello Vuex&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: mapState([<span class="string">&#x27;count&#x27;</span>]),</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    methods: mapMutations([<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;reduce&#x27;</span>]),</span><br><span class="line">    store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在调用的地方改成直接用add和reduce.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### action方式</span><br><span class="line"></span><br><span class="line">第二种方式：对象风格的传参方式</span><br><span class="line"></span><br><span class="line">提交 mutation 的另一种方式是直接使用包含 type 属性的对象：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">store.commit(&#123;</span><br><span class="line">  type: &#39;increment&#39;, &#x2F;&#x2F; 事件名</span><br><span class="line">  amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="在-Vuex-中，mutation-都是同步函数"><a href="#在-Vuex-中，mutation-都是同步函数" class="headerlink" title="在 Vuex 中，mutation 都是同步函数"></a>在 Vuex 中，mutation 都是同步函数</h3><h2 id="第四节-getters计算过滤操作"><a href="#第四节-getters计算过滤操作" class="headerlink" title="第四节 getters计算过滤操作"></a>第四节 getters计算过滤操作</h2><p>getters从字面上是获得的意思，获取state的数据。</p>
<p>可以把它看作在获取数据之前进行的一种再编辑，相当于对数据的一个加工和过滤。可以看作store的计算属性</p>
<p>Getters 也可以理解为 Vue 中的计算属性 (computed)。</p>
<h3 id="getters基本用法"><a href="#getters基本用法" class="headerlink" title="getters基本用法"></a>getters基本用法</h3><p>现在要对store的count进行一个计算属性的操作，在输出之前，加上100</p>
<p>首先在store/index.js里用const声明getters属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    count: <span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</span><br><span class="line">        state.count += <span class="number">100</span></span><br><span class="line">        <span class="keyword">return</span> state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写好getters后，还需要在Vuex.store()里引入，由于之前已经引入state和mutations，所以这里有三个引入属性。如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在store里的配置完成了，需要到组件页对computed进行配置，在vue的构造器里只能有一个computed属性，如果写多个，只有最后一个computed属性可用，所以要对上节课的computed属性进行改造。改造时，使用ES6中的展开运算符’…’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span><br><span class="line">    count () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>注意： 写了这个配置后，每次count的值发生变化，都会进行加100操作。</p>
<h3 id="用mapGetters简化模板写法"><a href="#用mapGetters简化模板写法" class="headerlink" title="用mapGetters简化模板写法"></a>用mapGetters简化模板写法</h3><p>state和mutations都有map的引用方法把我们的模板中的编码进行简化，getters也是，看下代码：</p>
<p>用import引入mapGetters</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapMutations, mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在computed属性中加入mapGetters</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>]),</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结-4"></a>总结-4</h3><p>到这里getters就学完了，还是要熟悉熟悉。<br>注意mapGetters是写在computed中的。<br>getter写的是函数，但我们应该把它当成计算属性来用。</p>
<h2 id="第5节-actions异步修改状态"><a href="#第5节-actions异步修改状态" class="headerlink" title="第5节 actions异步修改状态"></a>第5节 actions异步修改状态</h2><p>actions 和 mutations的功能基本一样，不同点是actions是异步的改变state的状态，而mutations是同步改变状态。</p>
<p>不同模块的 actions 均可以通过 store.dispatch 直接触发。</p>
<h3 id="在store里声明actions"><a href="#在store里声明actions" class="headerlink" title="在store里声明actions"></a>在store里声明actions</h3><p>actions可以调用mutations里的方法。</p>
<p>继续上节的代码，在actions里调用mutation里的add和reduce方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    addAction (context) &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;add&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    reduceAction (&#123;commit&#125;) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;reduce&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出里添加</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    <span class="comment">//  新增</span></span><br><span class="line">    actions,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意这里的传参方式！！！！！-addAction中的10"><a href="#注意这里的传参方式！！！！！-addAction中的10" class="headerlink" title="注意这里的传参方式！！！！！ addAction中的10"></a>注意这里的传参方式！！！！！ addAction中的10</h4><p>在actions里写了两个方法addAction和reduceAction，在方法体里都用commit调用了mutations里的方法。这两个方法的传的参数不一样。</p>
<ul>
<li>context： 上下文对象，这里可理解为store本身</li>
<li>{commit}: 直接把commit对象传过来，可以让方法体逻辑和代码更清晰明了</li>
</ul>
<h3 id="模板中的使用"><a href="#模板中的使用" class="headerlink" title="模板中的使用"></a>模板中的使用</h3><p>我们需要在Count.vue中调用，让actions生效。</p>
<p>复制之前的两个按钮，调用addAction和reduceAction</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addAction(10)&quot;</span>&gt;</span> 异步加分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;reduceAction&quot;</span>&gt;</span> 异步减分 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改造methods，用扩展运算符把mapMutations和mapActions引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([<span class="string">&#x27;addAction&#x27;</span>, <span class="string">&#x27;reduceAction&#x27;</span>]),</span><br><span class="line">    ...mapMutations([<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;reduce&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="用dispatch调用action"><a href="#用dispatch调用action" class="headerlink" title="用dispatch调用action"></a>用dispatch调用action</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">&#x27;asyncAdd&#x27;</span>);</span><br><span class="line"></span><br><span class="line">store.dispatch(<span class="string">&#x27;addAction&#x27;</span>, &#123;</span><br><span class="line">    n: <span class="number">10</span> <span class="comment">// 传参</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;addAction&#x27;</span>, <span class="attr">n</span>: <span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="增加异步校验"><a href="#增加异步校验" class="headerlink" title="增加异步校验"></a>增加异步校验</h3><p>现在看到的效果和mutations效果是一样的，怎样区别与mutations里的方法呢，现在演示actions里的异步功能。</p>
<p>这里增加一个计时器延迟执行。</p>
<p>在addAction里使用setTimeout就行延迟执行。<br>处理逻辑，先加10，隔500毫秒，减一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    addAction (context) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            context.commit(<span class="string">&#x27;reduce&#x27;</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;我是异步执行的&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">        context.commit(<span class="string">&#x27;add&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我先执行&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    reduceAction (&#123;commit&#125;) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;reduce&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结-5"></a>总结-5</h3><p>mutation和action都可以对store进行操作</p>
<p>mutation必须是同步操作，action可以是任何异步操作。</p>
<p>action不直接更改状态，而是提交mutation</p>
<h2 id="第6节-module模块组"><a href="#第6节-module模块组" class="headerlink" title="第6节 module模块组"></a>第6节 module模块组</h2><p>随着项目复杂度的增加，共享的状态越来越多，这时候，需要把我们状态的操作进行分组，分组后，再按组编写。</p>
<p>今天学习module: 状态管理器的模块组操作。</p>
<p>每个module拥有自己的state、mutation，action，getter，甚至嵌套子模块。具体结构如下:(来自官网)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<h3 id="声明模块组"><a href="#声明模块组" class="headerlink" title="声明模块组"></a>声明模块组</h3><p>在store/index.js中，将之前定义好的state,getters，mutations，actions都提取到一个变量中，命名ModuleA。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前导出是将这些都导出的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在都装到moduleA中，导出moduleA</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state, mutations, getters, actions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="在模板中使用"><a href="#在模板中使用" class="headerlink" title="在模板中使用"></a>在模板中使用</h3><p>在计算属性中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.a.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>再看效果，和之前是一样的。</p>
<p>这样就算创建了一个module,</p>
<h3 id="TODO-后续需要将module单独抽离成一个文件"><a href="#TODO-后续需要将module单独抽离成一个文件" class="headerlink" title="TODO 后续需要将module单独抽离成一个文件"></a>TODO 后续需要将module单独抽离成一个文件</h3><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结-6"></a>总结-6</h3><p>可以看到， 一个vuex里包含</p>
<ol>
<li><p>state<br> 用来定义通用的数据，类似于组件中的data</p>
<p> mapState是获取state的辅助函数。获取state都是通过computed来获取的，如果获取多个会显得冗余，用mapState辅助函数可以帮助我们生成计算属性。</p>
</li>
<li><p>getter<br> 可以认为是store的计算属性，类似于组件中的computed属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p> mapGetters是getter的辅助函数 将 store 中的 getter 映射到局部计算属性：</p>
</li>
<li><p>mutation<br> 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p>
<p> Mutation 必须是同步函数</p>
<blockquote>
<p>Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>
</blockquote>
<ol>
<li><p>最好提前在你的 store 中初始化好所有所需属性。</p>
</li>
<li><p>当需要在对象上添加新属性时，你应该</p>
<p>使用 Vue.set(obj, ‘newProp’, 123), 或者</p>
<p>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：</p>
<p>state.obj = { …state.obj, newProp: 123 }</p>
</li>
</ol>
</li>
<li><p>action</p>
<p> 类似于mutation<br> 区别:</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
</li>
<li><p>module (这个不一定)<br> 将一个大的store拆分成一个个子模块，即module</p>
</li>
</ol>
<h2 id="mutation-只管存，你给我（dispatch）我就存"><a href="#mutation-只管存，你给我（dispatch）我就存" class="headerlink" title="mutation 只管存，你给我（dispatch）我就存"></a>mutation 只管存，你给我（dispatch）我就存</h2><h2 id="action只管中间处理，处理完我就给你，你怎么存我不管"><a href="#action只管中间处理，处理完我就给你，你怎么存我不管" class="headerlink" title="action只管中间处理，处理完我就给你，你怎么存我不管"></a>action只管中间处理，处理完我就给你，你怎么存我不管</h2><h2 id="Getter-我只管取，我不改的"><a href="#Getter-我只管取，我不改的" class="headerlink" title="Getter 我只管取，我不改的"></a>Getter 我只管取，我不改的</h2><h2 id="Vuex-应用场景"><a href="#Vuex-应用场景" class="headerlink" title="Vuex 应用场景"></a>Vuex 应用场景</h2><h3 id="Vuex应用场景有什么？什么时候适合使用Vuex，什么时候不适合"><a href="#Vuex应用场景有什么？什么时候适合使用Vuex，什么时候不适合" class="headerlink" title="Vuex应用场景有什么？什么时候适合使用Vuex，什么时候不适合"></a>Vuex应用场景有什么？什么时候适合使用Vuex，什么时候不适合</h3><h3 id="一般回答"><a href="#一般回答" class="headerlink" title="一般回答"></a>一般回答</h3><ol>
<li>涉及到非父子关系的组件，例如兄弟关系、祖孙关系、甚至更远关系。</li>
<li>他们之间有数据交互，应该使用Vuex实现。</li>
<li>如果页面复杂度较低，可以考虑使用global-event-bus 实现</li>
<li>如果只是父子关系的组件数据交互，使用props进行单向传递</li>
<li>涉及到子组件向父组件的数据传递，考虑使用$emit 和 $on</li>
</ol>
<h3 id="更针对性的回答"><a href="#更针对性的回答" class="headerlink" title="更针对性的回答"></a>更针对性的回答</h3><p> <a href="https://www.tuicool.com/articles/EvYJRfv">https://www.tuicool.com/articles/EvYJRfv</a></p>
<p>在以下场景，我们应当使用Vuex：</p>
<h4 id="1-组件会被销毁"><a href="#1-组件会被销毁" class="headerlink" title="1. 组件会被销毁"></a>1. 组件会被销毁</h4><p>解决办法</p>
<ol>
<li><p>将值存在父组件中，实际是修改的父组件中的值</p>
</li>
<li><p>存在sessionStorage、cookie之类的东西中，在created时读取，destroyed时写入</p>
</li>
<li><p>存到global-event-bus里</p>
</li>
<li><p>存在vuex中</p>
<ol>
<li>通过$store.state来调用，通过commit来修改值</li>
<li>在created时读取state里的值，在destroyed时写入state</li>
</ol>
</li>
</ol>
<p>优点： 解耦，不跟其他组件打交道</p>
<h4 id="2-组件基于数据而创建"><a href="#2-组件基于数据而创建" class="headerlink" title="2. 组件基于数据而创建"></a>2. 组件基于数据而创建</h4><p>假设一个场景：</p>
<ol>
<li>用户将登录后，读取权限配置表，这是个异步操作</li>
<li>这个配置表会影响很多页面。</li>
</ol>
<p>这些组件不一定是父子关系，其他组件读取权限配置表不太方便</p>
<p>解决办法：</p>
<ol>
<li>写在global-event-bus里</li>
<li>放在Vuex里</li>
</ol>
<h4 id="3-多对多事件-–-多处触发，影响多处"><a href="#3-多对多事件-–-多处触发，影响多处" class="headerlink" title="3. 多对多事件 – 多处触发，影响多处"></a>3. 多对多事件 – 多处触发，影响多处</h4><p>假设一个场景</p>
<ol>
<li>切换页面显示风格，改变一个变量的值</li>
<li>在多个地方可以切换</li>
<li>这个变量将影响多个地方的样式</li>
<li>这就是多对多场景</li>
</ol>
<p>那么：</p>
<ol>
<li>无论这个变量放在哪个组件里，其他组件调用都很麻烦</li>
<li>即使存在于根组件，用this.$root.xx来获取这个变量，也是很麻烦的</li>
</ol>
<p>解决办法：</p>
<ol>
<li>用<code>global-event-bus</code>来存储这个变量 ，会比较麻烦</li>
<li>使用<code>VueX</code><ol>
<li>通过<code>$store.state.xxx</code>来获取这个变量</li>
<li>通过<code>$store.commit()</code>来提交修改(在某些条件下可禁止修改)</li>
<li>可以通过<code>$store.dispatch()</code>获取其他风格样式，并通过<code>$store.state</code>和<code>$store.getters</code>来返回新风格样式</li>
</ol>
</li>
</ol>
<h2 id="总结-使用场景"><a href="#总结-使用场景" class="headerlink" title="总结-使用场景"></a>总结-使用场景</h2><p>如果需要数据和组件分离，分别处理，那么使用VueX非常合适。<br>相反，如果不需要分离处理，不使用VueX也没关系。<br>比如某个数据只跟某组件交互，是强耦合的，其他组件用不到，那么这个组件就可以防止该组件的data属性中。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/24357762">vuex不错的讲解</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建Hexo博客笔记</title>
    <url>/posts/hexo%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="hexo-搭建"><a href="#hexo-搭建" class="headerlink" title="hexo 搭建"></a>hexo 搭建</h2><ol>
<li><a href="https://hexo.io/zh-cn/docs/">HEXO 官网</a></li>
<li><a href="https://hexo.io/zh-cn/docs/">文档</a></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>node.js git 已经安装，跳过</li>
<li>hexo 安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<!-- more  -->
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">不能在文章中有&#123;&#123;&#125;&#125;,否则hexo无法见解析，会报错</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>访问 localhost:4000 即可看到网页</p>
<p>在 sources/posts 文件夹下新建一个 test.md 文件，再次访问页面，可看到新加的文章。</p>
<a id="more"></a>

<h2 id="安装-hexo-admin"><a href="#安装-hexo-admin" class="headerlink" title="安装 hexo-admin"></a>安装 hexo-admin</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br><span class="line">hexo server -d</span><br><span class="line">open http://localhost:4000/admin</span><br></pre></td></tr></table></figure>

<h2 id="安装-next-主题"><a href="#安装-next-主题" class="headerlink" title="安装 next 主题"></a>安装 next 主题</h2><p><a href="https://github.com/Ailln/awesome-hexo-theme">好的主题推荐</a><br><a href="https://hexo.voxel.site/">链接</a></p>
<p>next主题不在维护~~，不推荐使用</p>
<ol>
<li><p>在根目录运行</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p> 会在 themes 目录下创建 next 文件夹</p>
<p> (需运行多次才能顺利下载)</p>
</li>
<li><p>在根目录的_config.yml 里配置 themes: next</p>
</li>
</ol>
<h2 id="发布到-github"><a href="#发布到-github" class="headerlink" title="发布到 github"></a>发布到 github</h2><p>需先安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>在根目录_config.yml 里配置 deploy。<br><strong>根据 github 配置提示，branch 只能是 master，其他分支不生效(实测)。</strong><br><strong>repo 项目名一定要是用户名.github.io</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:believezjp/believezjp.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置完成运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<p>发布出去。<br>访问 believezjp.github.io，即可看到主页。</p>
<p>如果没有权限，需要将本地的 id_rsa.pub 里的 key 加到 github 的 SSH key 中<br>查看本地的 key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less  ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>githubSSH keys 地址<a href="https://github.com/settings/ssh">快捷地址</a>, 添加 SSH key 值</p>
<h2 id="打赏设置"><a href="#打赏设置" class="headerlink" title="打赏设置"></a>打赏设置</h2><p>将二维码图片放到主题 source/images 下面<br>打开主题目录下面的配置文件_config.yml<br>这里的配置项可能每个主题不一样。<br>根据每个主题自己配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 打赏文字提示</span></span><br><span class="line">reward_comment: <span class="string">&#x27;扫码送礼, 走起~~~&#x27;</span></span><br><span class="line"><span class="comment">## 微信收款图片</span></span><br><span class="line">wechatpay: /images/wechatpay.jpeg</span><br><span class="line"><span class="comment">## 支付宝收款图片</span></span><br><span class="line">alipay: /images/alipay.jpeg</span><br><span class="line"><span class="comment">## 比特币收款</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>

<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;标题&quot;</span></span><br></pre></td></tr></table></figure>

<p>在 _posts 目录下会生成文件标题.md, 如下:</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: &#x27;标题&#x27;</span><br><span class="line">date: 2018-11-04 10:17:16 #发表日期，一般不改动</span><br><span class="line">categories: hexo #文章文类</span><br><span class="line">tags: [hexo,github] #文章标签，多于一项时用这种格式</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">正文，使用Markdown语法书写</span><br></pre></td></tr></table></figure>

<p>编辑完后保存，hexo server，浏览器输入 localhost:4000 预览</p>
<h2 id="添加阅读全文隔断"><a href="#添加阅读全文隔断" class="headerlink" title="添加阅读全文隔断"></a>添加阅读全文隔断</h2><p>默认文章列表页是全部展示, 只展示部分的话，可以在文章中加入</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会自动隔断，添加阅读全文按钮。(注意, 是在文章列表页有阅读全文按钮)</p>
<h2 id="展示摘要"><a href="#展示摘要" class="headerlink" title="展示摘要"></a>展示摘要</h2><h2 id="字数统计和阅读时长"><a href="#字数统计和阅读时长" class="headerlink" title="字数统计和阅读时长"></a>字数统计和阅读时长</h2><ol>
<li>安装 hexo-wordcount</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>文件配置<br>在根目录的_config.yml 中添加如下配置(注意格式一定要准确无误):</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">symbols<span class="emphasis">_count_</span>time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total<span class="emphasis">_symbols: true</span></span><br><span class="line"><span class="emphasis">  total_</span>time: true</span><br></pre></td></tr></table></figure>

<p>在 next 主题的配置文件中查看如下配置是否启用</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">symbols<span class="emphasis">_count_</span>time:</span><br><span class="line">  separated<span class="emphasis">_meta: true</span></span><br><span class="line"><span class="emphasis">  item_</span>text<span class="emphasis">_post: true</span></span><br><span class="line"><span class="emphasis">  item_</span>text<span class="emphasis">_total: false</span></span><br><span class="line"><span class="emphasis">  awl: 4</span></span><br><span class="line"><span class="emphasis">  wpm: 275</span></span><br></pre></td></tr></table></figure>

<p>重启服务, 刷新页面, 可以看到效果。<br>这个只针对文章详情页才会展示。列表页不会展示。</p>
<h2 id="展示总访问量"><a href="#展示总访问量" class="headerlink" title="展示总访问量"></a>展示总访问量</h2><p><a href="http://busuanzi.ibruce.info/">不蒜子 - 极简网页计数器</a></p>
<p>在 themes/next/layout/_partials/footer.swig 中添加如下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  async</span><br><span class="line">  src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>本站总访问量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次&lt;/span</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>即可在首页末尾看到总数，因为本地是 localhost:4000,所以数量有误</p>
<h2 id="修改-footer-内容"><a href="#修改-footer-内容" class="headerlink" title="修改 footer 内容"></a>修改 footer 内容</h2><p>next 主题默认会有由 next 强力驱动等文字。不喜欢可以去掉, 配置方法:<br>在目录 themes/next/_config.yml 中搜 footer:, 将 copyright 中的 powered, 如下配置。即可去掉。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">copyright:</span></span><br><span class="line"><span class="attr">powered:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">version:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="网站运行时间添加"><a href="#网站运行时间添加" class="headerlink" title="网站运行时间添加"></a>网站运行时间添加</h3><p>根据目录 themes/next/layout/_partials/footer.swig, 找到页脚配置文件。<br>在末尾添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;timeDate&quot;</span>&gt;载入天数...&lt;<span class="regexp">/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/</span>span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createtime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;02/14/2018 12:49:00&quot;</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间</span></span><br><span class="line">        now.setTime(now.getTime()+<span class="number">250</span>);</span><br><span class="line">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="built_in">Math</span>.floor(days);</span><br><span class="line">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="built_in">Math</span>.floor(hours);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">String</span>(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span><br><span class="line">        mnum = <span class="built_in">Math</span>.floor(minutes); <span class="keyword">if</span>(<span class="built_in">String</span>(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span><br><span class="line">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span><br><span class="line">        snum = <span class="built_in">Math</span>.round(seconds); <span class="keyword">if</span>(<span class="built_in">String</span>(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;timeDate&quot;</span>).innerHTML = <span class="string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="string">&quot; 天 &quot;</span>;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;times&quot;</span>).innerHTML = hnum + <span class="string">&quot; 小时 &quot;</span> + mnum + <span class="string">&quot; 分 &quot;</span> + snum + <span class="string">&quot; 秒&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="leancloud-阅读统计功能"><a href="#leancloud-阅读统计功能" class="headerlink" title="leancloud 阅读统计功能"></a>leancloud 阅读统计功能</h2><ol>
<li><p><a href="https://leancloud.cn/dashboard/login.html#/signup">注册 leancloud</a></p>
</li>
<li><p>登录后创建应用,点击设置-应用 key, 查看 app ID 和 app Key</p>
</li>
<li><p>在 next/_config.yml 中搜索<code>leancloud_visitors</code>配置 ID 和 Key</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="comment">#&lt;app_key&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 Class<br>在左侧点击存储，创建一个名为 Counter 的 Class 文件，这里的名称一定为 Counter 不能随意取！！！<br>权限设置要选无限制, 否则在第二次访问会报错。<br>设置完后，回到我的博客，随便点击一篇博文，刷新几次 就可以在 leancloud–》存储–》Counter 看到我们的浏览记录了，在我们的博文副标题也可以看到浏览记录。</p>
</li>
</ol>
<h2 id="hexo-新建目录，page-标签-分类-关于"><a href="#hexo-新建目录，page-标签-分类-关于" class="headerlink" title="hexo 新建目录，page, 标签, 分类, 关于"></a>hexo 新建目录，page, 标签, 分类, 关于</h2><p>在主题的_config.yml 中打开配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到左上角新增关于, 标签, 分类</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>运行 hexo new page tags<br>访问标签页, 新页面可以正常访问<br>在 source/tags/index.md 中如下设置, 即可看到标签分类(前提:在文章中需添加 tags)</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-11-06 16:55:49</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在 source/categories/index.md 中添加如下</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-11-06 17:11:29</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>文章中多个 tag 时，如下配置</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line"><span class="bullet">    -</span> http</span><br><span class="line"><span class="bullet">    -</span> 网络</span><br></pre></td></tr></table></figure>

<p>单个</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">tags: 网络</span><br></pre></td></tr></table></figure>

<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>在 source/about/index.md 写个人信息</p>
<h2 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h2><p>在主题配置文件中搜索 social:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/believeZJP</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="string">微博:</span> <span class="string">https://weibo.com/u/6021664425</span> <span class="string">||</span> <span class="string">weibo</span></span><br><span class="line">  <span class="attr">QQ:</span> <span class="string">tencent://message/?uin=421790588&amp;Site=www&amp;Menu=yes</span> <span class="string">||</span> <span class="string">qq</span></span><br></pre></td></tr></table></figure>

<p>图标配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br><span class="line">  <span class="string">微博:</span> <span class="string">weibo</span></span><br><span class="line">  <span class="attr">QQ:</span> <span class="string">qq</span></span><br></pre></td></tr></table></figure>

<p>在左侧即可看到链接。<br>需要注意, 图标的配置是根据 font-awesome.min.css 中的 css 属性样式, 想添加对应的可以在文件中搜索。</p>
<p>默认显示文字和图标, 如果只显示图标可设置<br>icons_only: true</p>
<h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>在主题 next/_config.yml 中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在全局配置中_config.yml 添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>———–正常情况到这就可以使用搜索功能了———</p>
<p>复盘:</p>
<p>点击首页搜索,发现弹框弹出, loading 一直加载。没有显示搜索界面.</p>
<ul>
<li>检查 network, 发现 search.xml 请求成功, 状态 200.</li>
<li>用链接直接访问 search.xml localhost:4000/search.xml<br>提示报错, 有错误字符</li>
<li>可以拉到最后看哪篇文章被截断</li>
<li>也可以审查元素, 点击每个 entry-content 查看最近为空的那个,找到后, 这篇文章中有错误字符不识别。</li>
<li>在 network 看 search.xml 中截断的文章中有两个字中间有个点的地方, 在文中找到这个地方光标移动发现会有一次没有移动, 删除即可。</li>
<li>实在找不到可以先剪切文章, 看是否能正常显示.</li>
<li>用 vim 编辑器查看特殊字符一目了然<br>常见的特殊字符<code>^H, .(灰色)</code></li>
</ul>
<h2 id="来必力评论"><a href="#来必力评论" class="headerlink" title="来必力评论"></a>来必力评论</h2><p><a href="https://www.livere.com/%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%BF%99%E4%B8%AA%E6%B3%A8%E5%86%8C,">https://www.livere.com/一定要用这个注册,</a> 中文版(<a href="http://www.laibili.com.cn/)%E5%A4%B1%E6%95%88%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81">http://www.laibili.com.cn/)失效！！！！</a><br>注册完成后, 填写相应信息, 即可获取到 data-uid.<br>next/_config.yml 中搜索<code>livere_uid</code>, 填入对应 data-uid<br><strong>注意:</strong><br>格式如下:<br>livere_uid: fsdfs343==<br>一定不要加任何引号~~~~~~~(🕳🕳🕳🕳🕳)</p>
<h2 id="本地图片添加"><a href="#本地图片添加" class="headerlink" title="本地图片添加"></a>本地图片添加</h2><ol>
<li>在_config.yml 中搜索<code>post_asset_folder</code>, 设为 true</li>
<li>在 source 文件夹下创建文件夹 img</li>
<li>在 img 中添加图片</li>
<li>在 md 中引用图片</li>
</ol>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">记忆曲线</span>](<span class="link">/img/clipboard.png</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/img/clipboard.png&quot;</span> &gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意: 这里一定要用绝对路径, 因为图片在根目录下</p>
<h3 id="不用根目录的图片添加"><a href="#不用根目录的图片添加" class="headerlink" title="不用根目录的图片添加"></a>不用根目录的图片添加</h3><p>用<code>hexo n &#39;文章标题&#39;</code>创建文章后，会生成与文章标题相同的文件夹，可以把图片放到对应文件夹中<br>在md中引用方式</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">添加自定义search</span>](<span class="link">/posts/Alfred/addbaidu.png</span>)</span><br><span class="line">![<span class="string">设置百度内容</span>](<span class="link">/posts/Alfred/addbaidu-input.png</span>)</span><br></pre></td></tr></table></figure>

<h2 id="部署命令简化"><a href="#部署命令简化" class="headerlink" title="部署命令简化"></a>部署命令简化</h2><p>在 package.json 中添加</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;d&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;,</span><br><span class="line">  &quot;s&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>部署时，只需在终端运行<code>npm run d</code>即可发布文章</p>
<p>启动时，运行<code>npm run s</code>,即可在本地访问服务</p>
<p><a href="https://blog.csdn.net/qq_35561857/article/details/81590953">好的链接</a></p>
<h2 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h2><p>在 next/_config.yml 中搜索 baidu_analytics, 配置 id</p>
<p>在<a href="https://tongji.baidu.com/">官网</a>,新建应用，点击管理，复制 id</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> _hmt = _hmt || [];</span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span></span><br><span class="line"><span class="javascript">  hm.src = <span class="string">&quot;https://hm.baidu.com/hm.js?60d1bc14f9ca17b7&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span></span><br></pre></td></tr></table></figure>

<h2 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h2><p>在 next/config.yml 里搜 avatar,如下配置, 图片链接可更换</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.gif</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h2><p><a href="https://www.npmjs.com/package/hexo-offline">hexo-offline</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-offline --save</span><br></pre></td></tr></table></figure>

<h2 id="修改默认的文章链接"><a href="#修改默认的文章链接" class="headerlink" title="修改默认的文章链接"></a>修改默认的文章链接</h2><p><a href="https://hexo.io/zh-cn/docs/permalinks.html">官方文档</a></p>
<p>默认文章链接是<a href="http://localhost:4000/2018/10/18/hello-world/">http://localhost:4000/2018/10/18/hello-world/</a></p>
<p>有年月日层级太深，不利于 SEO</p>
<p>修改为<a href="http://localhost:4000/posts/hello-world/">http://localhost:4000/posts/hello-world/</a></p>
<p>在_config.yml 中搜索<code>permalink</code>,修改如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">## permalink: :year/:month/:day/:title/</span><br><span class="line">permalink: :category/:title/</span><br></pre></td></tr></table></figure>

<p>搜索<code>default_category</code>,修改如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">default_category: posts</span><br></pre></td></tr></table></figure>

<p>重启服务即可</p>
<h2 id="绑定自己域名"><a href="#绑定自己域名" class="headerlink" title="绑定自己域名"></a>绑定自己域名</h2><p>在阿里云控制台域名修改域名解析，记录类型 CNAME, 记录纸为 believezjp.github.io</p>
<p>在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">believezjp.oriht.com</span><br></pre></td></tr></table></figure>

<p>注意，这个要写自己的域名，不是 github 的域名</p>
<p>在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages 的 Custom domain 设置里填上购买的域名。</p>
<p>详见:<a href="https://blog.csdn.net/wgshun616/article/details/81019739">参考链接</a></p>
<h2 id="替换-jquery-资源库地址"><a href="#替换-jquery-资源库地址" class="headerlink" title="替换 jquery 资源库地址"></a>替换 jquery 资源库地址</h2><p>在主题目录下找到 after-footer.ejs 文件，PS：主题目录指的是 themes 下 next 目录</p>
<p>找到下面一段代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改为：（将 jquery 的在线地址修改为百度的静态资源库地址）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="项目添加-changelog❌"><a href="#项目添加-changelog❌" class="headerlink" title="项目添加 changelog❌"></a>项目添加 changelog❌</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save conventional-changelog</span><br><span class="line"></span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure>

<h2 id="项目添加git-commit-规范"><a href="#项目添加git-commit-规范" class="headerlink" title="项目添加git commit 规范"></a>项目添加git commit 规范</h2><p><a href="https://github.com/marionebl/commitlint">插件链接</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @commitlint/&#123;cli,config-conventional&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;;&quot;</span> &gt; commitlint.config.js</span><br><span class="line">npm install --save-dev husky</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在package.json中配置</span></span><br><span class="line"><span class="comment">## package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提交方式：</p>
<p>格式：</p>
<blockquote>
<p>type(scope?): subject  ## scope 可选</p>
</blockquote>
<p>subject是 commit 目的的简短描述，不超过50个字符，且结尾不加句号（.）</p>
<p>eg:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chore: run tests on travis ci</span><br><span class="line">fix(server): send cors headers</span><br><span class="line">feat(blog): add comment section</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>build: 主要目的是修改项目构建系统(例如 gulp，webpack，rollup 的配置等)的提交</li>
<li>ci: 主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交</li>
<li>docs：文档（documentation）</li>
<li>feat：新功能（feature）</li>
<li>merge: 合并分支</li>
<li>fix：修复bug</li>
<li>perf: (performance) 优化相关，比如提升性能、体验</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>revert: 回滚到上一个版本</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>test：增加测试</li>
<li>wip：移除文件或者代码</li>
<li>chore：不属于以上类型的其他类型</li>
</ul>
<h2 id="生成changelog"><a href="#生成changelog" class="headerlink" title="生成changelog"></a>生成changelog</h2><p>Change log 就可以用脚本自动生成。生成的文档包括以下三个部分：</p>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes.</li>
</ul>
<p><a href="https://github.com/conventional-changelog/conventional-changelog">onventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。<br>用到的是其中的<a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli">cli工具</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s -w -r 0</span><br></pre></td></tr></table></figure>

<p>为了方便使用，可以将其写入 package.json 的 scripts 字段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;changelog&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -s -w -r 0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，直接运行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure>

<h2 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h2><p>草稿相当于很多博客都有的“私密文章”功能。<br><code>hexo new draft &quot;new draft&quot;</code><br>会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。<br>也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。<br>如果你希望强行预览草稿，更改配置文件_config.yml：<br><code>render_drafts: true</code><br>或者，如下方式启动server：<br><code>hexo server --drafts</code><br>下面这条命令可以把草稿变成文章，或者页面：<br><code>hexo publish [layout] &lt;filename&gt;</code><br>或<code>hexo P &lt;filename&gt;</code><br>filename为不包含md后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。</p>
<blockquote>
<p>若日后想将正式文章转为为草稿，只需手动将文章从 source/_posts 目录移动到 source/_drafts 目录即可。</p>
</blockquote>
<h2 id="hexo-命令"><a href="#hexo-命令" class="headerlink" title="hexo 命令"></a>hexo 命令</h2><p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo <span class="built_in">help</span> <span class="comment">#查看帮助</span></span><br><span class="line">hexo init <span class="comment">#初始化一个目录</span></span><br><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成网页，可以在 public 目录查看整个网站的文件</span></span><br><span class="line">hexo server <span class="comment">#本地预览，&#x27;Ctrl+C&#x27;关闭</span></span><br><span class="line">hexo deploy <span class="comment">#部署.deploy目录</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹**</span></span><br></pre></td></tr></table></figure>

<p>简写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="git-push以后自动发布到gitHub上"><a href="#git-push以后自动发布到gitHub上" class="headerlink" title="git push以后自动发布到gitHub上"></a>git push以后自动发布到gitHub上</h2><p>使用Travis 自动化部署Hexo Blog</p>
<ol>
<li>添加.travis.yml</li>
<li>配置token</li>
</ol>
<h2 id="Hexo博客收录百度和谷歌-基于Next主题"><a href="#Hexo博客收录百度和谷歌-基于Next主题" class="headerlink" title="Hexo博客收录百度和谷歌-基于Next主题"></a>Hexo博客收录百度和谷歌-基于Next主题</h2><p><a href="https://www.jianshu.com/p/8c0707ce5da4">参考链接</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://tigerliu.site/2017/06/hexo-1/">Hexo 进阶高级教程</a><br><a href="https://www.cnblogs.com/shwee/p/11421156.html">Hexo+Github: 个人博客网站搭建完全教程</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>js 代码片段</title>
    <url>/posts/js-%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="js比较版本号"><a href="#js比较版本号" class="headerlink" title="js比较版本号"></a>js比较版本号</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 版本比较 versionCompare</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>currVer 当前版本.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>promoteVer 比较版本.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span> </span>false 当前版本小于比较版本返回 true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> * versionCompare(&quot;6.3&quot;,&quot;5.2.5&quot;); // false.</span></span><br><span class="line"><span class="comment"> * versionCompare(&quot;6.1&quot;, &quot;6.1&quot;); // false.</span></span><br><span class="line"><span class="comment"> * versionCompare(&quot;6.1.5&quot;, &quot;6.2&quot;); // true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">versionCompare</span>(<span class="params">currVer = <span class="string">&#x27;0.0.0&#x27;</span>, promoteVer = <span class="string">&#x27;0.0.0&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currVer === promoteVer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> currVerArr = currVer.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> promoteVerArr = promoteVer.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">Math</span>.max(currVerArr.length, promoteVerArr.length);</span><br><span class="line">    <span class="comment">// ~是按位取反的意思，计算机里面处理二进制数据时候的非，</span></span><br><span class="line">    <span class="comment">// ~~利用两个按位取反的符号，进行类型的转换，转换成数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 将比较对象转成数字</span></span><br><span class="line">        <span class="keyword">const</span> proVal = ~~promoteVerArr[i];</span><br><span class="line">        <span class="keyword">const</span> curVal = ~~currVerArr[i];</span><br><span class="line">        <span class="keyword">if</span> (proVal &lt; curVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (proVal &gt; curVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind 返回的是一个新的函数，你必须调用它才会被执行</p>
<p>function() {}.bind(thisArg [, arg1 [, arg2, …]]);</p>
<p>bind函数传参会先于新函数调用时的参数传入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;.bind(&#123;<span class="attr">name</span>: <span class="number">2</span>&#125;), <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="number">1</span>&#125;</span><br><span class="line">fn.call(obj1) <span class="comment">//输出2 ，因为bind的参数先于其他参数。</span></span><br><span class="line"></span><br><span class="line">自己实现bind</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">            , args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(context, args.slice(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="把queryString转换成js对象"><a href="#把queryString转换成js对象" class="headerlink" title="把queryString转换成js对象"></a>把queryString转换成js对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryObject</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    url=url==<span class="literal">null</span>?<span class="built_in">window</span>.location.href:url;</span><br><span class="line">    <span class="keyword">var</span> search=url.substring(url.lastIndexOf(<span class="string">&quot;?&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> reg=<span class="regexp">/([^?&amp;=]+)=([^?&amp;=]*)/g</span>;</span><br><span class="line">    search.replace(reg,<span class="function"><span class="keyword">function</span>(<span class="params">rs,$<span class="number">1</span>,$<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name=<span class="built_in">decodeURIComponent</span>($<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> val=<span class="built_in">decodeURIComponent</span>($<span class="number">2</span>);</span><br><span class="line">        obj[name]=<span class="built_in">String</span>(val);</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getQueryObject(<span class="string">&quot;http://www.cnblogs.com/zichi/p/4359786.html?aa=111&amp;bb=3dadsads&amp;43=43a&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="实现一个异步缓存器，第一次调用，发送请求，第二次调用，直接取结果"><a href="#实现一个异步缓存器，第一次调用，发送请求，第二次调用，直接取结果" class="headerlink" title="实现一个异步缓存器，第一次调用，发送请求，第二次调用，直接取结果"></a>实现一个异步缓存器，第一次调用，发送请求，第二次调用，直接取结果</h2><p>用发布订阅者模式</p>
<p>不管谁调用都是拿的同一个Promise，</p>
<h2 id="Promise-写法"><a href="#Promise-写法" class="headerlink" title="Promise 写法"></a>Promise 写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准写法：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">/* 异步操作成功 */</span> ) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 一、这里是Promise要执行的代码</span></span><br><span class="line">    log(<span class="string">&#x27;start new Promise...&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="built_in">Math</span>.random() * <span class="number">2</span>;</span><br><span class="line">    log(<span class="string">&#x27;set timeout to: &#x27;</span> + timeOut + <span class="string">&#x27; seconds.&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            log(<span class="string">&#x27;call resolve()...&#x27;</span>);</span><br><span class="line">            <span class="comment">// 二、这里才是异步执行后调用的步骤</span></span><br><span class="line">            resolve(<span class="string">&#x27;200 OK&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            log(<span class="string">&#x27;call reject()...&#x27;</span>);</span><br><span class="line">            reject(<span class="string">&#x27;timeout in &#x27;</span> + timeOut + <span class="string">&#x27; seconds.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">&#x27;Done: &#x27;</span> + r);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">&#x27;Failed: &#x27;</span> + reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自己实现promise-all"><a href="#自己实现promise-all" class="headerlink" title="自己实现promise.all"></a>自己实现promise.all</h2><p>思路，用一个数组将所有要请求的存起来，循环发送执行后，根据数组长度判断是否执行完成。</p>
<p>1、接收一个 Promise 实例的数组或具有 Iterator 接口的对象，</p>
<p>2、如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</p>
<p>3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</p>
<p>4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调<br>all() 的返回值也是新的 Promise 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isArray(promises)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;arguments must be an array&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> resolvedCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> promiseNum = promises.length;</span><br><span class="line">    <span class="keyword">var</span> resolvedValues = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          resolvedCounter++</span><br><span class="line">          resolvedValues[i] = value</span><br><span class="line">          <span class="keyword">if</span> (resolvedCounter == promiseNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(resolvedValues)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="手动写多次异步调用回调"><a href="#手动写多次异步调用回调" class="headerlink" title="手动写多次异步调用回调"></a>手动写多次异步调用回调</h2><p>场景一：先调用getData1，再调用getData2，再调用getData3  …</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建一个Promise实例，获取数据。并把数据传递给处理函数resolve和reject。需要注意的是Promise在声明的时候就执行了。</span></span><br><span class="line"><span class="keyword">var</span> getData1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">        url:<span class="string">&quot;index.aspx&quot;</span>,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.Status==<span class="string">&quot;1&quot;</span>)&#123;</span><br><span class="line">                resolve(data.ResultJson)<span class="comment">//在异步操作成功时调用</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(data.ErrMsg);<span class="comment">//在异步操作失败时调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getData2= <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">        url:<span class="string">&quot;index.aspx&quot;</span>,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.Status==<span class="string">&quot;1&quot;</span>)&#123;</span><br><span class="line">                resolve(data.ResultJson)<span class="comment">//在异步操作成功时调用</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(data.ErrMsg);<span class="comment">//在异步操作失败时调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> getData3=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">        url:<span class="string">&quot;index.aspx&quot;</span>,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.Status==<span class="string">&quot;1&quot;</span>)&#123;</span><br><span class="line">                resolve(data.ResultJson)<span class="comment">//在异步操作成功时调用</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(data.ErrMsg);<span class="comment">//在异步操作失败时调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">getData1.then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> getData2(res)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> getData3(res)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).cache(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br><span class="line">场景二：getData3的执行依赖getData1和getData2</span><br><span class="line"><span class="comment">//Promise的all方法，等数组中的所有promise对象都完成执行</span></span><br><span class="line"><span class="built_in">Promise</span>.all([getData1,getData2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">[ResultJson1,ResultJson2]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//这里写等这两个ajax都成功返回数据才执行的业务逻辑</span></span><br><span class="line">　　getData3()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj, prop, descriptor)"></a>Object.defineProperty(obj, prop, descriptor)</h2><p>value<br>属性对应的值,可以使任意类型的值，默认为undefined</p>
<p>writable<br>属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false</p>
<p>enumerable<br>此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。</p>
<p>configurable<br>是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。</p>
<p>这个属性起到两个作用：</p>
<p>目标属性是否可以使用delete删除</p>
<p>目标属性是否可以再次设置特性</p>
<p>//第一种情况：configurable设置为false，不能被删除。<br>//第二种情况：configurable设置为true，可以被删除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象新添加的属性的特性描述</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&quot;newKey&quot;</span>,&#123;</span><br><span class="line">    configurable:<span class="literal">true</span> | <span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span> | <span class="literal">false</span>,</span><br><span class="line">    value:任意类型的值,</span><br><span class="line">    writable:<span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存取器描述</span><br><span class="line">当使用存取器描述属性的特性的时候，允许设置以下特性属性：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&quot;newKey&quot;</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; | <span class="literal">undefined</span>,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;&#125; | <span class="literal">undefined</span></span><br><span class="line">    configurable: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">    enumerable: <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">属性对应的值,可以使任意类型的值，默认为<span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getter 是一种获得属性值的方法</span><br><span class="line"></span><br><span class="line">setter是一种设置属性值的方法。</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> initValue = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&quot;newKey&quot;</span>,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当获取值的时候触发的函数</span></span><br><span class="line">        <span class="keyword">return</span> initValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当设置值的时候触发的函数,设置的新值通过参数value拿到</span></span><br><span class="line">        initValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey );  <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">obj.newKey = <span class="string">&#x27;change value&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( obj.newKey ); <span class="comment">//change value</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符串重复"><a href="#字符串重复" class="headerlink" title="字符串重复"></a>字符串重复</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="number">264</span> <span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="number">265</span> <span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">0</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组重复"><a href="#数组重复" class="headerlink" title="数组重复"></a>数组重复</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.cp = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        n--;</span><br><span class="line">        arr= arr.concat(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="js复制数组"><a href="#js复制数组" class="headerlink" title="js复制数组"></a>js复制数组</h2><p>一、 slice</p>
<p>slice 方法返回一个 Array 对象，<br>其中包含了 arrayObj 的指定部分。</p>
<p>如果省略 end ，那么 slice 方法将一直复制到 arrayObj 的结尾。<br>如果 end 出现在 start 之前，不复制任何元素到新数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;One&quot;</span>,<span class="string">&quot;Two&quot;</span>,<span class="string">&quot;Three&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrtoo = arr.slice(<span class="number">0</span>);</span><br><span class="line">arrtoo[<span class="number">1</span>] = <span class="string">&quot;set Map&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr  One,Two,Three</span></span><br><span class="line"><span class="comment">// arrtoo  One,set Map,Three</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二、concat() 方法用于连接两个或多个数组。<br>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrtooo = arr.concat();</span><br><span class="line">arrtooo[<span class="number">1</span>] = <span class="string">&quot;set Map To&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>三、虽然说assgin也是深拷贝，但是他只是第一层深拷贝，第二层之后还是进行浅拷贝</p>
<h2 id="模拟链式调用"><a href="#模拟链式调用" class="headerlink" title="模拟链式调用"></a>模拟链式调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">obj.a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line">obj.b=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line">obj.a().b();</span><br></pre></td></tr></table></figure>

<h2 id="参数链式调用"><a href="#参数链式调用" class="headerlink" title="参数链式调用"></a>参数链式调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> functionFunction = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    s += <span class="string">&#x27;,&#x27;</span> + str;</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">  &#125;</span><br><span class="line">  func.toString = func.valueOf = <span class="function">() =&gt;</span> s;</span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(functionFunction(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// 2,3,4</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise异步链式写法"><a href="#Promise异步链式写法" class="headerlink" title="Promise异步链式写法"></a>Promise异步链式写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn_a</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num!= <span class="literal">undefined</span>)&#123;</span><br><span class="line">            num=num+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">setTimeout</span>(resolve(num), <span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//错误</span></span><br><span class="line">            reject(<span class="string">&quot;num未定义&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn_b</span>(<span class="params">num,parm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            num=num*parm;</span><br><span class="line">            <span class="built_in">setTimeout</span>(resolve(num), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">fn_a(<span class="number">1</span>).then(<span class="function"><span class="params">num</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn_b(num,<span class="number">5</span>);</span><br><span class="line">&#125;,<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">num</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);<span class="comment">//在1.5秒回返回10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="map，forEach，-filter，-reduce"><a href="#map，forEach，-filter，-reduce" class="headerlink" title="map，forEach， filter， reduce"></a>map，forEach， filter， reduce</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(a)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">a.indexOf(<span class="number">2</span>)); <span class="comment">//1</span></span><br><span class="line">a.lastIndexOf(<span class="number">2</span>); <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e,i,array</span>)</span>&#123;</span><br><span class="line">    array[i]=e+<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">e,i,arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i+<span class="string">&#x27; : &#x27;</span>+e);</span><br><span class="line">    <span class="keyword">return</span> e&lt;<span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.map(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e*e;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组 arr = [1,2,3,4] 求数组的和</span></span><br><span class="line"></span><br><span class="line">forEach 实现</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;sum += e;&#125;); <span class="comment">// sum = 10</span></span><br><span class="line">map 实现</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;sum += obj&#125;);<span class="comment">//return undefined array. sum = 10</span></span><br><span class="line">reduce实现</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur</span>)</span>&#123;<span class="keyword">return</span> pre + cur&#125;); <span class="comment">// return 10</span></span><br></pre></td></tr></table></figure>

<h2 id="写一个方法clone-实现js五种数据类型-string-number-boolean-array-object-的复制"><a href="#写一个方法clone-实现js五种数据类型-string-number-boolean-array-object-的复制" class="headerlink" title="写一个方法clone; 实现js五种数据类型(string, number, boolean, array, object)的复制"></a>写一个方法clone; 实现js五种数据类型(string, number, boolean, array, object)的复制</h2><p>number , string , boolean 直接赋值</p>
<p>object , array 遍历后赋值</p>
<p>方法中用到的apply方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copy;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">typeof</span> obj)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>:</span><br><span class="line">        copy = obj;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;object&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            copy = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toString.apply(obj) === <span class="string">&#x27;[object Array]&#x27;</span>) &#123;</span><br><span class="line">            copy = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                copy.push(clone(obj[i]))</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            copy = &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                copy[j] = clone(obj[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//各种类型的返回值; call 和 apply 返回值相同; 只是参数不同</span></span><br><span class="line">　　 <span class="built_in">console</span>.log(<span class="string">&quot;string&quot;</span> +toString.apply(str))</span><br><span class="line">　　 <span class="comment">// string[object String]  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;number&quot;</span> +toString.apply(num))</span><br><span class="line">    <span class="comment">// number[object Number]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;object&quot;</span> +toString.apply(obj))</span><br><span class="line">    <span class="comment">// object[object Object]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;array&quot;</span> + toString.apply(arr))</span><br><span class="line">    <span class="comment">// array[object Array]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;boolean&quot;</span> + toString.apply(bool))</span><br><span class="line">    <span class="comment">// boolean[object Boolean]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;undefined&quot;</span> + toString.apply(<span class="literal">undefined</span>))</span><br><span class="line">    <span class="comment">//undefined[object Undefined]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;null&quot;</span> + toString.apply(<span class="literal">null</span>))</span><br><span class="line">    <span class="comment">//  null[object Null]</span></span><br></pre></td></tr></table></figure>

<h2 id="纯js的ajax"><a href="#纯js的ajax" class="headerlink" title="纯js的ajax"></a>纯js的ajax</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到ajax对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getajaxHttp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xmlHttp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Firefox, Opera 8.0+, Safari</span></span><br><span class="line">        xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// Internet Explorer</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Msxml2.XMLHTTP&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                alert(<span class="string">&quot;您的浏览器不支持AJAX！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xmlHttp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送ajax请求</span></span><br><span class="line"><span class="comment"> * url--url</span></span><br><span class="line"><span class="comment"> * methodtype(post/get)</span></span><br><span class="line"><span class="comment"> * con (true(异步)|false(同步))</span></span><br><span class="line"><span class="comment"> * parameter(参数)</span></span><br><span class="line"><span class="comment"> * functionName(回调方法名，不需要引号,这里只有成功的时候才调用)</span></span><br><span class="line"><span class="comment"> * (注意：这方法有二个参数，一个就是xmlhttp,一个就是要处理的对象)</span></span><br><span class="line"><span class="comment"> * obj需要到回调方法中处理的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxrequest</span>(<span class="params">url,methodtype,con,parameter,functionName,obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xmlhttp=getajaxHttp();</span><br><span class="line">    xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xmlhttp.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//HTTP响应已经完全接收才调用</span></span><br><span class="line">            functionName(xmlhttp,obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xmlhttp.open(methodtype,url,con);</span><br><span class="line">    xmlhttp.send(parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这就是参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createxml</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xml=<span class="string">&quot;&lt;user&gt;&lt;userid&gt;haorooms 纯js ajax请求&lt;\/userid&gt;&lt;\/user&gt;&quot;</span>;<span class="comment">//&quot;\/&quot;这不是大写V而是转义是左斜杠和右斜杠</span></span><br><span class="line">    <span class="keyword">return</span> xml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这就是参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createjson</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> json=&#123;<span class="attr">id</span>:<span class="number">0</span>,<span class="attr">username</span>:<span class="string">&quot;haorooms&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">ajaxrequest(<span class="string">&quot;http://www.haorooms.com&quot;</span>,<span class="string">&quot;post&quot;</span>,<span class="literal">true</span>,createxml(),c,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<h2 id="reduce用法"><a href="#reduce用法" class="headerlink" title="reduce用法"></a>reduce用法</h2><h2 id="将数组所有项相加"><a href="#将数组所有项相加" class="headerlink" title="将数组所有项相加"></a>将数组所有项相加</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// total == 6</span></span><br></pre></td></tr></table></figure>

<h2 id="数组扁平化-有多种解决办法"><a href="#数组扁平化-有多种解决办法" class="headerlink" title="数组扁平化  有多种解决办法"></a>数组扁平化  有多种解决办法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">使用递归实现</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array, depth=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  array.forEach (<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> d = depth;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item) &amp;&amp; d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      result.push(...(flattenDepth(item, --d)))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flattenDepth([<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>]],<span class="number">5</span>]]))</span><br></pre></td></tr></table></figure>

<h2 id="数组去重多种方法"><a href="#数组去重多种方法" class="headerlink" title="数组去重多种方法"></a>数组去重多种方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">扩展运算符（…）内部使用<span class="keyword">for</span>…<span class="keyword">of</span>循环</span><br><span class="line"></span><br><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>])]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理：利用forEach的三个参数和indexOf()的第二个参数(从哪里开始查找)，</span></span><br><span class="line">在数组中检测该元素后方是否有与该元素相同的元素。</span><br><span class="line">distinct = <span class="function">(<span class="params">arr</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _arr = [];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bool = arr.indexOf(item,index+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(bool === -<span class="number">1</span>)&#123;</span><br><span class="line">            _arr.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> _arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line">distinct(arr);</span><br><span class="line">=&gt; [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]   <span class="comment">//1是后面的1，2也是后出现的2.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理：splice()删除元素，会改变原数组。</span></span><br><span class="line"></span><br><span class="line">distinct = <span class="function">(<span class="params">arr</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;  </span><br><span class="line">         <span class="keyword">if</span>(arr[i] === arr[j]) &#123;  </span><br><span class="line">             arr.splice(j,<span class="number">1</span>);  </span><br><span class="line">             len--;  </span><br><span class="line">             j--;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line">distinct(arr);</span><br><span class="line">=&gt;[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取数组最大最小值"><a href="#获取数组最大最小值" class="headerlink" title="获取数组最大最小值"></a>获取数组最大最小值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.max = <span class="function"><span class="keyword">function</span>(<span class="params"> array </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.max.apply( <span class="built_in">Math</span>, array );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Array</span>.min = <span class="function"><span class="keyword">function</span>(<span class="params"> array </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.min.apply( <span class="built_in">Math</span>, array );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.max = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(&#123;&#125;,<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(&#123;&#125;,<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].max()<span class="comment">// =&gt; 3</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].min()<span class="comment">// =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>]];</span><br><span class="line"><span class="keyword">var</span> ta=a.join(<span class="string">&quot;,&quot;</span>).split(<span class="string">&quot;,&quot;</span>);<span class="comment">//转化为一维数组</span></span><br><span class="line">alert(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,ta));<span class="comment">//最大值</span></span><br><span class="line">alert(<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,ta));<span class="comment">//最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort()排序默认为升序，reverse()将数组掉个</span></span><br><span class="line"><span class="keyword">var</span> max3 = arr.sort().reverse()[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(max3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用ES6的扩展运算符</span><br><span class="line"> <span class="keyword">var</span> arr = [<span class="number">22</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">55</span>,<span class="number">30</span>];</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr)); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>函数防抖和节流都能控制一段时间内函数执行的次数.</p>
<p>函数防抖: 将本来短时间内爆发的一组事件组合成单个事件来触发。等电梯就是一个非常形象的比喻，电梯不会立即上行，而是等待一段时间内没有人再上电梯了才上行，换句话说此时函数执行时一阵一阵的，如果一直有人上电梯，电梯就永远不会上行。</p>
<blockquote>
<p>使用场合：用户输入关键词实时搜索，如果用户每输入一个字符就发请求搜索一次，就太浪费网络，页面性能也差；再比如缩放浏览器窗口事件；再再比如页面滚动埋点</p>
</blockquote>
<p>函数节流: 控制持续快速触发的一系列事件每隔’X’毫秒执行一次,就像Magic把瓢泼大雨编程了绵绵细雨。</p>
<blockquote>
<p>使用场合：页面滚动过程中不断统计离底部距离以便懒加载。<br>作用是在短时间内多次触发同一个函数，只执行最后一次，或者只在开始时执行。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// debounce 函数接受一个函数和延迟执行的时间作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 维护一个 timer</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的函数并没有使用箭头函数，目的是在事件执行时确定上下文</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取函数的作用域和变量</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;trigger&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 debounce 中包装我们的函数，过 2 秒触发一次</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, debounce(foo, <span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">每一次事件被触发，都会清除当前的 timer 然后重新设置超时调用。</span><br><span class="line">只有在最后一次触发事件，才能在 delay 时间后执行。</span><br></pre></td></tr></table></figure>

<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>节流是在一段时间内只允许函数执行一次。</p>
<p>时间戳实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait = <span class="number">100</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timerId</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId)</span><br><span class="line">    <span class="keyword">if</span> (now - start &gt;= wait) &#123;<span class="comment">// 可以保证func一定会被执行</span></span><br><span class="line">      func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      start = now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用时间戳实现的节流函数会在第一次触发事件时立即执行，以后每过 delay 秒之后才执行一次，并且最后一次触发事件不会被执行；而定时器实现的节流函数在第一次触发时不会执行，而是在 delay 秒之后才执行，当最后一次停止触发后，还会再执行一次函数。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>参数够了就执行，参数不够就返回一个函数，之前的参数存起来，直到够了为止。</p>
<p>3个常见作用：1. 参数复用；2. 提前返回；3. 延迟计算/运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> l = func.length;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span>(args.length &lt; l) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> argsInner = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(argsInner))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log([a,b,c])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curried = curry(f);</span><br><span class="line">curried(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　c.uber = p;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line"></span><br><span class="line">　　　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　　　　c[i] = p[i];</span><br><span class="line"></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自己实现bind方法"><a href="#自己实现bind方法" class="headerlink" title="自己实现bind方法"></a>自己实现bind方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind=<span class="built_in">Function</span>.prototype.bind||<span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self=<span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(contex,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>js前端小知识</title>
    <url>/posts/js%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="前端替换字符串中的特殊字符"><a href="#前端替换字符串中的特殊字符" class="headerlink" title="前端替换字符串中的特殊字符"></a>前端替换字符串中的特殊字符</h2><p> 比如回车，换行，等。<br>在window中，换行有可能是\r\n连起来的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.replace(<span class="regexp">/\\n/g</span>, <span class="string">&quot;\\n&quot;</span>)</span><br><span class="line">  .replace(<span class="regexp">/\n/g</span>, <span class="string">&quot;\\n&quot;</span>)</span><br><span class="line">  .replace(<span class="regexp">/\\&#x27;/g</span>, <span class="string">&quot;\\&#x27;&quot;</span>)  </span><br><span class="line">  .replace(<span class="regexp">/&quot; &quot;/g</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  .replace(<span class="regexp">/\\&quot;/g</span>, <span class="string">&quot;\\\&quot;&quot;</span>)  </span><br><span class="line">  .replace(<span class="regexp">/\\&amp;/g</span>, <span class="string">&quot;\\&amp;&quot;</span>)  </span><br><span class="line">  .replace(<span class="regexp">/\\r/g</span>, <span class="string">&quot;\\r&quot;</span>)  </span><br><span class="line">  .replace(<span class="regexp">/\\t/g</span>, <span class="string">&quot;\\t&quot;</span>)  </span><br><span class="line">  .replace(<span class="regexp">/\\b/g</span>, <span class="string">&quot;\\b&quot;</span>)  </span><br><span class="line">  .replace(<span class="regexp">/\\f/g</span>, <span class="string">&quot;\\f&quot;</span>);</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="js获取options的列表和每个的文本和值"><a href="#js获取options的列表和每个的文本和值" class="headerlink" title="js获取options的列表和每个的文本和值"></a>js获取options的列表和每个的文本和值</h2><p><code>var opts=document.getElementById(&quot;option&quot;).options;</code><br>opts[0].value得到第一个value的值<br>opts[0].text得到显示的文本值</p>
<p>js获取时间戳<br><code>var nowTimestamp = new Date().getTime();</code><br>获取3个小时前的时间戳<br><code>var threeHourAgo = nowTimestamp - 3 *60 * 60* 1000;</code></p>
<hr>
<h2 id="js获取select选中的值"><a href="#js获取select选中的值" class="headerlink" title="js获取select选中的值"></a>js获取select选中的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#s option:selected&quot;</span>).text();  <span class="comment">//获取选中的option的文本值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取select中option的被选中的value值，</span></span><br><span class="line">$(<span class="string">&quot;#s&quot;</span>).val();</span><br><span class="line">$(<span class="string">&quot;#s option:selected&quot;</span>).val();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// js获取select选中的值</span></span><br><span class="line"><span class="keyword">var</span> sel=<span class="built_in">document</span>.getElementById(<span class="string">&quot;select1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> index = sel.selectedIndex; <span class="comment">// 选中索引</span></span><br><span class="line">albumid= sel.options[index].value;<span class="comment">//要的值</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="获取文本为-的元素"><a href="#获取文本为-的元素" class="headerlink" title="获取文本为{}的元素"></a>获取文本为{}的元素</h2><p>$(“table tr td:contains(‘{}’)”)</p>
<hr>
<h2 id="在当前元素上添加一个父元素"><a href="#在当前元素上添加一个父元素" class="headerlink" title="在当前元素上添加一个父元素"></a>在当前元素上添加一个父元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给table添加一个div.table-responsive的父元素，可以使table变成响应式的。</span></span><br><span class="line">$(<span class="string">&#x27;table&#x27;</span>).addClass(<span class="string">&#x27;table&#x27;</span>).wrap(<span class="string">&#x27;&lt;div class=&quot;table-responsive&quot;/&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="js-触发resize"><a href="#js-触发resize" class="headerlink" title="js 触发resize"></a>js 触发resize</h2><p>jQuery: $(selector).resize()<br> eg: $(window).resize();</p>
<p>js的暂未找到！！！！！！</p>
<h2 id="js设置时间为标准时间格式"><a href="#js设置时间为标准时间格式" class="headerlink" title="js设置时间为标准时间格式"></a>js设置时间为标准时间格式</h2><ul>
<li>普通 new Date();</li>
<li>var a = new Date(‘2016-10-12 12:12:11’);</li>
<li>这种情况在safari下不能用<br>会返回Invalid Date</li>
<li>可以用a == ‘Invalid Date’ 判断<br>new Date(‘2016/10/12 12:12:11’)</li>
<li>这种可以在sarafi和chrome下使用</li>
<li>于是，</li>
<li>var a = ‘2016-10-12 12:12:11’</li>
<li>a = a.replace(/-/g,”/“)</li>
<li>var a = new Date(a)</li>
</ul>
<hr>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>

<p>调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间<br>所以即使，时间设置为0，也是会照样先执行函数b</p>
<hr>
<h2 id="js-replace-替换空格"><a href="#js-replace-替换空格" class="headerlink" title="js replace 替换空格"></a>js replace 替换空格</h2><p>var a = ‘{“string”:” “,”hex”:”20”,””:” “}’<br>a.replace(/“ “/g, “”)</p>
<p>输出结果：”{“string”:,”hex”:”20”,””:}”<br>解决办法：<br>    a.replace(/“ “/g, ‘“”‘)<br>    a.replace(/“ “/g, “&quot; &quot;“)</p>
<hr>
<h2 id="css去除所有边框"><a href="#css去除所有边框" class="headerlink" title="css去除所有边框"></a>css去除所有边框</h2><ol>
<li>border: none;</li>
<li>cellpadding=”0” cellspacing=”0”</li>
</ol>
<h2 id="css-换行"><a href="#css-换行" class="headerlink" title="css 换行"></a>css 换行</h2><p><code>word-break: break-word;</code><br>在火狐下不支持，解决方案：<br>所有的浏览器都支持</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">word-wrap</span>: <span class="selector-tag">break-word</span>;</span><br><span class="line"><span class="selector-tag">word-break</span>: <span class="selector-tag">break-all</span>;</span><br></pre></td></tr></table></figure>

<p>1、对已有对象进行扩充方法和属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">   object.name = <span class="string">&quot;zhangsan&quot;</span>;<span class="comment">//每个对象需要写这些语句</span></span><br><span class="line">   object.sayName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="comment">//每个对象需要写这些语句</span></span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;;</span><br><span class="line">   object.sayName(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">   alert(object.name);</span><br></pre></td></tr></table></figure>

<p>2、工厂方式创建对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">       object.username = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">       object.password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">       object.get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           alert(<span class="built_in">this</span>.username + <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> object1 = createObject();</span><br><span class="line">   <span class="keyword">var</span> object2 = createObject();</span><br><span class="line">   object1.get();</span><br><span class="line">   object2.get();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 带参数的构造方法</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">username, password</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">       object.username = username;</span><br><span class="line">       object.password = password;</span><br><span class="line">       object.get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//缺点是，多少个对象则方法就有多少个</span></span><br><span class="line">           alert(<span class="built_in">this</span>.username + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> object1 = createObject(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">123456</span>);</span><br><span class="line">   object1.get();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最佳改进方式</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;<span class="comment">//使该函数被多个对象共享</span></span><br><span class="line">       alert(<span class="built_in">this</span>.username + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">username, password</span>)</span>&#123;<span class="comment">//创建对象</span></span><br><span class="line">       <span class="keyword">var</span> object = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">       object.username = username;</span><br><span class="line">       object.password = password;</span><br><span class="line">       object.get = get;</span><br><span class="line">       <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> object1 = createObject(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> object2 = createObject(<span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;654321&quot;</span>);</span><br><span class="line">   object1.get();</span><br><span class="line">   object2.get();</span><br></pre></td></tr></table></figure>

<p>3、构造函数方式创建对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">//在执行第一行代码欠，js引擎会为我们生成一个对象</span></span><br><span class="line">       <span class="built_in">this</span>.username = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">       <span class="built_in">this</span>.password = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">       <span class="built_in">this</span>.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           alert(<span class="built_in">this</span>.username + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//此处有一个隐藏的return语句，用于将之前生成对象返回。</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">   p1.getInfo();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//带参数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">username, password</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.username = username;</span><br><span class="line">       <span class="built_in">this</span>.password = password;</span><br><span class="line">       <span class="built_in">this</span>.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           alert(<span class="built_in">this</span>.username + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;1234546&quot;</span>);</span><br><span class="line">   p1.getInfo();</span><br></pre></td></tr></table></figure>

<p>4、原型（“prototype”）方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    Person.prototype.username = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    Person.prototype.password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    Person.prototype.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.username + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">    person.username = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">    person.getInfo();</span><br><span class="line">    person2.getInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单纯使用原型方式定义对象无法在构造函数中为属性赋值，只能在对象生成后再去改变属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype.username = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    Person.prototype.password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Person.prototype.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.username + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">    person.username.push(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    person.username.push(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    person.password = <span class="string">&quot;321&quot;</span>;</span><br><span class="line">    person.getInfo();</span><br><span class="line">    person2.getInfo();</span><br></pre></td></tr></table></figure>

<p>5、综合方式（原型+构造函数方式搭配）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.username = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//不被多个对象共享</span></span><br><span class="line">      <span class="built_in">this</span>.password = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)//被多个对象共享</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      alert(<span class="built_in">this</span>.username + <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line">  p1.username.push(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">  p2.username.push(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">  p1.getInfo();</span><br><span class="line">  p2.getInfo();</span><br></pre></td></tr></table></figure>

<p>6、动态原型方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.username = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.password = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="comment">//通过标志量让所有的对象共享方法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> Person.flag == <span class="string">&quot;undefined&quot;</span>)&#123;</span><br><span class="line">        alert(<span class="string">&quot;prototype&quot;</span>);</span><br><span class="line">        Person.prototype.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.username + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.password);</span><br><span class="line">        &#125;</span><br><span class="line">        Person.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p.getInfo();</span><br><span class="line">p2.getInfo();</span><br></pre></td></tr></table></figure>

<p>一道容易做错的JavaScript面试题</p>
<p><a href="http://caibaojian.com/toutiao/5446?fid=0#0-tsina-1-81079-397232819ff9a47a7b7e80a40613cfe1">http://caibaojian.com/toutiao/5446?fid=0#0-tsina-1-81079-397232819ff9a47a7b7e80a40613cfe1</a></p>
<hr>
<h2 id="js获取字符串字节数方法小结"><a href="#js获取字符串字节数方法小结" class="headerlink" title="js获取字符串字节数方法小结"></a>js获取字符串字节数方法小结</h2><p>  方法一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理：把中文字符替换成2个英文字母，那么字节数就是2，</span></span><br><span class="line"><span class="comment">//\u0000这个表示的是unicode编码</span></span><br><span class="line">alert(<span class="string">&#x27;a你好&#x27;</span>.replace(<span class="regexp">/[^\u0000-\u00ff]/g</span>,<span class="string">&quot;aa&quot;</span>).length);</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果是6</span></span><br><span class="line"><span class="comment">//原理也很简单，用正则判断是不是中文，如果是的话，字节数就加1。</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;我我我&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bytesCount;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> c = str.charAt(i);</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^[\u0000-\u00ff]$/</span>.test(c)) <span class="comment">//匹配双字节</span></span><br><span class="line">  &#123;</span><br><span class="line">  bytesCount += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  bytesCount += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(bytesCount);</span><br></pre></td></tr></table></figure>

<h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><p>匹配中文字符的正则表达式： [\u4e00-\u9fa5]</p>
<p>匹配双字节字符(包括汉字在内)：[^\u0000-\u00ff]</p>
<h2 id="过滤特殊字符"><a href="#过滤特殊字符" class="headerlink" title="过滤特殊字符"></a>过滤特殊字符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /[&quot;&#x27;&lt;&gt;%;)(&amp;+]/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/[&#x27;&quot;)-&gt;&lt;&amp;\\\/\.]/</span>.test(value)) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;包含特殊字符，不允许提交!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IllegalString = <span class="string">&quot;\`~!#$%^&amp;*()+&#123;&#125;|\\:\&quot;&lt;&gt;?-=/,\&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;[%--`~!@#$^&amp;*()=|&#123;&#125;&#x27;:;&#x27;,\\\\\[\\].&lt;&gt;/?~！@#￥……&amp;*（）——|&#123;&#125;【】‘；：”“&#x27;。，、？]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/[ ,\\`,\\~,\\!,\\@,\#,\\$,\\%,\\^,\\+,\\*,\\&amp;,\\\\,\\/,\\?,\\|,\\:,\\.,\\&lt;,\\&gt;,\\&#123;,\&#125;,\\(,\\),\\&#x27;&#x27;,\\;,\\=,\&quot;]/</span>.test(key)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/[&#x27;&quot;)-&gt;&lt;&amp;\\\/\.]/</span>.test(key)) &#123;</span><br><span class="line"> alert(<span class="string">&#x27;包含特殊字符，不允许提交!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-如何通过css使div-实现全屏效果"><a href="#1-如何通过css使div-实现全屏效果" class="headerlink" title="1.如何通过css使div 实现全屏效果"></a>1.如何通过css使div 实现全屏效果</h2><p>–全屏要素：<br>    1.全屏的元素及其父元素都要设置为height:100%,<br>    2.将html,body标签设置为height100%,<br>注：height:100%是跟随其父元素高度变化而变化的</p>
<h2 id="jQuery插件的封装"><a href="#jQuery插件的封装" class="headerlink" title="jQuery插件的封装"></a>jQuery插件的封装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>

<p>闭包的作用<br>    –避免全局依赖<br>    –避免第三方破坏<br>    –兼容jQuery操作符‘$’和jQuery</p>
<h2 id="开发方式"><a href="#开发方式" class="headerlink" title="开发方式"></a>开发方式</h2><p>类级别组件开发<br>    -即给jQuery命名空间下添加新的全局函数，也称静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如： $.ajax,$.extend()</p>
<h2 id="对象级别组件开发"><a href="#对象级别组件开发" class="headerlink" title="对象级别组件开发"></a>对象级别组件开发</h2><p>-即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法，<br>    也称动态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;;</span><br><span class="line">这里$.fn===$.prototype</span><br></pre></td></tr></table></figure>

<p>例如：addClass()、attr()等，需要创建实例来调用</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eg: $(<span class="string">&quot;div&quot;</span>).next().addClass()....</span><br><span class="line"> $.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">//do something</span></span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>return this 返回当前对象，来维护插件的链式调用</li>
<li>each 循环实现每个元素的访问</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.fn.myPlugin  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> me = $(<span class="built_in">this</span>),</span><br><span class="line">            instance = me.data(<span class="string">&quot;myPlugin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">        me.data(<span class="string">&quot;myPlugin&quot;</span>,(instance= <span class="keyword">new</span> Plugin()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码说明：<br>    -如果实例存在则不再重新创建实例<br>    -利用data()来存放插件对象的实例</p>
<h2 id="es6-从数组中查找一个元素"><a href="#es6-从数组中查找一个元素" class="headerlink" title="es6 从数组中查找一个元素"></a>es6 从数组中查找一个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = data.users</span><br><span class="line">result = users.find(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ele.username === username &amp;&amp; ele.password === password</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>从数组中删除某个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">splice(index, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数组比较"><a href="#数组比较" class="headerlink" title="数组比较"></a>数组比较</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 =[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 =[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    arr1.sort() === arr1,</span><br><span class="line">    arr2.sort() === arr2,</span><br><span class="line">    arr1.sort() === arr2.sort()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// true, true, false</span></span><br></pre></td></tr></table></figure>

<p>解析:</p>
<p>arr.sort方法对原始数组进行排序，并返回该数组的引用，调用.sort(), 对数组内对象进行排序</p>
<p>当比较对象时，数组的排序顺序并不重要。由于arr1.sort()和arr1指向内存中的同一对象，因此第一个和第二个返回true.</p>
<p>arr1.sort()和arr2.sort()排序顺序相同；但他们指向内存中的不同对象，所以返回false</p>
<h2 id="前端实现即时通讯的方式有哪些，并介绍对应的优缺点"><a href="#前端实现即时通讯的方式有哪些，并介绍对应的优缺点" class="headerlink" title="前端实现即时通讯的方式有哪些，并介绍对应的优缺点"></a>前端实现即时通讯的方式有哪些，并介绍对应的优缺点</h2><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><p>短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。</p>
<p>优点：兼容性强，实现非常简单<br>缺点：延迟性高，非常消耗请求资源，影响性能</p>
<h3 id="comet"><a href="#comet" class="headerlink" title="comet"></a>comet</h3><p>comet有两种主要实现手段， 一种是基于AJAX的长轮询(1ong-polling) 方式， 另一种是基于Iframe及html file的流(streaming) 方式，通常被叫做长连接。</p>
<p>a.长轮询优缺点：<br>优点：兼容性好，资源浪费较小<br>缺点：服务器hold连接会消耗资源， 返回数据顺序无保证，难于管理维护</p>
<p>b.长连接优缺点：<br>优点：兼容性好，消息即时到达，不发无用请求<br>缺点：服务器维护长连接消耗资源</p>
<h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><p>SSE(Server-Sent Event， 服务端推送事件) 是一种允许服务端向客户端推送新数据的HTML 5技术。</p>
<p>a.优点：基于HTTP而生， 因此不需要太多改造就能使用， 使用方便， 而websocket非常复杂， 必须借<br>助成熟的库或框架<br>b.缺点：基于文本传输效率没有websocket高， 不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求</p>
<h3 id="Web-socket"><a href="#Web-socket" class="headerlink" title="Web socket"></a>Web socket</h3><p>Web socket是一个全新的、独立的协议， 基于TCP协议，与http协议兼容、却不会融入http协议， 仅仅作为htmL 5的一部分， 其作用就是在服务器和客户<br>端之间建立实时的双向通信。<br>a.优点：真正意义上的实时双向通信，性能好，低延迟<br>b.缺点：独立与http的协议， 因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器</p>
<h3 id="Service-workers"><a href="#Service-workers" class="headerlink" title="Service workers"></a>Service workers</h3><p>Service Worker从英文翻译过来就是一个服务工人， (服务于前端页面的后台线程， 基于Web Worker实现。有着独立的js运行环境，分担、协助前端页面完成前端开发者分配的需要在后台悄悄执行的任<br>务。基于它可以实现拦截和处理网络请求、消息推送、静默更新、事件同步等服务。</p>
<p>优势及使用场景：</p>
<p>①离线缓存：可以将H5应用中不变化的资源或者很少变化的资源长久的存储在用户端，提升加载速度<br>降低流量消耗、降低服务器压力。如中重度的H5游戏、框架数据独立的web资讯客户端、web邮件客户端等</p>
<p>②消息推送：激活沉睡的用户，推送即时消息、公告通知，激发更新等。如web资讯客户端、web即时通讯工具、h5游戏等运营产品。</p>
<p>③事件同步：确保web端产生的任务即使在用户关闭了web页面也可以顺利完成。如web邮件客户端、web即时通讯工具等。</p>
<p>④定时同步：周期性的触发Service Worker脚中的定时同事件，可借助它提前刷新缓存内容。如web资讯客户端。</p>
<h2 id="数组push"><a href="#数组push" class="headerlink" title="数组push"></a>数组push</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToList</span>(<span class="params">item, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.push(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = addToList(<span class="string">&#x27;abc&#x27;</span>, [<span class="string">&#x27;de&#x27;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// 结果是2</span></span><br></pre></td></tr></table></figure>

<p>push方法返回新数组的长度<br>push方法修改原始数组，如果想从函数返回数组而不是数组长度，应该先push，后返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">list.push(item);</span><br><span class="line"><span class="keyword">return</span> list;</span><br></pre></td></tr></table></figure>

<h2 id="Script放在底部会影响DOM的解析和渲染吗"><a href="#Script放在底部会影响DOM的解析和渲染吗" class="headerlink" title="Script放在底部会影响DOM的解析和渲染吗"></a>Script放在底部会影响DOM的解析和渲染吗</h2><p>Script放在底部影响DOM渲染。不会影响解析。</p>
<h2 id="Script内的代码执行会会等待CSS加载完成么"><a href="#Script内的代码执行会会等待CSS加载完成么" class="headerlink" title="Script内的代码执行会会等待CSS加载完成么"></a>Script内的代码执行会会等待CSS加载完成么</h2><p>Script内的代码执行会等待CSS加载</p>
<h2 id="CSS加载会影响DOMContentLoaded么"><a href="#CSS加载会影响DOMContentLoaded么" class="headerlink" title="CSS加载会影响DOMContentLoaded么"></a>CSS加载会影响DOMContentLoaded么</h2><p>CSS代码下若无Script代码段，就不会影响DOMContentLoaded</p>
<p>也可以借助<strong>控制台的Performance</strong>详细的查看HTML的整体渲染流程，这是成为高级前端的第一步。</p>
<h2 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all"></a>实现Promise.all</h2><p>思路</p>
<ol>
<li>接收一个Promise实例的数组或具有Iterator接口的对象作为参数</li>
<li>这个方法返回一个新的promise对象</li>
<li>遍历传入的参数，用promise.resolve()将参数包一层，使其变成一个promise对象</li>
<li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li>
<li>参数数组其中一个失败，则触发失败状态，第一个触发失败的Promise错误信息作为Promise.all的错误信息</li>
</ol>
<p>扩展</p>
<p>一般来说，Promise.all用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来。<br>不过如果其中一个借口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;argument must be a array&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> resolvedCounter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> promiseNum = promises.length;</span><br><span class="line">        <span class="keyword">let</span> resolvedResult = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;promiseNum;i++) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                resolvedCounter++;</span><br><span class="line">                resolvedResult[i] = value;</span><br><span class="line">                <span class="keyword">if</span> (resolvedCounter === promiseNum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> resolve(resolvedResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(error)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promiseAll([p3, p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Linux学习</title>
    <url>/posts/linux%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>window远程连接工具：<br>secure CRT<br>配置：<br>选项-会话选项-仿真<br>    终端：x-term  ansi颜色<br>    外观：颜色方案：黄黑<br>        光标 竖线<br>    编码：回话选项-外观-字符编码-UTF-8</p>
<h2 id="git-定时任务crontab"><a href="#git-定时任务crontab" class="headerlink" title="git 定时任务crontab"></a>git 定时任务crontab</h2><p><a href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">链接</a></p>
<h2 id="在centos执行git-pull报错"><a href="#在centos执行git-pull报错" class="headerlink" title="在centos执行git pull报错"></a>在centos执行git pull报错</h2><p>Peer reports incompatible or unsupported protocol version.</p>
<p>解决办法：</p>
<p>yum update -y nss curl libcurl</p>
<p>执行后，可以正常运行。</p>
<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="==++文件与目录管理++=="></a>==++文件与目录管理++==</h2><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><p>mkdir</p>
<p>eg:mkdir test</p>
<p>mkdir -p test/123/abc</p>
<p>-p 递归创建目录，即使上级目录不存在。<br>还有一种情况就是如果你想要创建的目录存在的话，会提示报错，然后你加上-p参数后，就不会报错了。</p>
<h3 id="命令详情"><a href="#命令详情" class="headerlink" title="命令详情"></a>命令详情</h3><p> man rm,<br> man ls</p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>cp</p>
<p>eg: cp a b</p>
<p>cp copy的简写，即拷贝。格式为 cp [选项] [ 来源文件 ] [目的文件] ，例如我想把test1 拷贝成test2 ，这样即可 cp test1 test2，</p>
<p>-d 这里涉及到一个“连接”的概念。连接分为软连接和硬连接</p>
<p>如果不加这个-d 则拷贝软连接时会把软连接的目标文件拷贝过去，而加上后，其实只是拷贝了一个连接文件（即快捷方式）。</p>
<ul>
<li><p>-r 如果你要拷贝一个目录，必须要加-r选项，否则你是拷贝不了目录的。 omitting directory ‘d’</p>
</li>
<li><p>-i 如果遇到一个存在的文件，会问是否覆盖。</p>
</li>
<li><p>-u 该选项仅当目标文件存在时才会生效，如果源文件比目标文件新才会拷贝，否则不做任何动作</p>
</li>
</ul>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>mv 移动的意思，是move的简写。格式为 mv [ 选项 ] [源文件] [目标文件]。</p>
<ul>
<li><p>-i 和cp的-i 一样，当目标文件存在时会问用户是否要覆盖。</p>
</li>
<li><p>-u 和上边cp 命令的-u选项一个作用，当目标文件存在时才会生效，如果源文件比目标文件新才会移动，否则不做任何动作。</p>
</li>
</ul>
<p>-</p>
<p>windows下的重命名，在linux下用mv就可以搞定。</p>
<h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p> rm -rf</p>
<p> eg:rm -rf testCLI</p>
<p>rmdir 只能删除目录但不能删除文件，要想删除一个文件，则要用rm命令了。</p>
<p>-f 强制的意思，如果不加这个选项，当删除一个不存在的文件时会报错。</p>
<p>-i 这个选项的作用是，当用户删除一个文件时会提示用户是否真的删除。</p>
<p>-r 当删除目录时，加该选项，如果不加这个选项会报错。rm是可以删除不为空的目录的。</p>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>touch a</p>
<blockquote>
<p>a.txt 可以创建一个文件<br>a也是一个文件<br>vi a</p>
</blockquote>
<p>vi a /vim a 可以查看文件内容</p>
<p>输入i，进入编辑模式</p>
<p>按esc，退出编辑模式</p>
<p>输入:wq退出查看文件</p>
<h2 id="进入linux的主目录"><a href="#进入linux的主目录" class="headerlink" title="进入linux的主目录"></a><strong>进入linux的主目录</strong></h2><p>cd /home</p>
<p>pwd 这个命令打印出当前所在目录<br>./ 指的是当前目录</p>
<p>../ 指的是当前目录的上一级目录。<br>cd wwwroot/<br>ls</p>
<blockquote>
<p>绝对路径：路径的写法一定由根目录”/”写起，例如/usr/local/mysql 这就是绝对路径。</p>
</blockquote>
<p>相对路径：路径的写法不是由根目录”/”写起，例如，首先用户进入到/ 然后再进入到 home ，命令为 cd /home 然后 cd test 此时用户所在的路径为 /home/test 。第一个cd命令后跟 /home 第二个 cd 命令后跟 test ，并没有斜杠，这个test是相对于/home 目录来讲的，所以叫做相对路径。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>echo 变量<br>echo ‘abc’&gt;111 将字符输出到一个文件中<br>大于号”&gt;” 在linux中这叫做重定向，即把前面产生的输出写入到后面的文件中。<br>”&gt;&gt;”是追加的意思，而用”&gt;”，如果文件中有内容则会删除文件中内容，而”&gt;&gt;”则不会。</p>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><ul>
<li><p>cat 比较常用的一个命令，即查看一个文件的内容并显示在屏幕上<br>  -n 查看文件时，把行号也显示到屏幕上。<br>  -A 显示所有东西出来，包括特殊字符</p>
</li>
<li><p>tac 其实是cat的反写，同样的功能也是反向打印文件的内容到屏幕上。</p>
</li>
<li><p>more也是用来查看一个文件的内容。当文件内容太多，一屏幕不能占下，而你用cat肯定是看不前面的内容的，那么使用more就可以解决这个问题了。当看完一屏后按<strong>空格键</strong>继续看下一屏。但看完所有内容后就会退出。如果你想提前退出，只需按q键即可。</p>
</li>
<li><p>less作用跟more一样，但比more好在可以上翻，下翻。空格键同样可以翻页，而<strong>按”j”键可以向下移动</strong>（按一下就向下移动一行）<strong>，按”k”键向上移动</strong>。在使用more和less查看某个文件时，你可以按一下”/” 键，然后输入一个word回车，这样就可以查找这个word了。如果是多个该word可以按”n”键显示下一个。另外你也可以不按”/”而是按”?”后边同样跟word来搜索这个word，唯一不同的是，<strong>”/”是在当前行向下搜索，而”?”是在当前行向上搜索</strong>。</p>
<p>  <strong>按n向上，按N向下显示</strong>–老罗</p>
</li>
<li><p>vim</p>
</li>
<li><p>head head后直接跟文件名，则显示文件的前十行。如果加 –n 选项则显示文件前n行。</p>
</li>
<li><p>tail 和head一样，后面直接跟文件名，则显示文件最后十行。如果加-n 选项则显示文件最后n行。</p>
</li>
<li><p>-f <strong>动态显示文件的最后十行</strong>，如果文件是不断增加的，则用-f 选项。如：tail -f /var/log/messages</p>
</li>
</ul>
<p>-</p>
<h3 id="实时查看文件内容"><a href="#实时查看文件内容" class="headerlink" title="实时查看文件内容"></a>实时查看文件内容</h3><ul>
<li>tail -f catalina.out  ！！！！！！！！</li>
</ul>
<h2 id="文件的所属主以及所属组"><a href="#文件的所属主以及所属组" class="headerlink" title="文件的所属主以及所属组"></a>文件的所属主以及所属组</h2><p>所属组”就派上用场了。即，创建一个群组users，让user0和user1同属于users组，然后建立一个文件test2，且其所属组为users，那么user0和user1都可以访问test2文件。</p>
<h2 id="查看文件列表list"><a href="#查看文件列表list" class="headerlink" title="查看文件列表list"></a>查看文件列表list</h2><p>ls<br>ls -l<br>-a 全部的档案都列出，包括隐藏的。</p>
<p>-l 详细列出文件的属性信息，包括大小、创建日期、所属主所属组等等。ll 这个命令等同于ls –l 。</p>
<p>-d 后边跟目录，如果不加这个选项则列出目录下的文件，加上后只列车目录本身。</p>
<h2 id="linux-文件属性"><a href="#linux-文件属性" class="headerlink" title="linux 文件属性"></a>linux 文件属性</h2><p>用ls –l 查看当前目录下的文件时，共显示了9列内容（用空格划分列），都代表了什么含义呢？</p>
<p>第1列，包含的东西有该文件类型和所属主、所属组以及其他用户对该文件的权限。第一列共10位。其中第一位用来描述该文件的类型。上例中，我们看到的类型有”d”, “-“ ，其实除了这两种外还有”l”, “b”, “c”,”s”等。</p>
<p>d 表示该文件为目录；</p>
<ul>
<li>表示该文件为普通文件；</li>
</ul>
<p>l 表示该文件为连接文件（linux file），上边提到的软连接即为该类型；</p>
<p>b 表示该文件为块设备文件，比如磁盘分区</p>
<p>c 表示该文件为串行端口设备，例如键盘、鼠标。</p>
<p>s 表示该文件为套接字文件（socket），用于进程间通信。</p>
<p>后边的9位，每三个为一组。均为rwx 三个参数的组合。其中r 代表可读，w代表可写，x代表可执行。前三位为所属主（user）的权限，中间三位为所属组（group）的权限，最后三位为其他非本群组（others）的权限。下面拿一个具体的例子来述说一下。</p>
<p>一个文件的属性为-rwxr-xr– ，它代表的意思是，该文件为普通文件，文件拥有者可读可写可执行，文件所属组对其可读不可写可执行，其他用户对其只可读。</p>
<p>对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个目录必须要有x权限才能打开并查看该目录。例如一个目录的属性为 drwxr–r– 其所属主为root，那么除了root外的其他用户是不能打开这个目录的。</p>
<p>第2列，表示为连接占用的节点（inode），若为目录时，通常与该目录地下还有多少目录有关系，关于连接（link）在以后章节详细介绍。</p>
<p>第3列，表示该文件的所属主。</p>
<p>第4列，表示该文件的所属组。</p>
<p>第5列，表示该文件的大小。</p>
<p>第6列、第7列和第8列为该文件的创建日期或者最近的修改日期，分别为月份日期以及时间。</p>
<p>第9列，文件名。如果前面有一个. 则表示该文件为隐藏文件。</p>
<h2 id="更改文件的权限"><a href="#更改文件的权限" class="headerlink" title="更改文件的权限"></a>更改文件的权限</h2><p>==？？？太多了？？？以后再学==</p>
<h2 id="在-linux-下搜索一个文件"><a href="#在-linux-下搜索一个文件" class="headerlink" title="在 linux 下搜索一个文件"></a>在 linux 下搜索一个文件</h2><ul>
<li><p>which 用来查找可执行文件的绝对路径</p>
<p>  which只能用来查找PATH环境变量中出现的路径下的可执行文件。不知道某个命令的绝对路径，which一下就知道了。</p>
</li>
<li><p>whereis 通过预先生成的一个文件列表库去查找跟给出的文件名相关的文件。</p>
<p>  语法： whereis [-bmsu] [文件名称]</p>
<p>  -b：只找binary 文件</p>
<p>  -m：只找在说明文件manual路径下的文件</p>
<p>  -s：只找source来源文件</p>
<p>  -u：没有说明档的文件</p>
</li>
<li><p>locate 类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里。后边直接跟文件名。</p>
</li>
<li><p><strong>find</strong> 用的最多，务必要熟悉。<br>  语法： find [路径] [参数] 下面介绍几个笔者经常用的参数</p>
<p>  -atime +n ：访问或执行时间大于n天的文件</p>
<p>  -ctime +n ：写入、更改inode属性（例如更改所有者、权限或者连接）时间大于n天的文件</p>
<p>  -mtime +n ：写入时间大于n天的文件</p>
<p>  -name filename <strong>直接查找该文件名的文件，这个使用最多了。</strong></p>
<p>  -type type ：通过文件类型查找。type 包含了 f, b, c, d, l, s 等等。后续的内容还会介绍文件类型的。</p>
</li>
</ul>
<p>你对这三个time是不是有些晕了，那笔者就先给你介绍一下这三个time属性。</p>
<p>文件的 Access time，atime 是在读取文件或者执行文件时更改的。文件的 Modified time，mtime 是在写入文件时随文件内容的更改而更改的。<br>文件的 Create time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。<br>因此，更改文件的内容即会更改 mtime 和 ctime，但是文件的 ctime 可能会在 mtime 未发生任何变化时更改，例如，更改了文件的权限，但是文件内容没有变化。 如何获得一个文件的atime mtime 以及ctime ？</p>
<p>ls -l 命令可用来列出文件的 atime、ctime 和 mtime。</p>
<p>ls -lc filename         列出文件的 ctime</p>
<p>ls -lu filename         列出文件的 atime</p>
<p>ls -l filename          列出文件的 mtime</p>
<p>atime不一定在访问文件之后被修改，因为：<br>使用ext3文件系统的时候，如果在mount的时候使用了noatime参数那么就不会更新atime的信息。而这是加了 noatime 取消了, 不代表真实情況。<br>反正, 這三個 time stamp 都放在 inode 中。若 mtime, atime 修改inode 就一定會改, 既然 inode 改了, 那 ctime 也就跟著要改了。</p>
<h2 id="linux-文件类型"><a href="#linux-文件类型" class="headerlink" title="linux 文件类型"></a>linux 文件类型</h2><p>1）正规文件（regular file）：就是一般类型的文件，当用ls –l 查看某个目录时，第一个属性为”-“的文件就是正规文件，或者叫普通文件。正规文件又可分成纯文字文件（ascii）和二进制文件（binary）。纯文本文件是可以通过cat, more, less等工具直接查看内容的，而二进制文件并不能。例如我们用的命令/bin/ls 这就是一个二进制文件。</p>
<p>2）目录（directory）即文件夹,ls –l 查看第一个属性为”d”。</p>
<p>3）连接档（link）：ls –l 查看第一个属性为 “l”，类似windows下的快捷方式。</p>
<p>4）设备档（device）：与系统周边相关的一些档案，通常都集中在 /dev 这个目录之下！通常又分为两种：<br>    区块 (block) 设备档：说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的档案啦！第一个属性为 “ b “；<br>    字符 (character) 设备档：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为 “ c “。</p>
<h3 id="linux-文件后缀名"><a href="#linux-文件后缀名" class="headerlink" title="linux 文件后缀名"></a>linux 文件后缀名</h3><p>1.sh代表它是一个shell script<br>2.tar.gz 代表它是一个压缩包，<br>3.my.cnf 代表它是一个配置文件，<br>4.test.zip 代表它是一个压缩文件。<br>早期Unix系统文件名最多允许14个字符，而新的Unix或者linux系统中，文件名最长可以到达 256 个字符！</p>
<h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩 解压缩"></a>压缩 解压缩</h2><p>tar</p>
<p>  解包：tar zxvf filename.tar</p>
<p>  打包：tar czvf filename.tar dirname</p>
<p>zip命令</p>
<p>解压：unzip filename.zip</p>
<p>压缩：zip filename.zip dirname</p>
<h2 id="ln-建立连接档"><a href="#ln-建立连接档" class="headerlink" title="ln 建立连接档"></a>ln 建立连接档</h2><p>ln 语法： ln [-s] [来源文件] [目的文件]<br>ln 常用的选项就一个-s ，如果不加就是建立硬连接，加上就建立软连接。</p>
<p>Hard Link 的限制太多了，包括无法做目录的 link ，所以在用途上面是比较受限的！反而是 Symbolic Link 的使用方向较广！<br>在建立硬连接前后，空间大小不改变。<br>不能创建目录的硬连接。<br>目录是可以软连接的。<br>删除软连接对源文件没有任何影响。</p>
<h2 id="环境变量-PATH"><a href="#环境变量-PATH" class="headerlink" title="环境变量 PATH"></a>环境变量 PATH</h2><p>有两个方法。</p>
<p>一种方法是直接将 /root 的路径加入 PATH 当中！如何增加？可以使用： 　</p>
<p>PATH=”$PATH”:/root</p>
<p>另一种方式则是使用完整档名，亦即直接使用相对或绝对路径来执行，例如：</p>
<p>/root/ls</p>
<p>./ls</p>
<p>====</p>
<h3 id="vim查看版本"><a href="#vim查看版本" class="headerlink" title="vim查看版本"></a>vim查看版本</h3><p>vim</p>
<h4 id="设置vim编码"><a href="#设置vim编码" class="headerlink" title="设置vim编码"></a>设置vim编码</h4><p>vim ~/.vimrc</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="vim-编辑"><a href="#vim-编辑" class="headerlink" title="vim 编辑"></a>vim 编辑</h3><p> 按i ,进入编辑模式，</p>
<p> 编辑完成后，按esc退出编辑模式</p>
<h4 id="退出保存"><a href="#退出保存" class="headerlink" title="退出保存"></a>退出保存</h4><p> :wq</p>
<h4 id="退出不保存"><a href="#退出不保存" class="headerlink" title="退出不保存"></a>退出不保存</h4><p> :q<br>会提示: No write since last change (add ! to override)<br>再输入一次</p>
<p>:q!<br>即可</p>
<p>将以下复制到其中</p>
<p>syntax on<br>set nu!<br>set encoding=utf-8<br>set fenc=utf-8<br>set fileencodings=ucs-bom,utf-8,cp936,gb2312,gb18030</p>
<h4 id="查看系统的编码"><a href="#查看系统的编码" class="headerlink" title="查看系统的编码"></a>查看系统的编码</h4><p>echo $LANG</p>
<h2 id="乱码解决方案"><a href="#乱码解决方案" class="headerlink" title="乱码解决方案"></a>乱码解决方案</h2><ol>
<li>系统编码</li>
<li>vim的编码</li>
<li>连接服务器的终端。<ol>
<li>SecureCRT设置字条编码<br>Option–Session Option–Appearance<br>设置字符编码</li>
</ol>
</li>
</ol>
<h2 id="命令行远程登录服务器"><a href="#命令行远程登录服务器" class="headerlink" title="命令行远程登录服务器"></a>命令行远程登录服务器</h2><p>ssh <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#56;&#x2e;&#x31;&#x2e;&#50;&#x35;">&#x72;&#x6f;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#56;&#x2e;&#x31;&#x2e;&#50;&#x35;</a><br>    用户名@ip</p>
<h2 id="服务器上安装公钥"><a href="#服务器上安装公钥" class="headerlink" title="服务器上安装公钥"></a>服务器上安装公钥</h2><p>键入以下命令，在服务器上安装公钥：</p>
<p>[root@host ~]$ cd .ssh</p>
<p>[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</p>
<p>将本地的key复制到authorized_keys文件中</p>
<h3 id="从gitbash中获ssh-key"><a href="#从gitbash中获ssh-key" class="headerlink" title="从gitbash中获ssh key"></a>从gitbash中获ssh key</h3><p>  clip &lt; ~/.ssh/id_rsa.pub</p>
<p> ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOmNk1rDPVPv+DTpe/ynM9dLDj/FjG/3xkAvjz8EoxSM/QBXNLj69m0SXA4jI6LOIwuS3Pdn011qWGa14zHPDI0wY9cGzlC+AvcuAZ0s+ndppAVk5PktYM0zCfBhlpLyHCgCVNxDxv1shd1A+gG3Lbi+tJ75oOnvJ5uSWC6x6wJgwJy/zUdQHTA3od4Mfkbz/6hr1sWqnCJE3r4H9Na6XtYMbjyl+O+JnePxH4PDwT/0MVxPpojyEqAv/FE9Gb7WjqmLsT5TWEoRhb4V0pm75moh6QObgqQ+RfJLS6Cz+NIvep980qVrYaRQGQG+7bEwy3fNDZlSGXRUALgELceVP/ HP@HP-PC</p>
<h2 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h2><p> uname -r</p>
<h2 id="查看系统"><a href="#查看系统" class="headerlink" title="查看系统"></a>查看系统</h2><p>uname</p>
<h2 id="查看当前正在进行的进程"><a href="#查看当前正在进行的进程" class="headerlink" title="查看当前正在进行的进程"></a>查看当前正在进行的进程</h2><p> jobs</p>
<h2 id="启一个服务，在后台执行，并将日志输出到log"><a href="#启一个服务，在后台执行，并将日志输出到log" class="headerlink" title="启一个服务，在后台执行，并将日志输出到log"></a>启一个服务，在后台执行，并将日志输出到log</h2><p> node . &gt;log 2&gt;&amp;1 &amp;</p>
<p> tail -f log</p>
<h2 id="查找某个进程-eg-node"><a href="#查找某个进程-eg-node" class="headerlink" title="查找某个进程(eg:node)"></a>查找某个进程(eg:node)</h2><p> ps -ef|grep node</p>
<h2 id="在历史命令中查找某个命令"><a href="#在历史命令中查找某个命令" class="headerlink" title="在历史命令中查找某个命令"></a>在历史命令中查找某个命令</h2><p> history|grep cd</p>
<h2 id="写了脚本以后执行一个脚本"><a href="#写了脚本以后执行一个脚本" class="headerlink" title="写了脚本以后执行一个脚本"></a>写了脚本以后执行一个脚本</h2><p>./control.sh</p>
<h2 id="linux-查找文件"><a href="#linux-查找文件" class="headerlink" title="linux 查找文件"></a>linux 查找文件</h2><p>find / -name nginx.conf</p>
<p>find / -name php.ini</p>
<p>find / -name my.cnf</p>
<p>find / -name httpd.conf</p>
<h2 id="php-相关"><a href="#php-相关" class="headerlink" title="php 相关"></a>php 相关</h2><p> 查看php运行目录命令：<br>which php</p>
<p>which 用来查找一个命令的绝对路径</p>
<p>/usr/bin/php<br>查看php-fpm进程数：</p>
<p>ps aux | grep -c php-fpm</p>
<p>查看运行内存<br>/usr/bin/php  -i|grep mem</p>
<p>关闭PHP</p>
<p>killall php-fpm</p>
<p>php重启</p>
<p>/usr/local/php/sbin/php-fpm &amp;</p>
<h2 id="php-配置"><a href="#php-配置" class="headerlink" title="php 配置"></a>php 配置</h2><ol>
<li>端口 httpd.conf listen 80</li>
</ol>
<p>2.</p>
<h2 id="查看linux-IP"><a href="#查看linux-IP" class="headerlink" title="查看linux IP"></a>查看linux IP</h2><h3 id="公网IP"><a href="#公网IP" class="headerlink" title="公网IP"></a>公网IP</h3><p>curl members.3322.org/dyndns/getip</p>
<p>47.94.93.83</p>
<h3 id="内网IP"><a href="#内网IP" class="headerlink" title="内网IP"></a>内网IP</h3><p>ifconfig</p>
<p>inet addr:192.168.42.128</p>
<h2 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h2><p>启动：/usr/local/nginx/sbin/nginx</p>
<p>service nginx start<br>关闭：/usr/local/nginx/sbin/nginx  -s stop</p>
<p>service nginx stop</p>
<p>重启：/usr/local/nginx/sbin/nginx -s  reload</p>
<p>查看nginx状态<br> service nginx status</p>
<p>查看当前nginx目录<br>ps -ef | grep nginx<br>可以在conf目录下的nginx.conf中找到对应的配置。</p>
<p>查看一个服务是否已经启动：</p>
<p>ps -A | grep nginx</p>
<p>如果返回结果的话，说明有nginx在运行，服务已经启动</p>
<p>nginx -V 查看nginx安装目录</p>
<p>cd /usr/local/etc/nginx 里有nginx.conf</p>
<p>sudo nginx -s reload<br>Sudo nginx -s stop</p>
<p>openresty/nginx/coupon</p>
<p>./sbin/nginx -s reload</p>
<p>Nginx 命令<br>service nginx stop/start/status/reload</p>
<p>2、查看nginx.conf配置文件目录</p>
<p>输入命令</p>
<h3 id="nginx-t"><a href="#nginx-t" class="headerlink" title="nginx -t"></a>nginx -t</h3><p>返回结果包含配置文件目录<br>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</p>
<p>nginx: configuration file /etc/nginx/nginx.conf test is successful</p>
<p>检查下80端口是否被其他进程占用了。<br>lsof -i:80</p>
<h3 id="Nginx-配置实现CORS"><a href="#Nginx-配置实现CORS" class="headerlink" title="Nginx 配置实现CORS"></a>Nginx 配置实现CORS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ &#x2F;api&#x2F;v1 &#123;</span><br><span class="line"></span><br><span class="line"> add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, PUT, DELETE, OPTIONS&#39;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type    &#39;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line"> if ($request_method &#x3D; &#39;OPTIONS&#39;) &#123;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, PUT, DELETE, OPTIONS&#39;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type    &#39;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">  add_header &#39;Access-Control-Max-Age&#39; 1728000; # 20 天</span><br><span class="line">  add_header &#39;Content-Type&#39; &#39;text&#x2F;html charset&#x3D;UTF-8&#39;;</span><br><span class="line">  add_header &#39;Content-Length&#39; 0;</span><br><span class="line">  return 200;</span><br><span class="line"> &#125;</span><br><span class="line">    # 这下面是要被代理的后端服务器，它们就不需要修改代码来支持跨域了</span><br><span class="line"> proxy_pass http:&#x2F;&#x2F;127.0.0.1:8085;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> proxy_redirect off;</span><br><span class="line"> proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"> proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"> proxy_connect_timeout 60;</span><br><span class="line"> proxy_read_timeout 60;</span><br><span class="line"> proxy_send_timeout 60;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="telnet-80-d端口ping不通"><a href="#telnet-80-d端口ping不通" class="headerlink" title="telnet 80 d端口ping不通"></a>telnet 80 d端口ping不通</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl &lt;http://127.0.0.1&gt;</span><br><span class="line">curl http:oriht.com</span><br></pre></td></tr></table></figure>

<p>查看实例安全组规则  端口范围是否有80端口</p>
<p>允许自定义 TCP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80&#x2F;80 地址段访问</span><br><span class="line">0.0.0.0&#x2F;0</span><br><span class="line">-</span><br><span class="line"></span><br><span class="line">1 2017-09-25 11:03:54</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果新配置nginx一直403 禁止访问的话</p>
<p>修改/etc/selinux/config<br>将SELINUX=enforcing 改为<br>SELINUX=disabled</p>
<h2 id="跟着吴博学linux"><a href="#跟着吴博学linux" class="headerlink" title="跟着吴博学linux"></a>跟着吴博学linux</h2><p>ls -lh</p>
<p>sudo sh updata_<a href="http://www.sh/">www.sh</a></p>
<p>less update_<a href="http://www.sh/">www.sh</a></p>
<p>ls -l</p>
<p>sudo su root</p>
<p>git branch -r</p>
<h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="!/bin/bash"></a>!/bin/bash</h2><p>rm www-old<br>mv ./www ./www-old<br>ln -s ./ac-www-releases/ac-www-2016-10-17/ www<br>sh git.pull.sh</p>
<p>exit</p>
<p>sudo sh update_<a href="http://www.sh/">www.sh</a></p>
<hr>
<h2 id="找不到httpd-conf"><a href="#找不到httpd-conf" class="headerlink" title="找不到httpd.conf"></a>找不到httpd.conf</h2><p>httpd.conf的位置一般位于<br>/etc/httpd/conf/httpd.conf</p>
<p>如果没<br>执行命令<br>yum install httpd<br>重新安装一下，</p>
<h2 id="根据nginx配置，查找文件目录"><a href="#根据nginx配置，查找文件目录" class="headerlink" title="根据nginx配置，查找文件目录"></a>根据nginx配置，查找文件目录</h2><p>原本nginx配置好后，目录应该在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x2F;data&#x2F;www&#x2F;hosts;</span><br></pre></td></tr></table></figure>

<p>但如果有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~ &#x2F; &#123;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001&#x2F;;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则应根据3001端口来找具体进程对应的进程</p>
<p>执行 如下命令找到对应进程的pid</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netstat -nplt | grep 3001</span><br></pre></td></tr></table></figure>

<p>根据pid来找到目录，执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux | grep 37098</span><br></pre></td></tr></table></figure>

<p>出现如下结果，则为对应的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">501      37098  0.0  0.2 1209696 42828 ?       Ssl  Aug08   8:37 node /home/nodeProjects/express/dist/index.js</span><br></pre></td></tr></table></figure>

<h2 id="跟着立斌学命令行"><a href="#跟着立斌学命令行" class="headerlink" title="跟着立斌学命令行"></a>跟着立斌学命令行</h2><p>dash<br>zsh<br>/oh-my-zsh<br>oh-my-zsh</p>
<p>sh -c “$(curl -fsSL <a href="https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</a><br>需要提前装zsh，<br> yum install zsh</p>
<h2 id="切换到zsh"><a href="#切换到zsh" class="headerlink" title="切换到zsh"></a>切换到zsh</h2><p>chsh -s /usr/local/bin/zsh</p>
<p>修改主题，目录<br>/root/.oh-my-zsh/templates/zshrc.zsh-template</p>
<p>zsh-autosuggestions</p>
<p>安装方法：<br>git clone git://github.com/zsh-users/zsh-autosuggestions <del>/.zsh/zsh-autosuggestions<br>source</del>/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh</p>
<p>看一下自己目前使用的终端是什么：</p>
<p>echo $SHELL</p>
<p>查看当前主题</p>
<p>echo $ZSH_THEME</p>
<p>我用的主题<br>robbyrussell</p>
<p> 主题修改文件路径:sudo vim ~/.zshrc</p>
<h2 id="linux-用命令启动服务不掉线"><a href="#linux-用命令启动服务不掉线" class="headerlink" title="linux 用命令启动服务不掉线"></a>linux 用命令启动服务不掉线</h2><p>创建control.sh<br>  运行./control.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">nohup npm start ./ 1&gt;&gt;<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>cat access.log | cut -d’ ‘ -f7 | sort | uniq -c | sort -nr | head -n30</p>
<hr>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>业务?! 业务与技术之争</title>
    <url>/posts/%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E4%B8%8E%E6%8A%80%E6%9C%AF%E4%B9%8B%E4%BA%89/</url>
    <content><![CDATA[<p>以前确实不重视业务，读了接下来这篇文章，发现了自己的误区。将好的观点抄下来，以便领会吸收。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a href="https://juejin.im/post/5eb3cab66fb9a043856f3987">原文链接</a></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>作为一个业务前端，完成业务需求的同时，还要处理各种线上问题，加班辛苦忙碌了一年，还要被老板说“思考是不够的”、“没有业务 sence”，出去面试，被问项目，也说不出什么有亮点或者有挑战的东西，想做点牛逼的东西，也没有发现什么有价值的方向，好不容易找到一些方向，还要被老板一顿质问，业务价值是什么？ROI 怎样？最终可能就只是做了一点性能优化工作，抽离了一些可复用的组件……不禁让人感叹，业务难、前端难、做业务的前端更难！</p>
<a id="more"></a>

<h2 id="1-业务前端的困境"><a href="#1-业务前端的困境" class="headerlink" title="1. 业务前端的困境"></a>1. 业务前端的困境</h2><h3 id="1-1-业务前端“好忙”"><a href="#1-1-业务前端“好忙”" class="headerlink" title="1.1 业务前端“好忙”"></a>1.1 业务前端“好忙”</h3><p>业务前端，顾名思义，做业务的前端，直接与业务的 PD、运营接触，对产品的用户直接负责。在实际的工作中，业务前端经常忙于业务的各种会议、项目和答疑，即便一条业务线上有多个前端同学支持，面对成山的需求，可能依然感到吃力，这其中的原因可能有：</p>
<ol>
<li>用户侧产品往往需要快速上线，大部分需求都需要倒排工期，开发时间尤其紧张</li>
<li>对业务不熟悉，在项目需求已确定的时候才去参加视觉评审，没有办法判断需求背后的业务逻辑跟业务大节奏是否匹配、需求本身是否能够达成业务目标、有没有更好的实现方式，只能接下需求，然后排期</li>
<li>维护成本高，每天还要忙于解决各种线上问题，比如这里样式有点问题，那里怎么没有显示……各种琐碎问题让你过的非常“充实”</li>
<li>需求响应速度较慢，比如业务的技术栈较老，或者定制逻辑过多，边写代码还要边查文档，查不到可能还要查源码，效率大幅降低。又或者跟别的业务技术体系不同，难以复用和沉淀，如果要用，可能还要重写一遍……</li>
</ol>
<h3 id="1-2-业务前端是“资源”"><a href="#1-2-业务前端是“资源”" class="headerlink" title="1.2 业务前端是“资源”"></a>1.2 业务前端是“资源”</h3><p>前端岗位的特点就是有视觉稿就可以完成工作，不需要理解业务全貌，所以在繁忙期很容易让前端忽视了业务思考，加上之前描述的各种原因，业务前端经常沦落为“资源”，当你沦落为“资源”的时候，其实就已经失去了和业务平等对话的资格，他们只会把你当成莫得感情的开发机器，跟你输入需求，让你吐出页面，而你在这样的关系中，本来写着还算工整的代码，为了快速实现业务需求，也开始写起乱糟糟的代码，对于你所创造的产品也没有话语权，久而久之也失去了激情和耐心。</p>
<p>失去激情，写的不开心也就算了，因为你没有做出什么特别的东西，老板也不会特别认可你的辛苦，还会觉得你思考不够、没有业务 sence，对业务没有助力，没有让业务因为你的存在而有所不同……</p>
<h3 id="1-3-业务前端想突破"><a href="#1-3-业务前端想突破" class="headerlink" title="1.3 业务前端想突破"></a>1.3 业务前端想突破</h3><p>好吧，那我决定做点什么改变一下，于是跟老板提出了一系列想法：</p>
<ol>
<li>这里技术体系太老了，为了进一步提升开发效率，我们想要搞技术重构</li>
<li>前后端联调有点费劲，我们想搞个联调数据中台，提升联调效率</li>
<li>那里展现速度太慢了，我们要搞性能优化</li>
<li>……</li>
</ol>
<p>老板往往会来一系列灵魂提问：</p>
<ol>
<li>为什么要做？（有什么业务价值？有什么技术价值？）</li>
<li>为什么是现在做？</li>
<li>为什么是你做？</li>
<li>ROI（投入产出比）怎么样？</li>
</ol>
<p>还没有开始，躁动的心就被老板的一系列“质疑”浇了一盆冷水。</p>
<p>如果没有回答好这些问题、说服老板，自然也争取不到什么资源，只能一个人搞搞，一个人搞的往往质量不行、也没有人用，久而久之自己也不维护了，只能又开始埋头在需求中。</p>
<p>干的不开心，也没有成长，最后只能暗淡离职，但换了一个公司就会好吗，很可能又是类似的过程……</p>
<p>这真的堪称是业务前端的“困境”，那么如何突破这种困境呢？首先我们就要摆正心态，从了解业务开始。</p>
<h2 id="2-了解业务"><a href="#2-了解业务" class="headerlink" title="2. 了解业务"></a>2. 了解业务</h2><h3 id="2-1-业务和需求"><a href="#2-1-业务和需求" class="headerlink" title="2.1 业务和需求"></a>2.1 业务和需求</h3><p>在了解业务之前，首先我们要知道，业务跟需求是不一样的。理解需求并不等于理解业务，需求是业务经过产品消化后的产物，可能已经经过演绎或者拆解，因此需求并不是业务本身，当然了解的需求越多，对业务的全貌也会更加了解。</p>
<p>那么什么是业务呢？业界对”业务”有多种定义，但是其主要思想基本不变，业务就是一系列人通过一系列活动完成某一任务的过程，因此，业务可大可小，可以无限拆分。</p>
<p>我们本文涉及的业务泛指商业业务，就是与该 BU 或者公司商业模式直接关联的业务或其组成部分。</p>
<h3 id="2-2-前端为什么要学习业务"><a href="#2-2-前端为什么要学习业务" class="headerlink" title="2.2 前端为什么要学习业务"></a>2.2 前端为什么要学习业务</h3><p>前端即使不学习业务，其实也不影响做需求，毕竟你只要告诉我交互是什么样的，前端就可以帮你实现，而且已经有产品经理的角色了，大家各司其职不就好了，为什么一个做技术的，要狗拿耗子、或者是越俎代庖呢？这就要说到：</p>
<ol>
<li><p>只有了解业务，才能从技术的角度想到业务方不曾想到的地方；不了解业务，你可能听不懂业务方要什么，甚至连需求的业务逻辑都搞不清，这种情况的合作模式只有一种，需求下来了，你接住，然后给排期。也许，这个需求的设计不合理，你不知道；这个需求有更好的实现方案，你不知道；这个需求可以通过现成的关联产品方案解决，省时省人力，你也不知道。</p>
</li>
<li><p>只有了解到业务背后的原因，才能从全局的视角去规划技术的未来。不了解业务，会让你离用户的真实需求很远，你越难发现其中的一些痛点和挑战，没法真正提出你的思考和解决方案，去解决用户的难题。</p>
</li>
<li><p>作为一名产品研发工程师，自然是希望亲手打磨一款解决用户问题、体验友好的产品，如果产品能得到用户认可，产生影响力、自然会特别有成就感。</p>
</li>
<li><p>阿里作为一家商业科技公司，对技术人的要求就是技术与业务相结合，在满足业务需求的基础上，成为技术与业务的桥梁，主动走进业务，思考如何通过技术手段帮助业务做赢、满足市场和用户需求，先一步技术规划、人才储备、技术架构和技术预研。</p>
</li>
</ol>
<h3 id="2-3-你了解业务吗"><a href="#2-3-你了解业务吗" class="headerlink" title="2.3 你了解业务吗"></a>2.3 你了解业务吗</h3><p>那么目前你了解你对接的业务吗？不妨尝试回答下以下问题：</p>
<ol>
<li>业务做的是什么？产品大图有吗？</li>
<li>业务的核心指标是什么？KPI目标是什么，这些数字背后的含义是什么？要达成这些目标，业务策略是什么？</li>
<li>业务的用户是谁？流量怎么分层？占比多少？分别在业务中是怎样的定位？</li>
<li>业务的商业模式？靠什么吸引流量，盈利模式是怎样的？</li>
<li>我们做的页面是什么东西？为业务带来什么价值？要创造更多的价值，我们可以做什么？</li>
</ol>
<h2 id="2-4-如何学习业务"><a href="#2-4-如何学习业务" class="headerlink" title="2.4 如何学习业务"></a>2.4 如何学习业务</h2><h3 id="2-4-1-业务领域知识的阅读"><a href="#2-4-1-业务领域知识的阅读" class="headerlink" title="2.4.1 业务领域知识的阅读"></a>2.4.1 业务领域知识的阅读</h3><p>找到该领域相关的评分较好的书籍集中阅读，快速形成知识框架。</p>
<h3 id="2-4-2-了解业务背景和规划"><a href="#2-4-2-了解业务背景和规划" class="headerlink" title="2.4.2 了解业务背景和规划"></a>2.4.2 了解业务背景和规划</h3><p>刚刚接手新的业务，可以邀请业务方老板或者资深的运营/产品同学，给你讲讲这块业务的过去、现在、未来、愿景、财年规划，以及对技术同学的期望；</p>
<ol>
<li>花时间读合作方（运营、产品、研发）的周报，了解现在在发生什么，是不是离目标越来越近了；</li>
<li>了解业务目标、落地策略、衡量目标的数据口径，关注数据，关注目前做的项目是否为了达成目标而战，如果不是，提出你的想法和建议；</li>
<li>多参会，建立产品 sense。收集信息最好的方式就是参加所处业务老大的 KO 会，各种 KO 会会把战略上的拆解和背后的思考整体梳理之后宣讲传达给 BU 或部门的同学，</li>
</ol>
<h3 id="2-4-3-多交流"><a href="#2-4-3-多交流" class="headerlink" title="2.4.3 多交流"></a>2.4.3 多交流</h3><p>与服务端同学聊天，与 PM 聊天，与用户聊天，多角度看业务，但要注意的是，针对专业型比较强的业务，需要先做功课，至少一些英文的缩写要清楚的明白意思。</p>
<h3 id="2-4-4-谨记数字"><a href="#2-4-4-谨记数字" class="headerlink" title="2.4.4 谨记数字"></a>2.4.4 谨记数字</h3><p>如果前面还需要花比较长的时间，那这一个可以现在就做起来，那就是把业务相关的数字记得越精细约好，越具体越好，越全面越多越好。这样做有两个好处：</p>
<ol>
<li>所记的数字指标本身，很大程度已经涵盖了这个业务价值方向，你便知道了这个业务重点关注的是哪个维度的东西</li>
<li>这些数字可以作为和业务方以及产品“平等对话”的源头，否则连最基本的对话基础都没有</li>
</ol>
<h3 id="2-4-5-从日常需求入手"><a href="#2-4-5-从日常需求入手" class="headerlink" title="2.4.5 从日常需求入手"></a>2.4.5 从日常需求入手</h3><p>对于项目中的需求，我们要尝试分析背后的目的和价值，做了之后有什么预期的收益，为什么这么做就可以达到这个收益，跟总体目标是否契合，还要判断业务方提到的点是不是有效的方案或者说成本太大的方案，看能不能给出替代方案，用现有的方案或者小成本的方式来满足业务方。<br>而在项目提测上线后，还要仔细分析以及多关注上线之后的业务数据和效果，会有如下好处：</p>
<ol>
<li><p>提高自己对业务的理解能力，你在关注业务数据的同时，也就会更多的从业务的角度来看到这个功能所带来的价值是否符合预期，当出现不符合预期的时候，可以和业务方一起进行数据漏斗的分析从而找到问题所在，避免我们的劳动成果成为一次性的工作。</p>
</li>
<li><p>总结的同时可以帮助自己梳理这个项目中自己哪些地方做的不足，或者相关推进中存在什么问题，以及后面怎么改进，提高了下次项目中的迭代效率和质量。比如这个项目是否存在需求理解不到位存在返工，或者沟通 &amp; 联调低效，环境不稳定，自己设计的方案是否合理等问题，后续要怎么解决。</p>
</li>
<li><p>也可以从数据和总结中判断出什么样的需求是靠谱的 &amp; 什么的样业务方是靠谱的，频繁争取资源上线效果又不好的业务方，下次再有需求过来则需要多增加一个心眼和思考的过程。</p>
</li>
</ol>
<h3 id="2-4-6-坚持"><a href="#2-4-6-坚持" class="headerlink" title="2.4.6 坚持"></a>2.4.6 坚持</h3><p>业务思考力，没有个至少半年是不会见效的</p>
<h2 id="3-助力业务"><a href="#3-助力业务" class="headerlink" title="3. 助力业务"></a>3. 助力业务</h2><h3 id="3-1-思考"><a href="#3-1-思考" class="headerlink" title="3.1 思考"></a>3.1 思考</h3><p>尽管平时的业务很忙，<strong>但再忙，也要抽时间思考</strong>，那么思考哪些内容呢？以下举一些例子：</p>
<ol>
<li><p>养成每天记工作内容的习惯，分析一下自己的时间到底耗在哪了</p>
</li>
<li><p>在业务开发中，有遇到让你特别想吐槽的点吗？想下问题背后的原因，有什么方法可以避免下次不犯，能不能提炼为更加通用的解决方案，其他同学怎么解决的，我可以怎么解决？</p>
</li>
<li><p>不断地输入、观察，业务的真实需求是什么？站在业务方的角度思考，业务遇到的痛点、挑战在哪里？</p>
</li>
</ol>
<h3 id="3-2-沟通"><a href="#3-2-沟通" class="headerlink" title="3.2 沟通"></a>3.2 沟通</h3><p>和老板、团队同学、业务方对焦，确认“我想做的”是不是“大家想要的”？<br>你可能会提出很多意见，但一般会遭到老板或者业务方无情的拒绝，而且问得你一脸懵逼，就比如：</p>
<ol>
<li>当前业务背景下，为什么要做？（有什么业务价值？有什么技术价值？）</li>
<li>现在必须做么？</li>
<li>为什么是你做？</li>
<li>怎么做？（体系化、全链路、单点技术挑战）</li>
<li>有什么业务和技术结果？能否被复用？</li>
<li>未来规划（能否跟BU或集团的方案联动、共建）</li>
</ol>
<p>而这往往是因为你提出要做的事情，有价值但不是必须做的，没有结合目前业务需要什么。也就是说，你想做的技术是个人和纯技术角度思考的，没有基于业务的现状和痛点去考虑技术方案，不接地气，投入产出比不高。<br>所以给技术产出先找好业务的阵地，看看有没有可以借力的地方，不要重复造轮子。快速验证这个方向的正确性后，再逐渐多加投入、丰满技术设计。不要自己YY、默默地做完，这样做出来的东西没有业务场景埋单。</p>
<h3 id="3-3-技术规划"><a href="#3-3-技术规划" class="headerlink" title="3.3 技术规划"></a>3.3 技术规划</h3><p>业务赋能其实是需要我们紧贴业务规划，制定技术规划和方案。在了解业务方今年的 KPI 重点是什么，预计的拆解和实现路径是什么后，再结合自己的和团队情况，想想自己能做哪些事情来帮助业务实现其 KPI，这里有两点需要注意下：</p>
<p><strong>抓住本质从点及面，通盘考虑:</strong> 很多时候，我们收到的痛点和业务需求都是单点的，这时我们不能着眼于眼前的单点问题，而需要通盘来考虑，比如SEO的页面对性能非常敏感，经常可能会收到一些业务方来反馈，说目前我们的SEO有这个地方，那个地方需要优化下，而单点解决这些问题可能对业务带来的收益并不大，对自己的技能也没有什么成长。这时候如果通盘考虑这个命题，其实会发现做SEO页面的优化，其实目的是为了提升SEO页面的收录和排名。而提升SEO页面的收录和排名其实不仅有前端性能优化这一个路径，而是还有一些其他的路径：比如优化关键词&amp;长尾词，采用Google的AMP技术改造SEO页面，优化爬虫爬取页面的耗时提升爬取率等等。这样就能吧点的问题转化为面的问题，才能制定更有效和全面的抓手来赋能业务。</p>
<p><strong>既要解决眼前痛点，也要长远谋划:</strong> 很多时候我们不能仅满足于眼前的KPI，还需要了解业务方长远的想法和可以预见的规划。就比如试点的新业务，一层规划是保证业务项目的按时上线，考虑到未来，另一层规划可能就是如何做到技术方案的可以复制性。</p>
<h3 id="3-4-站在巨人的肩膀上"><a href="#3-4-站在巨人的肩膀上" class="headerlink" title="3.4 站在巨人的肩膀上"></a>3.4 站在巨人的肩膀上</h3><p>当你需要制定一个产品化的方案或者工具和框架的时候，最好先放眼集团内部和行业进行一番调研，看看业界和其他同事是怎么解决这个问题的。尽量站在别人的肩膀上做出创新或者参与共建，避免小团队内造出重复和质量低的轮子</p>
<h2 id="4-技术深度"><a href="#4-技术深度" class="headerlink" title="4. 技术深度"></a>4. 技术深度</h2><h3 id="4-1-技术知识与技术能力"><a href="#4-1-技术知识与技术能力" class="headerlink" title="4.1 技术知识与技术能力"></a>4.1 技术知识与技术能力</h3><p>“技术”不能是一个笼统的词汇，我想它至少可以分为“技术知识”和“技术能力”两大部分。<br>什么是“技术知识”？知识就是 I KNOW</p>
<ul>
<li>《TypeScript 从入门到放弃》</li>
<li>《React 从入门到放弃》</li>
<li>《Webpack 从入门到放弃》</li>
<li>……</li>
</ul>
<p>什么是“技术能力”？能力就是 I CAN</p>
<ul>
<li>我用 TypeScript 重构了一个大型系统，代码健壮性及研发效率大幅提升。</li>
<li>我用 React Hooks 给全栈同学进行前端培训，培训效果大幅提升。</li>
<li>我深入研究了 Webpack，优化配置，使得系统构建速度大幅提升。<br>…..</li>
</ul>
<h3 id="4-2-培养技术视野"><a href="#4-2-培养技术视野" class="headerlink" title="4.2 培养技术视野"></a>4.2 培养技术视野</h3><ol>
<li>关注日常业界新技术。不一定要深入了解，但对新技术保持好奇心，大概了解它是做什么的，如果在工作中遇到匹配的落地环境，可以考虑写个 demo 看看是不是有价值</li>
<li>关注集团和业界的解决方案。在业务中发现问题，做解决方案的时候，我们很容易陷入自己的设计中，一脑子地想把所有东西都自己做出来，但投入会非常大，产出的价值是否一样大呢？不知道。大部分情况下，你想做的，在ATA能搜到，前人踩的坑，或者已有的成熟的解决方案，只要你去沟通去接触，就可以轻松地接进来，为什么要花大量的时间去造轮子呢？可以借力的地方，就去借力吧，把时间剩下来，做你的解决方案中更核心更有价值的事情。</li>
</ol>
<h3 id="4-3-技术深度"><a href="#4-3-技术深度" class="headerlink" title="4.3 技术深度"></a>4.3 技术深度</h3><p>一聊到“技术深度”，可能很自然地会认为是在某项技术上挖得很深，或者解决了一个业界公认难度很高的技术难题，但这只是“技术深度”的其中一部分：</p>
<ol>
<li>体系化 / 系统化<br>体系化思维是认识事物的一种方式，在面对问题的时候，能够针对复杂的问题，列出关键的要素和解决方法，将散乱无序的问题，变得逻辑清晰，有章可循。<br>在问题的定位和解决的体现，从表象到本质，拆解出造成问题背后的原因，针对性地去解决本质的原因，而非治标不治本，有解决方案有节奏地解决。</li>
<li>全链路<br>除了前端的部分，向前向后的技术栈，还能挖多深。</li>
<li>单点技术挑战<br>在某个技术挑战上，你的思考和解决方案是怎样的。</li>
</ol>
<h3 id="4-4-技术与业务共赢"><a href="#4-4-技术与业务共赢" class="headerlink" title="4.4 技术与业务共赢"></a>4.4 技术与业务共赢</h3><p>真正有突破性的、带来重大价值的业务成果必然伴随着技术上的深入乃至创新，所以在做业务成果的时候，一定会有让我们增加技术深度的场景。</p>
<h2 id="5-给你更多体感"><a href="#5-给你更多体感" class="headerlink" title="5. 给你更多体感"></a>5. 给你更多体感</h2><p>培养业务感确实是一件非常有难度的事情，他要求你以业务而非技术为第一视角，这可能违背了很多人内心的“技术坚持”，但如果一直做技术，其实是很难有非常大的突破的，在工作中，如果能实现技术与业务共赢，将会助力你到达更高的高度。</p>
<p>改变的确很难，但结果值得冒险。</p>
]]></content>
      <tags>
        <tag>业务</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>正则</title>
    <url>/posts/%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<p>[TOC]<br><a href="https://juejin.im/post/5bf174396fb9a049ca36f13d#heading-7">参考链接</a><br><a href="https://juejin.im/post/5b62717ee51d4519873f858a">面试官！让我们聊聊正则</a></p>
<p><a href="http://www.runoob.com/regexp/regexp-metachar.html">正则表达式 - 元字符!!!</a><br>一直以来正则都靠搜索，复制粘贴。今天开始学习，以后就可以自己写啦~~~</p>
<h2 id="正则表达式是什么"><a href="#正则表达式是什么" class="headerlink" title="正则表达式是什么"></a>正则表达式是什么</h2><p>正则表达式(Regular Expression)是一个描述字符模式的对象，使用正则表达式可以进行强大的模式匹配和文本检索与替换功能。<br>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<p>正则表达式是处理字符串的利器，并提高工作效率，一个好的正则能够帮我们省去几十甚至上百行代码。</p>
<a id="more"></a>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><strong>学习正则表达式最好方法是从例子开始，理解例子之后再对例子进行修改，实验。</strong></p>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ol>
<li>姓名<ul>
<li>2-9位中文昵称： <code>^[\u4e00-\u9fa5]&#123;2,9&#125;$</code></li>
</ul>
</li>
<li>验证密码<ul>
<li>只能是数字、字母、下划线，长度不限制: <code>^\w+$</code></li>
<li>允许 小写字母 a-z、大写字母 A-Z、数字 0-9、下划线 _、 连接符 -，且长度在 6-18 位数：<br><code>/^[a-zA-Z0-9_-]&#123;6,18&#125;$/</code></li>
<li>必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</code></li>
</ul>
</li>
<li>验证 Email<ul>
<li>允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-+.] + @ + 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-.] + . + 允许有一个字符符合 [A-Za-z0-9_] 之后可以有 [A-Za-z0-9_-.] 的邮箱：^\w+([-+.]\w+)*@\w+([-.]\w+)<em>.\w+([-.]\w+)</em>$</li>
</ul>
</li>
<li>验证身份证<ul>
<li>18 位身份证号，尾数是数字或者字母 X：<code>^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)([0-9]|X)$</code></li>
<li>15 或者 18 位身份证号，尾数可以是数字及 X 或者 x：<code>(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</code></li>
</ul>
</li>
<li>验证手机号<ul>
<li>以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：<code>^1[3,4,5,7,8,9]\d&#123;9&#125;$</code></li>
<li>移动号码：<code>^134[0-8]\d&#123;7&#125;$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\d&#123;7,8&#125;$</code></li>
<li>电信号码：<code>^(?:133|153|1700|1701|1702|177|173|18[019])\d&#123;7,8&#125;$</code></li>
<li>联通号码：<code>^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])\d&#123;7,8&#125;|$</code></li>
</ul>
</li>
</ol>
<h2 id="JavaScript-创建正则表达式"><a href="#JavaScript-创建正则表达式" class="headerlink" title="JavaScript 创建正则表达式"></a>JavaScript 创建正则表达式</h2><p>两种方式：</p>
<ol>
<li>用<code>/正则表达式/</code>两个斜杠来包裹要写的正则表达式</li>
<li>构造函数创建(不推荐)<br><code>var reg = new RegExp(&#39;\\d+&#39;, &#39;img&#39;)</code><br>第一个参数是元字符并且\d这种特殊字符在这里面是普通字符，所以需要用\转义为特殊字符，第二个参数是修饰符</li>
</ol>
<p>这两种的用途有区别，一般需要动态创建正则元字符采用构造函数创建，因为里面元字符是字符串拼接，常规固定写死正则采用字面量创建，例子如下：</p>
<p><code>var reg = /^[a-z0-9_-]&#123;6,12&#125;$/</code></p>
<p>这就是一条规则。</p>
<p>如何匹配一个字符串。这里用test方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc-cba_abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[a-z0-9_-]&#123;6,12&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>reg 通过 test() 方法去测试 str 是否符合 reg的规则，如果符合则返回 true，如果不符合则返回 false。<br>这里返回的是 true，因为我们的 str 是符合 reg 规则的。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>要想玩转正则首先要明白三大元素：<code>修饰符 元字符 量词</code><br>例：var reg = /^\d$/g 这是一个简单点正则，下面我们来对三大元素一探究竟</p>
<h3 id="1-修饰符"><a href="#1-修饰符" class="headerlink" title="1. 修饰符"></a>1. 修饰符</h3><ul>
<li><code>g</code> - global 全局匹配（只要有匹配成功的结果一直匹配直到没有为止）</li>
<li><code>i</code> - ignoreCase 忽略大小写</li>
<li><code>m</code> - multiline 多行匹配</li>
</ul>
<h3 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h3><p>元字符分为特殊元字符和普通元字符<br>普通元字符就是列入数组，字母等元素<br>常用特殊元字符如下：</p>
<ul>
<li><p><code>\</code> 转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义的字符转变为普通字符）</p>
</li>
<li><p><code>.</code> 除了<code>\n</code>（换行符）以外的任意字符</p>
</li>
<li><p><code>\d</code> 匹配一个<code>0~9</code>之间的数字</p>
</li>
<li><p><code>\D</code> 匹配一个非<code>0~9</code>之间的数字（大写与小写字母组合正好是相反含义</p>
</li>
<li><p><code>\w</code> 匹配一个0~9或字母或_之间的一个字符</p>
</li>
<li><p><code>\s</code> 匹配一个任意空白字符</p>
</li>
<li><p><code>\b</code> 匹配一个边界符</p>
</li>
<li><p><code>x|y</code> 匹配x或者y中的一个</p>
</li>
<li><p><code>[a-z]</code> 匹配<code>a-z</code>中的任意一个字符</p>
</li>
<li><p><code>[^a-z]</code> 匹配非<code>a-z</code>中的任意一个字符</p>
</li>
<li><p><code>[x- yz]</code> 匹配x或y或z中的一个字符</p>
</li>
<li><p><code>[^xyz</code> 和上方相反</p>
</li>
<li><p><code>()</code> 整的小分组，匹配一个小分组（可以理解为大正则中的一个小正则）</p>
</li>
<li><p><code>^</code> 以某一个元字符开始。例：<code>var reg = /^2/;</code> 表示开头必须是2，如果开始元字符放在[]里面 例：<code>[^]</code>表示非中括号种情况 相反含义</p>
</li>
<li><p><code>$</code> 以某一个元字符结束。例： <code>var reg = /2$/;</code> 表示结尾必须是2，如果是 <code>var reg = /^2$/;</code> 表示只能为2，因为2只代表一个元字符。</p>
</li>
<li><p><code>?:</code> 只匹配不捕获</p>
</li>
<li><p><code>?=</code> 正向肯定预查</p>
</li>
<li><p><code>?!</code> 正向否定预查</p>
</li>
</ul>
<h3 id="使用解析"><a href="#使用解析" class="headerlink" title="使用解析"></a>使用解析</h3><h4 id="1-小分组-匹配子项"><a href="#1-小分组-匹配子项" class="headerlink" title="1. () 小分组 匹配子项"></a>1. <code>()</code> 小分组 匹配子项</h4><p>匹配子项，就是小括号<code>()</code>，也叫分组操作。<br>|表达式| 释义| 用法|<br>|—–|——-|——|<br>|(子表达式)|标记一个子表达式的开始和结束位置。| (\w)\1 能匹配 deep 中的 ee|</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^18|19$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个例子很多同学能够了解是18或者19开头 但是结尾呢？真的只匹配19么？ 其实并不是</span></span><br><span class="line"><span class="comment">// 正确的匹配除了18 19 还有181、189、819 这时候小分组就起到了作用如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(18|19)$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将18或19用()包裹起来，起到小分组的作用</span></span><br><span class="line"><span class="comment">// 这样这个正则只匹配18开头结尾或者19而不是181和189</span></span><br></pre></td></tr></table></figure>

<p><code>var re = /(\d+)(-)/g;</code></p>
<p>分析这个正则：</p>
<ul>
<li><code>/(\d+)/</code> 表示任意 1 个及以上的数字</li>
<li><code>/(-)/</code> 表示匹配字符 -</li>
<li><code>g</code> 表示匹配一次以上</li>
</ul>
<p>所以这段正则的意思就是匹配一次及以上的 <code>数字-</code> 形式的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;2018-11-28&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\d+)(-)/g</span>;</span><br><span class="line">str = str.replace(re, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">0</span>, $<span class="number">1</span>, $<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数：$0（母亲)</span></span><br><span class="line">    <span class="comment">// 第二个参数：$1（第一个孩子）</span></span><br><span class="line">    <span class="comment">// 第三个参数：$2 (第二个孩子)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;$0：&quot;</span> + $<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;$1：&quot;</span> + $<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;$2：&quot;</span> + $<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> $<span class="number">1</span> + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 2018.11.28</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>console结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$<span class="number">0</span>：<span class="number">2018</span>-</span><br><span class="line">$<span class="number">1</span>：<span class="number">2018</span></span><br><span class="line">$<span class="number">2</span>：-</span><br><span class="line">$<span class="number">0</span>：<span class="number">11</span>-</span><br><span class="line">$<span class="number">1</span>：<span class="number">11</span></span><br><span class="line">$<span class="number">2</span>：-</span><br><span class="line"><span class="number">2018.11</span><span class="number">.28</span></span><br></pre></td></tr></table></figure>

<p>这里使用了 replace() 方法。<br>观察 Console 打印出来的结果，可以看出<br><code>$0</code> 即是我们的正则 var re = /(\d+)(-)/g 去匹配 var str = “2018-11-28” 所得到的结果，<br>这里我们匹配成功了两次，即 2018- 及 11-；<br><code>$1</code> 即是我们的一个小括号 (\d+) 的匹配结果，所以结果为 2018 以及 11；<code>$2</code> 即是我们的第二个小括号 (-) 的匹配结果，所以结果为 - 以及 -。<br> 最后，我们做的事情就是，将 $1 加上 <code>.</code>，并返回最终结果给 str，最终结果：<code>2018.11.28</code>。</p>
<p>另一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(a)(b)(c)/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(re));</span><br></pre></td></tr></table></figure>

<p>console结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">&quot;abc&quot;</span>, <span class="attr">groups</span>: <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2-分组引用-n"><a href="#2-分组引用-n" class="headerlink" title="2. 分组引用\n"></a>2. 分组引用<code>\n</code></h4><p>分组引用的概念就是可以引用大正则中指定的小正则规则，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^([a-z])([a-z])\2([a-z])$/</span></span><br><span class="line"><span class="comment">// 符合的字符串：book week http ...​</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体上面的例子理解为\2代表着第二个小正则规则的完全引用，就是和第二个小正则([a-z])一样，可以减少正则的复杂度和处理多次重复规则</p>
</blockquote>
<h4 id="4-匹配字符"><a href="#4-匹配字符" class="headerlink" title="4. 匹配字符 []"></a>4. 匹配字符 <code>[]</code></h4><p><code>[]</code> 这样的中括号的整体，代表一个字符。<br><strong>字符串包含中括号中任一字符即满足条件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[a-zA_Z0-9_]$/</span></span><br><span class="line"><span class="comment">// 这个正则和等价于\w 就是匹配一个0~9或字母或_之间的一个字符</span></span><br><span class="line"><span class="comment">// 而正则[xyz]中的xyz分别代表a-z、A_Z、0-9,xyz只是一个代表标识，</span></span><br><span class="line"><span class="comment">// 可以有xyzhw各种组合</span></span><br><span class="line"><span class="comment">// 就像这个例子中有下划线_一样四个的匹配</span></span><br><span class="line"><span class="comment">// 有一个重点补充，在[]中的特殊元字符一般都代表本身含义，如下</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[.?+&amp;]$/</span></span><br><span class="line"><span class="comment">// 代表着匹配. .? ?+ ...等等</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/a[bcd]c/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1.test(str1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="regexp">/a[^bcd]c/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re2.test(str2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">&quot;a.c&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re3 = <span class="regexp">/a[a-z0-9A-Z]c/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re3.test(str3));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>/a/：匹配字母 a</li>
<li>/[bcd]/：匹配字母 bcd 中的一位</li>
<li>/[d]：匹配字母 d</li>
<li>^ 如果写在 [] 里面的话，就代表排除的意思。在这里就代表着 a 和 c 中间不能是 bcd 中的任意一个</li>
<li>/[a-z0-9A-Z]/：匹配小写字母 a-z，或者数字 0-9，或者大写字母 A-Z。即 a 与 c 之间只能是上面匹配地上的字符。</li>
</ul>
<h4 id="5-边界符-b"><a href="#5-边界符-b" class="headerlink" title="5. 边界符\b"></a>5. 边界符<code>\b</code></h4><p>匹配一个单词边界，也就是指单词和空格间的位置（边界主要是单词的左右两边） 例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/er\b/</span></span><br><span class="line"><span class="comment">// 可以匹配never中的er，但是不能匹配verb中的er</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b\w+\b/g</span></span><br><span class="line"><span class="comment">// 能匹配字母数字和下划线与单词边界 &#x27;my blog is www.ngaiwe.com&#x27;</span></span><br><span class="line"><span class="comment">// 能匹配 &#x27;my&#x27;、&#x27;blog&#x27;、&#x27;is&#x27;、&#x27;www&#x27;、&#x27;ngaiwe&#x27;、&#x27;com&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-只匹配不捕获"><a href="#6-只匹配不捕获" class="headerlink" title="6. 只匹配不捕获 ?"></a>6. 只匹配不捕获 <code>?</code></h4><p>下面举一个例子，但是涉及到捕获内容，如果同学们不太明白，可以先跳过此处，看完下面捕获，再返回来看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(\d|X)$/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;110105199001220613&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str))</span><br><span class="line"><span class="comment">// 打印结果为 &quot;110105199001220613&quot;, &quot;110105&quot;, &quot;1990&quot;, &quot;01&quot;, &quot;22&quot;, &quot;1&quot;, &quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;6&#125;)(?:\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(\d|X)$/g</span></span><br><span class="line"><span class="comment">// 打印结果为 &quot;110105199001220613&quot;, &quot;110105&quot;, &quot;01&quot;, &quot;22&quot;, &quot;1&quot;, &quot;3&quot;</span></span><br><span class="line"><span class="comment">// 会将第二个小分组只匹配，不捕获</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-正向肯定预查"><a href="#7-正向肯定预查" class="headerlink" title="7. 正向肯定预查 ?="></a>7. 正向肯定预查 <code>?=</code></h4><p>这个概念比较难理解，用于就是为了匹配一个元素后面是的元素是否符合相应规则，但是并不消耗这个规则，例子1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/windows(?=95|98|NT|2000)/</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;windows2000&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;windowsxp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str1))</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str2))</span><br><span class="line"><span class="comment">// str1 为true str2 为false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str1))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str2))</span><br><span class="line"><span class="comment">// 能捕获到str1 并且捕获结果时windows 并没有将2000也同时捕获</span></span><br><span class="line"><span class="comment">// 说明正向预查只负责匹配相应规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------例子2-----------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/win(?=d)dows/</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/win(d)dows/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;windows&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(reg1.test(str))</span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(str))</span><br><span class="line"><span class="comment">// reg1 返回true reg2返回 false</span></span><br><span class="line"><span class="comment">// 原因是正向预查只负责匹配，不消耗字符，也就是并不会匹配为里面规则的字符</span></span><br><span class="line"><span class="comment">// reg1 相当于匹配windows并且符合win后面第一个出现的是d</span></span><br><span class="line"><span class="comment">// reg2 相当于匹配winddows</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-正想否定预查"><a href="#8-正想否定预查" class="headerlink" title="8. 正想否定预查 ?!"></a>8. 正想否定预查 <code>?!</code></h4><p>和正向肯定预查相反，匹配不符合规则的正则</p>
<h4 id="9-转义字符"><a href="#9-转义字符" class="headerlink" title="9. \ 转义字符"></a>9. <code>\</code> 转义字符</h4><blockquote>
<p>将特殊元字符转换为普通字符，例：<code>var reg = /^2.3$/</code> 正常理解为匹配启示为2 结束为3中间是.的正则，但是在这里面.属于特殊元字符，意义是除了\n（换行符）以外的任意字符，所以不论是2.3/2+3/2s.3等等，只要是不·\n都匹配成功，所以为了这种需求就用到了转义字符\ 如下： <code>var reg = /^2\.3$/</code> 将特殊元字符.转义为真正的.元素，再次匹配只有2.3才能匹配成功 如下思考：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/^\d$/</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/^\\d$/</span></span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/^\\\d$/</span></span><br><span class="line"><span class="keyword">var</span> reg4 = <span class="regexp">/^\\\\d$/</span></span><br></pre></td></tr></table></figure>

<p>首先reg1 表示0-9之间的数字 所以0-9都能匹配成功</p>
<p>reg2出现两个\ 不论是0-9 d \d都匹配失败，只有\d才匹配成功，<br>原因在于第一个转义字符把第二个\转义为普通\，<br>此时第一个\也表示普通字符，所以只有匹配到<code>\\d</code>才生效</p>
<p>reg3出现三个\，此时大家一定会认为<code>\\\d</code>才是正确答案，非也，<br>此时的正确答案是\[0-9]意思是\和0-9中任意一个数字，<br>原因在于第一个\将第二个转义，所以变为<code>\\ \d</code>分为了两部分，<br>\为普通字符，而\d表示一个0~9之间的数字，所以正确答案是<code>\\[0-9]</code></p>
<p>reg4出现四个\ 很多同学会认为正确答案一定是\[0-9], 很可惜，<br>正确的是<code>\\\\d</code>，原因是当第一个把第二个转义为普通字符时，<br>第三个又把第四个转义为普通字符，所以最后匹配为<code>\\\\d</code></p>
<p>看到这里相信有一部分小伙伴已经晕了，<br>虽然在工作我们不会玩这种操作，但是要深刻理解转义字符，<br>在正则中如果你直接写 <code>var reg = /\/</code> 会报错，<br>因为正则中不能单独一个\出现，因为它是一个特殊元字符，<br>需要写至少两个, 例如： <code>var reg = /^\\$/</code><br>正确的匹配结果为<code>\\</code>，所以牢记两个\代表真正的\，<br>到这里能搞明白的同学，相信转义字符已经完全掌握。</p>
<h2 id="3-量词"><a href="#3-量词" class="headerlink" title="3. 量词"></a>3. 量词</h2><p>量词主要的作用是用来描述元字符出现的次数 如下：</p>
<ul>
<li><code>+</code> 让前面的元字符出现一到多次</li>
<li><code>?</code> 出现零到一次</li>
<li><code>*</code> 出现零到多次</li>
<li><code>&#123;n&#125;</code> 出现n次</li>
<li><code>&#123;n,&#125;</code> 出现n到多次</li>
<li><code>&#123;n,m&#125;</code> 出现n到m次</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>JavaScript 正则默认： 正则匹配成功就会结束，不会继续匹配。如果想查找全部，就要加标识 <code>g</code>（全局匹配）</p>
<h3 id="1-test"><a href="#1-test" class="headerlink" title="1. test()"></a>1. test()</h3><p>规则：匹配字符串，匹配成功返回true，匹配失败返回false<br>语法：正则.test(字符串)<br>案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\D/</span>; <span class="comment">// 匹配非数字</span></span><br><span class="line"><span class="keyword">if</span>(re.test(str)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;不全是数字！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;全是数字！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当test匹配到结尾或者匹配不到时，返回false，<br>成功则向数组添加当前小分组匹配第一个元素内容。<br>在RegExp的constructor中存在$1-$9，他们的具体指的是当前本次匹配小分组第一到第九捕获的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;([a-z]+)\&#125;/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;my name is &#123;weiran&#125;. I am from &#123;china&#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> result = []</span><br><span class="line"><span class="keyword">while</span> (reg.test(str)) &#123;</span><br><span class="line"> result.push(<span class="built_in">RegExp</span>.$1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// [&#x27;weiran&#x27;, &#x27;china&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>手动实现一个函数匹配到全部内容并且都能捕获到</p>
<p>这个方法当正则reg加了修饰符g 则返回大正则匹配到结果，如果没加g则返回exec捕获结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(\d|X)$/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;110105199001220613&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.prototype.myExec = <span class="function"><span class="keyword">function</span> <span class="title">myExec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> str = <span class="built_in">arguments</span>[<span class="number">0</span>] || <span class="string">&#x27;&#x27;</span></span><br><span class="line"> <span class="keyword">var</span> result = []</span><br><span class="line"> <span class="comment">// 首先this指向的是RegExp，所以判断this是否加了全局修饰符g</span></span><br><span class="line"> <span class="comment">// 如果没有，防止执行死循环，我们只执行一次exec并将其返回即可</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(!<span class="built_in">this</span>.global) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.exec(str)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> arrs = <span class="built_in">this</span>.exec(str)</span><br><span class="line"> <span class="keyword">while</span>(arrs) &#123;</span><br><span class="line">  result.push(arrs[<span class="number">0</span>])</span><br><span class="line">  <span class="comment">// 此时lastIndex的值已经变为上一次的结尾</span></span><br><span class="line">  arrs = <span class="built_in">this</span>.exec(str)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-search"><a href="#2-search" class="headerlink" title="2. search()"></a>2. search()</h3><p>规则：匹配成功，返回成功的位置，失败返回-1<br>用法：字符串.search(正则)<br>案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/d/i</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="regexp">/h/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(re1)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(re2)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-match"><a href="#3-match" class="headerlink" title="3. match()"></a>3. match()</h3><p>规则：匹配成功，返回匹配成功的数组，匹配不成功，返回 null<br>用法：字符串.match(正则)<br>案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123fadf321dfadf4fadf1&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/\d+/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(re)); <span class="comment">//(4) [&quot;123&quot;, &quot;321&quot;, &quot;4&quot;, &quot;1&quot;]</span></span><br></pre></td></tr></table></figure>

<p>当加了修饰符<code>g</code>，返回的是大正则匹配结果组成的数组，<br>不加修饰符<code>g</code>则返回大正则和每个小分组返回结果组成的数组，<br>但是他也有局限性，就想上面说的在加了修饰符g的时候，会忽略小分组捕获内容，只捕获大正则捕获内容，解决办法就向上面myExec一样，将arrs[0]改为arrs，在每次匹配到结果时，将每个小分组也保存下来。</p>
<h3 id="4-replace"><a href="#4-replace" class="headerlink" title="4. replace()"></a>4. replace()</h3><p>规则：匹配陈宫的字符串替换成新的字符串。<br>用法：字符串.replace(正则, 新的字符串)<br>案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/a+/g</span>;</span><br><span class="line">str = str.replace(re, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p>敏感词替换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;非诚勿扰在中国船的监视之下寸步难行&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/非诚|中国船|监视之下/g</span>;</span><br><span class="line">s1.replace(re, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span>.repeat(str.length);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>替换大括号里的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;my name is &#123;lalala&#125;, I\&#x27;m from &#123;haia&#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;([a-z]+)\&#125;/</span></span><br><span class="line">str = str.replace(reg, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"><span class="comment">// 打印出 my name is 123, I&#x27;m from &#123;ngaiwe&#125;</span></span><br><span class="line"><span class="comment">// 同学们会发现和exec的懒惰性很相似，不加修饰符g 只匹配第一个lastIndex没有改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;([a-z]+)\&#125;/g</span></span><br><span class="line"><span class="comment">// 打印出 my name is 123, I&#x27;m from 123</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>replace不会修改原始字符串</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;my name is &#123;weiran&#125;, my blog is &#123;ngaiwe&#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\&#123;([a-z]+)\&#125;/g</span></span><br><span class="line">str = str.replace(reg, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印出当前匹配的小分组，如果函数中没有return出替换值，则返回undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="5-split"><a href="#5-split" class="headerlink" title="5. split()"></a>5. split()</h3><p>按照正则规则拆分数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;weiRanNgaiWe&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[A-Z]/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(reg))</span><br><span class="line"><span class="comment">// [&quot;wei&quot;, &quot;an&quot;, &quot;gai&quot;, &quot;e&quot;]按照大写拆分成数组</span></span><br></pre></td></tr></table></figure>

<h2 id="正则原型方法"><a href="#正则原型方法" class="headerlink" title="正则原型方法"></a>正则原型方法</h2><p><code>RegExp.prototype</code>正则原型对象上一共就三个方法,<code>exec</code> <code>test</code>和<code>toString</code></p>
<h3 id="exec用于捕获组而设计，实参是要匹配的字符串"><a href="#exec用于捕获组而设计，实参是要匹配的字符串" class="headerlink" title="exec用于捕获组而设计，实参是要匹配的字符串"></a><code>exec</code>用于捕获组而设计，实参是要匹配的字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;234ewqe2r3562&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/</span>;</span><br><span class="line">reg.exec(str);</span><br><span class="line"><span class="comment">// [&quot;234&quot;, index: 0, input: &quot;234ewqe2r3562&quot;, groups: undefined]</span></span><br><span class="line"><span class="comment">// 0: &quot;234&quot;</span></span><br><span class="line"><span class="comment">// groups: undefined</span></span><br><span class="line"><span class="comment">// index: 0</span></span><br><span class="line"><span class="comment">// input: &quot;234ewqe2r3562&quot;</span></span><br><span class="line"><span class="comment">// length: 1</span></span><br><span class="line"><span class="comment">// __proto__: Array(0)</span></span><br><span class="line">str = <span class="string">&#x27;文字&#x27;</span>;</span><br><span class="line">reg.exec(str);</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>捕获原理</p>
<ol>
<li>在捕获的时候先验证当前字符串和正则是否匹配，不匹配返回null（没有捕获到任何内容）</li>
<li>如果匹配从字符串最左边开始，向右查找到匹配内容，并把匹配的内容返回</li>
</ol>
<p>捕获结果</p>
<ol>
<li>结果是一个数组</li>
<li>第一项0 是当前本次大正则中匹配的结果</li>
<li>index是匹配到的结果在字符串中的索引位置</li>
<li>input当前正则操作的原始字符串</li>
<li>如果大正则中有分组()，获取的数组中从第二项开始都是每个小分组的捕获结果<br>下面举一个身份证正则的例子 便于参考，具体里面匹配规则下面会单独介绍，这里只学习字段意义</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(\d|X)$/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;110010199301032345&#x27;</span></span><br><span class="line">reg.exec(str)</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// [&quot;110010199301032345&quot;, &quot;110010&quot;, &quot;1993&quot;, &quot;01&quot;, &quot;03&quot;, &quot;4&quot;, &quot;5&quot;, index: 0, input: &quot;110010199301032345&quot;, groups: undefined]</span></span><br><span class="line"><span class="comment">// 0: &quot;110010199301032345&quot;</span></span><br><span class="line"><span class="comment">// 1: &quot;110010&quot;</span></span><br><span class="line"><span class="comment">// 2: &quot;1993&quot;</span></span><br><span class="line"><span class="comment">// 3: &quot;01&quot;</span></span><br><span class="line"><span class="comment">// 4: &quot;03&quot;</span></span><br><span class="line"><span class="comment">// 5: &quot;4&quot;</span></span><br><span class="line"><span class="comment">// 6: &quot;5&quot;</span></span><br><span class="line"><span class="comment">// groups: undefined</span></span><br><span class="line"><span class="comment">// index: 0</span></span><br><span class="line"><span class="comment">// input: &quot;110010199301032345&quot;</span></span><br><span class="line"><span class="comment">// length: 7</span></span><br></pre></td></tr></table></figure>

<h3 id="懒惰性"><a href="#懒惰性" class="headerlink" title="懒惰性"></a>懒惰性</h3><p>正则捕获存在懒惰性，在上面执行exec只捕获到第一个符合规则的内容，第二次执行也是捕获到第一个内容，<br>后面的内容无论执行多少次都无法捕获到。</p>
<blockquote>
<p>解决办法：在正则末尾加修饰符<code>g</code>(全局匹配)</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>正则本身有<code>lastIndex</code>属性, 下一次正则在字符串中匹配查找的开始索引<br>默认值是0， 从字符串第一个位置开始查找，由此可见当执行完exec后lastIndex并没有变，<br>并且就算手动修改lastIndex也不会起作用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;1w2q3e&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line">reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line">reg.exec(str)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>在正则表达式末尾加<code>g</code>后，每次执行exec后，浏览器默认会修改lastIndex。<br>下次从上一次结束的位置开始查找</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">reg = <span class="regexp">/\d+/g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">// 0</span></span><br><span class="line">reg.exec(str)</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">// 1</span></span><br><span class="line">reg.exec(str)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>reg.global</code> 可以判断正则是否是全局匹配</p>
</blockquote>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>将正则表达式转化为字符串</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>如上</p>
<h2 id="正则解析"><a href="#正则解析" class="headerlink" title="正则解析"></a>正则解析</h2><p>看一个简单的正则：<code>^[a-z0-9_-]&#123;6,12&#125;$</code></p>
<ul>
<li>^表示匹配字符串的开始位置</li>
<li>[a-z0-9_-]表示字符串的开头可以为<code>a-z</code>的字母, <code>0-9</code>的数字, <code>_</code>下划线, <code>-</code>连接符<ul>
<li>[a-z] 表示匹配 a-z 中任意单个字母；</li>
<li>[0-9] 表示匹配 0-9 中任意单个数字；</li>
<li>[_] 表示匹配下划线；</li>
<li>[-] 表示匹配连接符 -。<br>所以，将前面的连起来，[a-z0-9_-] 表示字符串可以包含数字、字母、_、- 这四种形式的字符串。</li>
</ul>
</li>
<li>{6, 12} 表示该字符串的长度为 6-12 位。</li>
<li><code>$</code>表示结束标志，<code>^</code> 表示开始</li>
</ul>
<blockquote>
<p><code>^</code> 与 <code>$</code> 同时使用，表示精确匹配。</p>
</blockquote>
<p>综上：这个正则表达式的用途校验字符串只能包含小写字母，数字，下划线，连接字符，并且最长12位，最短6位。</p>
<h3 id="小栗子🌰🌰🌰"><a href="#小栗子🌰🌰🌰" class="headerlink" title="小栗子🌰🌰🌰"></a>小栗子🌰🌰🌰</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Cheer for yourself&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/^Cheer/</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/yourself$/</span>;</span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/for/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg1.test(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg2.test(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg3.test(str));</span><br></pre></td></tr></table></figure>

<p> 第一个判断该字符串是否以 Cheer 开头；<br> 第二个判断该字符串是否以 yourself 结尾；<br> 第三个判断该字符串是否包含 for。</p>
<ol>
<li><p>身份证号<br> 前6位是数字地区区号组成，然后四位是年，两位月，两位日和四位随机，倒数第二位单数男性，双数女性，<br> 最后一位可能是大写X,所以根据这个规则的正则是</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;110105199109214237&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(\d|X)$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str))</span><br><span class="line"><span class="comment">// [&quot;110105199109214237&quot;, &quot;110105&quot;, &quot;1991&quot;, &quot;09&quot;, &quot;21&quot;, &quot;3&quot;, &quot;7&quot;, index: 0, input: &quot;110105199109214237&quot;, groups: undefined]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>邮箱<br> 规则：</p>
<ol>
<li><p>@前面可能是数字、字母、下划线、-、.</p>
</li>
<li><p>-和.不能相连在一起<br> /^\w+((-|\w+)|(.\w+))*/ 开头一定是数字，字母或下划线组成，后面的内容可能是-与数字字母下划线 或者.和数字字母下划线组成的0到多个字符</p>
</li>
<li><p>@后面部分<br>首先一定是数字字母组成的多位字符<br>然后可能存在是.组成的邮箱后缀或者链接前方字符的.和-<br>最后肯定是.组成的邮箱后缀</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\w+((-|\w+)|(\.\w+))*@[a-zA-Z0-9]+((\.|-)[a-zA-Z0-9]+)*\.[a-zA-Z0-9]+$/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aaa@hotmail.com.cn&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>URL截取<br> 获取url后的搜索参数<br> 参数转化键值对和哈希值{key: ‘value’}</p>
</li>
</ol>
<p>需要分为两部分捕获，首先第一次捕获?后面的参数，第二次捕获#后面的hash值<br>首先匹配第一个，他的规则是匹配等号两边所以是/()=()/，并且匹配的是非?&amp;=#的特殊字符，将他们保存在obj对象中<br>其次匹配hash，方法和第一个类似只是匹配#后面的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.myQueryURLParameter = <span class="function"><span class="keyword">function</span> <span class="title">myQueryURLParameter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"> <span class="built_in">this</span>.replace(<span class="regexp">/([^?&amp;=#]+)=([^?&amp;=#]+)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  obj[<span class="built_in">arguments</span>[<span class="number">1</span>]] = <span class="built_in">arguments</span>[<span class="number">2</span>]</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">this</span>.replace(<span class="regexp">/#([^?&amp;=#]+)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  obj[<span class="string">&#x27;HASH&#x27;</span>] = <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编写验证规则最流行和最简单的方法就是正则表达式了，但唯一的一个问题是正则表达式的语法太隐晦了，让人蛋疼无比。很多开发者为了在项目中应用复杂的验证，经常要使用一些小抄来记住正则式的复杂语法和各种常用命令。</p>
<p>在这篇文章中，我将试图让大家明白什么是正则表达式，以及如何更轻松地学习正则表达式。</p>
<p>也许你是初学者，那以防万一，我先来讲讲什么是正则表达式吧：</p>
<p>正则表达式可以帮助我们更好的描述复杂的文本格式。一旦你描述清楚了这些格式，那你就可以利用它们对文本数据进行检索、替换、提取和修改操作。</p>
<p>下面有一个正则表达式的简单例子。第一步先要引入有关正则式的命名空间：<br>using System.Text.RegularExpressions;<br>第二步就是用指定的正则式构建一个正则表达式对象,下面的正则式是用来搜索长度为10的a-z的英文字母：<br>Regex obj = new Regex(“[a-z]{10}”);<br>最后，根据正则式在指定数据中检索匹配项,如果匹配IsMatch方法就会返回true。<br>MessageBox.Show(obj.IsMatch(“shivkoirala”).ToString());<br>3个重要的正则式命令</p>
<p>记住正则语法最好的办法就是记住这三样东西：Bracket（括号）, caret（插入符号）和Dollars（美元符号）。</p>
<p>B</p>
<p>在正则表达式中有3种类型的括号</p>
<p>方括号 “[“和花括号“{“ 。</p>
<p>方括号”[“内是需要匹配的字符，花括号”{“内是指定匹配字符的数量。</p>
<p>圆括号“(“ 则是用来分组的。</p>
<p>C<br>插入符号 “^” 表示正则式的开始。</p>
<p>D<br>美元符号“$” 表示正则式的结束。<br>现在你知道上面的3个语法后，你就可以写世界上任何一条验证规则了。比如下面的例子就很好的说明了上面3条正则语法是如何协调运作的。</p>
<p>注：上图有个错误，”()”应为”{}”</p>
<p>上面的这条正则式只能匹配a-z的英文字母，同样是在中括号中标明匹配范围。</p>
<p>花括号中则是标明匹配字符串的最小长度和最大长度。</p>
<p>最后为了让表达式更规则，分别在开头和结尾加上了插入符号”^”和美元符号”$”。</p>
<p>好了，现在我们就用上面的3条语法来实现一些正则表达式的验证规则吧。</p>
<p>检查用户是否输入了shivkoirala？<br>shivkoirala<br>让我们开始第一个验证，输入的字符在a-g之间？<br>[a-g]<br>输入的字符在a-g之间并且长度为3？<br>[a-g]{3}<br>输入的字符在a-g之间并且最大长度为3最小长度为1？<br>[a-g]{1,3}<br>我如何在匹配像91230456, 01237648那样的固定8位数？<br>^[0-9]{8}$<br>如何验证最小长度为3最大长度为7的数字，如：123, 1274667, 87654？<br>^[0-9]{3,7}$<br>如何验证像LJI1020那样的发票编号，前3个是字母剩余为8位长度的数字？</p>
<p>前三个是字母：<br>^[a-z]{3}<br>后面是8位长度的数字：<br>[0-9]{8}<br>所以整个表达式为：<br>^[a-z]{3}[0-9]{7}$<br>验证像INV190203 或 inv820830那样的前3位是不区分大小写的英文字母，剩余8位是数字。</p>
<p>在前面的表达式中只能匹配前3个是小写英文字母的发票编号，如果我们输入大写字母那就不能匹配了。所以为了确保前3个字母是不区分大小写的，我们就要用表达式^[a-zA-Z]{3}。<br>^[a-zA-Z]{3}[0-9]{7}$<br>我们可以验证简单的网址URL格式吗？</p>
<p>第一步：检查是否存在www：<br>^www.<br>第二步：域名必须是长度在1-15的英文字母：<br>. [a-z]{1,15}<br>第三步：以.com或者.org结束：<br>. (com|org)$<br>完整的表达式如下：<br>^www[.][a-z]{1,15}<a href="com%7Corg">.</a>$<br>让我们在来看看BCD（其实也就是上面说的3条基本语法）如何验证email格式。</p>
<p>第一步：email开始是长度在1-10的英文字母，最后跟一个”@”：<br>^[a-zA-Z0-9]{1,10}@<br>第二步：@后面是长度在1-10的英文字母，后面跟一个”.”：<br>[a-zA-Z]{1,10}.<br>第三步：最后以.com或.org结束：<br>.(com|org)$<br>最后完整的表达式如下：<br>^[a-zA-Z0-9]{1,10}@[a-zA-Z]{1,10}.(com|org)$<br>验证值在0-25的数字：<br>^(([0-9])|([0-1][0-9])|([0-2][0-5]))$<br>验证格式为MM/DD/YYYY, YYYY/MM/DD and DD/MM/YYYY的日期：<br>步骤</p>
<p>正则式</p>
<p>描述说明</p>
<p>先来检查 DD. 首先DD的长度为1-29 ( 2月份) , 1-30 (月小) , 1-31 (月大) .</p>
<p>所以 DD 就是 1-9 或 01-09</p>
<p>[1-9]|0[1-9]</p>
<p>允许用户输入1-9或者01-09.</p>
<p>再为DD添加匹配10-19</p>
<p>[1-9]|1[0-9]</p>
<p>允许用户输入01-19.</p>
<p>再为DD添加匹配20-29</p>
<p>[1-9]|1[0-9]|2[0-9]</p>
<p>允许用户输入01-29.</p>
<p>i再为DD添加匹配30-31</p>
<p>[1-9]|1[0-9]|2[0-9]|3[0-1]</p>
<p>最后用户可以输入01-31.</p>
<p>再来匹配日期间的分隔符”/“，”-“</p>
<p>[/ . -]</p>
<p>允许用户输入日期分隔符.</p>
<p>MM也是类似的操作</p>
<p>[1-9]|0[1-9]|1[0-2]</p>
<p>让用户输入月份值01-12.</p>
<p>最后就是YY的操作</p>
<p>1[9][0-9][0-9]|2[0][0-9][0-9]</p>
<p>允许用户输入年份1900-2099.<br>最后DD/MM/YYYY格式的日期的正则表达式为：<br>^([1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])<a href="%5B1-9%5D%7C0%5B1-9%5D%7C1%5B0-2%5D">- / .</a><a href="1%5B9%5D%5B0-9%5D%5B0-9%5D%7C2%5B0%5D%5B0-9%5D%5B0-9%5D">- / .</a>$<br>MM/DD/YYYY格式的日期：<br>^([1-9]|0[1-9]|1[0-2])<a href="%5B1-9%5D%7C0%5B1-9%5D%7C1%5B0-9%5D%7C2%5B0-9%5D%7C3%5B0-1%5D">- / .</a><a href="1%5B9%5D%5B0-9%5D%5B0-9%5D%7C2%5B0%5D%5B0-9%5D%5B0-9%5D">- / .</a>$<br>YYYY/MM/DD格式的日期：<br>^(1[9][0-9][0-9]|2[0][0-9][0-9])<a href="%5B1-9%5D%7C0%5B1-9%5D%7C1%5B0-2%5D">- / .</a><a href="%5B1-9%5D%7C0%5B1-9%5D%7C1%5B0-9%5D%7C2%5B0-9%5D%7C3%5B0-1%5D">- / .</a>$<br>快捷命令</p>
<p>你也可以用以下的快捷命令来简化你的正则表达式：<br>实际命令<br>快捷命令</p>
<p>[0-9]<br>d</p>
<p>[a-z][0-9][_]<br>w</p>
<p>0次或多次发生<br>*</p>
<p>至少一次发生<br>+</p>
<p>0次或1次发生<br>?</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>正则</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP积累</title>
    <url>/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="http-方法，每个方法分别什么情况下用"><a href="#http-方法，每个方法分别什么情况下用" class="headerlink" title="http 方法，每个方法分别什么情况下用"></a>http 方法，每个方法分别什么情况下用</h2><p>put和get有什么相同点<br><a href="https://www.jianshu.com/p/ce44e5f4623a">链接</a></p>
<p>trace是用来干嘛的，</p>
<p>options是用来干嘛的</p>
<p>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>OPTIONS 允许客户端查看服务器的性能。</p>
<p>TRACE 回显服务器收到的请求，主要用于测试或诊断。</p>
<p>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</p>
<a id="more"></a>

<h2 id="HTTP2-与-HTTP1-1-区别"><a href="#HTTP2-与-HTTP1-1-区别" class="headerlink" title="HTTP2 与 HTTP1.1 区别"></a>HTTP2 与 HTTP1.1 区别</h2><ul>
<li>http2 使用二进制传送，http1.x 使用文本(字符串)传送<blockquote>
<p>二进制传送单位是帧和流，帧组成了流，同时流还有流 ID 标识</p>
</blockquote>
</li>
<li>http2 支持多路复用<blockquote>
<p>有流 ID，通过同一个 HTTP 请求实现多个 http 请求传输变成了可能，可以通过流 ID 来标示究竟是哪个流从而定位到是哪个 http 请求</p>
</blockquote>
</li>
<li>http2 头部压缩<blockquote>
<p>http2 通过 gzip 和 compress 压缩头部再发送，同时客户端和服务端同时维护一张头信息表，所有字段都记录在这张表中，以后每次传输只需要传输表里面的索引 id，通过索引 id 可以知道表头的值</p>
</blockquote>
</li>
<li>http2 支持服务器推送<blockquote>
<p>支持在客户端未经请求许可的情况下，主动向客户端推送内容</p>
</blockquote>
</li>
</ul>
<h2 id="http-方法，每个方法分别什么情况下用-1"><a href="#http-方法，每个方法分别什么情况下用-1" class="headerlink" title="http 方法，每个方法分别什么情况下用"></a>http 方法，每个方法分别什么情况下用</h2><p>put 和 get 有什么相同点<br><a href="https://www.jianshu.com/p/ce44e5f4623a">链接</a></p>
<p>trace 是用来干嘛的，</p>
<p>options 是用来干嘛的</p>
<p>CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>OPTIONS 允许客户端查看服务器的性能。</p>
<p>TRACE 回显服务器收到的请求，主要用于测试或诊断。</p>
<p>HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</p>
<ul>
<li>GET：获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:获取报文首部</li>
<li>DELETE：删除文件</li>
<li>OPTIONS：查询支持方法</li>
<li>TRACK：追踪路径</li>
<li>CONNECT：要求用隧道协议连接代理</li>
</ul>
<h2 id="ajax-状态值"><a href="#ajax-状态值" class="headerlink" title="ajax 状态值"></a>ajax 状态值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 代表未初始化。 还没有调用 open 方法</span><br><span class="line">1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用</span><br><span class="line">2 代表已加载完毕。send 已被调用。请求已经开始</span><br><span class="line">3 代表交互中。服务器正在发送响应</span><br><span class="line">4 代表完成。响应发送完毕</span><br></pre></td></tr></table></figure>

<h2 id="7-层模型"><a href="#7-层模型" class="headerlink" title="7 层模型"></a>7 层模型</h2><h4 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7 应用层"></a>7 应用层</h4><h4 id="6-表示层-定义数据格式及加密"><a href="#6-表示层-定义数据格式及加密" class="headerlink" title="6 表示层 定义数据格式及加密"></a>6 表示层 定义数据格式及加密</h4><p>示例：加密，ASII</p>
<h4 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5 会话层"></a>5 会话层</h4><p>定义了如何开始、控制和结束一个会话，<br>包括对多个双向小时的控制和管理，<br>以便在只完成连续消息的一部分时可以通知应用，<br>从而使表示层看到的数据是连续的，</p>
<p>示例：RPC，SQL 等。</p>
<h4 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4 传输层"></a>4 传输层</h4><p>功能包括是否选择差错恢复协议还是无差错恢复协议，<br>及在同一主机上对不同应用的数据流的输入进行复用，<br>还包括对收到的顺序不对的数据包的重新排序功能。</p>
<p>示例：TCP，UDP，SPX。</p>
<h4 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3 网络层"></a>3 网络层</h4><pre><code>为建立网络连接和为上层提供服务,

示例：IP,IPX</code></pre>
<h4 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2 数据链路层"></a>2 数据链路层</h4><pre><code>为网络层提供数据传送服务的。示例：ATM，FDDI等。</code></pre>
<h4 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1 物理层"></a>1 物理层</h4><pre><code>连接头、针、针的使用、电流、电流、编码及光调制等都属于各种物理层规范中的内容。</code></pre>
<h4 id="OSI-分层的优点"><a href="#OSI-分层的优点" class="headerlink" title="OSI 分层的优点"></a>OSI 分层的优点</h4><p>（1）人们可以很容易的讨论和学习协议的规范细节。</p>
<p>（2）层间的标准接口方便了工程模块化。</p>
<p>（3）创建了一个更好的互连环境。</p>
<p>（4）降低了复杂度，使程序更容易修改，产品开发的速度更快。</p>
<p>（5）每层利用紧邻的下层服务，更容易记住个层的功能。</p>
<h2 id="get-和-post-区别"><a href="#get-和-post-区别" class="headerlink" title="get 和 post 区别"></a>get 和 post 区别</h2><h3 id="最直观的区别"><a href="#最直观的区别" class="headerlink" title="最直观的区别"></a>最直观的区别</h3><p>1).GET 把参数包含在 URL 中，POST 通过 request body 传递参数;</p>
<p>2).GET 在浏览器回退时是无害的，而 POST 会再次提交请求;</p>
<p>3).GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以;</p>
<p>4).GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置;</p>
<p>5). GET 请求只能进行 url 编码，而 POST 支持多种编码方式;</p>
<p>6).GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留;</p>
<p>7).GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制;</p>
<p>8). 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制;</p>
<p>9).GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息;</p>
<h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h3><p>首先 GET 和 POST 请求都是 HTTP 协议中的两种发送请求的方法,而 HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议,HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。</p>
<p>1).虽然理论上 GET 和 POST 请求在使用上可以没有区别,但是不同的浏览器(发起 http 请求)和服务器(接受 http 请求)会限制单次传送数据了来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制 url 长度在 2K 个字节，而(大多数)服务器最多处理 64K 大小的 url。超过的部分，恕不处理。如果你用 GET 服务，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然 GET 可以带 request body，也不能保证一定能被接收到.</p>
<p>2).GET 产生一个 TCP 数据包;POST 产生两个 TCP 数据包;对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200(返回数据);而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok(返回数据)。因为 ==POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。== 因此 Yahoo 团队有推荐用 GET 替换 POST 来优化网站性能。</p>
<h2 id="HTTPS-和-HTTP-的区别"><a href="#HTTPS-和-HTTP-的区别" class="headerlink" title="HTTPS 和 HTTP 的区别"></a>HTTPS 和 HTTP 的区别</h2><ol>
<li>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</li>
</ol>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>Last-Modify/If-Modify-Since</p>
<p>ETag/If-None-Match</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>Expires 或者 Cache-Control</p>
<p>因为 http1.1&gt;http1.0，</p>
<p>所以 Cache-Control&gt;Expires，ETag&gt;Last-Modified。</p>
<p>依照就近原则，先找本地缓存，没有再向服务器发请求，</p>
<p>所以 Expires&gt;Last-Modified,Cache-Control&gt;ETag，</p>
<table>
<thead>
<tr>
<th>缓存类型</th>
<th>获取资源形式</th>
<th>状态码</th>
<th>发送请求到服务器</th>
</tr>
</thead>
<tbody><tr>
<td>强缓存</td>
<td>从缓存取</td>
<td>200（from cache）</td>
<td>否，直接从缓存取</td>
</tr>
<tr>
<td>协商缓存</td>
<td>从缓存取</td>
<td>304（Not Modified）</td>
<td>否，通过服务器来告知缓存是否可用</td>
</tr>
</tbody></table>
<p>200 from memory cache 不访问服务器，直接读缓存，==从内存中读取缓存==。此时的数据时缓存到内存中的，当 kill 进程后，也就是浏览器关闭以后，数据将不存在。但是这种方式只能缓存派生资源</p>
<p>200 from disk cache 不访问服务器，直接读缓存，==从磁盘中读取缓存==，当 kill 进程时，数据还是存在。这种方式也只能缓存派生资源</p>
<p>304 Not Modified 访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。</p>
<h5 id="三级缓存原理"><a href="#三级缓存原理" class="headerlink" title="三级缓存原理"></a>三级缓存原理</h5><p>先去内存看，如果有，直接加载</p>
<p>如果内存没有，择取硬盘获取，如果有直接加载</p>
<p>如果硬盘也没有，那么就进行网络请求</p>
<p>加载到的资源缓存到硬盘和内存</p>
<p>application cache 和上面缓存有点区别，是离线缓存，就是资源可以从硬盘上读取而不用联网，即使断网，用户也可以浏览。</p>
<h6 id="解决缓存文件没有及时更新思路"><a href="#解决缓存文件没有及时更新思路" class="headerlink" title="解决缓存文件没有及时更新思路"></a>解决缓存文件没有及时更新思路</h6><p>用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。</p>
<p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p>
<p>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</p>
<ul>
<li><p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>
</li>
<li><p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>
</li>
<li><p>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。</p>
</li>
<li><p>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。</p>
</li>
<li><p>must-revalidate: 一旦缓存过期，必须向源服务器进行校验，不得使用过期内容。如果无法连接必须返回 504。<br>没有值</p>
</li>
<li><p>proxy-revalidate<br>与 must-revalidate 相同，但仅对公共缓存生效。<br>没有值</p>
</li>
<li><p>max-stale<br>如果有值，客户端可以接受过期时间不超过指定值的缓存<br>如果没有值，客户端愿意接受过期缓存而无论过期过久。</p>
</li>
<li><p>min-fresh<br>客户端愿意接受一个新鲜度不小于当前 age 加上指定时间的响应。简单说在指定的后续一段时间内不会过期的响应。<br>总是有值</p>
</li>
</ul>
<ol>
<li>public 指示响应数据可以被任何客户端缓存</li>
<li>private 指示响应数据可以被非共享缓存所缓存。这表明响应的数据可以被发送请求的浏览器缓存，而不能被中介所缓存</li>
<li>no-cache 指示响应数据不能被任何接受响应的客户端所缓存</li>
<li>no-store 指示所传送的响应数据除了不能被缓存，也不能存入磁盘。一般用于敏感数据，以免数据被复制。</li>
<li>must-revalidate 指示所有的缓存都必须重新验证，在这个过程中，浏览器会发送一个 If-Modified-Since 头。如果服务器程序验证得出当前的响应数据为最新的数 据，那么服务器应当返回一个 304 Not Modified 响应给客户端，否则响应数据将再次被发送到客户端。</li>
<li>proxy-revalidate 与 must-revalidate 相似，不同的是用来指示共享缓存。</li>
<li>max-age 数据经过 max-age 设置的秒数后就会失效，相当于 HTTP/1.0 中的 Expires 头。如果在一次响应中同时设置了 max-age 和 Expires，那么 max-age 将具有较高的优先级。</li>
<li>s-maxage 与 max-age 相似，不同的是用来指示共享缓存。</li>
</ol>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>主机 A 向主机 B 发出连接请求数据包：</p>
<p><strong>“我想给你发数据，可以吗？”</strong>，这是第一次对话；</p>
<p>主机 B 向主机 A 发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：<br><strong>“可以，你什么时候发？”</strong>，这是第二次对话；<br>主机 A 再发出一个数据包确认主机 B 的要求同步：</p>
<p><strong>“我现在就发，你接着吧！”</strong>，这是第三次对话。<br>三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机 A 才向主机 B 正式发送数据。</p>
<p>首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。</p>
<h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><p>Client 端发起中断连接请求，也就是发送 FIN 报文。</p>
<p>意思是说”我 Client 端没有数据要发给你了”，<br>但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。</p>
<p>所以服务端先发送 ACK，告诉 Client 端: “你的请求我收到了，但是我还没准备好，请继续你等我的消息”。</p>
<p>这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。</p>
<p>当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，<br>告诉 Client 端: “好了，我这边数据发完了，准备好关闭连接了”。</p>
<p>Client 端收到 FIN 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。</p>
<p>Server 端收到 ACK 后，”就知道可以断开连接了”。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！</p>
<h2 id="长连接，短链接，长轮询，websocket"><a href="#长连接，短链接，长轮询，websocket" class="headerlink" title="长连接，短链接，长轮询，websocket"></a>长连接，短链接，长轮询，websocket</h2><ul>
<li><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>在 HTTP 1.1，客户端发出请求，服务端接收请求，双方建立连接，在服务端没有返回之前保持连接，当客户端再发送请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。</p>
<p>优势：省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。</p>
<p>劣势：可能会影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间<br>随着客户端连接越来越多，server 会保持过多连接</p>
</li>
</ul>
<p>server 端采取策略：</p>
<ol>
<li>关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致 server 端服务受损</li>
<li>如果条件允许则可以限制每个客户端的最大长连接数，避免恶意的客户端拖垮整体后端服务</li>
</ol>
<ul>
<li><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><p>在 HTTP1.0 中，客户端发送请求，服务器接收请求，双方建立连接，服务器响应资源，请求结束。<br>劣势： 请求频繁，在 TCP 的建立和关闭操作上浪费较多时间和带宽。</p>
</li>
<li><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>客户端像传统轮询一样从服务器请求数据。然而，如果服务器没有可以立即返回给客户端的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（或者恰当的超时），之后将数据作为结果返回给客户端。</p>
</li>
<li><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助 HTTP 请求完成。</p>
<p>客户端发送一次 http websocket 请求，<br>服务器响应请求，双方建立持久连接，并进行双向数据传输，后面不进行 HTTP 连接，而是使用 TCP 连接。</p>
<p>是独立的、创建在 TCP 上的协议。<br>通过 HTTP/1.1 协议的 101 状态码进行握手。<br>使用 ws 或 wss 的统一资源标志符，类似于 HTTPS，其中 wss 表示在 TLS 之上的 Websocket。<br>ws://example.com/wsapi<br>wss://secure.example.com/</p>
<p>使用和 HTTP 相同的 TCP 端口，<br>可以绕过大多数防火墙的限制。<br>默认情况下，Websocket 协议使用 80 端口；运行在 TLS 之上时，默认使用 443 端口。<br>数据格式比较轻量，性能开销较小，通信高效<br>可以发送文本和二进制数据。<br>没有同源限制，可以任意服务器通信</p>
<p>websocket 协议解析<br>wensocket 协议包含两部分:一部分是“握手”，一部分是“数据传输”。</p>
</li>
</ul>
<p>优势：较少的控制开销。更强的实时性。保持连接状态。更好的二进制支持。可以支持扩展。更好的压缩效果。</p>
<pre><code>数据传输试用的是一系列数据帧，
基本的数据帧为一个opcode、一个payload长度和发送的应用数据，
根据ABNF的定义，</code></pre>
<p>Websocket 协议解决了服务器与客户端全双工通信的问题。</p>
<p>注:什么是单工、半双工、全工通信？<br>信息只能单向传送为单工；<br>信息能双向传送但不能同时双向传送称为半双工；<br>信息能够同时双向传送则称为全双工。 -</p>
<p>HTTP/1.0 中默认使用短连接。 从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。</p>
<p>使用长连接的 HTTP 协议，会在响应头加入这行代码：</p>
<p>==Connection:keep-alive==</p>
<p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端请求</span><br><span class="line"></span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP&#x2F;n9NdMgdcy2VJFQ&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line"></span><br><span class="line">服务器回应</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s&#x3D;</span><br><span class="line">Sec-WebSocket-Location: ws:&#x2F;&#x2F;example.com&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="WebSocket-与-HTTP-的关系"><a href="#WebSocket-与-HTTP-的关系" class="headerlink" title="WebSocket 与 HTTP 的关系"></a>WebSocket 与 HTTP 的关系</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol>
<li>都是一样基于 TCP 的，都是可靠性传输协议。</li>
<li>都是应用层协议。</li>
</ol>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol>
<li>WebSocket 是双向通信协议，模拟 Socket 协议，可以双向发送或接受信息。HTTP 是单向的。</li>
<li>WebSocket 是需要握手进行建立连接的。</li>
</ol>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>WebSocket 在建立握手时，数据是通过 HTTP 传输的。但是建立之后，在真正传输时候是不需要 HTTP 协议的。</p>
<h2 id="WebSocket-与-Socket-的关系"><a href="#WebSocket-与-Socket-的关系" class="headerlink" title="WebSocket 与 Socket 的关系"></a>WebSocket 与 Socket 的关系</h2><p>Socket 其实并不是一个协议，而是为了方便使用 TCP 或 UDP 而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。</p>
<p>Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</p>
<p>当两台主机通信时，必须通过 Socket 连接，Socket 则利用 TCP/IP 协议建立 TCP 连接。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。</p>
<p>WebSocket 则是一个典型的应用层协议。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Socket 是传输控制层协议，WebSocket 是应用层协议。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>一、资源内容不变 + 设置长时间 max-age<br>// 设置缓存时间为 1 年<br>Cache-Control: max-age=31536000</p>
<p>二、对于经常修改的内容，始终需要进行服务器认证<br>Cache-Control: no-cache</p>
<p>Cache-Control 比 Expires 可以控制的多一些，<br>而且 Cache-Control 会重写 Expires 的规则，<br>Cache-Control 是关于浏览器缓存的最重要的设置，<br>因为它覆盖其他设置，比如 Expires 和 Last-Modified</p>
<p>Mainfest 可以缓存一个应用，pwa 中有 Mainfest 和 Service Worker 可以实现缓存</p>
<h2 id="HTTP-request-报文结构是怎样的"><a href="#HTTP-request-报文结构是怎样的" class="headerlink" title="HTTP request 报文结构是怎样的"></a>HTTP request 报文结构是怎样的</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rfc2616中进行了定义：</span><br><span class="line"></span><br><span class="line">首行是Request-Line包括：</span><br><span class="line">    请求方法，请求URI，协议版本，CRLF</span><br><span class="line"></span><br><span class="line">首行之后是若干行请求头，包括</span><br><span class="line">    general-header，</span><br><span class="line">    request-header或者</span><br><span class="line">    entity-header，</span><br><span class="line">    每个一行以CRLF结束</span><br><span class="line">请求头和消息实体之间有</span><br><span class="line">一个CRLF分隔</span><br><span class="line">根据实际请求需要可能包含一个消息实体</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User-Agent：产生请求的浏览器类型。</span><br><span class="line">Accept：客户端可识别的内容类型列表。</span><br><span class="line">Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</span><br><span class="line"></span><br><span class="line">POST方法适用于需要客户填写表单的场合。</span><br><span class="line">与请求数据相关的</span><br><span class="line">最常使用的请求头是Content-Type和</span><br><span class="line">Content-Length。</span><br><span class="line"></span><br><span class="line">一个请求报文例子如下：</span><br><span class="line">GET &#x2F;Protocols&#x2F;rfc2616&#x2F;rfc2616-sec5.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.w3.org</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;35.0.1916.153 Safari&#x2F;537.36</span><br><span class="line">Referer: https:&#x2F;&#x2F;www.google.com.hk&#x2F;</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,en;q&#x3D;0.6</span><br><span class="line">Cookie: authorstyle&#x3D;yes</span><br><span class="line">If-None-Match: &quot;2cc8-3e3073913b100&quot;</span><br><span class="line">If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class="line"></span><br><span class="line">name&#x3D;qiu&amp;age&#x3D;25</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-response-报文结构是怎样的"><a href="#HTTP-response-报文结构是怎样的" class="headerlink" title="HTTP response 报文结构是怎样的"></a>HTTP response 报文结构是怎样的</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rfc2616中进行了定义：</span><br><span class="line"></span><br><span class="line">首行是状态行包括：</span><br><span class="line">    HTTP版本，状态码，</span><br><span class="line">    状态描述，后面跟一个CRLF</span><br><span class="line"></span><br><span class="line">首行之后是若干行响应头，包括：</span><br><span class="line">    通用头部，响应头部，实体头部</span><br><span class="line"></span><br><span class="line">响应头部和响应实体之间用一个CRLF空行分隔</span><br><span class="line"></span><br><span class="line">最后是一个可能的消息实体</span><br><span class="line">响应报文例子如下：</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Tue, 08 Jul 2014 05:28:43 GMT</span><br><span class="line">Server: Apache&#x2F;2</span><br><span class="line">Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT</span><br><span class="line">ETag: &quot;40d7-3e3073913b100&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 16599</span><br><span class="line">Cache-Control: max-age&#x3D;21600</span><br><span class="line">Expires: Tue, 08 Jul 2014 11:28:43 GMT</span><br><span class="line">P3P: policyref&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;05&#x2F;P3P&#x2F;p3p.xml&quot;</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;iso-8859-1</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-封装-Ajax"><a href="#Promise-封装-Ajax" class="headerlink" title="Promise 封装 Ajax"></a>Promise 封装 Ajax</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getJSON(url)&#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt;&#123;</span><br><span class="line">        var xhr &#x3D; new XMLHttpRequest()</span><br><span class="line">        &#x2F;&#x2F; get</span><br><span class="line">        xhr.open(&#39;GET&#39;, url, true)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; post</span><br><span class="line">        &#x2F;&#x2F; xhr.open(&#39;POST&#39;, url, true)</span><br><span class="line">        &#x2F;&#x2F; xhr.setRequestHeader(&#39;Content-type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;)</span><br><span class="line">        xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">            if(this.readyState &#x3D;&#x3D;&#x3D; 4)&#123;</span><br><span class="line">                if(this.status &#x3D;&#x3D;&#x3D; 200)&#123;</span><br><span class="line">                    resolve(this.responseText, this)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    var resJson &#x3D; &#123;code: this.status, response: this.response&#125;</span><br><span class="line">                    reject(resJson, this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.send()</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; post</span><br><span class="line">        &#x2F;&#x2F; xhr.send(JSON.stringify(data))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="URL-详解"><a href="#URL-详解" class="headerlink" title="URL 详解"></a>URL 详解</h2><p><a href="http://caibaojian.com/http-protocol.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL(Uniform Resource Locator) 地址用于描述一个网络上的资源， 基本格式如下</span><br><span class="line">schema:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;...&#x2F;[;url-params][?query-string][#anchor]</span><br><span class="line">　　scheme 指定低层使用的协议(例如：http, https, ftp)</span><br><span class="line">　　host HTTP服务器的IP地址或者域名</span><br><span class="line">　　port# HTTP服务器的默认端口是80，</span><br><span class="line">　　       https是443</span><br><span class="line">　　这种情况下端口号可以省略。如果使用了别的端口，</span><br><span class="line">　　必须指明，例如 http:&#x2F;&#x2F;www.cnblogs.com:8080&#x2F;</span><br><span class="line">　　path 访问资源的路径</span><br><span class="line">　　url-params</span><br><span class="line">　　query-string 发送给http服务器的数据</span><br><span class="line">　　anchor- 锚</span><br><span class="line"></span><br><span class="line">URL 的一个例子：</span><br><span class="line">http:&#x2F;&#x2F;www.mywebsite.com&#x2F;sj&#x2F;test;id&#x3D;8079?name&#x3D;sviergn&amp;x&#x3D;true#stuff</span><br><span class="line">Schema: http</span><br><span class="line">host: www.mywebsite.com</span><br><span class="line">path: &#x2F;sj&#x2F;test</span><br><span class="line">URL params: id&#x3D;8079</span><br><span class="line">Query String: name&#x3D;sviergn&amp;x&#x3D;true</span><br><span class="line">Anchor: stuff</span><br></pre></td></tr></table></figure>

<h2 id="http-常见状态码有哪些"><a href="#http-常见状态码有哪些" class="headerlink" title="http 常见状态码有哪些"></a>http 常见状态码有哪些</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1XX：信息状态码-表示请求已接收，继续处理。</span><br><span class="line">100 Continue：客户端应当继续发送请求。</span><br><span class="line">这个临时响应是用来通知客户端它的部分请求</span><br><span class="line">已经被服务器接收，且仍未被拒绝。</span><br><span class="line">101 Switching Protocols：</span><br><span class="line">服务器已经理解力客户端的请求，</span><br><span class="line">并将通过Upgrade消息头通知客户端</span><br><span class="line">采用不同的协议来完成这个请求。</span><br><span class="line">在发送完这个响应最后的空行后，</span><br><span class="line">服务器将会切换到Upgrade消息头中</span><br><span class="line">定义的那些协议。</span><br><span class="line"></span><br><span class="line">一: 2开头状态码</span><br><span class="line">2xx (成功)表示成功处理了请求的状态代码</span><br><span class="line">200 (成功) 服务器已成功处理了请求</span><br><span class="line"></span><br><span class="line">200  from cache： 表示该资源已经被缓存过，</span><br><span class="line">并且在有效期内，所以不再向浏览器发出请求，</span><br><span class="line">直接使用本地缓存。</span><br><span class="line"></span><br><span class="line">201 Created：</span><br><span class="line">202 Accepted：</span><br><span class="line">203 Non-Authoritative Information：</span><br><span class="line">204 No Content：</span><br><span class="line">205 Reset Content：</span><br><span class="line">206 Partial Content：</span><br><span class="line">二: 3开头状态码</span><br><span class="line">3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</span><br><span class="line">304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line"></span><br><span class="line">300 Multiple Choices：</span><br><span class="line">301 Moved Permanently：永久性转移(Permanently Moved),</span><br><span class="line">302 Found：重定向表示临时性转移(Temporarily Moved )，</span><br><span class="line">    当一个网页URL需要短期变化时使用。</span><br><span class="line">303 See Other：</span><br><span class="line">304 Not Modified：</span><br><span class="line">    表示浏览器虽然发现了本地有该资源的缓存，但是不确定是否是最新的，</span><br><span class="line">    于是向服务器询问，若服务器认为浏览器的缓存版本还可用（即还未更新），</span><br><span class="line">    那么便会返回304，继续使用本地的缓存。</span><br><span class="line">305 Use Proxy：</span><br><span class="line">306 （unused）：</span><br><span class="line">307 Temporary Redirect：</span><br><span class="line"></span><br><span class="line">301重定向与302重定向的区别   301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。   302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三: 4开头状态码</span><br><span class="line">4xx(请求错误) 客户端错误--请求有语法错误或请求无法实现。</span><br><span class="line">1:400 (错误请求) 服务器不理解请求的语法。</span><br><span class="line"></span><br><span class="line">2:403 (禁止) 服务器拒绝请求。</span><br><span class="line"></span><br><span class="line">3:404 (未找到) 服务器找不到请求的网页。</span><br><span class="line"></span><br><span class="line">400 Bad Request:客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized:请求未经授权，</span><br><span class="line">    这个状态代码必须和WWW-Authenticate报头域一起使用。</span><br><span class="line">402 Payment Required:</span><br><span class="line">403 Forbidden:服务器收到请求，但是拒绝提供服务。</span><br><span class="line">404 Not Found:请求资源不存在</span><br><span class="line">405 Method Not Allowed:</span><br><span class="line">406 Not Acceptable:</span><br><span class="line">407 Proxy Authentication Required:</span><br><span class="line">408 Request Timeout:</span><br><span class="line">409 Conflict:</span><br><span class="line">410 Gone:</span><br><span class="line">411 Length Required:</span><br><span class="line">412 Precondition Failed:</span><br><span class="line">413 Request Entity Too Large:</span><br><span class="line">414 Request-URI Too Long:</span><br><span class="line">415 Unsupported Media Type:</span><br><span class="line">416 Requested Range Not Satisfiable:</span><br><span class="line">417 Expectation Failed:</span><br><span class="line">四: 5开头状态码</span><br><span class="line">5xx服务器端错误--服务器未能实现合法的请求。</span><br><span class="line">500 (服务器内部错误) 服务器遇到错误，无法完成请求。</span><br><span class="line"></span><br><span class="line">501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line"></span><br><span class="line">502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line"></span><br><span class="line">503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。</span><br><span class="line"></span><br><span class="line">504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line"></span><br><span class="line">505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure>

<p>十四、http 的状态响应码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1**(信息类)：表示接收到请求并且继续处理</span><br><span class="line">100——客户必须继续发出请求</span><br><span class="line">101——客户要求服务器根据请求转换HTTP协议版本</span><br><span class="line"></span><br><span class="line">2**(响应成功)：表示动作被成功接收、理解和接受</span><br><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">201——提示知道新文件的URL</span><br><span class="line">202——接受和处理、但处理未完成</span><br><span class="line">203——返回信息不确定或不完整</span><br><span class="line">204——请求收到，但返回信息为空</span><br><span class="line">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class="line">206——服务器已经完成了部分用户的GET请求</span><br><span class="line"></span><br><span class="line">3**(重定向类)：为了完成指定的动作，必须接受进一步处理</span><br><span class="line">300——请求的资源可在多处得到</span><br><span class="line">301——本网页被永久性转移到另一个URL</span><br><span class="line">302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class="line">303——建议客户访问其他URL或访问方式</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class="line">305——请求的资源必须从服务器指定的地址得到</span><br><span class="line">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class="line">307——申明请求的资源临时性删除</span><br><span class="line"></span><br><span class="line">4**(客户端错误类)：请求包含错误语法或不能正确执行</span><br><span class="line">400——客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">HTTP 401.1 - 未授权：登录失败</span><br><span class="line">HTTP 401.2 - 未授权：服务器配置问题导致登录失败</span><br><span class="line">HTTP 401.3 - ACL 禁止访问资源</span><br><span class="line">HTTP 401.4 - 未授权：授权被筛选器拒绝</span><br><span class="line">HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</span><br><span class="line">402——保留有效ChargeTo头响应</span><br><span class="line">403——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class="line">HTTP 403.1 禁止访问：禁止可执行访问</span><br><span class="line">HTTP 403.2 - 禁止访问：禁止读访问</span><br><span class="line">HTTP 403.3 - 禁止访问：禁止写访问</span><br><span class="line">HTTP 403.4 - 禁止访问：要求 SSL</span><br><span class="line">HTTP 403.5 - 禁止访问：要求 SSL 128</span><br><span class="line">HTTP 403.6 - 禁止访问：IP 地址被拒绝</span><br><span class="line">HTTP 403.7 - 禁止访问：要求客户证书</span><br><span class="line">HTTP 403.8 - 禁止访问：禁止站点访问</span><br><span class="line">HTTP 403.9 - 禁止访问：连接的用户过多</span><br><span class="line">HTTP 403.10 - 禁止访问：配置无效</span><br><span class="line">HTTP 403.11 - 禁止访问：密码更改</span><br><span class="line">HTTP 403.12 - 禁止访问：映射器拒绝访问</span><br><span class="line">HTTP 403.13 - 禁止访问：客户证书已被吊销</span><br><span class="line">HTTP 403.15 - 禁止访问：客户访问许可过多</span><br><span class="line">HTTP 403.16 - 禁止访问：客户证书不可信或者无效</span><br><span class="line">HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class="line">404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class="line">405——用户在Request-Line字段定义的方法不允许</span><br><span class="line">406——根据用户发送的Accept拖，请求资源不可访问</span><br><span class="line">407——类似401，用户必须首先在代理服务器上得到授权</span><br><span class="line">408——客户端没有在用户指定的饿时间内完成请求</span><br><span class="line">409——对当前资源状态，请求不能完成</span><br><span class="line">410——服务器上不再有此资源且无进一步的参考地址</span><br><span class="line">411——服务器拒绝用户定义的Content-Length属性请求</span><br><span class="line">412——一个或多个请求头字段在当前请求中错误</span><br><span class="line">413——请求的资源大于服务器允许的大小</span><br><span class="line">414——请求的资源URL长于服务器允许的长度</span><br><span class="line">415——请求资源不支持请求项目格式</span><br><span class="line">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class="line">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br><span class="line"></span><br><span class="line">5**(服务端错误类)：服务器不能正确执行一个正确的请求HTTP</span><br><span class="line">500 - 服务器遇到错误，无法完成请求</span><br><span class="line">HTTP 500.100 - 内部服务器错误 - ASP 错误</span><br><span class="line">HTTP 500-11 服务器关闭</span><br><span class="line">HTTP 500-12 应用程序重新启动</span><br><span class="line">HTTP 500-13 - 服务器太忙</span><br><span class="line">HTTP 500-14 - 应用程序无效</span><br><span class="line">HTTP 500-15 - 不允许请求 global.asa Error</span><br><span class="line">501 - 未实现HTTP</span><br><span class="line">502 - 网关错误HTTP</span><br><span class="line">503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>

<h2 id="HTML5-离线缓存"><a href="#HTML5-离线缓存" class="headerlink" title="HTML5 离线缓存"></a>HTML5 离线缓存</h2><p>典型的 manifest 文件代码结构:</p>
<p>基本格式为三段：</p>
<p>CACHE，<br>NETWORK，<br>FALLBACK，</p>
<p>CACHE:（必须）标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。</p>
<p>NETWORK:（可选）这一部分是要绕过缓存直接读取的文件，可以使用通配符＊。</p>
<p>FALLBACK:（可选）指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI</p>
<p>第一个表示资源， 第二个表示后备页面。</p>
<h6 id="三种方式，可以更新缓存"><a href="#三种方式，可以更新缓存" class="headerlink" title="三种方式，可以更新缓存"></a>三种方式，可以更新缓存</h6><p>一、更新 manifest 文件：给 manifest 添加或删除文件，都可更新缓存，如果我们更改了 js，而没有新增或删除，前面例子中注释中的版本号、时间戳或者 md5 码等进行修改，都可以很好的用来更新 manifest 文件</p>
<p>二、通过 javascript 操作：html5 中引入了 js 操作离线缓存的方法，下面的 js 可以手动更新本地缓存。</p>
<p>window.applicationCache.update();<br>三、清除浏览器缓存：如果用户清除了浏览器缓存（手动或用其他一些工具）都会重新下载文件。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>1、浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>
<p>2、如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>
<p>3、引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>
<p>4、FALLBACK 中的资源必须和 manifest 文件同源。</p>
<p>5、当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>
<p>6、站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>
<p>7、当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#version 1.2.2</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">#css</span><br><span class="line">http:&#x2F;&#x2F;www.haorooms.com&#x2F;theme&#x2F;assets&#x2F;style.css</span><br><span class="line">#js</span><br><span class="line">http:&#x2F;&#x2F;www.haorooms.com&#x2F;theme&#x2F;assets&#x2F;js&#x2F;main.js</span><br><span class="line"></span><br><span class="line">#img</span><br><span class="line">http:&#x2F;&#x2F;static.hyb.dev.ipo.com&#x2F;css&#x2F;wifi&#x2F;pc&#x2F;images&#x2F;logo-fk1.png</span><br><span class="line">http:&#x2F;&#x2F;static.hyb.dev.ipo.com&#x2F;css&#x2F;wifi&#x2F;images&#x2F;favicon.ico</span><br><span class="line"></span><br><span class="line">NETWORK:  </span><br><span class="line">*</span><br><span class="line">FALLBACK:</span><br><span class="line"> &#x2F;404.html</span><br></pre></td></tr></table></figure>

<h2 id="Service-Worker-与缓存及离线缓存"><a href="#Service-Worker-与缓存及离线缓存" class="headerlink" title="Service Worker 与缓存及离线缓存"></a>Service Worker 与缓存及离线缓存</h2><p>网络请求首先到达的是 SW 脚本中，如果未命中再转发给 HTTP 缓存。</p>
<p>网络请求首先到达的是 SW 脚本中，如果未命中再转发给 HTTP 缓存。</p>
<p>一个标配版的 sw 缓存工代代码应该有以下的片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const version &#x3D; &#39;2&#39;;</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#39;install&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(&#96;static-$&#123;version&#125;&#96;)</span><br><span class="line">      .then(cache &#x3D;&gt; cache.addAll([</span><br><span class="line">        &#39;&#x2F;styles.css&#39;,</span><br><span class="line">        &#39;&#x2F;script.js&#39;</span><br><span class="line">      ]))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#39;fetch&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(response &#x3D;&gt; response || fetch(event.request))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 SW 的 install 阶段我们将 script.js 和 styles.css 放入缓存中；而在请求发起的 fetch 阶段，通过资源的 URL 去缓存内查找匹配，成功后立刻返回，否则走正常的网络请求流程。</p>
<h2 id="PageCache-与-Ajax-可缓存"><a href="#PageCache-与-Ajax-可缓存" class="headerlink" title="PageCache 与 Ajax 可缓存"></a>PageCache 与 Ajax 可缓存</h2><p>PageCache 其实是 facebook 提出的，解决 ajax 缓存的一种方案！简单的说，就是将访问过的页面缓存在客户端。</p>
<p>更新思路：</p>
<p>1、增量更新：只要页面来自于缓存，即更新所有预定义的需增量更新的模块。</p>
<p>2、用户复写：通过 HistoryManager 记录用户操作并在 cache 页面读取后重放所有被标记为“replayable”的操作。</p>
<p>3、跨页更新：通过服务端 Database API 发送信号至客户端将过期缓存标识为 invalid（不清楚如何实现。也许是 DB 端提供一个开放的 webservice，客户端通过 Ajax 持续访问此 API 来获得此信息）。获得了缓存过期信号后，通过 Ajax 更新需要更新的信息。</p>
]]></content>
      <categories>
        <category>http</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>React 高阶组件</title>
    <url>/posts/React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件（ higher-order component ，HOC ）是 React 中复用组件逻辑的一种进阶技巧。<br>它本身并不是 React 的 API，而是一种 React 组件的设计理念，众多的 React 库已经证明了它的价值，例如耳熟能详的 react-redux。</p>
<a id="more"></a>

<p>高阶函数是把函数作为参数传入到函数中并返回一个新的函数。<br>把函数替换成组件，就是高阶组件。高阶组件就是一个函数，用来封装重复的逻辑。<br>传进去一个老组件，返回一个新组件</p>
<p><code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code></p>
<p>高阶组件可以抽离公共逻辑，像洋葱一样层层叠加给组件，每一层职能分明，可以方便地抽离与增添。在优化代码或解耦组件时，可以考虑使用高阶组件模式。</p>
<p>实现高阶组件的两种方式：</p>
<ol>
<li>属性代理(Props Proxy): 高阶组件操控传递给 WrappedComponent 的 props，</li>
<li>反向继承（Inheritance Inversion）：高阶组件继承（extends）WrappedComponent。</li>
</ol>
<p>可以用高阶组件做什么？</p>
<ul>
<li>代码复用，逻辑抽象，抽离底层准备（bootstrap）代码</li>
<li>渲染劫持</li>
<li>State 抽象和更改</li>
<li>Props 更改</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>例如，假设你有一个接受外部数据源渲染评论列表的CommentList组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="comment">// &quot;DataSource&quot; is some global data source</span></span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Subscribe to changes</span></span><br><span class="line">    DataSource.addChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Clean up listener</span></span><br><span class="line">    DataSource.removeChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Update component state whenever the data source changes</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      comments: DataSource.getComments()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.comments.map(<span class="function">(<span class="params">comment</span>) =&gt;</span> (</span><br><span class="line">          &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后，你编写一个订阅单个博文的组件，其遵循类似的模式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(props.id)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    DataSource.addChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    DataSource.removeChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      blogPost: DataSource.getBlogPost(<span class="built_in">this</span>.props.id)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">text</span>=<span class="string">&#123;this.state.blogPost&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CommentList和BlogPost是等价的，除了它们调用DataSource的不同方法，有不同的输出。但它们大部分的实现是类似的:</p>
<ul>
<li>组件mount结束后，都添加DataSource的change监听</li>
<li>除了监听函数，无论什么时候datasource改变之后，都会调用setState</li>
<li>组件unmount之后，都会移除监听。</li>
</ul>
<p>以上两个组件在大型项目中订阅及setState的方法会一次次出现。</p>
<blockquote>
<p><strong>我们需要将其抽象出来，使得我们能够在一个地方定义逻辑并且在组件中共享。这就是高阶组件的优点</strong></p>
</blockquote>
<p>写一个函数，能够创建类似于CommentList和BlogPost这类订阅DataSource的新的组件。这个函数接受一个子组件作为参数，这个子组件接受订阅数据源作为props，调用withSubscription如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentListWithSubscription = withSubscription(</span><br><span class="line">  CommentList,</span><br><span class="line">  (DataSource) =&gt; DataSource.getComments()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BlogPostWithSubscription = withSubscription(</span><br><span class="line">  BlogPost,</span><br><span class="line">  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第一个参数是被包含的组件，第二个参数根据给定的DataSource和当前的props取回我们需要的数据。</p>
<p>当CommentListWithSubscription和CommentListWithSubscription被渲染时，CommentList和BlogPost将会被传递data属性，其中包含从DataSource取回的最新数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This function takes a component...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent, selectData</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...and returns another component...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line">      <span class="built_in">this</span>.handleChange = <span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>);</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ... that takes care of the subscription...</span></span><br><span class="line">      DataSource.addChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="built_in">this</span>.handleChange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handleChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, <span class="built_in">this</span>.props)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ... and renders the wrapped component with the fresh data!</span></span><br><span class="line">      <span class="comment">// Notice that we pass through any additional props</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高阶组件既不会修改输入组件，也不会通过继承来复制行为。相反，通过包裹的形式，高阶组件将原先的组件组合在container组件中。高阶组件是纯函数，没有副作用。</p>
<p>被包裹的元素接受 container 的所有props和新的props，并使用其渲染输出。高阶组件并不关心数据将会如何或者为什么使用，并且被包裹的元素并不关心数据的源头。</p>
<p>因为withSubscription只是一个普通函数，你可以按照你的意愿添加很多或者很少的参数。例如，你可能希望data的名字是可以配置的，为了进一步隔离高阶组件和被包裹组件。或者你可以接受一个参数，它可以配置shouldComponentUpdate,或者是可以配置数据的来源。这都是可行的，因为高阶组件可以完全自己控制组件该如何定义。</p>
<p>和组件相类似，withSubscription和被包裹组件的联系是基于props的。只要为被包裹元素提供相同的属性，那么很容易将一个高阶组件组件转化成不同的高阶组件。例如，如果你想要改变数据获取的库，这将非常有用。</p>
<h2 id="一个简单的高阶组件"><a href="#一个简单的高阶组件" class="headerlink" title="一个简单的高阶组件"></a>一个简单的高阶组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">&#x27;./simpleHoc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.props, <span class="string">&#x27;props);</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                Usual</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default simpleHoc(Usual);</span></span><br></pre></td></tr></table></figure>

<p>simpleHoc.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simpleHoc = <span class="function"><span class="params">wrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;simpleHoc&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">wrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> simpleHoc;</span><br></pre></td></tr></table></figure>

<p>例二:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">withHeader</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;demo-header&quot;</span>&gt;</span><br><span class="line">          我是标题</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其他组件中引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@withHeader</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是一个普通组件</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>高阶组件可以看做是装饰器模式(Decorator Pattern) 在React的实现。即允许向一个现有对象添加新功能，同时不改变其结构，属于包装模式(Wrapper Pattern)的一种</p>
<p>上面例子可以改写为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">&#x27;./simple-hoc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@simpleHoc</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h2><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><p>属性代理本质上是返回了一个全新的 Component，此时原组件的静态属性、生命周期等一系列内容都被屏蔽，导致上层的高阶组件、对组件的操作都拿不到应有的内容。</p>
<p>一个简单例子中用的就是属性代理(Props Proxy)的形式。本来传给Usual的props在hoc中接收到，就是props proxy. 这里可以做一些操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里高阶组件的 render 方法返回了一个 type 为 WrappedComponent 的 React Element（也就是被包装的那个组件），我们把高阶组件收到的 props 传递给它，因此得名 Props Proxy。</p>
<p>注意：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line"><span class="comment">// is equivalent to</span></span><br><span class="line">React.createElement(WrappedComponent, <span class="built_in">this</span>.props, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>Props Proxy 可以做什么</p>
<ul>
<li>操作 props</li>
<li>通过 refs 获取组件实例</li>
<li>抽象 state</li>
<li>把 WrappedComponent 与其它 elements 包装在一起</li>
</ul>
<h3 id="操作props"><a href="#操作props" class="headerlink" title="操作props"></a>操作props</h3><p>接收到props可以做任何读取，编辑，删除等自定义操作。都可以通过props再传下去</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propsProxyHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml">&lt;WrappedComponent</span></span><br><span class="line"><span class="xml">      &#123;...this.props&#125;</span></span><br><span class="line"><span class="xml">      handleClick=&#123;this.handleClick&#125;</span></span><br><span class="line"><span class="xml">    /&gt;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> propsProxyHoc;</span><br></pre></td></tr></table></figure>

<p>在Usual组件中会接收到handleClick属性</p>
<p>在修改或删除重要 props 的时候要小心，你可能应该给高阶组件的 props 指定命名空间（namespace），以防破坏从外传递给 WrappedComponent 的 props。</p>
<p>例子：添加新 props。这个currentLoggedInUser可以在 WrappedComponent 通过 this.props.user 获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        user: currentLoggedInUser</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过refs获取组件实例"><a href="#通过refs获取组件实例" class="headerlink" title="通过refs获取组件实例"></a>通过refs获取组件实例</h3><p>尽管惯例是高阶组件会给被包裹组件传递所有的属性(props)，但是不会传递<code>refs</code>。因为<code>ref</code>不是一个属性，就像<code>key</code>一样，它是由React特殊处理的。如果你给高阶组件产生的组件的元素添加<code>ref</code>,<code>ref</code>引用的是外层的容器组件的实例，而不是被包裹的组件。</p>
<p>如果你遇到这个问题，最好的解决方法是避免使用<code>ref</code>。有时候，React新手用户依赖于<code>refs</code>，这时候<code>props</code>是更好的选择。</p>
<p>也就是说，也就是说<code>refs</code>有时候是必要的，否则React也不会提供<code>refs</code>。</p>
<p>选中输入框(focusing an input field)是一个你可能希望强制控制组件的例子。在这种例子中，一个解决办法是通过起一个别名，将<code>ref</code>作为一个普通的props传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Field</span>(<span class="params">&#123; inputRef, ...rest &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrap Field in a higher-order component</span></span><br><span class="line"><span class="keyword">const</span> EnhancedField = enhance(Field);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside a class component&#x27;s render method...</span></span><br><span class="line">&lt;EnhancedField</span><br><span class="line">  inputRef=&#123;<span class="function">(<span class="params">inputEl</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// This callback gets passed through as a regular prop</span></span><br><span class="line">    <span class="built_in">this</span>.inputEl = inputEl</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now you can call imperative methods</span></span><br><span class="line"><span class="built_in">this</span>.inputEl.focus();</span><br></pre></td></tr></table></figure>

<p>无论如何，这都是一个完美的解决方案。我们倾向于<code>refs</code>是由库去处理，而不是要求你手动地处理。我们正在寻找解决这个问题的办法，以便在使用高阶组件时不需要注意这个问题。</p>
<h3 id="抽象state"><a href="#抽象state" class="headerlink" title="抽象state"></a>抽象state</h3><p>这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件（文档），即把input都做成受控的，改变value的时候，用onChange事件同步到state中。</p>
<p>可以通过向 WrappedComponent 传递 props 和 callbacks（回调函数）来抽象 state，这和 React 中另外一个组件构成思想 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Presentational and Container Components</a> 很相似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通组件Login</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> formCreate <span class="keyword">from</span> <span class="string">&#x27;./form-create&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@formCreate</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;label id=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">            账户</span><br><span class="line">          &lt;/label&gt;</span><br><span class="line">          &lt;input name=<span class="string">&quot;username&quot;</span> &#123;...this.props.getField(<span class="string">&#x27;username&#x27;</span>)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div onClick=&#123;<span class="built_in">this</span>.props.handleSubmit&#125;&gt;提交&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>form-create.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HOC</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formCreate = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      fields: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onChange = <span class="function"><span class="params">key</span> =&gt;</span> <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; fields &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    fields[key] = e.target.value;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      fields,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleSubmit = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.fields);</span><br><span class="line">  &#125;</span><br><span class="line">  getField = <span class="function"><span class="params">fieldName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      onChange: <span class="built_in">this</span>.onChange(fieldName),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleSubmit: <span class="built_in">this</span>.handleSubmit,</span><br><span class="line">      getField: <span class="built_in">this</span>.getField,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml">&lt;WrappedComponent</span></span><br><span class="line"><span class="xml">      &#123;...props&#125;</span></span><br><span class="line"><span class="xml">    /&gt;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> formCreate;</span><br></pre></td></tr></table></figure>

<p>这里我们把state，onChange等方法都放到HOC里，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。</p>
<h3 id="把-WrappedComponent-与其它-elements-包装在一起"><a href="#把-WrappedComponent-与其它-elements-包装在一起" class="headerlink" title="把 WrappedComponent 与其它 elements 包装在一起"></a>把 WrappedComponent 与其它 elements 包装在一起</h3><p>出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起。一些基本的用法也可以使用正常的父组件来实现（附录 B），但是就像之前所描述的，使用高阶组件你可以获得更多的灵活性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PP</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">display</span>: <span class="string">&#x27;block&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><p>反向继承(Inheritance Inversion), 简称II，</p>
<p>简单的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 可以方便地得到state，做一些更深入的修改。</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的高阶组件类（Enhancer）继承了 WrappedComponent。这被叫做反向继承是因为 WrappedComponent 被动地被 Enhancer 继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。</p>
<p>反向继承允许高阶组件通过 this 关键词获取 WrappedComponent，意味着它可以获取到 state，props，组件生命周期（component lifecycle）钩子，以及渲染方法（render）。</p>
<p><strong>可以用反向继承高阶组件做什么？</strong></p>
<ul>
<li>渲染劫持（Render Highjacking）</li>
<li>操作 state</li>
</ul>
<h3 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h3><p>被叫做渲染劫持是因为高阶组件控制了 WrappedComponent 生成的渲染结果，并且可以做各种操作。</p>
<p>通过渲染劫持你可以：</p>
<ul>
<li>『读取、添加、修改、删除』任何一个将被渲染的 React Element 的 props</li>
<li>在渲染方法中读取或更改 React Elements tree，也就是 WrappedComponent 的 children</li>
<li>根据条件不同，选择性的渲染子树</li>
<li>给子树里的元素变更样式</li>
</ul>
<p>*渲染 指的是 WrappedComponent.render 方法</p>
<blockquote>
<p>你无法更改或创建 props 给 WrappedComponent 实例，因为 React 不允许变更一个组件收到的 props，但是你可以在 render 方法里更改子元素/子组件们的 props。</p>
</blockquote>
<p>就像之前所说的，反向继承的高阶组件不能保证一定渲染整个子元素树，这同时也给渲染劫持增添了一些限制。通过反向继承，你只能劫持 WrappedComponent 渲染的元素，这意味着如果 WrappedComponent 的子元素里有 Function 类型的 React Element，你不能劫持这个元素里面的子元素树的渲染。</p>
<p>例子1：条件性渲染。如果 this.props.loggedIn 是 true，这个高阶组件会原封不动地渲染 WrappedComponent，如果不是 true 则不渲染（假设此组件会收到 loggedIn 的 prop）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.render()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：通过 render 来变成 React Elements tree 的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Enhancer</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elementsTree = <span class="built_in">super</span>.render()</span><br><span class="line">      <span class="keyword">let</span> newProps = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (elementsTree &amp;&amp; elementsTree.type === <span class="string">&#x27;input&#x27;</span>) &#123;</span><br><span class="line">        newProps = &#123;<span class="attr">value</span>: <span class="string">&#x27;may the force be with you&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, elementsTree.props, newProps)</span><br><span class="line">      <span class="keyword">const</span> newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)</span><br><span class="line">      <span class="keyword">return</span> newElementsTree</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 WrappedComponent 的顶层元素是一个 input，则改变它的值为 “may the force be with you”。<br>这里你可以做任何操作，比如你可以遍历整个 element tree 然后变更某些元素的 props。这恰好就是 Radium 的工作方式。</p>
<blockquote>
<p>注意：你不能通过 Props Proxy 来做渲染劫持<br>即使你可以通过 WrappedComponent.prototype.render 获取它的 render 方法，你需要自己手动模拟整个实例以及生命周期方法，而不是依靠 React，这是不值当的，应该使用反向继承来做到渲染劫持。要记住 React 在内部处理组件的实例，而你只通过 this 或 refs 来处理实例。</p>
</blockquote>
<h3 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h3><p>高阶组件可以 『读取、修改、删除』WrappedComponent 实例的 state，如果需要也可以添加新的 state。需要记住的是，你在弄乱 WrappedComponent 的 state，可能会导致破坏一些东西。通常不建议使用高阶组件来读取或添加 state，添加 state 需要使用命名空间来防止与 WrappedComponent 的 state 冲突。</p>
<p>例子：通过显示 WrappedComponent 的 props 和 state 来 debug</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">IIHOCDEBUGGER</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">II</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;HOC Debugger Component&lt;/h2&gt;</span><br><span class="line">          &lt;p&gt;Props&lt;<span class="regexp">/p&gt; &lt;pre&gt;&#123;JSON.stringify(this.props, null, 2)&#125;&lt;/</span>pre&gt;</span><br><span class="line">          &lt;p&gt;State&lt;<span class="regexp">/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/</span>pre&gt;</span><br><span class="line">          &#123;<span class="built_in">super</span>.render()&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HOC和Mixin的比较"><a href="#HOC和Mixin的比较" class="headerlink" title="HOC和Mixin的比较"></a>HOC和Mixin的比较</h3><p><img src="/img/mixin-hoc.png" alt="hoc和Mixin比较"></p>
<p>高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。</p>
<p>作者：请叫我王磊同学<br>链接：<a href="https://juejin.im/post/5914fb4a0ce4630069d1f3f6">https://juejin.im/post/5914fb4a0ce4630069d1f3f6</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><p>用高阶组件优化之前老项目写的不好的地方，比如两个页面UI几乎一样，功能几乎相同，仅仅几个操作不太一样，却写了两个耦合很多的页面级组件。当我去维护它的时候，由于它的耦合性过多，经常会添加一个功能(这两个组件都要添加)，我要去改完第一个的时候，还要改第二个。而且有时候由于记性不好，会忘掉第二个… 就会出现bug再返工。所以加新功能时，写一个高阶组件，往HOC里添加方法，把那两个组件包装一下，也就是属性代理。这样新代码就不会再出现耦合，旧的逻辑并不会改变</p>
</li>
<li><p>另一种情况是之前写过一个组件A，做完上线，之后产品加了一个新需求，很奇怪要做的组件B跟A几乎一模一样，但稍微有区别。那我可能就通过II的方式去继承之前的组件A，比如它在didMount去fetch请求，需要的数据是一样的。不同的地方我就会放到HOC里，存储新的state这样，再通过劫持渲染，把不同的地方，添加的地方进行处理。但其实这算Hack的一种方式，能快速解决问题，也反映了组件设计规划之初有所不足(原因比较多)。</p>
</li>
<li><p>Container解决不了的时候甚至不太优雅的时候。其实大部分时候包一层Container组件也能做到差不多的效果，比如操作props，渲染劫持。但其实还是有很大区别的。比如我们现在有两个功能的container，添加样式和添加处理函数的，对Usual进行包装。栗子：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//usual</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.props, <span class="string">&#x27;props&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      Usual</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Usual;</span><br><span class="line"><span class="comment">//console - Object &#123;handleClick: function&#125;  &quot;props&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Usual <span class="keyword">from</span> <span class="string">&#x27;./usual&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StyleContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;#<span class="attr">76d0a3</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Usual</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> StyleContainer;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> StyleContainer <span class="keyword">from</span> <span class="string">&#x27;./container-add-style&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuncContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: <span class="built_in">this</span>.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">StyleContainer</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FuncContainer;</span><br></pre></td></tr></table></figure>

<p>外层Container必须要引入内层Container，进行包装，还有props的传递，同样要注意包装的顺序。当然你可以把所有的处理都放到一个Container里。那用HOC怎么处理呢，相信大家有清晰的答案了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: <span class="built_in">this</span>.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addStyle = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;#<span class="attr">76d0a3</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WrappenComponent = addStyle(addFunc(Usual));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedUsual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.props, <span class="string">&#x27;props&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">      &lt;WrappedComponent /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然HOC是更优雅一些的，每个HOC都定义自己独有的处理逻辑，需要的时候只需要去包装你的组件。相较于Container的方式，HOC耦合性更低，灵活性更高，可以自由组合，更适合应付复杂的业务。每个HOC负责独立的功能，比如可能只是一个Loading的效果，很多列表页都需要，用HOC只需要包装一下就可以了，不需要在每个组件里再重写这部分逻辑了。当然当你的需求很简单的时候，还是用Container去自由组合，应用场景需要你清楚。</p>
<h2 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h2><h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><p>React-Redux 是 Redux 官方的对于 React 的绑定。 其中一个方法 connect 处理了所有关于监听 store 的 bootstrap 代码 以及清理工作，这是通过 Props Proxy 来实现的。</p>
<p>如果你曾经使用过 Flux 你会知道 React 组件需要和一个或多个 store 连接，并且添加/删除对 store 的监听，从中选择需要的那部分 state。而 React-Redux 帮你把它们实现了，自己就不用再去写这些了。</p>
<h3 id="Radium"><a href="#Radium" class="headerlink" title="Radium"></a>Radium</h3><p>Radium 是一个增强了行内（inline）css 能力的库，它允许了在 inline css 使用 CSS 伪选择器。<a href="https://github.com/FormidableLabs/radium">点此</a>了解关于使用 inline css 的好处.</p>
<p>那么，Radium 是怎么允许 inline css 来实现 CSS 伪选择器的呢（比如 hover）？它实现了一个反向继承来使用渲染劫持，添加适当的事件监听来模拟 CSS 伪选择器。这要求 Radium 读取整个 WrappedComponent 将要渲染的元素树，每当找个某个元素带有 style prop，它就添加对应的时间监听 props。简单地说，Radium 修改了原先元素树的 props（实际上会更复杂，但这么说你可以理解到要点所在）。</p>
<p>Radium 只暴露了一个非常简单的 API 给开发者。这非常惊艳，因为开发者几乎不会注意到它的存在和它是怎么发挥作用的，而实现了想要的功能。这揭露了高阶组件的能力。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录A-高阶组件和参数"><a href="#附录A-高阶组件和参数" class="headerlink" title="附录A: 高阶组件和参数"></a>附录A: 高阶组件和参数</h3><p>有时，在高阶组件中使用参数是很有用的。这个在以上所有例子中都不是很明显，但是对于中等的 JavaScript 开发者是比较自然的事情。让我们迅速的介绍一下。</p>
<p>例子：一个简单的 Props Proxy 高阶组件搭配参数。重点是这个 HOCFactoryFactory 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOCFactoryFactory</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with params</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">HOCFactory</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以这样使用它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HOCFactoryFactory(params)(WrappedComponent)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">@HOCFatoryFactory(params)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果传入参数，则传入的参数将作为组件的标题呈现</span></span><br><span class="line">@withHeader(<span class="string">&#x27;Demo&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>withHead.js 接收参数，返回高阶组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">title</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">          &lt;div className=<span class="string">&quot;demo-header&quot;</span>&gt;</span><br><span class="line">            &#123;title</span><br><span class="line">              ? title</span><br><span class="line">              : <span class="string">&#x27;我是标题&#x27;</span>&#125;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>(title) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;demo-header&quot;</span>&gt;</span><br><span class="line">        &#123;title</span><br><span class="line">          ? title</span><br><span class="line">          : <span class="string">&#x27;我是标题&#x27;</span>&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<pre><code>柯里化 Curry
概念：只传递函数的一部分参数来调用它，让它返回一个函数去处理剩下的参数。

函数签名：fun(params)(otherParams)
应用：在React里，通过柯里化，我们可以通过传入不同的参数来得到不同的高阶组件。</code></pre>
<blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="附录-B：和父组件的不同之处"><a href="#附录-B：和父组件的不同之处" class="headerlink" title="附录 B：和父组件的不同之处"></a>附录 B：和父组件的不同之处</h3><p>父组件就是单纯的 React 组件包含了一些子组件（children）。React 提供了获取和操作一个组件的 children 的 APIs。</p>
<p>例子：父组件获取它的 children</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render((</span><br><span class="line">  &lt;Parent&gt;</span><br><span class="line">    &#123;children&#125;</span><br><span class="line">  &lt;/Parent&gt;</span><br><span class="line">), mountNode)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在来总结一下父组件能做和不能做的事情（与高阶组件对比）：</p>
<ul>
<li>渲染劫持</li>
<li>操作内部 props</li>
<li>抽象 state。但是有缺点，不能再父组件外获取到它的 state，除非明确地实现了钩子。</li>
<li>与新的 React Element 包装。这似乎是唯一一点，使用父组件要比高阶组件强，但高阶组件也同样可以实现。</li>
<li>Children 的操控。如果 children 不是单一 root，则需要多添加一层来包括所有 children，可能会使你的 markup 变得有点笨重。使用高阶组件可以保证单一 root。</li>
<li>父组件可以在元素树立随意使用，它们不像高阶组件一样限制于一个组件。</li>
</ul>
<p>通常来讲，能使用父组件达到的效果，尽量不要用高阶组件，因为高阶组件是一种更 hack 的方法，但同时也有更高的灵活性。</p>
<p><strong>高阶组件作为一个函数，它可以更加纯粹地关注业务逻辑层面的代码，比如数据处理，数据校验，发送请求等，可以改善目前代码里业务逻辑和UI逻辑混杂在一起的现状。父组件则是UI层的东西，我们先前经常把一些业务逻辑处理放在父组件里，这样会造成父组件混乱的情况。为了代码进一步解耦，可以考虑使用高阶组件这种模式。</strong></p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p><a href="https://reactjs.org.cn/doc/higher-order-components.html">原文链接</a></p>
<h2 id="不要改变原始组件，而是使用组合"><a href="#不要改变原始组件，而是使用组合" class="headerlink" title="不要改变原始组件，而是使用组合"></a>不要改变原始组件，而是使用组合</h2><p>要忍住在高阶组件修改组件原型(或者修改其他)的冲动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">InputComponent</span>) </span>&#123;</span><br><span class="line">  InputComponent.prototype.componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Current props: &#x27;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Next props: &#x27;</span>, nextProps);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// The fact that we&#x27;re returning the original input is a hint that it has</span></span><br><span class="line">  <span class="comment">// been mutated.</span></span><br><span class="line">  <span class="keyword">return</span> InputComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EnhancedComponent will log whenever props are received</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>

<p>这里存在一些问题，一个是输入组件(InputComponent)不能脱离增强组件分别重用。更重要的是，如果将另一个也修改componentWillReceiveProps的高阶组件应用于EnhancedComponent组件，第一个高阶组件的功能将会别覆盖。这个高阶组件对函数组件不会起作用，因为函数组件没有生命周期函数。</p>
<p>具有修改功能的高阶组件是一个漏洞的抽象过程：用户必须知道它是怎么实现的从而避免与其他高阶组件的冲突。</p>
<h2 id="组合多个高阶组件"><a href="#组合多个高阶组件" class="headerlink" title="组合多个高阶组件"></a>组合多个高阶组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@withHeader</span><br><span class="line">@withLoading</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用compose可以简化上述过程，也能体现函数式编程的思想。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> enhance = compose(withHeader,withLoading);</span><br><span class="line">@enhance</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组合 Compose<br>compose可以帮助我们组合任意个（包括0个）高阶函数，例如compose(a,b,c)返回一个新的函数d，函数d依然接受一个函数作为入参，只不过在内部会依次调用c,b,a，从表现层对使用者保持透明。<br>基于这个特性，我们便可以非常便捷地为某个组件增强或减弱其特征，只需要去变更compose函数里的参数个数便可。<br>compose函数实现方式有很多种，这里推荐其中一个recompact.compose，详情见下方参考类库。</p>
</blockquote>
<p><strong>相比于修改，高阶组件最好是通过将输入组件包裹在容器组件的方式来使用组合:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Current props: &#x27;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Next props: &#x27;</span>, nextProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// Wraps the input component in a container, without mutating it. Good!</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个高阶组件与之前的修改原型的版本有着相同的功能，但又避免了潜在的冲突可能。其在class类型和函数类型的组件都起作用。并且，因为是纯函数，它可以与其他高阶组件，甚至是自己组合。</p>
<p>你可能已经注意到高阶组件和被称为<strong>容器组件</strong>(container components)的模式有相同之处。容器组件是分离责任策略的一部分。这个分离策略是关于高层次和低层次关注点之间的责任分离。容器管理着类似订阅和状态这类东西，和给组件传递属性来处理类似渲染UI这类事情。高阶组件使用容器作为其实现的一部分。你可以将高阶组件视为定义参数化容器组件。</p>
<h2 id="约定-给包裹组件传递不相关的属性-Props"><a href="#约定-给包裹组件传递不相关的属性-Props" class="headerlink" title="约定: 给包裹组件传递不相关的属性(Props)"></a>约定: 给包裹组件传递不相关的属性(Props)</h2><p>高阶组件可以向组件添加功能。他不应该大幅度地改变功能。期望地是高阶组件返回的组件和被包裹组件具有相似的界面。</p>
<p>高阶组件应该通过props传递那些与特定功能无关的特性。大多数的高阶组件包含如下的render函数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// Filter out extra props that are specific to this HOC and shouldn&#x27;t be</span></span><br><span class="line">  <span class="comment">// passed through</span></span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inject props into the wrapped component. These are usually state values or</span></span><br><span class="line">  <span class="comment">// instance methods.</span></span><br><span class="line">  <span class="keyword">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass props to wrapped component</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个约定帮助确定高阶组件能够足够灵活和可以被重用。</p>
<h2 id="约定-最大化组合-Maximizing-Composability"><a href="#约定-最大化组合-Maximizing-Composability" class="headerlink" title="约定: 最大化组合(Maximizing Composability)"></a>约定: 最大化组合(Maximizing Composability)</h2><p>不是所有的高阶组件看起来都是一样的。有时候，它接受包裹组件作为单一参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NavbarWithRouter = withRouter(Navbar);</span><br></pre></td></tr></table></figure>

<p>通常情况下，高阶组件接受其他的参数。在Relay这个例子中，配置对象用来指定组件的数据依赖关系：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentWithRelay = Relay.createContainer(Comment, config);</span><br></pre></td></tr></table></figure>

<p>高阶组件最常见的签名如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React Redux&#x27;s `connect`</span></span><br><span class="line"><span class="keyword">const</span> ConnectedComment = connect(commentSelector, commentActions)(Comment);</span><br></pre></td></tr></table></figure>

<p>**什么?!**，如果你把它分开，就更容易看到发生了什么。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// connect is a function that returns another function</span></span><br><span class="line"><span class="keyword">const</span> enhance = connect(commentListSelector, commentListActions);</span><br><span class="line"><span class="comment">// The returned function is an HOC, which returns a component that is connected</span></span><br><span class="line"><span class="comment">// to the Redux store</span></span><br><span class="line"><span class="keyword">const</span> ConnectedComment = enhance(CommentList);</span><br></pre></td></tr></table></figure>

<p>总的来说，<code>connect</code>是一个返回高阶组件的高阶函数！</p>
<p>这种形式看起来是混乱的或者是没有必要的，但是它是一个有用的属性。单参数的高阶组件类似于<code>connect</code>函数所返回的函数，其签名为<code>Component =&gt; Component</code>。返回的函数的输出类型和输入类型是相同的，很容易相互组合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Instead of doing this...</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = connect(commentSelector)(withRouter(WrappedComponent))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... you can use a function composition utility</span></span><br><span class="line"><span class="comment">// compose(f, g, h) is the same as (...args) =&gt; f(g(h(...args)))</span></span><br><span class="line"><span class="keyword">const</span> enhance = compose(</span><br><span class="line">  <span class="comment">// These are both single-argument HOCs</span></span><br><span class="line">  connect(commentSelector),</span><br><span class="line">  withRouter</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>

<p>(这个相同的属性还允许连接和其他增强型高阶属性作为装饰器(decorators),这是一个实验性的JavaScript提案)。</p>
<p>包括lodash(例如<a href="https://lodash.com/docs/4.17.4#flowRight">lodash.flowRight</a>)、<a href="http://redux.js.org/docs/api/compose.html">Redux</a>和<a href="http://ramdajs.com/docs/#compose">Ramda</a>在内的许多第三方库都提供了组合函数。</p>
<h2 id="约定-为了方便调试包装显示名称-display-name"><a href="#约定-为了方便调试包装显示名称-display-name" class="headerlink" title="约定:为了方便调试包装显示名称(display name)"></a>约定:为了方便调试包装显示名称(display name)</h2><p>由高阶属性创建的容器组件在React开发者工具中显示同其他的组件相似。为了方便调试，选择一个显示名称(display name)，表示它是高阶组件的结果。</p>
<p>最常见的方法是给被包裹元素包裹一个显示名称(display name)。因此，如果你的高阶组件名字为<code>withSubscription</code>，被包裹的元素名称为<code>CommentList</code>，那就选择名称为<code>WithSubscription(CommentList)</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WithSubscription</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">  WithSubscription.displayName = <span class="string">`WithSubscription(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> WithSubscription;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>高阶组件有以下几个警告，如果你是刚接触React，这些警告可能不会立刻就被发现。</p>
<h3 id="不要在render函数中使用高阶组件"><a href="#不要在render函数中使用高阶组件" class="headerlink" title="不要在render函数中使用高阶组件"></a>不要在render函数中使用高阶组件</h3><p>React的diff算法(又称为reconciliation)使用组件标识符(component identity)来决定是否应该更新已有的子树或者将其抛出并安装一个新的子树。如果从render返回的组件等同于(===)之前render函数返回的组件，React将会迭代地通过diff算法更新子树到新的子树。如果不相等，则先前的子树将会完全卸载。</p>
<p>通常情况下，你不需要考虑这些。但是这对高阶组件非常重要，因为这意味你在组件的render方法中不能通过高阶组件产生组件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// A new version of EnhancedComponent is created on every render</span></span><br><span class="line">  <span class="comment">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class="line">  <span class="keyword">const</span> EnhancedComponent = enhance(MyComponent);</span><br><span class="line">  <span class="comment">// That causes the entire subtree to unmount/remount each time!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnhancedComponent</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题不仅仅关乎于性能，卸载组件会造成组件状态和其子元素全部丢失。</p>
<p>相反地，在组件定义外应用高阶组件，以便生成的组件只会被创建一次。然后，它的标识符在每次渲染中都是相同的。无论如何，这才是你想要的。</p>
<p>在一些极少的例子中你需要动态地引用高阶组件，你可以在组件的声明周期函数中使用或者在构造函数中使用。</p>
<h3 id="静态方法必须复制"><a href="#静态方法必须复制" class="headerlink" title="静态方法必须复制"></a>静态方法必须复制</h3><p>有时候，在React组价中定义静态方法是非常有用的。例如，Relay容器对外暴露一个静态方法<code>getFragment</code>，来帮助组合GraphQL代码。</p>
<p>当你将一个组件应用于高阶组件式，虽然原有的组件被容器组件所包裹，但这以为这新的组件没有之前组件的静态函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define a static method</span></span><br><span class="line">WrappedComponent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="comment">// Now apply an HOC</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The enhanced component has no static method</span></span><br><span class="line"><span class="keyword">typeof</span> EnhancedComponent.staticMethod === <span class="string">&#x27;undefined&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，在返回之前，可以向容器组件中复制原有的静态方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  <span class="comment">// Must know exactly which method(s) to copy :(</span></span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这需要你明确地知道哪些方法需要别复制。你可以使用<a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>来自动复制非React的静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个有效的方法是将静态方法与组件本身相分离：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Instead of...</span></span><br><span class="line">MyComponent.someFunction = someFunction;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...export the method separately...</span></span><br><span class="line"><span class="keyword">export</span> &#123; someFunction &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...and in the consuming module, import both</span></span><br><span class="line"><span class="keyword">import</span> MyComponent, &#123; someFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用compose组合HOC"><a href="#使用compose组合HOC" class="headerlink" title="使用compose组合HOC"></a>使用compose组合HOC</h3><p>函数式编程的套路… 例如应用redux中的middleware以增强功能。redux-middleware解析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addFuncHOC = ...</span><br><span class="line"><span class="keyword">const</span> addStyleHOC = ...<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> <span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.lenght === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> funcs.reduceRight(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> cur(res), last(component));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WrappedComponent = compose(addFuncHOC, addStyleHOC)(Usual);</span><br></pre></td></tr></table></figure>

<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="loading组件"><a href="#loading组件" class="headerlink" title="loading组件"></a>loading组件</h2><p>实现Loading组件时，发现需要去拦截它的渲染过程，故使用了反向继承的方式来完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Spin&#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">loadingCheck</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;withLoading将会更新&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadingCheck(<span class="built_in">this</span>.props)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">tip</span>=<span class="string">&quot;加载中&quot;</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;super.render()&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Spin</span>&gt;</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">@withLoading(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> props.IndexStore.accountList.length == <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="实现一个copy组件"><a href="#实现一个copy组件" class="headerlink" title="实现一个copy组件"></a>实现一个copy组件</h2><p>实现copy组件的时候，我们发现不需要去改变组件内部的展示方式，只是为其在外围增加一个功能，并不会侵入被传入的组件，故使用了属性代理的方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gotem <span class="keyword">from</span> <span class="string">&#x27;gotem&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;message&#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> copy = <span class="function">(<span class="params">targetName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ctx = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> dom = ReactDom.findDOMNode(ctx);</span><br><span class="line">        <span class="keyword">const</span> nodes = &#123;</span><br><span class="line">          trigger: dom,</span><br><span class="line">          <span class="comment">// targetName为DOM选择器，复制组件将会复制它的值</span></span><br><span class="line">          target: dom.querySelector(targetName)</span><br><span class="line">        &#125;;</span><br><span class="line">        gotem(nodes.trigger, nodes.target, &#123;</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            message.success(<span class="string">&#x27;复制成功&#x27;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            message.error(<span class="string">&#x27;复制失败，请手动输入&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 传入 h3 ，让复制组件去获取它的值</span></span><br><span class="line">@copy(<span class="string">&#x27;h3&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;</span><br><span class="line">          阿里云,点击复制这段文字</span><br><span class="line">        &lt;/h3&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="[参考链接]"></a>[参考链接]</h1><p><a href="https://github.com/MrErHu/React-Advanced-Guides-CN/blob/master/doc/Higher%20Order%20Components.md">React 进阶之高阶组件</a></p>
<p><a href="https://www.jianshu.com/p/0aae7d4d9bc1">深入理解 React 高阶组件</a></p>
<p><a href="https://github.com/dt-fe/weekly/blob/master/12.%E7%B2%BE%E8%AF%BB%20React%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.md">精度React组件</a></p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React进阶读书笔记</title>
    <url>/posts/React%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="React-四大特点"><a href="#React-四大特点" class="headerlink" title="React 四大特点"></a>React 四大特点</h1><ul>
<li>声明式视图层<br>  采用JSX语法来声明视图层, 可以在视图层中随意使用各种状态数据</li>
<li>简单的更新流程<br>  从状态到UI单向数据流让React组件的更新流程更清晰</li>
<li>灵活的渲染实现<br>  基于虚拟dom渲染</li>
<li>高效的DOM操作<br>  React可以尽量减少虚拟dom到真实DOM的渲染次数, 以及每次渲染需要改变的真实DOM节点数。</li>
</ul>
<p>React只是view层, 关注的是如何根据状态创建可复用的UI组件, 如何根据组件创建可组合的UI.<br>应用复杂时, 需要结合其他库(Redux, MobX等). </p>
<a id="more"></a>

<h1 id="React组件名必须大写"><a href="#React组件名必须大写" class="headerlink" title="React组件名必须大写"></a>React组件名必须大写</h1><p>因为DOM标签的首字母都是小写; React组件类型的标签必须首字母大写。<br>React正是通过首字母大小写判断渲染的是一个dom类型的标签还是React组件类型的标签。</p>
<h1 id="JSX语法实际是什么"><a href="#JSX语法实际是什么" class="headerlink" title="JSX语法实际是什么"></a>JSX语法实际是什么</h1><p>JSX语法只是React.createElement(component, props, …children)的语法糖, 所有的JSX语法最终都会被转换成对这个方法的调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ele = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;foo&#x27;</span>&gt;</span>Hello, React<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>转换后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ele = React.createElement(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="attr">className</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;Hello, React&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件定义方式"><a href="#组件定义方式" class="headerlink" title="组件定义方式"></a>组件定义方式</h1><p>有两种方式</p>
<ol>
<li><p>ES6 class(类组件)<br> 需满足条件:</p>
<ol>
<li><p>class继承自React.Component</p>
</li>
<li><p>class内部必须定义render方法, render返回代表该组件UI的React元素.</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">export default class PostList extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                列表</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用函数(函数组件)<br> 函数组件接收props作为参数,返回这个组件UI的React元素结构.</p>
<p> eg:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="React组件数据驱动UI"><a href="#React组件数据驱动UI" class="headerlink" title="React组件数据驱动UI"></a>React组件数据驱动UI</h1><p>React组件是由props和state两种类型的数据驱动渲染出组件UI. props是组件对外的接口, 组件通过props接收外部传入的数据(包括方法);<br>state是组件对内的接口, 组件内部状态的变化通过state来反映。<br>props是只读的, 不能再组件内部修改props, 要修改props只能在父组件中修改;<br>state是可变的, 组件状态的变化<br>通过修改state来实现.</p>
<p>这也是state和props的区别</p>
<h1 id="有状态组件-无状态组件"><a href="#有状态组件-无状态组件" class="headerlink" title="有状态组件 无状态组件"></a>有状态组件 无状态组件</h1><ul>
<li>如果组件内部状态是不变的, 就不用state, 这样的组件称之为无状态组件。</li>
</ul>
<p><strong>无状态组件尽量定义成函数组件.</strong></p>
<p>优点:<br>无状态组件不关心状态变化, 只聚焦于UI展示, 更容易被复用。</p>
<ul>
<li>组件内部状态会发生变化，需要使用state来保存变化，这样的组件称为有状态组件。</li>
</ul>
<p>建议:<br>开发React应用, 一定要先认真思考哪些组件应该设计成有状态组件, 哪些该设计成无状态组件.并且应尽可能多地使用无状态组件。<br>无状态组件数据从父级获取, 组件解耦更彻底.</p>
<p>React组件设计思路:<br>通过定义少数的有状态组件管理整个应用的状态变化, 将状态通过props传递给其余的无状态组件, 由无状态组件完成页面绝大部分UI的渲染工作。<br>有状态组件主要关注处理状态变化的业务逻辑, 无状态组件主要关注组件UI的渲染。</p>
<h1 id="属性校验和默认值"><a href="#属性校验和默认值" class="headerlink" title="属性校验和默认值"></a>属性校验和默认值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import PropTypes from &#39;prop-types&#39;;</span><br><span class="line"></span><br><span class="line">class PostItem extends React.Component &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PostItem.propsTypes &#x3D; &#123;</span><br><span class="line">    post: PropTypes.object,</span><br><span class="line">    onVote: PropTypes.func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果属性是一个对象或数组,至于对象的结构或数组元素类型无法确定。这种情况下使用<code>PropTypes.shape</code> 或<code>PropTypes.arrayOf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">&#125;),</span><br><span class="line">&#x2F;&#x2F; 必传属性 isRequired</span><br><span class="line">sqeuence: PropTypes.arrayof(PropTypes.number).isRequired</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认属性</span><br><span class="line">PostItem.defaultProps &#x3D; &#123;</span><br><span class="line">    name: &#39;Lucy&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组件与元素"><a href="#组件与元素" class="headerlink" title="组件与元素"></a>组件与元素</h1><p>React元素是一个普通的Javascript对象, 通过DOM节点或React组件描述界面.<br>JSX语法就是用来创建React元素的。</p>
<p>React组件是一个class或函数，它接收一些属性作为输入，返回一个React元素。<br>React组件由若干React元素组件而成。</p>
<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h2 id="1-挂载阶段"><a href="#1-挂载阶段" class="headerlink" title="1. 挂载阶段"></a>1. 挂载阶段</h2><ol>
<li>constructor<br>组件被创建时，会先调用组件的构造方法。构造方法接收一个props参数，props是从父组件中传入的属性对象，<br>如果父组件中没有传入属性而组件自身定义了默认属性，props执行组件默认属性。必须在和这个方法中先调用<br><code>super(props)</code>才能保证props被传入组件中.</li>
</ol>
<p>constructor常用于初始化组件的state以及绑定时间处理方法等工作。</p>
<ol start="2">
<li><p>componentWillMount<br> 组件被挂载到DOM前调用，只会调用一次。<br> 调用this.state不会引发组件重新渲染</p>
</li>
<li><p>render<br> 定义组件时唯一必要的方法(其他生命周期方法都可以省略)<br> render并不负责组件的实际渲染工作，只返回UI的描述，渲染页面DOM的工作由React自身负责<br> 不能在render调用<code>this.setState</code>会改变组件状态</p>
</li>
<li><p>componentDidMount<br> 组件被挂载到DOM后调用, 且只会被调用一次。<br> 可以获取到DOM结构, 依赖DOM节点的操作可以放到这个方法中</p>
<p> 通常会用于向服务器请求数据, 调用<code>this.setState</code>会引起组件重新渲染</p>
</li>
</ol>
<h2 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2. 更新阶段"></a>2. 更新阶段</h2><p>props引起组件更新时由渲染该组件的父组件引起的.<br>    当父组件的render被调用时组件会发生更新过程，无论props是否改变，父组件render方法每调用一次，会导致组件更新。<br>state组件更新是通过this.state修改组件state来触发的。</p>
<ol>
<li><p>componentWillReceiveProps(nextProps)<br> props引起组件更新过程才会调用<br> state引起的组件更新不会触发该方法执行。</p>
<p> 需要比较nextProps与this.props来决定是否执行props发生变化后的逻辑</p>
<p> tips:</p>
<pre><code> - componentWillReceiveProps中调用setState，只有在最近render及其之后的方法中，this.state指向的才是更新后的state。
 在render之前的方法shouldComponentUpdate、componentWillUpdate中，this.state依然指向的是更新前的state
 - 调用setState更新组件状态不会触发componentWillReceiveProps的调用，否则会进入死循环
 componentWillReceiveProps-&gt;this.setState-&gt;componentWillReceiveProps</code></pre>
</li>
<li><p>shouldComponentUpdate<br> 通过比较nextprops、nextState和组件当前的props、state决定这个方法的返回结果。<br> true： 继续更细过程<br> false： 组件停止更新，后续方法不执行。</p>
<p> 可以减少组件不必要渲染，优化组件性能。</p>
</li>
<li><p>componentWillUpdate<br> 一般很少用到</p>
<p> shouldComponentUpdate和componentWillUpdate都不能调用setState，否则会引起循环调用。</p>
</li>
<li><p>render</p>
</li>
<li><p>componentDidUpdate(preProps, preState)<br> 更新后调用可以操作更新后的DOM<br> 两个参数代表调用前的props和state</p>
</li>
</ol>
<h2 id="3-卸载阶段"><a href="#3-卸载阶段" class="headerlink" title="3. 卸载阶段"></a>3. 卸载阶段</h2><ol>
<li>componentWillUnmount<br> 组件被卸载前调用<br> 执行清理工作，如：取消定时器，手动创建DOM元素，取消http请求，以避免内存泄漏。</li>
</ol>
<p>==<strong>只有类组件才有生命周期方法，函数组件没有生命周期方法！！！！！！</strong>==</p>
<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> number = ++<span class="built_in">this</span>.state.number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        number: number</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;Click&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h1 id="受控组件-非受控组件"><a href="#受控组件-非受控组件" class="headerlink" title="受控组件 非受控组件"></a>受控组件 非受控组件</h1><ul>
<li><p>受控组件：非表单元素只需根据组件的属性或状态进行渲染<br>  如果一个表单元素的值是由React来管理的，那么它就是一个受控组件。</p>
</li>
<li><p>状态不受React控制的表单元素为非受控组件。input，textarea，select等<br>  React中，装填的修改必须通过组件的state，非受控组件的行为有悖于这一原则。<br>  为了让表单元素状态变更也能通过组件的state管理，React采用受控组件的技术达到这一目的。</p>
<p>  受控组件保证了表单元素的状态也由React统一管理，但需为每个表单元素定义onChange事件的处理函数，<br>  把表单状态同步到React组件的state。这一过程比较繁琐。</p>
</li>
</ul>
<p>一种替代方案是使用非受控组件。<br>表单元素的状态依然由表单元素自己管理，而不是交给React组件管理。使用非受控组件需要有一种方式可以获取到表单元素的值，<br>React中提供了一种特殊的属性ref, 用来引用React组件或DOM实例。因此可以通过为表单元素定义ref属性获取元素的值。</p>
<p>看似简化了操作表单元素的过程，但破坏了React对组件状态管理的一致性，旺旺容易出现不容易排查的问题，<br>非特殊情况，不建议使用。</p>
<h1 id="React-16新特性"><a href="#React-16新特性" class="headerlink" title="React 16新特性"></a>React 16新特性</h1><ol>
<li>render新的返回类型<br> React156之前必须返回单个元素。现在支持两种新的返回类型：数组(由React元素组成)和字符串。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return [</span><br><span class="line">            &lt;li key&#x3D;&quot;A&quot;&gt;First item&lt;&#x2F;li&gt;,</span><br><span class="line">            &lt;li key&#x3D;&quot;B&quot;&gt;Second item&lt;&#x2F;li&gt;,</span><br><span class="line">            &lt;li key&#x3D;&quot;C&quot;&gt;Third item&lt;&#x2F;li&gt;</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StringComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &quot;Just a strings&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>错误处理</li>
</ol>
<p>React16之前运行期执行出错，会阻塞整个应用的渲染。只能刷新页面才能恢复应用。</p>
<p>React16引入新的错误处理机制，默认情况下组件中抛出错误，组件会从组件树中卸载，避免整个应用崩溃。</p>
<p>还提供了错误边界(Error Boundaries),可以输出错误日志，显示错误提示.<br><code>componentDidCatch(error, info)</code></p>
<p>————–我的点评————–<br>项目中目前从后端返回的数据取值。eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.data.userInfo[0].nickName</span><br></pre></td></tr></table></figure>
<p>任何一个节点没有数据都可能引发异常<br>通常需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res &amp;&amp; res.data &amp;&amp; res.data.userInfo &amp;&amp; ...</span><br></pre></td></tr></table></figure>
<p>解决办法：<br>可以自己写个isEmpty 或引用<a href="https://www.npmjs.com/package/lodash.isempty">lodash.isEmpty</a></p>
<ol start="3">
<li>Portals<br>可以把组件渲染到当前组件树以外的DOM节点上。典型应用场景是渲染应用的全局弹框。<br>使用Portals后，任意组件都可以将弹框组件渲染到根节点上。</li>
</ol>
<p>Portals的实现依赖ReactDOM的一个新API:<code>ReactDOM.createPortal(child, container)</code><br>第一个参数child是可以被渲染的React节点。container是一个DOM元素，child将被挂载到这个DOM节点。</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="comment">// 根节点下创建一个div节点</span></span><br><span class="line">        <span class="built_in">this</span>.container = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(<span class="built_in">this</span>.container);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(<span class="built_in">this</span>.container);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建的DOM树挂载到this.container指向的div节点下面</span></span><br><span class="line">        <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">            &lt;div className=<span class="string">&quot;modal&quot;</span>&gt;</span><br><span class="line">                &lt;span className=<span class="string">&quot;close&quot;</span> onClick=</span><br><span class="line">                    &#123;<span class="built_in">this</span>.props.onClose&#125;&gt;</span><br><span class="line">                    &amp;times;</span><br><span class="line">              &lt;/span&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;content&quot;</span>&gt;</span><br><span class="line">                    &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;,</span><br><span class="line">            <span class="built_in">this</span>.container</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>App中使用Modal</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123; <span class="attr">showModal</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    closeModal = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123; <span class="attr">showModal</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;Dashboard&lt;/h2&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.showModal &amp;&amp; (</span><br><span class="line">                    &lt;Modal onClose=&#123;<span class="built_in">this</span>.closeModal&#125;&gt;Modal Dialog&lt;/Modal&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;/div&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><p>自定义DOM属性<br> React16可以识别自定义属性, 传递给DOM元素<br> <code>&lt;div custom-attribute=&quot;something&quot; /&gt;</code></p>
</li>
<li><p>还有其他特性<br> setState传入null时不会再触发组件更新<br> 更高效的服务器端渲染方式</p>
</li>
</ol>
<h1 id="设计合适的state"><a href="#设计合适的state" class="headerlink" title="设计合适的state"></a>设计合适的state</h1><p>state必须能代表一个组件UI呈现的完整状态集。组件的任何UI改变都可以从state的变化中反映出来; 同时state还必须代表一个组件UI呈现的最小状态集，<br>即state中的所有状态都用于反映组件UI的变化，没有任何多余状态，也不应该存在通过其他状态计算而来的中间状态。</p>
<p>eg:<br>错误的state</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    purchaseList: [],</span><br><span class="line">    totalCost: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含无用的状态totalCost，totalCost可以根据购买的每一项物品的价格和数量计算得出。totalCost属于中间状态，可以省略。</p>
<p>state可以分为两类数据：</p>
<ul>
<li>用作渲染组件时使用到的数据来源</li>
<li>用作组件UI展现形式的判断依据</li>
</ul>
<p>state与组件的普通属性</p>
<p>定义：除了state，props以外的组件属性成为组件的普通属性。<br> 在ES6中，可以使用this.{属性名}定义一个class的属性，可以说属性是直接挂载到this下的变量。<br>因此state， props也是组件的属性，只不过它们是React为我们Component Class中预定义好的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.timer = <span class="literal">null</span>; <span class="comment">// 普通属性</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：<br>当组件中需要用到一个变量，并且它与组件的渲染无关时，就应该把这个变量定义为组件的普通属性，直接挂载到this下，而不是作为组件state。<br>更直观的判断方法，看组件render方法中有没有用到这个变量，没有，就是普通属性。</p>
<p>总结：<br>判断一个变量是不是应该作为state可以通过以下4条依据判断：</p>
<ol>
<li>是否通过props从父组件中获取？是，不是state</li>
<li>是否在组件整个生命周期中保持不变？是，不是state</li>
<li>是否可以通过其他state或props计算得到？是，不是state</li>
<li>是否在组件render方法中使用？是，不是state，定义为普通属性更合适</li>
</ol>
<h1 id="state的修改"><a href="#state的修改" class="headerlink" title="state的修改"></a>state的修改</h1><ol>
<li>不能直接修改 <code>this.state.title = &#39;react&#39; //错误</code></li>
<li>state更新是异步的</li>
<li>state的更新时一个合并的过程</li>
</ol>
<h1 id="state与不可变对象"><a href="#state与不可变对象" class="headerlink" title="state与不可变对象"></a>state与不可变对象</h1><p>React官方建议把state当做不可变对象：</p>
<ul>
<li>直接修改this.state, 组件不会重新render</li>
<li>state中包含的所有状态都应该是不可变对象</li>
</ul>
<p>state中的某个状态发生变化，应该重新创建这个状态对象，而不是直接修改原来的状态。</p>
<h3 id="如何创建新的状态呢？三种情况"><a href="#如何创建新的状态呢？三种情况" class="headerlink" title="如何创建新的状态呢？三种情况"></a>如何创建新的状态呢？三种情况</h3><ol>
<li>不可变类型(数字，字符串，布尔值，null，undefined)—直接赋值 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">&#x27;React&#x27;</span>,</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>数组—concat, 扩展语法(spread syntax) <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    books: preState.books.concat([<span class="string">&#x27;React Guide&#x27;</span>])</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    books: [...preState.books, <span class="string">&#x27;React Guide&#x27;</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>截取部分元素作为新状态<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    books: preState.books.slice(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
<li>过滤部分元素作为新状态<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    books: preState.books.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item !== <span class="string">&#x27;React&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
注意：不要使用push,pop,shift,unshift,splice等方法修改数组类型状态。因为这些方法都是在原数组基础上修改，而从concat,slice,filter会<br>返回一个新数组。</li>
</ul>
<ol start="3">
<li>普通对象(不包含字符串，数组)—Object.assign,对象扩展语法(object spread properties)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    owner: <span class="built_in">Object</span>.assign(&#123;&#125;, preState.owner, &#123;<span class="attr">name</span>: <span class="string">&#x27;James Bond&#x27;</span>&#125;)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    owner: &#123;...preState.owner, <span class="attr">name</span>: <span class="string">&#x27;James Bond&#x27;</span>&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>总结：<br>    创建新状态对象的关键，避免使用会直接修改原对象的方法，而使用可以返回一个新对象的方法。<br>    也可用一些Immutable的JS库，(如Immutable.js)</p>
<p>为什么组件的状态是不可变对象？</p>
<ul>
<li>对不可变兑现的修改会返回一个新对象，不用但系原有对象在不小心情况下修改导致的错误，方便管理和调试</li>
<li>出于性能考虑，当对象组件状态都是不可变对象时，在shouldComponentUpdate方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，<br>避免不必要的render调用。</li>
</ul>
<h1 id="componentDidMount执行请求最佳，原因两个"><a href="#componentDidMount执行请求最佳，原因两个" class="headerlink" title="componentDidMount执行请求最佳，原因两个"></a>componentDidMount执行请求最佳，原因两个</h1><ol>
<li>在componentDidMount中执行请求可以保证获取到数据时，组件已处于挂载状态。即使操作DOM也是安全的。<br> componentWillMount无法保证</li>
<li>组件在服务端渲染时componentWillMount会调用两次，一次在服务端，一次在浏览器端。<br> 而componentDidMount能保证在任何情况下只调用一次。不会发送多余的请求。</li>
</ol>
<p>组件更新阶段也可以发送请求，获取服务最新数据。<br>例如：组件需要以props中某个属性作为与服务器通信时请求参数，当这个值发生更新，需要重新发起请求。<br>在componentWillReceiveProps阶段处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;</span><br><span class="line">        fetch(<span class="string">&#x27;url&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fetch之前需要对nextProps判断，如果不一致再发起请求</p>
<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><h2 id="父子组件通信–通过props"><a href="#父子组件通信–通过props" class="headerlink" title="父子组件通信–通过props"></a>父子组件通信–通过props</h2><p>父向子是通过父组件向子组件的props传递数据完成</p>
<p>子向父：父组件通过子组件的props传递给子组件一个回调函数，子组件在需要改变父组件时，调用这个回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line">&lt;UserList users=&#123;<span class="built_in">this</span>.state.users&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父</span></span><br><span class="line">&lt;UserList users=&#123;<span class="built_in">this</span>.state.users&#125; onAddUser=&#123;<span class="built_in">this</span>.handleAddUser&#125;/&gt;</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.props.onAddUser&#125;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h2><p>兄弟组件：有相同父组件，不是父子组件的组件。</p>
<p>兄弟组件不能直接互传数据，需要通过状态提升的方式实现兄弟组件的通信。<br>把组件之间需要共享的状态保存到距离它们最近的共同父组件内，任一兄弟组件都可以通过父组件传递的回调函数来修改共享状态，父组件中的共享状态的变化也会<br>通过props向下传递给所有兄弟组件，完成兄弟组件之间的通信</p>
<h2 id="Context–实验性API-不建议使用，会让数据流变得混乱"><a href="#Context–实验性API-不建议使用，会让数据流变得混乱" class="headerlink" title="Context–实验性API,不建议使用，会让数据流变得混乱"></a>Context–实验性API,不建议使用，会让数据流变得混乱</h2><p>组件层级太深，props传递层级繁琐。<br>context让任意层级的子组件都可以获取父组件的状态和方法</p>
<h2 id="其他通信方式"><a href="#其他通信方式" class="headerlink" title="其他通信方式"></a>其他通信方式</h2><ul>
<li>消息队列<br>  改变数据的组件发起消息，使用数据的组件监听，在响应函数中触发setState改变组件状态。–观察者模式<br>  (EventEmitter或Postal.js等消息队列库)</li>
<li>Redux, MobX状态管理库。</li>
</ul>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p>优点：<br>    获取表单元素，获取其他任意DOM元素，获取React组件实例<br>用处：控制元素焦点，文本选择，第三方操作DOM库集成</p>
<p>缺点：避免使用ref,破坏了React中以props为数据传递介质的典型数据流<br>ref接收一个回调函数作为值，在组件被挂载或卸载时，回调函数会被调用。<br>组件被挂载时，回调函数会接收当前DOM元素作为参数；组件被卸载时回调函数会接收null作为参数</p>
<ol>
<li><p>在DOM 上使用ref<br>让input自动获取焦点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过ref让input自动获取焦点</span></span><br><span class="line">        <span class="built_in">this</span>.textInput.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    blur= <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.textInput.blur();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=<span class="string">&#x27;text&#x27;</span> ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> &#123;<span class="built_in">this</span>.textInput = input&#125;&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件上使用ref<br>ref的回调函数接收的参数是当前组件的实例。提供了一种在组件外部操作组件的方式。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过ref调用AutoFocusInput组件的方法</span></span><br><span class="line"><span class="built_in">this</span>.inputInstance.blur();</span><br><span class="line">&lt;AutoFocusInput ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> &#123;<span class="built_in">this</span>.inputInstance = input&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>注意：只能为累组件定义ref属性，不能为函数组件定义ref属性。但可以在函数组件内部使用ref引用其他DOM元素或组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFuncitonCom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> textInput = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        textInput.focus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> &#123;textInput = input;&#125;&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;handleClick&#125;&gt;获取焦点&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>父组件访问子组件的DOM节点<br>因为ref只能访问子组件的实例对象，而不能获取子组件中的某个DOM元素。</li>
</ol>
<p>可以采用一种间接方式获取子组件的DOM元素：在子组件的DOM元素上定义ref, ref的值是父组件传递给子组件的一个回调函数，回调函数可以通过一个自定义<br>的属性传递，例如inputRef,这样父组件的回调函数中就能获取到这个DOM元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子组件使用父组件传递的inputRef， 为input的ref赋值</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input ref=&#123;props.inputRef&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义一个属性inputRef, 值是一个函数</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Children inputRef=&#123;<span class="function"><span class="params">el</span> =&gt;</span> <span class="built_in">this</span>.inputElement = el&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到即使子组件是函数组件，这种方式同样有效。</p>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><p>虚拟DOM是用来描述真实DOM的JavaScript对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div className&#x3D;&#39;foo&#39;&gt;</span><br><span class="line">    &lt;h1&gt;Hello React&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">对应的JavaScript对象</span><br><span class="line">&#123;</span><br><span class="line">    type: &#39;div&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        className: &#39;foo&#39;,</span><br><span class="line">        children: &#123;</span><br><span class="line">            type: &#39;h1&#39;,</span><br><span class="line">            props: &#123;</span><br><span class="line">                children: &#39;Hello React&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟DOM是普通的JavaScript对象，访问JavaScript对象当然比访问真实DOM快得多</p>
<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><p>React采用声明式API描述UI结构，每次组件的状态或属性更新，render方法都会返回一个新的虚拟DOM对象，用来标书新的UI结构。如果每次render都直接使用<br>新的虚拟DOM来生成真实DOM结构，会带来大量对真实DOM操作，影响效率。React通过<strong>比较两次虚拟DOM结构的变化找出差异部分，更新到真实DOM上</strong>，从而减少<br>最终要在真实DOM上的操作，提高效率。这就是React的调和过程(Reconciliation).其中的关键是比较两个树形结构的Diff算法。<br>基于两种假设, 算法复杂度从O(N^3)–&gt; O(N)</p>
<ol>
<li>两个元素类型不同，它们将生成两棵不同的树</li>
<li>为列表元素设置key属性，用key标识对应元素在多次render过程中是否发生变化</li>
</ol>
<h2 id="React如何比较两棵树的差异"><a href="#React如何比较两棵树的差异" class="headerlink" title="React如何比较两棵树的差异"></a>React如何比较两棵树的差异</h2><p>从根节点开始比较，根节点类型不同，React执行的操作也不同</p>
<ol>
<li>根节点不同类型<br>React认为新树和旧树完全不同，不再继续比较其他属性和子节点。把整棵树拆掉重建(包括虚拟DOM和真实DOM)</li>
</ol>
<p>虚拟DOM节点分为两类：DOM元素，div,p等；react组件类型，自定义组件等。<br>拆除过程中，旧的DOM元素类型节点被销毁，旧的react组件实例的componentWillUnmount会被调用<br>重建过程中，新的DOM元素被插入DOM树，新的组件实例的componentWillMount和componentDidMount会被调用</p>
<p>更新效率最低</p>
<ol start="2">
<li><p>根节点是相同DOM元素类型<br>两个根节点相同类型的DOM元素，React会保留根节点，比较根节点的属性，然后只更新那些变化了的属性</p>
</li>
<li><p>根节点是相同的组件类型<br>两个根节点是相同类型的组件，对应的组件实例不会被销毁，只是会执行更新操作。同步变化的属性到虚拟DOM树上，<br>组件的componentWillReceiveProps和componentWillUpdate会被调用</p>
</li>
</ol>
<p>需在组件更新并且render方法执行完成后，根据render返回的虚拟DOM结构决定如何更新真实DOM树</p>
<p>如此递归比较，直到比较完两棵树上所有节点，计算得到最终差异，更新到DOM树上。</p>
<h1 id="key的重要性"><a href="#key的重要性" class="headerlink" title="key的重要性"></a>key的重要性</h1><p>对多个li这种情况，React提供了key属性。<br>key帮助React提高diff算法效率。当一组子节点定义了key，React会根据key来匹配子节点，在每次渲染之后，只要子节点的key值没有变化，React就认为这是<br>同一个节点。<br>尽量不要使用元素在列表中的索引值作为key，因为列表中的元素顺序发生变化，可能导致大量的key失效，进而引起大量的修改操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>key的使用，减少了DOM操作，提高了DOM更新效率，当列表元素数量很多时，key的使用更显得重要</p>
<h1 id="React性能优化"><a href="#React性能优化" class="headerlink" title="React性能优化"></a>React性能优化</h1><ol>
<li>使用生产环境版本的库</li>
<li>避免不必要的组件渲染–shouldComponentUpdate， pureComponent</li>
<li>使用key</li>
</ol>
<h1 id="性能检测工具"><a href="#性能检测工具" class="headerlink" title="性能检测工具"></a>性能检测工具</h1><ol>
<li>React Developer Tools for Chrome<br>背景是黑色表示用生产环境版本的React，红色表示开发环境版本</li>
<li>Chrome Performance Tab</li>
<li>why-did-you-update</li>
</ol>
<h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>主要用来实现组件逻辑的抽象和服用<br><strong>本质</strong>：也是一个函数，并不是一个组件  装饰器设计模式</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JavaScript中，高阶组件是以函数为参数，并且返回值也是函数的函数。<br>类似的高阶组件(简称HOC), 接收React组件作为参数，并且返回一个新的React组件</p>
<p>形式：<code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code></p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>封装并分离组件的通用逻辑，让通用逻辑在组件间更好的被复用。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>操纵props</li>
<li>通过ref访问组件实例</li>
<li>组件状态提升</li>
<li>用其他元素包装组件</li>
</ol>
<h1 id="React-Router—"><a href="#React-Router—" class="headerlink" title="React Router—-"></a>React Router—-</h1><h1 id="划分组件原则"><a href="#划分组件原则" class="headerlink" title="划分组件原则"></a>划分组件原则</h1><p>划分页面组件需要根据页面结构、组件的复用性、组件的复杂度等因素综合考虑</p>
<p>划分组件两个极端，组件粒度过大或过小。过大，组件逻辑过于复杂，可维护性和复用性变差；<br>过小，组件数量激增，一个简单功能需引入大量组件，增加开发成本，过多也不利于查找。</p>
<p>一种观点是一个组件只负责一个功能。建议辩证看待。如果几个功能都很简单，且每一个功能都没有复用需求，<br>那么把这几个功能放到一个组件也可，提高开发效率。</p>
<h1 id="代码分片"><a href="#代码分片" class="headerlink" title="代码分片"></a>代码分片</h1><p>实现代码按需加载，提高应用加载速度</p>
<ol>
<li>借助<a href="https://github.com/webpack-contrib/bundle-loader">bundle-loader</a>来实现按需加载。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ListContainer <span class="keyword">from</span> <span class="string">&#x27;bundle-loader?lazy&amp;name=app-[name]!./app/list.js&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>动态import</li>
</ol>
<hr>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>Redux 通过reducer解析action</p>
<p>reducer是一个普通的JavaScript函数，接收action为参数，然后返回一个新的应用状态state。</p>
<p>主要思想：描述应用的状态如何根据action进行更新，Redux通过提供一系列API将这一主要思想的落地实施进行标准化和规范化。</p>
<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ol>
<li><p>唯一数据源<br>Redux只维护一个全局的状态对象，存储在Redux的store中。唯一数据源是一种集中式管理应用状态的方式，便于监控任意时刻应用的状态和调试应用，减少出错可能性。</p>
</li>
<li><p>保持应用状态只读<br>任何时刻都不能直接修改应用状态。需要修改，必须发送一个action，由这个action描述如何修改应用状态。<br>保证了大型应用中状态管理的有序进行。</p>
</li>
<li><p>应用状态的改变通过纯函数完成<br>action表明修改应用状态的意图，真正对应用状态做修改的是reducer</p>
</li>
</ol>
<p>reducer必须是纯函数，所以reducer在接收action时，不能直接修改原来的状态对象，而要创建一个新的状态对象返回。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>必须满足两个条件</p>
<ol>
<li>对于同样的参数值，函数的返回结果总是相同的。函数结果不依赖任何在程序执行过程中可能改变的变量。</li>
<li>函数的执行不会产生副作用，例如修改外部对象或输出到I/O设备。</li>
</ol>
<h2 id="主要组成"><a href="#主要组成" class="headerlink" title="主要组成"></a>主要组成</h2><p>action, reducer, store</p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action是Redux中信息的载体， 是store唯一的信息来源。<br>action发送给store必须通过store的dispatch。</p>
<p>action是普通的JavaScript对象，但每个action必须有一个type属性描述action的类型，一般被定义为字符串常量。除了type属性之外，action的结构完全由自己决定，但应该能确保action的结构能清晰的描述实际业务场景。</p>
<p>一般通过action creator创建action， action creator是返回action的函数。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>action用于描述应用发生了什么操作， reducer则根据action做出响应，决定如何修改state.</p>
<p>state既可以包含服务器端获取的数据，也可以包含UI状态。</p>
<p>最基本的reducer, eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; VisibilityFilters &#125; <span class="keyword">from</span> <span class="string">&#x27;./acitons&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    todos: [],</span><br><span class="line">    visibilityFilter: VisibilityFilters.SHOW_ALL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store是action和reducer之间的桥梁。负责以下工作：</p>
<ol>
<li>保存应用状态</li>
<li>通过getState访问应用状态</li>
<li>通过dispatch(action)发送更新状态的意图</li>
<li>通过subscribe(listener)注册监听函数、监听应用状态的改变。</li>
</ol>
<p>一个Redux应用中只有一个store，store保存了唯一数据源。<br>store通过createStore()创建，创建时需要传递reducer作为参数，创建store。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;</span><br><span class="line">import todoApp from &#39;.&#x2F;reducers&#39;</span><br><span class="line"></span><br><span class="line">let store &#x3D; createStore(todoApp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结redux数据流过程"><a href="#总结redux数据流过程" class="headerlink" title="总结redux数据流过程"></a>总结redux数据流过程</h2><ol>
<li>调用store.dispatch(action)。可以在任何地方调用。包括组件，XHR回调，定时器等。</li>
<li>store调用reducer。store传递两个参数给reducer：当前应用的状态和action。</li>
<li>根reducer会把多个子reducer的返回结果组合成最终的应用状态。redux提供了combineReducer方便组合。</li>
<li>store保存根reducer返回的完整应用状态。此时应用状态才完成更新。</li>
</ol>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="展示组件和容器组件"><a href="#展示组件和容器组件" class="headerlink" title="展示组件和容器组件"></a>展示组件和容器组件</h3><p>根据组件意图的不同，可以将组件划分为两类：展示组件(presentational components)和容器组件(container components).</p>
<p>展示组件负责应用的UI展示(how things look), 展示组件不关心渲染时使用的数据是如何获取的，数据如何获取是容器组件负责的事情。</p>
<p>容器组件负责应用逻辑的处理(how things work), 如发送请求，处理返回数据，将处理过的数据传递给展示组件等。还提供修改源数据的方法，通过展示组件的props传递给展示组件，当展示组件的状态变更引起源数据变化时，展示组件通过调用容器组件提供的方法同步这些变化。</p>
<p>展示组件和容器组件可以自由嵌套。这样的分工可以使与UI渲染无直接关系的业务逻辑由容器组件集中负责，展示组件只关注UI的渲染逻辑，从而使展示组件更容易被复用。</p>
<blockquote>
<p>展示组件和容器组件与无状态组件和有状态组件区别：<br>划分依据：<br>展示组件和容器组件是根据组件的意图划分组件<br>无状态组件和有状态组件是根据组件内部是否使用state划分组件。</p>
</blockquote>
<p>通常展示组件是通过无状态组件实现，容器组件通过有状态组件实现。但展示组件也可以是有状态组件，容器组件也可以是无状态组件。</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>react-redux提供了connect函数，用于把react组件和redux的store连接起来，生成一个容器组件，负责管理数据管理和业务逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">&#x27;./TodoList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect()(TodoList);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据Redux的数据流过程，VisibleTodoList需要承担两个工作：</p>
<ol>
<li>从Redux的store中获取展示组件所需的应用状态</li>
<li>把展示组件的状态同步到Redux的store中</li>
</ol>
<p>通过两个参数实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">&#x27;./TodoList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps</span><br><span class="line">)(TodoList);</span><br></pre></td></tr></table></figure>

<p>mapStateToProps 和 mapDsipatchToProps 的类型都是函数，前者负责从全局应用状态state中取出所需数据，映射到展示组件的props，后者负责把需要用到的action映射到展示组件的props上</p>
<h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h3><p>mapStateToProps作用是把state转换成props。state是store中保存的应用状态，会作为参数传递给mapStateToProps，props是被连接的展示组件的props。</p>
<p>每当store中的state更新时，mapStateToProps会重新执行，重新计算传递给展示组件的props，从而触发组件的重新渲染。</p>
<blockquote>
<p>store中的state更新一定会导致mapStateToProps重新执行，但不一定会触发组件render方法的重新执行。如果mapStateToProps新返回的对象和之前的对象浅比较(shallow comparison)相等，组件的shouldComponentUpdate会返回false，render不再触发。</p>
</blockquote>
<p>connect可以省略mapStateToProps参数，这样state的更新就不会引起组件的重新渲染。</p>
<p>mapStateToProps除了接收state参数外，还可以使用第二个参数，代表容器组件的props对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ownProps 是组件的props对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state, ownProps</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><p>！！！！<br>容器组件除了可以从state中读取数据外，还可以发送action更新state，这依赖于connect的第二个参数 mapDispatchToProps. mapDispatchToProps 接收 store.dispatch 方法作为参数返回展示组件用来修改state的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toggleTodo(id) 返回一个action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleTodo</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>: <span class="string">&#x27;TOGGLE_TODO&#x27;</span>, id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        onTodoClick: <span class="function"><span class="title">funciton</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">            dispatch(toggleTodo(id))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样展示组件内就可以调用 this.props.onTodoClick(id) 的action。<br>与mapStateToProps相同，mapDispatchToProps也支持第二个参数，代表容器组件的props。</p>
<h3 id="Provider组件"><a href="#Provider组件" class="headerlink" title="Provider组件"></a>Provider组件</h3><p>通过connect函数创建出容器组件，但这个容器组件如何获取到Redux的store？react-redux提供了Provider组件，示意代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            store: <span class="built_in">this</span>.props.store</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">    store: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Provider组件需要接收一个store属性，然后把store保存到context。Provider组件正是通过context把store传递给子组件，所以使用Provider组件时，一般把它作为根组件，这样内层的任意组件才可以从context中获取store对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="中间件与异步操作"><a href="#中间件与异步操作" class="headerlink" title="中间件与异步操作"></a>中间件与异步操作</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>redux的action类比web框架收到的请求，reducer类比web框架的业务逻辑层，因此redux的中间件代表action在到达reducer前经过的处理程序。</p>
<p>实际上，一个redux中间件就是一个函数。redux中间件增强了store的功能，可以利用中间件为action添加一些通用功能，如日志输出，异常捕获等。</p>
<p>通过改造 store.dispatch 增加日志输出功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;dispatching&#x27;</span>, action)</span><br><span class="line">    <span class="keyword">let</span> result = next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;next state&#x27;</span>, store.getState())</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过重新定义store.dispatch，在发送action前后都添加了日志输出，这就是中间件的雏形。</p>
<p>对store.dispatch方法进行搞糟，在发出action和执行 reducer 这两步之间添加其他功能。</p>
<p>实际项目中通常使用别人直接写好的中间件。如redux-logger.</p>
<p>在应用中会用到applyMiddleware。通过applyMiddleware将中间件logger传给createStore, 完成store.dispatch功能的加强。</p>
<p>applyMiddleware把接收到的中间件放入数组chain中，通过compose(…chain)(store.dispatch)定义加强版的dispatch。</p>
<p>compose是工具函数，compose(f, g, h)等价于 (…args)=&gt;f(g(h(args))). 每个中间件都接收一个包含getState和dispatch的参数对象，在利用中间件执行异步操作时，会用到这两个方法。</p>
<h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>redux中的异步操作必须借助中间件完成。</p>
<p><a href="">redux-thunk</a>是处理异步操作最常用的中间件。</p>
<p>store.dispatch 只能接收普通JavaScript对象代表的action，使用redux-thunk，store.dispatch 就能接收函数作为参数了。异步action先经过redux-thunk的处理，当请求返回后，再发送一个action: dispatch({type: ‘RECEIVE_DATA’, json}), 把返回的数据发送出去，这时的action就是一个普通的JavaScript对象了，处理流程和不使用中间件流程一样。</p>
<blockquote>
<p>常用中间件 redux-promise, redux-sage等。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章详细介绍了redux架构以及Redux各组成部分(action, reducer, store)，在react项目中使用redux需要借助react-redux，可以方便的将react组件和redux的store连接。中间件是redux的一大利器，redux中执行异步操作就是通过引入中间件实现的。</p>
<h1 id="redux实战经验"><a href="#redux实战经验" class="headerlink" title="redux实战经验"></a>redux实战经验</h1><h2 id="设计state"><a href="#设计state" class="headerlink" title="设计state"></a>设计state</h2><p>设计state<strong>容易犯的两个错误</strong>：</p>
<ol>
<li>以API作为设计state的依据<br>以API作为设计state的依据往往是一个API对应全局state中的一部分结构，且这部分结构同API返回的数据结构保持一致或接近一致。</li>
</ol>
<p>因为API是基于服务端逻辑设计的，而不是基于应用状态设计的。</p>
<ol start="2">
<li>以页面UI为设计state的依据<br>基于页面UI设计state 。页面UI需要什么样的数据和数据结构，state就设计成什么样。</li>
</ol>
<h3 id="合理设计state"><a href="#合理设计state" class="headerlink" title="合理设计state"></a>合理设计state</h3><p>最重要一句话：像设计数据库一样设计state。</p>
<p>把state看做一个数据库，state中的每一部分状态看做数据库中的一张表，状态中每个字段对应表的一个字段。</p>
<p>设计数据库遵循三个原则：</p>
<ul>
<li><ol>
<li>数据按照领域(Domain)分类存储在不同的表中，不同表中存储的列数据不能重复</li>
</ol>
</li>
<li><ol start="2">
<li>表中每一列的数据都依赖于这张表的主键</li>
</ol>
</li>
<li><ol start="3">
<li>表中除了主键以外其他列互相之间不能有直接依赖关系</li>
</ol>
</li>
</ul>
<p>对照以上三个原则，设计state原则：</p>
<ul>
<li><ol>
<li>整个应用的状态按照领域分成若干子状态，子状态之间不能保存重复的数据</li>
</ol>
</li>
<li><ol start="2">
<li>state以键值对的结构存储数据，以记录的key活ID作为记录索引，记录中的其他字段都依赖于索引</li>
</ol>
</li>
<li><ol start="3">
<li>state中不能保存可以通过state中的已有字段计算而来的数据，即state中的字段不互相依赖。</li>
</ol>
</li>
</ul>
<blockquote>
<p>有开发者习惯把UI状态数据保存在组件state中，由组件自己管理，而不是交给Redux管理。但将UI状态数据也交给redux统一管理有利于应用UI状态的追溯。</p>
</blockquote>
<h2 id="设计模块"><a href="#设计模块" class="headerlink" title="设计模块"></a>设计模块</h2><p>定义模块不能只被UI组件使用，各个模块之间也可以互相调用</p>
<blockquote>
<p>action和reducer之间并不存在一对一的关系。一个action可以被多个模块的reducer处理，尤其是多个模块之间存在关联关系时。</p>
</blockquote>
<p>良好的模块设计对外暴露的应该是模块的接口，而不是模块的具体结构</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1>]]></content>
      <tags>
        <tag>React</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法总结（JavaScript描述）</title>
    <url>/posts/s/</url>
    <content><![CDATA[<p>========================</p>
<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li><p>这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，JavaScript可谓风头无两，已经坐上了头把交椅。</p>
</li>
<li><p>在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（十大排序算法或是和十大排序算法同等难度的），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。</p>
</li>
<li><p>算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。</p>
<p>  <img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="大大"></p>
</li>
</ul>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h3><p><strong>（1）排序的定义：对一序列对象根据某个关键字进行排序；</strong></p>
<p>输入：n个数：a1,a2,a3,…,an 输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。</p>
<p><strong>（3）对于评述算法优劣术语的说明</strong></p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； <strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成； <strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。 <strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>
<p>关于时间空间复杂度的更多了解请戳<a href="http://blog.csdn.net/booirror/article/details/7707551/">这里</a>，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。</p>
<p><strong>（4）排序算法图片总结(图片来源于网络):</strong></p>
<p>排序对比：</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p><strong>图片名词解释：</strong> n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存</p>
<p>排序分类：</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><blockquote>
<p>好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>&lt;2&gt;.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>&lt;3&gt;.针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>&lt;4&gt;.重复步骤1~3，直到排序完成。</li>
</ul>
<p><strong>JavaScript代码实现：</strong></p>
<pre><code>function bubbleSort(arr) &#123;
    var len = arr.length;
    for (var i = 0; i &lt; len; i++) &#123;
        for (var j = 0; j &lt; len - 1 - i; j++) &#123;
            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<blockquote>
<p>**改进冒泡排序： **设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<p>改进后算法如下:</p>
<pre><code>function bubbleSort2(arr) &#123;
    console.time(&#39;改进后冒泡排序耗时&#39;);
    var i = arr.length-1;  //初始时,最后位置保持不变
    while ( i&gt; 0) &#123;
        var pos= 0; //每趟开始时,无记录交换
        for (var j= 0; j&lt; i; j++)
            if (arr[j]&gt; arr[j+1]) &#123;
                pos= j; //记录交换的位置
                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            &#125;
        i= pos; //为下一趟排序作准备
     &#125;
     console.timeEnd(&#39;改进后冒泡排序耗时&#39;);
     return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<blockquote>
<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
</blockquote>
<p>改进后的算法实现为:</p>
<pre><code>function bubbleSort3(arr3) &#123;
    var low = 0;
    var high= arr.length-1; //设置变量的初始值
    var tmp,j;
    console.time(&#39;2.改进后冒泡排序耗时&#39;);
    while (low &lt; high) &#123;
        for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者
            if (arr[j]&gt; arr[j+1]) &#123;
                tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            &#125;
        --high;                 //修改high值, 前移一位
        for (j=high; j&gt;low; --j) //反向冒泡,找到最小者
            if (arr[j]&lt;arr[j-1]) &#123;
                tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp;
            &#125;
        ++low;                  //修改low值,后移一位
    &#125;
    console.timeEnd(&#39;2.改进后冒泡排序耗时&#39;);
    return arr3;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<p>三种方法耗时对比：</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<blockquote>
<p>由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~</p>
</blockquote>
<p><strong>冒泡排序动图演示:</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p><strong>(3)算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
</ul>
<blockquote>
<p>当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</p>
</blockquote>
<ul>
<li>最差情况：T(n) = O(n2)</li>
</ul>
<blockquote>
<p>当输入的数据是反序时(卧槽，我直接反序不就完了….)</p>
</blockquote>
<ul>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><blockquote>
<p>表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
</blockquote>
<h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.初始状态：无序区为R[1..n]，有序区为空；</li>
<li>&lt;2&gt;.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>&lt;3&gt;.n-1趟结束，数组有序化了。</li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<pre><code>function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    console.time(&#39;选择排序耗时&#39;);
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    console.timeEnd(&#39;选择排序耗时&#39;);
    return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]


复制代码</code></pre>
<p><strong>选择排序动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..</p>
</blockquote>
<h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.从第一个元素开始，该元素可以认为已经被排序；</li>
<li>&lt;2&gt;.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>&lt;3&gt;.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>&lt;4&gt;.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>&lt;5&gt;.将新元素插入到该位置后；</li>
<li>&lt;6&gt;.重复步骤2~5。</li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<pre><code>function insertionSort(array) &#123;
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39;) &#123;
        console.time(&#39;插入排序耗时：&#39;);
        for (var i = 1; i &lt; array.length; i++) &#123;
            var key = array[i];
            var j = i - 1;
            while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;
                array[j + 1] = array[j];
                j--;
            &#125;
            array[j + 1] = key;
        &#125;
        console.timeEnd(&#39;插入排序耗时：&#39;);
        return array;
    &#125; else &#123;
        return &#39;array is not an Array!&#39;;
    &#125;
&#125;

复制代码</code></pre>
<blockquote>
<p><strong>改进插入排序：</strong> 查找插入位置时使用二分查找的方式</p>
</blockquote>
<pre><code>function binaryInsertionSort(array) &#123;
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39;) &#123;
        console.time(&#39;二分插入排序耗时：&#39;);

        for (var i = 1; i &lt; array.length; i++) &#123;
            var key = array[i], left = 0, right = i - 1;
            while (left &lt;= right) &#123;
                var middle = parseInt((left + right) / 2);
                if (key &lt; array[middle]) &#123;
                    right = middle - 1;
                &#125; else &#123;
                    left = middle + 1;
                &#125;
            &#125;
            for (var j = i - 1; j &gt;= left; j--) &#123;
                array[j + 1] = array[j];
            &#125;
            array[left] = key;
        &#125;
        console.timeEnd(&#39;二分插入排序耗时：&#39;);

        return array;
    &#125; else &#123;
        return &#39;array is not an Array!&#39;;
    &#125;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<blockquote>
<p>改进前后对比：</p>
</blockquote>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p><strong>插入排序动图演示:</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><blockquote>
<p>1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序</p>
</blockquote>
<h4 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。</p>
</blockquote>
<h4 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>&lt;1&gt;. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>&lt;2&gt;.按增量序列个数k，对序列进行k 趟排序；</li>
<li>&lt;3&gt;.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>function shellSort(arr) &#123;
    var len = arr.length,
        temp,
        gap = 1;
    console.time(&#39;希尔排序耗时:&#39;);
    while(gap &lt; len/5) &#123;          //动态定义间隔序列
        gap =gap*5+1;
    &#125;
    for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;
        for (var i = gap; i &lt; len; i++) &#123;
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;
                arr[j+gap] = arr[j];
            &#125;
            arr[j+gap] = temp;
        &#125;
    &#125;
    console.timeEnd(&#39;希尔排序耗时:&#39;);
    return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

复制代码</code></pre>
<p><strong>希尔排序图示（图片来源网络）：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="（3）算法分析"><a href="#（3）算法分析" class="headerlink" title="（3）算法分析"></a>（3）算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h4 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p> 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<h4 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>&lt;2&gt;.对这两个子序列分别采用归并排序；</li>
<li>&lt;3&gt;.将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><strong>Javscript代码实现:</strong></p>
<pre><code>function mergeSort(arr) &#123;  //采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    var result = [];
    console.time(&#39;归并排序耗时&#39;);
    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());
    console.timeEnd(&#39;归并排序耗时&#39;);
    return result;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(mergeSort(arr));

复制代码</code></pre>
<p><strong>归并排序动图演示:</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><blockquote>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。</p>
</blockquote>
<h4 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h4 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>&lt;2&gt;.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>&lt;3&gt;.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>/*方法说明：快速排序
@param  array 待排序数组*/
//方法一
function quickSort(array, left, right) &#123;
    console.time(&#39;1.快速排序耗时&#39;);
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39; &amp;&amp; typeof left === &#39;number&#39; &amp;&amp; typeof right === &#39;number&#39;) &#123;
        if (left &lt; right) &#123;
            var x = array[right], i = left - 1, temp;
            for (var j = left; j &lt;= right; j++) &#123;
                if (array[j] &lt;= x) &#123;
                    i++;
                    temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                &#125;
            &#125;
            quickSort(array, left, i - 1);
            quickSort(array, i + 1, right);
        &#125;
        console.timeEnd(&#39;1.快速排序耗时&#39;);
        return array;
    &#125; else &#123;
        return &#39;array is not an Array or left or right is not a number!&#39;;
    &#125;
&#125;

//方法二
var quickSort2 = function(arr) &#123;
    console.time(&#39;2.快速排序耗时&#39;);
&amp;emsp;&amp;emsp;if (arr.length &lt;= 1) &#123; return arr; &#125;
&amp;emsp;&amp;emsp;var pivotIndex = Math.floor(arr.length / 2);
&amp;emsp;&amp;emsp;var pivot = arr.splice(pivotIndex, 1)[0];
&amp;emsp;&amp;emsp;var left = [];
&amp;emsp;&amp;emsp;var right = [];
&amp;emsp;&amp;emsp;for (var i = 0; i &lt; arr.length; i++)&#123;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;if (arr[i] &lt; pivot) &#123;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;left.push(arr[i]);
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&#125; else &#123;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;right.push(arr[i]);
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&#125;
&amp;emsp;&amp;emsp;&#125;
console.timeEnd(&#39;2.快速排序耗时&#39;);
&amp;emsp;&amp;emsp;return quickSort2(left).concat([pivot], quickSort2(right));
&#125;;

var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]


复制代码</code></pre>
<p><strong>快速排序动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="快速排序"></p>
<h4 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
</blockquote>
<h4 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<h4 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>&lt;2&gt;.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>&lt;3&gt;.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>/*方法说明：堆排序
@param  array 待排序数组*/
function heapSort(array) &#123;
    console.time(&#39;堆排序耗时&#39;);
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39;) &#123;
        //建堆
        var heapSize = array.length, temp;
        for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123;
            heapify(array, i, heapSize);
        &#125;

        //堆排序
        for (var j = heapSize - 1; j &gt;= 1; j--) &#123;
            temp = array[0];
            array[0] = array[j];
            array[j] = temp;
            heapify(array, 0, --heapSize);
        &#125;
        console.timeEnd(&#39;堆排序耗时&#39;);
        return array;
    &#125; else &#123;
        return &#39;array is not an Array!&#39;;
    &#125;
&#125;
/*方法说明：维护堆的性质
@param  arr 数组
@param  x   数组下标
@param  len 堆大小*/
function heapify(arr, x, len) &#123;
    if (Object.prototype.toString.call(arr).slice(8, -1) === &#39;Array&#39; &amp;&amp; typeof x === &#39;number&#39;) &#123;
        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;
        if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;
            largest = l;
        &#125;
        if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;
            largest = r;
        &#125;
        if (largest != x) &#123;
            temp = arr[x];
            arr[x] = arr[largest];
            arr[largest] = temp;
            heapify(arr, largest, len);
        &#125;
    &#125; else &#123;
        return &#39;arr is not an Array or x is not a number!&#39;;
    &#125;
&#125;
var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];
console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]

复制代码</code></pre>
<p><strong>堆排序动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<h4 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<h4 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;. 找出待排序的数组中最大和最小的元素；</li>
<li>&lt;2&gt;. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>&lt;3&gt;. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>&lt;4&gt;. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>function countingSort(array) &#123;
    var len = array.length,
        B = [],
        C = [],
        min = max = array[0];
    console.time(&#39;计数排序耗时&#39;);
    for (var i = 0; i &lt; len; i++) &#123;
        min = min &lt;= array[i] ? min : array[i];
        max = max &gt;= array[i] ? max : array[i];
        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;
    &#125;
    for (var j = min; j &lt; max; j++) &#123;
        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);
    &#125;
    for (var k = len - 1; k &gt;= 0; k--) &#123;
        B[C[array[k]] - 1] = array[k];
        C[array[k]]--;
    &#125;
    console.timeEnd(&#39;计数排序耗时&#39;);
    return B;
&#125;
var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];
console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]

复制代码</code></pre>
<p><strong>JavaScript动图演示：</strong>、</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
<h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</blockquote>
<h4 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
</blockquote>
<h4 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.设置一个定量的数组当作空桶；</li>
<li>&lt;2&gt;.遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>&lt;3&gt;.对每个不是空的桶进行排序；</li>
<li>&lt;4&gt;.从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<pre><code>/*方法说明：桶排序
@param  array 数组
@param  num   桶的数量*/
function bucketSort(array, num) &#123;
    if (array.length &lt;= 1) &#123;
        return array;
    &#125;
    var len = array.length, buckets = [], result = [], min = max = array[0], regex = &#39;/^[1-9]+[0-9]*$/&#39;, space, n = 0;
    num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10);
    console.time(&#39;桶排序耗时&#39;);
    for (var i = 1; i &lt; len; i++) &#123;
        min = min &lt;= array[i] ? min : array[i];
        max = max &gt;= array[i] ? max : array[i];
    &#125;
    space = (max - min + 1) / num;
    for (var j = 0; j &lt; len; j++) &#123;
        var index = Math.floor((array[j] - min) / space);
        if (buckets[index]) &#123;   //  非空桶，插入排序
            var k = buckets[index].length - 1;
            while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123;
                buckets[index][k + 1] = buckets[index][k];
                k--;
            &#125;
            buckets[index][k + 1] = array[j];
        &#125; else &#123;    //空桶，初始化
            buckets[index] = [];
            buckets[index].push(array[j]);
        &#125;
    &#125;
    while (n &lt; num) &#123;
        result = result.concat(buckets[n]);
        n++;
    &#125;
    console.timeEnd(&#39;桶排序耗时&#39;);
    return result;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

复制代码</code></pre>
<p><strong>桶排序图示（图片来源网络）：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p>关于桶排序<a href="http://www.cnblogs.com/lonelyxmas/p/3561938.html">更多</a></p>
<h4 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p> 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
</blockquote>
<h4 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h4 id="2-算法描述和实现-9"><a href="#2-算法描述和实现-9" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.取得数组中的最大数，并取得位数；</li>
<li>&lt;2&gt;.arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>&lt;3&gt;.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>/**
 * 基数排序适用于：
 *  (1)数据范围较小，建议在小于1000
 *  (2)每个数值都要大于等于0
 * @author xiazdong
 * @param  arr 待排序数组
 * @param  maxDigit 最大位数
 */
//LSD Radix Sort

function radixSort(arr, maxDigit) &#123;
    var mod = 10;
    var dev = 1;
    var counter = [];
    console.time(&#39;基数排序耗时&#39;);
    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;
        for(var j = 0; j &lt; arr.length; j++) &#123;
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]== null) &#123;
                counter[bucket] = [];
            &#125;
            counter[bucket].push(arr[j]);
        &#125;
        var pos = 0;
        for(var j = 0; j &lt; counter.length; j++) &#123;
            var value = null;
            if(counter[j]!=null) &#123;
                while ((value = counter[j].shift()) != null) &#123;
                      arr[pos++] = value;
                &#125;
          &#125;
        &#125;
    &#125;
    console.timeEnd(&#39;基数排序耗时&#39;);
    return arr;
&#125;
var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

复制代码</code></pre>
<p><strong>基数排序LSD动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-7"><a href="#3-算法分析-7" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
<p>基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<p>![<a href="https://user-gold-cdn.xitu.io/2020/2/3/1700919fb9a285de?w=450&amp;h=359&amp;f=png&amp;s=66765%5D">https://user-gold-cdn.xitu.io/2020/2/3/1700919fb9a285de?w=450&amp;h=359&amp;f=png&amp;s=66765]</a>(<a href="https://juejin.cn/post/data:image/svg+xml;utf8">https://juejin.cn/post/data:image/svg+xml;utf8</a><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="450" height="359"></svg>)</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。</p>
</blockquote>
<p>.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</p>
]]></content>
  </entry>
  <entry>
    <title>精读你不知道的JavaScript上卷</title>
    <url>/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%B2%BE%E8%AF%BB%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E5%8D%B7/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="I-第1章作用域是什么"><a href="#I-第1章作用域是什么" class="headerlink" title="I-第1章作用域是什么"></a>I-第1章作用域是什么</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>JavaScript是一门编译语言</p>
<p>传统的编译语言在代码执行前会经历三个步骤(编译)</p>
<ul>
<li><p>分词/词法分析(Tokenizing/Lexing)</p>
<p>  将由字符组成的字符串分解成(对编程语言来说)有意义的代码块(词法单元token)</p>
</li>
<li><p>解析/语法分析(Parsing)</p>
<p>  将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树(抽象语法树Abstract Syntax Tree，AST)。</p>
</li>
<li><p>代码生成</p>
<p>  将 AST 转换为可执行代码</p>
</li>
</ul>
<p>JavaScript引擎编译过程比普通编译语言更复杂<br>在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。<br>用尽了各种办法(比如 JIT，可以延迟编译甚至实施重编译)来保证性能最佳。</p>
<h3 id="理解作用域-建议多读几遍"><a href="#理解作用域-建议多读几遍" class="headerlink" title="理解作用域(建议多读几遍)"></a>理解作用域(建议多读几遍)</h3><p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</p>
<p>可以将 RHS 理解成 retrieve his source value(取到它的源值)，这意味着“得到某某的值”。<br>在概念上最好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”。</p>
<p>如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。</p>
<p>赋值操作符会导致 LHS 查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。</p>
<p>遍历嵌套作用域链的规则: 从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>
<hr>
<p>编码经验：减少无意义的变量查找次数和未定义变量的查找，可以提升效率</p>
<hr>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>RHS 查询遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。</p>
<p>非严格模式：引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。</p>
<p>严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。</p>
<p>如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。</p>
<p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>

<ol>
<li><p>找出所有的LHS查询(这里有3处!)</p>
<p> c = ..;、a = 2(隐式变量分配)、b = ..</p>
</li>
<li><p>找出所有的RHS查询(这里有4处!)</p>
<p> foo(2..、= a;、a ..、.. b</p>
</li>
</ol>
<h2 id="I-第2章-词法作用域"><a href="#I-第2章-词法作用域" class="headerlink" title="I-第2章 词法作用域"></a>I-第2章 词法作用域</h2><p>词法作用域就是定义在词法阶段的作用域。</p>
<p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p>
<p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p>
<hr>
<p>在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。</p>
<p>全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问<code>window.a</code>，通过这种方式可以访问那些被同名变量所遮蔽的全局变量。</p>
<p>但非全局的变量如果被遮蔽了，无论如何都无法被访问到。</p>
<hr>
<h3 id="欺骗语法"><a href="#欺骗语法" class="headerlink" title="欺骗语法"></a>欺骗语法</h3><p>JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。</p>
<p>前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。</p>
<p>后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。</p>
<p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。会导致性能下降。<strong>不要使用它们。</strong></p>
<h2 id="I-第3章-函数作用域和块作用域"><a href="#I-第3章-函数作用域和块作用域" class="headerlink" title="I-第3章 函数作用域和块作用域"></a>I-第3章 函数作用域和块作用域</h2><blockquote>
<p>开发中，函数写的太多了。怎样才是个好的函数？我们常讲封装。封装函数，封装常用的方法，通过这章内容可以学习到为什么要封装，封装的好处和一些封装的方法。</p>
</blockquote>
<p>函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(在嵌套的作用域中也可以使用)。<br>这种设计方案能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。</p>
<h3 id="利用函数作用域隐藏内部实现"><a href="#利用函数作用域隐藏内部实现" class="headerlink" title="利用函数作用域隐藏内部实现"></a>利用函数作用域隐藏内部实现</h3><p>正确的代码应该考虑到如何选择作用域来包含变量和函数。遵循最小授权原则。</p>
<hr>
<p>最小授权或最小暴露原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</p>
<hr>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>b</code> 和函数 <code>doSomethingElse(..)</code> 是 <code>doSomething(..)</code> 内部具体实现的“私有”内容。<br>给予外部作用域对 <code>b</code> 和 <code>doSomethingElse(..)</code> 的“访问权限”不仅没有必要，而且可能是“危险”的，<br>因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了doSomething(..) 的适用条件。<br>更“合理”的设计会将这些私有的具体内容隐藏在 <code>doSomething(..)</code> 内部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> b;</span><br><span class="line">    b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>功能和效果都没受影响，设计上将具体内容私有化，设计良好的软件都会依此进行实现。</strong></p>
<h4 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h4><p>隐藏作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        i = <span class="number">3</span>; <span class="comment">// 修改for循环所属作用域中的i</span></span><br><span class="line">        <span class="built_in">console</span>.log( a + i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这里用<code>var i = 3;</code>和 <code>j = 3;</code>都可以解决这个问题，但使用作用域来“隐藏”内部声明是唯一的最佳选择。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li><p>全局命名空间</p>
<p> 在jQuery时代，引用各种第三方库尤为明显。如果组件没有很好的将内部私有函数和变量隐藏起来会引起很多问题。</p>
<p> 最佳实践：声明一个名字足够独特的变量，通常是一个对象。所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。</p>
<p> 示例</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line">    awesome: <span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块管理</p>
<p> 从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。</p>
</li>
</ol>
<h3 id="函数作用域优化"><a href="#函数作用域优化" class="headerlink" title="函数作用域优化"></a>函数作用域优化</h3><p>函数作用域需要显示声明函数名和调用该函数</p>
<p>采用包装函数来解决，将函数声明转成表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- 添加这一行</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    &#125;)(); <span class="comment">// &lt;-- 以及这一行</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</span><br></pre></td></tr></table></figure>

<h4 id="匿名和具名函数"><a href="#匿名和具名函数" class="headerlink" title="匿名和具名函数"></a>匿名和具名函数</h4><h5 id="匿名函数表达式"><a href="#匿名函数表达式" class="headerlink" title="匿名函数表达式"></a>匿名函数表达式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I waited 1 second!&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>

<p>这叫作匿名函数表达式，因为 <code>function()..</code> 没有名称标识符。函数表达式可以是匿名的，<br>而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p>
<p>匿名函数缺点：</p>
<ol>
<li>匿名函数在栈追踪中不会显示函数名，调试很困难。</li>
<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。<br>另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li>
<li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li>
</ol>
<p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。<br>给函数表达式指定一个函数名可以有效解决以上问题。<br><strong>始终给函数表达式命名是一个最佳实践</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;-- 快看，我有名字了!</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;I waited 1 second!&quot;</span> );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>

<h5 id="立即执行函数表达式-IIFE-Immediately-Invoked-Function-Expression"><a href="#立即执行函数表达式-IIFE-Immediately-Invoked-Function-Expression" class="headerlink" title="立即执行函数表达式(IIFE Immediately Invoked Function Expression)"></a>立即执行函数表达式(IIFE Immediately Invoked Function Expression)</h5><p>将函数包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数。<br>比如 <code>(function foo()&#123; .. &#125;)()</code>, 另一种形式<code>(function()&#123; .. &#125;())</code>。两种形式在功能上是一致的。</p>
<p>IIFE进阶用法，把它们当作函数调用并传递参数进去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> <span class="built_in">global</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">global</span>.a ); <span class="comment">// 2</span></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。<br>这对于改进代码风格是非常有帮助的。</p>
<p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。<br>这种模式在 UMD(Universal Module Definition)项目中被广泛使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>) </span>&#123;</span><br><span class="line">    def( <span class="built_in">window</span> );</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> <span class="built_in">global</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">global</span>.a ); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p><code>&#123;&#125;</code>, <code>for</code>, <code>if</code>, <code>with</code>, <code>try/catch</code>, <code>let</code>, <code>const</code>都是声明块级作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">    &#123; <span class="comment">// &lt;-- 显式的块</span></span><br><span class="line">        <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">        bar = something( bar ); <span class="built_in">console</span>.log( bar );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</strong></p>
<h2 id="I-第4章-提升"><a href="#I-第4章-提升" class="headerlink" title="I-第4章 提升"></a>I-第4章 提升</h2><blockquote>
<p>编译器在编译代码时是从上到下一行行编译的吗？</p>
</blockquote>
<p>引擎会在执行 JavaScript 代码之前先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</p>
<p>变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。</p>
<p>注意：函数声明会被提升，<strong>包括函数表达式的赋值在内的赋值操作</strong>并不会提升。</p>
<p><strong>函数会首先被提升，然后才是变量。</strong></p>
<p>后面的函数声明可以覆盖前面的，如下输出3</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式不会提升</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个代码被引擎解析如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题!</p>
<p>用<code>let</code>和<code>const</code>可以解决重复声明的问题。</p>
<h2 id="I-第5章-作用域闭包"><a href="#I-第5章-作用域闭包" class="headerlink" title="I-第5章 作用域闭包"></a>I-第5章 作用域闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
<p>经典示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 2 —— 这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>

<p>bar() 在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为引擎有垃圾回收器用来释放不再使用的内存空间。<br>由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p>
<p>而闭包的“神奇”之处正是可以阻止这件事情的发生。<br>由于 bar() 所声明的位置在foo内部，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。</p>
<p>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>
<p>循环经典案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i ); <span class="comment">// 以每秒一次的频率输出五次 6</span></span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。</p>
<p>改进，为每次迭代生成新的作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( j );</span><br><span class="line">        &#125;, j*<span class="number">1000</span> );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>let</code>解决。let变量在循环过程中不止被声明一次，每次迭代都会声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块模式需要具备两个必要条件。</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( something );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( another.join( <span class="string">&quot; ! &quot;</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// modifying the public API</span></span><br><span class="line">        publicAPI.identify = identify2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">identify1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( id );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">identify2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( id.toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> publicAPI = &#123;</span><br><span class="line">        change: change,</span><br><span class="line">        identify: identify1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> publicAPI;</span><br><span class="line">&#125;)( <span class="string">&quot;foo module&quot;</span> );</span><br><span class="line"></span><br><span class="line">foo.identify(); <span class="comment">// foo module</span></span><br><span class="line">foo.change();</span><br><span class="line">foo.identify(); <span class="comment">// FOO MODULE</span></span><br></pre></td></tr></table></figure>

<p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>
<h4 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply( impl, deps );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        get: get</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>核心代码是这行<code>modules[name] = impl.apply( impl, deps );</code></strong><br>为了模块的定义引入了包装函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。</p>
<p>看看怎么使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyModules.define( <span class="string">&quot;bar&quot;</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Let me introduce: &quot;</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello: hello</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">MyModules.define( <span class="string">&quot;foo&quot;</span>, [<span class="string">&quot;bar&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">&quot;hippo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = MyModules.get( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> foo = MyModules.get( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    bar.hello( <span class="string">&quot;hippo&quot;</span> )</span><br><span class="line">); <span class="comment">// Let me introduce: hippo</span></span><br><span class="line"></span><br><span class="line">foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多花一点时间来研究这些示例代码并完全理解闭包的作用吧。最重要的是要理解模块管理器没有任何特殊的“魔力”。<br>它们符合前面列出的模块模式的两个特点:为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。<br>换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。</p>
<h4 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h4><p>ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立的模块来处理。<br>每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。</p>
<p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。</p>
<p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上(在我们的例子里是 hello)。<br>module 会将整个模块的 API 导入并绑定到一个变量上(在我们的例子里是 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公共 API。<br>这些操作可以在模块定义中根据需要使用任意多次。</p>
<p>bar.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Let me introduce: &quot;</span> + who;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> hello;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>baz.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar.hello( <span class="string">&quot;rhino&quot;</span> )); <span class="comment">// Let</span></span><br></pre></td></tr></table></figure>

<h2 id="II-第1章-关于this"><a href="#II-第1章-关于this" class="headerlink" title="II-第1章 关于this"></a>II-第1章 关于this</h2><p>this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。</p>
<p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>
<p>this<strong>既不指向函数自身也不指向函数的词法作用域</strong></p>
<p><strong>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</strong></p>
<h2 id="II-第2章-this全面解析"><a href="#II-第2章-this全面解析" class="headerlink" title="II-第2章 this全面解析"></a>II-第2章 this全面解析</h2><p>从<a href="https://juejin.im/post/5efe67276fb9a07e5d76be30">上一章</a>知道理解this，就是要理解<code>函数被调用的位置</code>。但实践起来有点复杂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重要的是分析调用栈，在当前正在执行函数前一个调用中。在函数第一行设置&#96;debugger&#96;,开发者工具调用栈的第二个元素就是真正的调用位置。</span><br></pre></td></tr></table></figure>

<h3 id="四条绑定规则"><a href="#四条绑定规则" class="headerlink" title="四条绑定规则"></a>四条绑定规则</h3><h4 id="1-独立调用"><a href="#1-独立调用" class="headerlink" title="1. 独立调用"></a>1. 独立调用</h4><p>独立函数调用，即使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</p>
<p>this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 <code>strict mode</code> 下时，默认绑定才能绑定到全局对象;严格模式下与 foo() 的调用位置无关:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h4><p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>一个最常见的 this 绑定问题是被隐式绑定的函数会丢失绑定对象，它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名!</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// a 是全局对象的属性 bar(); // &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>回调函数里也会有this丢失现象</p>
<h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h3><p><code>call</code>和<code>apply</code>可以直接指定 this 的绑定对象，称之为显式绑定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>( bar, <span class="number">10</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 硬绑定的 bar 不可能再修改它的 this</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在<code>bar</code>中强制把foo的this绑定到obj上，无论之后怎么调用bar，都不会修改this。这种显示强绑定，称为硬绑定。</p>
<p>ES5 中提供了内置的方法<code>Function.prototype.bind</code>也是强绑定。</p>
<h4 id="API调用的“上下文”-context"><a href="#API调用的“上下文”-context" class="headerlink" title="API调用的“上下文”(context)"></a>API调用的“上下文”(context)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</span><br><span class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>

<p>这种也是通过call和apply实现的显示绑定。</p>
<h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h3><p>js通过new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建(构造)一个全新的对象。</li>
<li>这个新对象会被执行原型连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>四条绑定原则的优先级</p>
<ol>
<li>由new调用? 绑定到新创建的对象。</li>
<li>由call或者apply(或者bind)调用? 绑定到指定的对象。</li>
<li>由上下文对象调用? 绑定到那个上下文对象。</li>
<li>默认:在严格模式下绑定到undefined，否则绑定到全局对象。</li>
</ol>
<h3 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h3><p>把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值<br>在调用时会被忽略，实际应用的是默认绑定规则。</p>
<p>函数的间接引用，会导致应用默认绑定。</p>
<h4 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h4><p>硬绑定可以强制绑定到指定对象(除new时)，降低了函数的灵活性。采用软绑定方式可以实现和硬绑定相同的效果，同时保留隐式绑定修改this的能力。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 捕获所有 curried 参数</span></span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">            (!<span class="built_in">this</span> || <span class="built_in">this</span> === (<span class="built_in">window</span> || <span class="built_in">global</span>)) ?</span><br><span class="line">            obj : <span class="built_in">this</span></span><br><span class="line">            curried.concat.apply( curried, <span class="built_in">arguments</span> )</span><br><span class="line">            );</span><br><span class="line">        &#125;;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this语法"><a href="#this语法" class="headerlink" title="this语法"></a>this语法</h3><p>箭头函数<code>() =&gt; &#123;&#125;</code>无法使用上述四种规则。而是<strong>根据外层（函数或者全局）作用域来决定this</strong>。<br>箭头函数可以像 <code>bind(..)</code> 一样确保函数的 this 被绑定到指定对象，它用更常见的词法作用域取代了传统的 this 机制。</p>
<p>没有箭头函数之前我们习惯采用的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>; <span class="comment">// lexical capture of this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( self.a );</span><br><span class="line">    &#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>self = this</code> 和箭头函数看起来都可以取代<code>bind(..)</code>，但是从本质上来说，它们想替代的是 this 机制。</p>
<h3 id="小结this全面解析"><a href="#小结this全面解析" class="headerlink" title="小结this全面解析"></a>小结this全面解析</h3><p>学习本章了解this绑定的方式，通过4条准则定位函数运行时this到底指向什么。</p>
<p>在箭头函数出来之后，用<code>() =&gt; &#123;&#125;</code>和<code>bind</code>可以解决大多数问题了。</p>
<p>ES5出来之后，很多js的问题被新语法取代了，但我们可以抽时间多了解新语法背后的历史，能更深入的了解js本身的魅力。</p>
<h2 id="II-第3章-对象"><a href="#II-第3章-对象" class="headerlink" title="II-第3章 对象"></a>II-第3章 对象</h2><p>对象是JavaScript的基础。</p>
<p>ECMAScript 标准定义了 8 种数据类型:</p>
<p>7 种原始类型:<br>Undefined<br>Null<br>Number<br>Boolean<br>BigInt<br>String<br>Symbol<br>和 Object</p>
<p>记忆口诀：欧呦(O)你(U)俩(2个)牛(N)逼(B)啥(S)</p>
<p>定义对象两种形式：声明形式和构造形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    key: value</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure>

<h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    [prefix + <span class="string">&quot;bar&quot;</span>]:<span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    [prefix + <span class="string">&quot;baz&quot;</span>]: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject[<span class="string">&quot;foobar&quot;</span>]; <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>js中函数不会属于一个对象，因为this是在运行时根据调用位置动态绑定的。 所以方法这个称呼不太成立。但这只是个称呼，不必太纠结。</p>
<h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>浅复制</p>
<p>对于JSON安全(可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象)的对象可以用<code>JSON.parse</code>复制</p>
<p><code>var newObj = JSON.parse(JSON.stringify(someObj));</code></p>
<p>ES6中可以用<code>Object.assign(&#123;&#125;, obj)</code>复制</p>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>属性描述符<code>writable(可写), configurable(可配置), enumerable(可枚举)</code></p>
<p>可以使用<code>Object.defineProperty</code>定义属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;KEY&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果把 enumerable 设置成 false，这个属性不会出现在枚举中（比如for..in）。但可以正常访问这个属性。</p>
<p>结合<code>writable: false</code>和<code>configurable: false</code>可以创建一个真正的常量属性(不可修改、重定义或删除)</p>
<p>禁止一个对象添加新属性并且保留已有属性，可以使用<code>Object.preventExtensions(obj)</code></p>
<p>密封：<code>Object.seal(..)</code>调用<code>Object.preventExtensions(obj)</code>把所有现有属性标记为<code>configurable: false</code>。密封后不能添加，重新配置和删除现有属性。可以修改属性的值。</p>
<p>冻结：<code>Object.freeze(..)</code>调用<code>Object.seal(..)</code>把所有数据访问属性标记为<code>writable: false</code>。这样就无法修改属性值。</p>
<h3 id="get-set"><a href="#get-set" class="headerlink" title="get, set"></a>get, set</h3><p>get: 属性访问先在对象中查找是否有名称相同的属性，没找到就遍历可能存在的原型链，找不到的话返回undefined。</p>
<p>set:</p>
<ol>
<li>先判断属性是否是访问描述符，存在setter就调用setter。</li>
<li>writable是否为false。是，非严格模式下静默失败，严格模式抛出TypeError异常。</li>
<li>都不是，设置属性值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="comment">// 给 a 定义一个 getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">// 给 a 定义一个 setter</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = <span class="number">2</span>; myObject.a; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>判断对象是否有某个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// false</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;b&quot;</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>操作符会检查属性是否在对象及其原型链中</p>
<p><code>hasOwnProperty(..)</code> 只会检查属性是否在 myObject 对象中，不会检查链。</p>
<p>所有的普通对象都可以通过对于 Object.prototype 的委托来访问 hasOwnProperty(..)，<br>但是有的对象可能没有连接到 Object.prototype(通过 Object. create(null) 来创建)。<br>在这种情况下，形如<code>myObejct.hasOwnProperty(..)</code>就会失败。</p>
<p>可以采用<code>Object.prototype.hasOwnProperty. call(myObject,&quot;a&quot;)</code>判断</p>
<p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否可枚举</span></span><br><span class="line">myObject.propertyIsEnumerable( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.propertyIsEnumerable( <span class="string">&quot;b&quot;</span> ); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 所有可枚举属性的数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys( myObject ); <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"><span class="comment">// 所有属性，无论它们是否可枚举</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames( myObject ); <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><code>for..in</code>无法直接获取属性值，因为它遍历的是对象中的所有可枚举属性，需要手动获取属性值。<br><code>for..of</code>循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值。</p>
<h3 id="小结-第3章对象"><a href="#小结-第3章对象" class="headerlink" title="小结 第3章对象"></a>小结 第3章对象</h3><p>了解对象是什么，怎么定义，一些常用方法和特性，遍历对象。</p>
<p>工作中对象的使用是非常频繁的，熟练掌握各种API是提升技术的必备条件。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;</span><br><span class="line">    a: <span class="number">12</span>,</span><br><span class="line">    b: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">newObj.a = <span class="number">12</span>;</span><br><span class="line">newObj.b = <span class="number">23</span>;</span><br><span class="line">newObj[<span class="string">&#x27;a&#x27;</span>] = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    ...newObj</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    a: newObj.a,</span><br><span class="line">    b: newObj.b</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="II-第4章-混合对象”类“"><a href="#II-第4章-混合对象”类“" class="headerlink" title="II-第4章 混合对象”类“"></a>II-第4章 混合对象”类“</h2><blockquote>
<p>我的理解类也是一种对象而已，没那么复杂。</p>
</blockquote>
<p>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。</p>
<p>类意味着复制。<br>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。<br>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的是复制的结果。</p>
<p>JavaScript 并不会(像类那样)自动创建对象的副本。</p>
<p>混入模式用来模拟类的复制行为。Vue中也提供了类似的API,<a href="https://cn.vuejs.org/v2/guide/mixins.html">mixin</a></p>
<h2 id="II-第5章-原型（还需多读几遍）"><a href="#II-第5章-原型（还需多读几遍）" class="headerlink" title="II-第5章 原型（还需多读几遍）"></a>II-第5章 原型（还需多读几遍）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这篇文章是JS的重中之重，要用心研读~~</span><br></pre></td></tr></table></figure>

<p>能学到的知识：</p>
<ol>
<li><p>对象查找和设置属性背后发生了什么</p>
</li>
<li><p>原型链形成的机制和特点</p>
</li>
</ol>
<p>前面说到在对象里查找属性时，如果在对象本身找不到，会继续访问对象的prototype链。如果都没有的话返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个关联到 anotherObject 的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line"><span class="built_in">console</span>.log(myObject); <span class="comment">// &#123;&#125;</span></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>现在<code>myObject</code>的<code>prototype</code>关联到<code>anotherObject</code>，<code>myObject.a</code>并不存在，但<code>myObject.a</code>结果为2</p>
<p><code>for..in</code>遍历对象时原理和查找原型链类似。任何可通过原型链访问到(并且是enumerable)的属性都会被枚举</p>
<p>当你通过各种语法进行属性查找时都会查找原型链，直到找到属性或者查找完整条原型链。</p>
<p><strong>原型链的尽头是<code>Object.prototype</code></strong><br><code>toString()</code>、<code>valueOf()</code>和其他一些通用的功能 都存在于<code>Object.prototype</code>对象上，因此语言中所有的对象都可以使用它们。</p>
<h3 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h3><p>给一个对象设置属性的过程并不简单。通过例子来看<code>myObject.foo = &quot;bar&quot;;</code></p>
<p>一、 如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p>
<p>二、 如果 foo 不是直接存在于 myObject 中，原型链就会被遍历。如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。</p>
<p>三、 如果 foo 存在于原型链上层，赋值语句 <code>myObject.foo = &quot;bar&quot;</code> 的行为就会有些不同。</p>
<p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的原型链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。</p>
<blockquote>
<p>屏蔽：在当前作用域添加属性，以隔绝访问原型链上层的同样属性</p>
</blockquote>
<p>发生屏蔽的三种情况：</p>
<ol>
<li>如果在原型链上层存在名为foo的普通数据访问属性并且没有被标记为只读，那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</li>
<li>如果在原型链上层存在foo，但是它被标记为只读，那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li>如果在原型链上层存在foo并且它是一个setter，那就一定会调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这个 setter。</li>
</ol>
<p>向原型链上层已经存在的属性赋值，不一定会触发屏蔽(第二三种)。<br>如果希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 = 操作符来赋值，而是使用 Object.defineProperty(..)来向 myObject 添加 foo。</p>
<blockquote>
<p>只读属性会阻止原型链下层屏蔽同名属性。这样做主要是为了模拟类属性的继承。你可以把原型链上层的 foo 看作是父类中的属性，它会被 myObject 继承(复制)，这样一来 myObject 中的 foo 属性也是只读，所以无法创建。但是一定要注意，实际上并不会发生类似的继承复制。这看起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不能包含 foo 属性。更奇怪的是，这个限制只存在于 = 赋值中，使用 Object. defineProperty(..) 并不会受到影响。</p>
</blockquote>
<p>有些情况下会隐式产生屏蔽，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">anotherObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a++; <span class="comment">// 隐式屏蔽!</span></span><br><span class="line">anotherObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a; <span class="comment">// 3</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>++</code> 操作相当于 <code>myObject.a = myObject.a + 1</code>。因此 ++ 操作首先会通过原型链查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着将值 3 赋给 myObject 中新建的屏蔽属性 a。</p>
<p>修改委托属性时一定要小心。如果想让 anotherObject.a 的值增加，唯一的办法是 anotherObject.a++。</p>
<h3 id="类函数"><a href="#类函数" class="headerlink" title="类函数"></a>类函数</h3><p>函数的一种特殊特性:所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象: Foo的原型。我们通过名为 Foo.prototype 的属性引用来访问它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype; <span class="comment">// &#123; &#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf( a ) === Foo.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用 new Foo() 时会创建 a，其中的一步就是给 a 一个内部的原型链，关联到 Foo.prototype 指向的那个对象。</p>
<p>在 JavaScript 中，不能创建一个类的多个实例，只能创建多个对象，它们的原型链关联的是同一个对象。在默认情况下多次实例化一个类不会进行复制， 因此这些对象之间并不会完全失去联系，它们是互相关联的。</p>
<p>通过<code>new Foo()</code>得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联。</p>
<p>实际上，绝大多数 JavaScript 开发者不知道的秘密是，new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。new Foo() 只是间接完成了我们的目标:一个关联到其他对象的新对象。</p>
<p>通过<code>Object.create(..)</code>可以直接做到这一点。</p>
<p>通常我们讲原型继承。继承意味着复制操作。JS默认不会复制对象属性。会在两个对象之间创建关联，这样一个对象可以通过委托访问另一个对象的属性和函数。</p>
<p>差异继承？</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。</p>
<p>函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.constructor === Foo; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Foo.prototype 默认(在代码中第一行声明时)有一个公有并且不可枚举的属性<code>.constructor</code>，这个属性引用的是对象关联的函数(本例中是 Foo)。<br>此外，我们可以看到通过“构造函数”调用 new Foo() 创建的对象也有一个 <code>.constructor</code> 属性，指向 “创建这个对象的函数”。</p>
<p><code>a.constructor</code> 只是通过默认的原型委托指向 Foo，这和构造毫无关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* .. */</span> &#125;</span><br><span class="line">Foo.prototype = &#123; <span class="comment">/* .. */</span> &#125;; <span class="comment">// 创建一个新原型对象</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</span><br><span class="line">a1.constructor === Foo; <span class="comment">// false!</span></span><br><span class="line">a1.constructor === <span class="built_in">Object</span>; <span class="comment">// true!</span></span><br></pre></td></tr></table></figure>

<p>Object(..) 并没有“构造”a1，看起来应该是 Foo()“构造”了它。<br>大部分开发者 都认为是 Foo() 执行了构造工作，但是问题在于，如果你认为<code>constructor</code>表示“由…… 构造”的话，a1.constructor 应该是 Foo，但是它并不是 Foo !</p>
<p>a1 并没有 .constructor 属性，所以它会委托原型链上的 Foo. prototype。但是这个对象也没有 .constructor 属性(不过默认的 Foo.prototype 对象有这 个属性!)，<br>所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象 有 .constructor 属性，指向内置的 Object(..) 函数。</p>
<p>对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用。</p>
<p><strong>constructor 并不表示被构造</strong><br>.constructor 并不是一个不可变属性。它是不可枚举的，但是它的值是可写的。此外，你可以给任意原型链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p><code>Bar.prototype = Object.create()</code><br>Object.create(..) 会凭空创建一个“新”对象并把新对象内部的原型链关联到指定的对象(本例中是 Foo.prototype)。<br>换句话说，这条语句的意思是:“创建一个新的 Bar.prototype 对象并把它关联到 Foo. prototype”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和你想要的机制不一样!</span></span><br><span class="line">Bar.prototype = Foo.prototype;</span><br><span class="line"><span class="comment">// 基本上满足你的需求，但是可能会产生一些副作用 :(</span></span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p>Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。<br>因此当你执行类似<code>Bar.prototype. myLabel = ...</code>的赋值语句时会直接修改 Foo.prototype 对象本身。<br>显然这不是你想要的结果，否则你根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会更简单一些。</p>
<p>Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象。<br>但是它使用了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些副作用(比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等)的话，<br>就会影响到 Bar() 的“后代”，后果 不堪设想。</p>
<p>对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class="line">Bar.ptototype = <span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line"><span class="comment">// ES6 开始可以直接修改现有的</span></span><br><span class="line">Bar.prototype <span class="built_in">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></figure>

<p>如果忽略掉 Object.create(..) 方法带来的轻微性能损失(抛弃的对象需要进行垃圾回收)，它实际上比 ES6 及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法。</p>
<h3 id="检查类关系"><a href="#检查类关系" class="headerlink" title="检查类关系"></a>检查类关系</h3><p><code>instanceof</code> 操作符的左操作数是一个普通的对象，右操作数是一个函数。</p>
<p>在 a 的整条原型链中是否有指向 Foo.prototype 的对象?</p>
<p>这个方法只能处理对象(a)和函数(带 .prototype 引用的 Foo)之间的关系。如果你想判断两个对象(比如 a 和 b)之间是否通过原型链关联，只用 instanceof 无法实现。</p>
<p>第二种判断反射的方法：</p>
<p><code>Foo.prototype.isPrototypeOf( a ); // true</code></p>
<p>b 是否出现在 c 的原型链中?<br><code>b.isPrototypeOf( c );</code></p>
<p>直接获取一个对象原型链的方法<code>Object.getPrototypeOf(a)</code></p>
<p><code>Object.getPrototypeOf( a ) === Foo.prototype; // true</code></p>
<p>非标准的方法<code>a.__proto__ === Foo.prototype; // true</code></p>
<p><code>.constructor</code>和<code>.__proto__</code>一样，并不存在于你正在使用的对象中 (本例中是 a)。<br>它和其他的常用函数(.toString()、.isPrototypeOf(..)，等等)<br>一样，存在于内置的 Object.prototype 中。是不可枚举的。</p>
<p>.<strong>proto</strong> 的实现大致上是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty( <span class="built_in">Object</span>.prototype, <span class="string">&quot;__proto__&quot;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf( <span class="built_in">this</span> ); &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ES6 中的 setPrototypeOf(..)</span></span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf( <span class="built_in">this</span>, o );</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><p><code>Object.create(..)</code> 会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，<br>这样我们就可以充分发挥原型链机制的威力(委托)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成 <code>.prototype</code> 和 <code>.constructor</code> 引用)。</p>
<p><code>Object.create()</code>的polyfill代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="II-第6章-行为委托"><a href="#II-第6章-行为委托" class="headerlink" title="II-第6章 行为委托"></a>II-第6章 行为委托</h2><p>委托行为意味着某些对象(XYZ)在找不到属性或者方法引用时会把这个请求委托给另一个对象(Task)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Task = &#123;</span><br><span class="line">    setID: <span class="function"><span class="keyword">function</span>(<span class="params">ID</span>) </span>&#123; <span class="built_in">this</span>.id = ID; &#125;,</span><br><span class="line">    outputID: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="built_in">this</span>.id ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 让XYZ委托Task</span></span><br><span class="line">XYZ = <span class="built_in">Object</span>.create( Task );</span><br><span class="line">XYZ.prepareTask = <span class="function"><span class="keyword">function</span>(<span class="params">ID,Label</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setID(ID);</span><br><span class="line">    <span class="built_in">this</span>.label = Label;</span><br><span class="line">&#125;;</span><br><span class="line">XYZ.outputTaskDetails = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.outputID();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.label);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。</p>
<p>写不下去了~~</p>
<p>学不精，所以讲不通</p>
<p>待我理解透彻再来更新吧</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>精读</tag>
      </tags>
  </entry>
  <entry>
    <title>精读你不知道的JavaScript中卷</title>
    <url>/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%B2%BE%E8%AF%BB%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E5%8D%B7/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="I-第1章-类型"><a href="#I-第1章-类型" class="headerlink" title="I-第1章 类型"></a>I-第1章 类型</h2><p>一个人身上的特异性和一个人身上的特异性与惊奇性并不会对另一人产生压制。你身上的天才，会激发我身上的天才。</p>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>ECMAScript 标准定义了 8 种数据类型:</p>
<p>7 种原始类型:<br>Undefined<br>Null<br>Number<br>Boolean<br>BigInt<br>String<br>Symbol<br>和 Object(基本类型)</p>
<p>记忆口诀：欧呦(O)你(U)俩(2个)牛(N)逼(B)啥(S)</p>
<p>用typeof来查看值的类型，返回的是字符串。但类型和它们的字符串值不一一对应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&#x27;boolean&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">12</span> === <span class="string">&#x27;number&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;12&#x27;</span> === <span class="string">&#x27;string&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">life</span>: <span class="number">12</span> &#125; === <span class="string">&#x27;object&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> BigInt(<span class="string">&#x27;1&#x27;</span>) === <span class="string">&#x27;bigint&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>(BigInt(<span class="string">&#x27;2&#x27;</span>)) === <span class="string">&#x27;object&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不一样的</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测null值的类型需要复合条件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span>;</span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">&#x27;object&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function也是JS的内置类型，实际是object的子类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;<span class="comment">/**/&#125; === &#x27;function&#x27;; // true</span></span><br><span class="line"><span class="comment">// 数组也是object的子类型</span></span><br><span class="line"><span class="comment">typeof [1,2,3] === &#x27;object&#x27; // true</span></span><br></pre></td></tr></table></figure>

<h3 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h3><p>JS中变量没有类型，值才有。变量可以随时持有任何类型的值。</p>
<p>typeof得到的结果不是该变量的类型，而是该变量持有值的类型。返回的总是字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">12</span>; <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="typeof-Undeclared"><a href="#typeof-Undeclared" class="headerlink" title="typeof Undeclared"></a>typeof Undeclared</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a; <span class="comment">// undefined</span></span><br><span class="line">b; <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<p>typeof对未定义的变量也返回<code>undefined</code>。且没有报错。</p>
<p>这是因为typeof有一个特殊的安全防范机制。</p>
<p>多个脚本会在共享的全局命名空间中加载变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Debugging is starting&#x27;</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样是安全的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> DEBUG !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Debugging is starting&#x27;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对内建API也有帮助</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> atob === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    atob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>typeof安全机制也可以用来判断非全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FeatureXYZ</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*.. my XYZ feature ..*/</span> &#125;</span><br><span class="line">    <span class="comment">// 包含doSomethingCool(..)</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomethingCool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> helper =</span><br><span class="line">            (<span class="keyword">typeof</span> FeatureXYZ !== <span class="string">&#x27;undefined&#x27;</span>) ? FeatureXYZ :</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*.. default feature ..*/</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> val = helper();</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">    doSomethingCool();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这里FeatureXYZ不是全局变量，也可以用typeof安全防范机制来做检查</p>
<p>也可以用依赖注入方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingCool</span>(<span class="params">FeatureXYZ</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> helper = FeatureXYZ ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*.. default feature ..*/</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> val = helper();</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型小结"><a href="#类型小结" class="headerlink" title="类型小结"></a>类型小结</h3><ol>
<li>了解JS内置类型</li>
<li>根据typeof判断类型</li>
<li>typeof的安全机制应用场景</li>
</ol>
<h2 id="I-第2章-值"><a href="#I-第2章-值" class="headerlink" title="I-第2章 值"></a>I-第2章 值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过这章的学习，可以了解，数组，字符串，特殊数值，值传递和值引用的区别</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JS的数组可容纳任何类型的值，数组声明后即可添加值，不用预设大小。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, [<span class="number">3</span>]];</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] === <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">4</span>] =  <span class="number">5</span>;</span><br><span class="line">a[<span class="number">3</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>a[3]为undefined，称作”稀疏数组”（sparse array）。这里的undefined与显示赋值为undefined不同。</p>
<p>数组也是对象。可以自定义属性(不计算在数组长度内)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>];</span><br><span class="line">a[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">a.length; <span class="comment">// 1</span></span><br><span class="line">a[<span class="string">&#x27;foo&#x27;</span>]; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类数组转数组常用方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice() 返回参数列表的一个数组复本。</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call( <span class="built_in">arguments</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from( <span class="built_in">arguments</span> );</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串和数组相似，都有length属性，indexOf, concat方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">b.length; <span class="comment">// 3</span></span><br><span class="line">a.indexOf(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line">b.indexOf(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.concat( <span class="string">&#x27;bar&#x27;</span> );<span class="comment">// &#x27;foobar&#x27;</span></span><br><span class="line"><span class="keyword">var</span> d = b.concat( [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>] );<span class="comment">// [&#x27;f&#x27;,&#x27;o&#x27;,&#x27;o&#x27;,&#x27;b&#x27;,&#x27;a&#x27;,&#x27;r&#x27;]</span></span><br><span class="line">a === c;<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">b === d;<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a; <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">b; <span class="comment">// [&#x27;f&#x27;,&#x27;o&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
<p>借助数组方法来处理字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.join;   <span class="comment">// undefined</span></span><br><span class="line">a.map;   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Array</span>.prototype.join.call( a, <span class="string">&#x27;-&#x27;</span> );</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Array</span>.prototype.map.call( a, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.toUpperCase() + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125; ).join( <span class="string">&#x27;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">c;    <span class="comment">// &#x27;f-o-o&#x27;</span></span><br><span class="line">d;    <span class="comment">// &#x27;F.O.O.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>字符串反转</p>
<p>字符串没有<code>reverse</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = a</span><br><span class="line"><span class="comment">// 将a的值转换为字符数组</span></span><br><span class="line">.split( <span class="string">&quot;&quot;</span> )</span><br><span class="line"><span class="comment">// 将数组中的字符进行倒转</span></span><br><span class="line">.reverse()</span><br><span class="line"><span class="comment">// 将数组中的字符拼接回字符串</span></span><br><span class="line">.join( <span class="string">&quot;&quot;</span> );</span><br><span class="line">c; <span class="comment">// &quot;oof&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果经常以字符数组方式处理字符串的话，倒不如直接用数组。在需要时使用<code>join()</code>将数组转成字符串。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>toFixed()返回的是字符串<br>toPrecision(..) 方法用来指定有效数位的显示位数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42.59</span>;</span><br><span class="line">a.toFixed( <span class="number">0</span> ); <span class="comment">// &quot;43&quot;</span></span><br><span class="line">a.toFixed( <span class="number">1</span> ); <span class="comment">// &quot;42.6&quot;</span></span><br><span class="line">a.toFixed( <span class="number">2</span> ); <span class="comment">// &quot;42.59&quot;</span></span><br><span class="line">a.toFixed( <span class="number">3</span> ); <span class="comment">// &quot;42.590&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42.59</span>;</span><br><span class="line"></span><br><span class="line">a.toPrecision( <span class="number">1</span> ); <span class="comment">// &quot;4e+1&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">2</span> ); <span class="comment">// &quot;43&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">3</span> ); <span class="comment">// &quot;42.6&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">4</span> ); <span class="comment">// &quot;42.59&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">5</span> ); <span class="comment">// &quot;42.590&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过对于 <code>.</code> 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。</p>
<p><code>42.tofixed(3)</code> 是无效语法，因为 <code>.</code> 被视为常量 <code>42.</code> 的一部分(如前所述)，所以没有 <code>.</code> 属 性访问运算符来调用 tofixed 方法。<br><code>42..tofixed(3)</code> 则没有问题，因为第一个 <code>.</code> 被视为 number 的一部分，第二个 <code>.</code> 是属性访问运算符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invalid syntax:</span></span><br><span class="line"><span class="number">42.</span>toFixed( <span class="number">3</span> ); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// these are all valid:</span></span><br><span class="line">(<span class="number">42</span>).toFixed( <span class="number">3</span> ); <span class="comment">// &quot;42.000&quot;</span></span><br><span class="line"><span class="number">0.42</span>.toFixed( <span class="number">3</span> ); <span class="comment">// &quot;0.420&quot;</span></span><br><span class="line"><span class="number">42.</span>.toFixed( <span class="number">3</span> ); <span class="comment">// &quot;42.000&quot;</span></span><br><span class="line"><span class="number">42</span> .toFixed(<span class="number">3</span>); <span class="comment">// &quot;42.000&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>怎样判断<code>0.1+0.2 === 0.3</code></p>
<p>最常见的方法是设置一个误差范围值，通常称为“机器精度”(machine epsilon)，对JavaScript的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。<br>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前<br>的版本写 polyfill:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.EPSILON = <span class="built_in">Math</span>.pow(<span class="number">2</span>,-<span class="number">52</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 Number.EPSILON 来比较两个数字是否相等(在指定的误差范围内):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbersCloseEnoughToEqual</span>(<span class="params">n1,n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.3</span>;</span><br><span class="line">numbersCloseEnoughToEqual( a, b );  <span class="comment">// true</span></span><br><span class="line">numbersCloseEnoughToEqual( <span class="number">0.0000001</span>, <span class="number">0.0000002</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>数字“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为 Number.MAX_SAFE_INTEGER。<br>最小整数是 -9007199254740991， 在 ES6 中 被 定 义 为 Number. MIN_SAFE_INTEGER。</p>
<p>整数检测<code>Number.isInteger(..)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42.000</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42.3</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> num == <span class="string">&quot;number&quot;</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测安全的整数<code>Number.isSafeInteger(..)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Number</span>.MAX_SAFE_INTEGER );<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) );<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) - <span class="number">1</span> );<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger) &#123; <span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>.isInteger( num ) &amp;&amp;</span><br><span class="line">        <span class="built_in">Math</span>.abs( num ) &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h3><h4 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h4><p>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名<br>称既是类型也是值。</p>
<ul>
<li>null 指空值(empty value)，曾赋过值，但是目前没有值</li>
<li>undefined 指没有值(missing value)，从未赋值</li>
</ul>
<p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而<br>undefined 却是一个标识符，可以被当作变量来使用和赋值。（不要给undefined赋值！）</p>
<h4 id="void运算符"><a href="#void运算符" class="headerlink" title="void运算符"></a>void运算符</h4><p>表达式void ___没有返回值，因此返回结果是undefined。void并不改变表达式的结果， 只是让表达式不返回值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">void</span> a, a ); <span class="comment">// undefined 42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要将代码中的值(如表达式的返回值)设为 undefined，就可以使用 void。</p>
<h4 id="特殊的数字"><a href="#特殊的数字" class="headerlink" title="特殊的数字"></a>特殊的数字</h4><p>NaN 意指“不是一个数字”(not a number)，不是数字的数字，但仍然是数字类型</p>
<p>NaN是一个特殊值，它和自身不相等，是唯一一个非自反(自反，reflexive，即x === x不成立)的值。而 NaN != NaN 为 true，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">a == <span class="literal">NaN</span>;   <span class="comment">// false</span></span><br><span class="line">a === <span class="literal">NaN</span>;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>ES6以后，可以用Number.isNaN()判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isNaN) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="built_in">window</span>.isNaN( n ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">Number</span>.isNaN( a ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN( b );<span class="comment">// false——好!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种更简单的方法</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isNaN) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n !== n;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> JavaScript 中Infinity(即 Number.POSITIVE_INfiNITY)表示无穷数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="keyword">var</span> b = -<span class="number">1</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<p>负零（-0）</p>
<p>加法和减法运算不会得到负零(negative zero)。</p>
<p>判断是否是负零</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNegZero</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    n = <span class="built_in">Number</span>( n );</span><br><span class="line">    <span class="keyword">return</span> (n === <span class="number">0</span>) &amp;&amp; (<span class="number">1</span> / n === -<span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line">isNegZero( -<span class="number">0</span> );<span class="comment">// true</span></span><br><span class="line">isNegZero( <span class="number">0</span> / -<span class="number">3</span> );<span class="comment">// true</span></span><br><span class="line">isNegZero( <span class="number">0</span> );<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度)，数字的符号位 (sign)用来代表其他信息(比如移动的方向)。<br>此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。</p>
<h4 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h4><p>ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等。<br>仅用来判断NaN和-0等情况，能用===就不用这个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = -<span class="number">3</span> * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( a, <span class="literal">NaN</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, -<span class="number">0</span> );  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">0</span> );  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>polyfill</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.is) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.is = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// test for `-0`</span></span><br><span class="line">        <span class="keyword">if</span> (v1 === <span class="number">0</span> &amp;&amp; v2 === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / v1 === <span class="number">1</span> / v2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// test for `NaN`</span></span><br><span class="line">        <span class="keyword">if</span> (v1 !== v1) &#123;</span><br><span class="line">        <span class="keyword">return</span> v2 !== v2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// everything else</span></span><br><span class="line">        <span class="keyword">return</span> v1 === v2;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h3><p>JS中，值复制还是引用复制，一切由值的类型来决定。</p>
<p>简单类型（null、undefined、字符串、数字、布尔和 ES6 中的 symbol）总是通过值复制方式来赋值/传递。</p>
<p>复合值(compound value)——对象(包括数组和封装对象)和函数，则总是通过引用复制的方式来赋值/传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// `b` is always a copy of the value in `a`</span></span><br><span class="line">b++;</span><br><span class="line">a; <span class="comment">// 2</span></span><br><span class="line">b; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c; <span class="comment">// `d` is a reference to the shared `[1,2,3]` value</span></span><br><span class="line">d.push( <span class="number">4</span> );</span><br><span class="line">c; <span class="comment">// [1,2,3,4]</span></span><br><span class="line">d; <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>函数传参的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x.push( <span class="number">4</span> );</span><br><span class="line">    x; <span class="comment">// [1,2,3,4]</span></span><br><span class="line">    <span class="comment">// 这里x变成了一个新数组，a还是原来的</span></span><br><span class="line">    x = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    x.push( <span class="number">7</span> );</span><br><span class="line">    x; <span class="comment">// [4,5,6,7]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">foo( a );</span><br><span class="line">a; <span class="comment">// [1,2,3,4]  not  [4,5,6,7]</span></span><br></pre></td></tr></table></figure>

<p>将 a 的值变为 [4,5,6,7]，必须更改 x 指向的数组，而不是为 x 赋值一个新的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x.push( <span class="number">4</span> );</span><br><span class="line">    x; <span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样做不会创建新数组</span></span><br><span class="line">    x.length = <span class="number">0</span>; <span class="comment">// empty existing array in-place</span></span><br><span class="line">    x.push( <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> );</span><br><span class="line">    x; <span class="comment">// [4,5,6,7]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">foo( a );</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// [4,5,6,7]  not  [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>如果通过值复制的方式来传递复合值(如数组)，就需要为其创建一个复本，这样传递的就不再是原始值。<br><code>foo( a.slice() );</code> a.slice()返回的是数组的浅复本，foo的操作不会影响a指向的数组。<br>相反，如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值(对象、数组等)中，然后通过引用复制的方式传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">wrapper</span>) </span>&#123;</span><br><span class="line">    wrapper.a = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo( obj );</span><br><span class="line"></span><br><span class="line">obj.a; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h2 id="I-第3章-原生函数"><a href="#I-第3章-原生函数" class="headerlink" title="I-第3章 原生函数"></a>I-第3章 原生函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">学习原生函数，封装对象包装，拆分。</span><br></pre></td></tr></table></figure>

<p>常用的原生函数<br>• String()<br>• Number()<br>• Boolean()<br>• Array()<br>• Object()<br>• Function()<br>• RegExp()<br>• Date()<br>• Error()<br>• Symbol()</p>
<p>原生函数可以被当作构造函数来使用。通过构造函数(如new String(“abc”))创建出来的是封装了基本类型值(如”abc”)的封装对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;abc&quot;</span> );</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// 是&quot;object&quot;，不是&quot;String&quot;</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( a ); <span class="comment">// &quot;[object String]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="内部属性class"><a href="#内部属性class" class="headerlink" title="内部属性class"></a>内部属性class</h3><p>所有 typeof 返回值为 “object” 的对象(如数组)都包含一个内部属性Class。这个属性无法直接访问，通过 <code>Object.prototype.toString(..)</code> 来查看。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="regexp">/regex-literal/i</span> ); <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="literal">null</span> ); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="literal">undefined</span> ); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="string">&quot;abc&quot;</span> ); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="number">42</span> ); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="literal">true</span> ); <span class="comment">// &quot;[object Boolean]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h3><p>由于基本类型值没有<code>.length</code>和<code>.toString()</code>这样的属性和方法，需要通过封装对象才能访问。JS会自动为基本类型包装一个封装对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase(); <span class="comment">// &quot;ABC&quot;</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什么时候应该使用封装对象。</p>
<p>如果要自行封装基本类型值，可以用Object()函数(不带new关键字)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>( a );</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>( a );</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> c; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( b ); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( c ); <span class="comment">// &quot;[object String]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h3><p>要拆封封装对象中的基本类型值，可以用valuesOf()函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;abc&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">42</span> );</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">a.valueOf(); <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">b.valueOf(); <span class="comment">// 42</span></span><br><span class="line">c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;abc&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot;&quot;</span>; <span class="comment">// b拥有了拆封后的值abc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h3><ol>
<li><p>数组</p>
<p> 永远不要创建和使用空单元数组。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>( <span class="number">3</span> );</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span> ];</span><br><span class="line"><span class="keyword">var</span> c = [];</span><br><span class="line">c.length = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object(..)、Function(..) 和 RegExp(..)</p>
<p> 不建议使用Object和Function</p>
<p> 强烈建议使用常量形式(如 /^a*b+/g)来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。<br> 与前面的构造函数不同，RegExp(..) 有时还是很有用的，比如动态定义正则表达式时:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Kyle&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> namePattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">&quot;\\b(?:&quot;</span> + name + <span class="string">&quot;)+\\b&quot;</span>, <span class="string">&quot;ig&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> matches = someText.match( namePattern );</span><br></pre></td></tr></table></figure>

<p> 上述情况在JavaScript编程中时有发生，这时new RegExp(“pattern”,”flags”)就能派上用场。</p>
</li>
<li><p>Date(..) 和 Error(..)</p>
<p> 创建日期必须使用 <code>new Date()</code>。<br> Date(..) 主要用来获得当前的 Unix 时间戳(从 1970 年 1 月 1 日开始计算，以秒为单位)。 该值可以通过日期对象中的 getTime() 来获得。</p>
<p> 用<code>Date.now()</code>即可获取</p>
<p> 创建错误对象(error object)主要是为了获得当前运行栈的上下文(大部分 JavaScript 引擎通过只读属性 .stack 来访问)。<br> 栈上下文信息包括函数调用栈信息和产生错误的代码行号， 以便于调试(debug)。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">&quot;x wasn’t provided&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通常错误对象至少包含一个 message 属性，有时也不乏其他属性(必须作为只读属性访问)，如 type。<br> 除了访问 stack 属性以外，最好的办法是调用toString() 来获得经过格式化的便于阅读的错误信息。</p>
</li>
<li><p>Symbol</p>
<p> 可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键<br> 字，否则会出错:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysym = <span class="built_in">Symbol</span>( <span class="string">&quot;my own symbol&quot;</span> );</span><br><span class="line">mysym;    <span class="comment">// Symbol(my own symbol)</span></span><br><span class="line">mysym.toString(); <span class="comment">// &quot;Symbol(my own symbol)&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> mysym;   <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123; &#125;;</span><br><span class="line">a[mysym] = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols( a );</span><br><span class="line"><span class="comment">// [ Symbol(my own symbol) ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原生原型</p>
<p> 原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。</p>
<p> 这些对象包含其对应子类型所特有的行为特征。</p>
<p> Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式(无任何匹配)，而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isThisCool</span>(<span class="params">vals = <span class="built_in">Array</span>.prototype,fn = <span class="built_in">Function</span>.prototype,rx = <span class="built_in">RegExp</span>.prototype</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rx.test(</span><br><span class="line">        vals.map( fn ).join( <span class="string">&quot;&quot;</span> )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isThisCool();  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">isThisCool(</span><br><span class="line">    [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>],</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123; <span class="keyword">return</span> v.toUpperCase(); &#125;,</span><br><span class="line">    /D/</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 这种方法的一个好处是 .prototype 已被创建并且仅创建一次。相反，如果将 []、function(){} 和 /(?:)/ 作为默认值，<br> 则每次调用 isThisCool(..) 时它们都会被创建一次 (具体创建与否取决于 JavaScript 引擎，稍后它们可能会被垃圾回收)，这样无疑会造成内存和 CPU 资源的浪费。</p>
</li>
</ol>
<h2 id="I-第4章-强制类型转换"><a href="#I-第4章-强制类型转换" class="headerlink" title="I-第4章 强制类型转换"></a>I-第4章 强制类型转换</h2><p>值从一个类型转换为另一种类型，称为类型转换(type casting)。这是显示的情况，隐式的情况称为强制类型转换(coercion)。</p>
<p>类型转换发生在静态语言的编译阶段，强制类型转换发生在动态类型语言的运行时</p>
<p>在JS中统称为强制类型转换。可以通过隐式强制类型和强制类型转换来区分。</p>
<p>隐式类型转换不明显，通常是某些操作产生的副作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot;&quot;</span>; <span class="comment">// 隐式强制类型转换</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">String</span>(a); <span class="comment">// 显式强制类型转换</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h3><h4 id="ToString-非字符串到字符串强制类型转换"><a href="#ToString-非字符串到字符串强制类型转换" class="headerlink" title="ToString 非字符串到字符串强制类型转换"></a>ToString 非字符串到字符串强制类型转换</h4><p>基本类型值的字符串化规则为:null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。数字极大极小值用指数形式。<br>数组的toString默认将所有单元字符串化后用<code>,</code>连接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.toString(); <span class="comment">// &#x27;1,2,3,&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h4><p>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。<br>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</p>
<p>JSON字符串化用<code>stringify</code>,遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">undefined</span> );     <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; );     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( [<span class="number">1</span>,<span class="literal">undefined</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="number">4</span>] ); <span class="comment">// &quot;[1,null,null,4]&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( &#123; <span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; );  <span class="comment">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>包含循环引用的对象执行 JSON.stringify(..) 会出错。</p>
<p>如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，需要定义 toJSON() 方法来返回一个能够被字符串化的安全的 JSON 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">42</span>,</span><br><span class="line">    c: o,</span><br><span class="line">    d: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a被循环引用</span></span><br><span class="line">o.e = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于循环引用，会抛出异常</span></span><br><span class="line"><span class="comment">// JSON.stringify( a );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define a custom JSON value serialization</span></span><br><span class="line">a.toJSON = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// only include the `b` property for serialization</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="built_in">this</span>.b &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a ); <span class="comment">// &quot;&#123;&quot;b&quot;:42&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>向 <code>JSON.stringify(..)</code> 传递一个可选参数 replacer，可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。<br>如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。<br>如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined，否则返回指定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">42</span>,</span><br><span class="line">    c: <span class="string">&quot;42&quot;</span>,</span><br><span class="line">    d: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a, [<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>] ); <span class="comment">// &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a, <span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k !== <span class="string">&quot;c&quot;</span>) <span class="keyword">return</span> v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h4><p>true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>
<p>对象(包括数组)会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</p>
<h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><ol>
<li><p>假值(false value) 可以被强制类型转换为 false 的值。</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0, -0, NaN</li>
<li>‘’</li>
</ul>
</li>
<li><p>假值对象</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">0</span> );</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;&quot;</span> );</span><br></pre></td></tr></table></figure>

<p> a, b, c都为true</p>
</li>
<li><p>真值</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;false&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;&#x27;&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );</span><br><span class="line">d; <span class="comment">// 字符串不为空所以为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );</span><br><span class="line">d; <span class="comment">// [], &#123;&#125;, function()&#123;&#125; 不为空，为true</span></span><br></pre></td></tr></table></figure>

<h3 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h3><p>代码转换清晰，可读性高，更容易理解，推荐使用。</p>
<ol>
<li><p>字符串数字互转</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">String</span>( a );</span><br><span class="line">b; <span class="comment">// &quot;42&quot;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Number</span>( c );</span><br><span class="line">d; <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = +c; <span class="comment">// 最常用~~~</span></span><br><span class="line">d; <span class="comment">// 3.14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>奇特的~运算符</p>
<p> 字位运算符(如 | 和 ~)和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字。</p>
</li>
</ol>
<p>在 -(x+1) 中唯一能够得到 0(或者严格说是 -0)的 x 值是 -1。也就是说如果 x 为 -1 时，~和一些数字值在一起会返回假值 0，其他情况则返回真值。</p>
<p><code>indexOf</code>搜索到指定字符串返回字符串所在位置(从0开始)，否则返回-1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;lo&quot;</span> ) &gt;= <span class="number">0</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// found it!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;lo&quot;</span> ) != -<span class="number">1</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// found it</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;ol&quot;</span> ) &lt; <span class="number">0</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// not found!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;ol&quot;</span> ) == -<span class="number">1</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// not found!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">&quot;lo&quot;</span> );   <span class="comment">// -4   &lt;-- truthy!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (~a.indexOf( <span class="string">&quot;lo&quot;</span> )) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// found it!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">&quot;ol&quot;</span> );   <span class="comment">// 0    &lt;-- falsy!</span></span><br><span class="line">!~a.indexOf( <span class="string">&quot;ol&quot;</span> );  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!~a.indexOf( <span class="string">&quot;ol&quot;</span> )) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// not found!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&gt;= 0</code>和<code>== -1</code>这样的写法不是很好，称为“抽象渗漏”，在代码中暴露了底层的实现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉。<br><strong><code>~</code> 和 <code>indexOf()</code> 一起可以将结果强制类型转换(实际上仅仅是转换)为真 / 假值</strong></p>
<p>这种写法看起来逼格也高，哈哈</p>
<p><code>~~</code>中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。</p>
<p>只适用于 32 位数字，更重要的是它对负数的处理与 Math. floor(..) 不同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor( -<span class="number">49.6</span> ); <span class="comment">// -50</span></span><br><span class="line">~~-<span class="number">49.6</span>; <span class="comment">// -49</span></span><br></pre></td></tr></table></figure>

<h3 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h3><p>解析(parseInt)允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。字符串转数字(Number)不允许出现非数字字符，否则会失败并返回 NaN。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;42px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>( a ); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">parseInt</span>( a ); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>( b ); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>( b ); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>parseInt(..) 针对的是字符串值。向 parseInt(..) 传递其他类型的参数，比如 <code>true、function()&#123;...&#125;</code> 和 <code>[1,2,3]</code>。<br>会首先被强制类型转换为字符串，依赖这样的隐式强制类型转换并非上策，应该避免向 parseInt(..) 传递非字符串参数。</p>
<p>parseInt(..) 先将参数强制类型转换为字符串再进行解析。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>( <span class="number">1</span>/<span class="number">0</span>, <span class="number">19</span> ); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>怎么来处理 Infinity(1/0 的结果)最合理呢?有两个选择:”Infinity” 和 “∞”，JavaScript选择的是 “Infinity”。</p>
<p>parseInt(1/0, 19) 实际上是 parseInt(“Infinity”, 19)。第一个字符是 “I”，以 19 为基数 时值为 18。第二个字符 “n” 不是一个有效的数字字符，解析到此为止，和 “42px” 中的 “p” 一样。</p>
<p>最后的结果是 18，而非 Infinity 或者报错。所以理解其中的工作原理对于我们学习 JavaScript 是非常重要的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.000008</span> );  <span class="comment">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.0000008</span> );  <span class="comment">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="literal">false</span>, <span class="number">16</span> );  <span class="comment">// 250 (&quot;fa&quot; from &quot;false&quot;)</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="built_in">parseInt</span>, <span class="number">16</span> ); <span class="comment">// 15  (&quot;f&quot; from &quot;function..&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">&quot;0x10&quot;</span> );   <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">&quot;103&quot;</span>, <span class="number">2</span> );  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="显示转换为布尔值"><a href="#显示转换为布尔值" class="headerlink" title="显示转换为布尔值"></a>显示转换为布尔值</h3><p>显式强制类型转换为布尔值最常用的方法<code>!!</code>，第二个<code>!</code>会把结果反转回原值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> g;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>( a ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>( b ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>( c ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>( d ); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>( e ); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>( f ); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>( g ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!a; <span class="comment">// true</span></span><br><span class="line">!!b; <span class="comment">// true</span></span><br><span class="line">!!c; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!!d; <span class="comment">// false</span></span><br><span class="line">!!e; <span class="comment">// false</span></span><br><span class="line">!!f; <span class="comment">// false</span></span><br><span class="line">!!g; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>三元运算符 <code>? :</code> 判断 a 是否为真，如果是则将变量 b 赋值为 true，否则赋值为 false。 表面上这是一个显式的 ToBoolean 强制类型转换，因为返回结果是 true 或者 false。<br>然而这里涉及隐式强制类型转换，因为 a 要首先被强制类型转换为布尔值才能进行条件判断。这种情况称为“显式的隐式”，有百害而无一益，我们应彻底杜绝。<br>建议使用 Boolean(a) 和 !!a 来进行显式强制类型转换。</p>
<h3 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h3><p>不够明显的强制类型转换都可以算作隐式强制类型转换。</p>
<p>隐式强制类型转换的作用是减少冗余，让代码更简洁。可能会让代码晦涩难懂。</p>
<p><code>+</code>既能用于字符串也能用于数字。怎么判断要执行哪个操作？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a + b; <span class="comment">// &quot;420&quot;</span></span><br><span class="line">c + d; <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">a + b; <span class="comment">// &quot;1,23,4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数字转成字符串</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot;&quot;</span>;</span><br><span class="line">b; <span class="comment">// &quot;42&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果其中一个操作数是对象(包括数组)，则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用DefaultValue，以数字作为上下文。<br>数组的 valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()。因此上例中的两个数组变成了 “1,2” 和 “3,4”。+ 将它们拼接后返回 “1,23,4”。</p>
<p>如果 + 的其中一个操作数是字符串(或者通过以上步骤可以得到字符串)， 则执行字符串拼接;否则执行数字加法。</p>
<p>a + “”(隐式)和前面的String(a)(显式)之间有一个细微的差别需要注意。<br>根据 ToPrimitive抽象操作规则，a + “”会对a调用valueOf()方法，然后通过ToString抽象 操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。</p>
<p>如果a是对象，结果会不一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a + <span class="string">&quot;&quot;</span>;   <span class="comment">// &quot;42&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>( a ); <span class="comment">// &quot;4</span></span><br></pre></td></tr></table></figure>

<p>在定制 valueOf() 和 toString() 方法时需要特别小心，因为这会影响强制类型转换的结果。</p>
<p><code>-</code>减法运算符，会先转换为字符串，再转换为数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = a - <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">b; <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>];</span><br><span class="line">a - b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔值到数字的隐式强制类型转换"><a href="#布尔值到数字的隐式强制类型转换" class="headerlink" title="布尔值到数字的隐式强制类型转换"></a>布尔值到数字的隐式强制类型转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">arr = [<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>]</span><br><span class="line">arr.reduce(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">    sum +=item</span><br><span class="line">&#125;, sum)</span><br></pre></td></tr></table></figure>

<p>在控制台显示是NaN？？？和书里不一样</p>
<h3 id="隐式强制类型转换为布尔值"><a href="#隐式强制类型转换为布尔值" class="headerlink" title="隐式强制类型转换为布尔值"></a>隐式强制类型转换为布尔值</h3><p>(1)if (..)语句中的条件判断表达式。<br>(2)for ( .. ; .. ; .. )语句中的条件判断表达式(第二个)。<br>(3) while (..) 和 do..while(..) 循环中的条件判断表达式。<br>(4)? :中的条件判断表达式。<br>(5) 逻辑运算符 ||(逻辑或)和 &amp;&amp;(逻辑与)左边的操作数(作为条件判断表达式)。</p>
<p>以上情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的 ToBoolean 抽象操作规则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;yep&quot;</span> );  <span class="comment">// yep</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (c) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;nope, never runs&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = d ? a : b;</span><br><span class="line">c;     <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a &amp;&amp; d) || c) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;yep&quot;</span> );  <span class="comment">// yep</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h3><p>JS中返回的不一定布尔值。而是两个操作数中的一个的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a || b;  <span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b;  <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">c || b;  <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">c &amp;&amp; b;  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>|| 和 &amp;&amp; 首先会对第一个操作数(a 和 c)执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p>
<p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数(a 和 c)的值，如果为 false 就返回第二个操作数(b)的值。<br>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数(b)的值，如果为 false 就返回第一个操作数(a 和 c)的值。</p>
<p>换个角度理解</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a || b;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">a ? a : b;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">a ? b : a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同三元表达式不同的是, 如果a是表达式，可能会执行两次。</span></span><br></pre></td></tr></table></figure>

<h4 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h4><p>设置默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line"> a = a || <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> b = b || <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log( a + <span class="string">&quot; &quot;</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();     <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line">foo( <span class="string">&quot;yeah&quot;</span>, <span class="string">&quot;yeah!&quot;</span> ); <span class="comment">// &quot;yeah yeah!&quot;</span></span><br></pre></td></tr></table></figure>

<p>短路机制</p>
<p>a为false时，foo不会执行。比<code>if (a) &#123; foo() &#125;</code>简洁明了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h3><p><strong><code>==</code>允许在相等比较中进行强制类型转换，而<code>===</code>不允许。</strong></p>
<p>人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级 (百万分之一秒)的差别而已。<br>如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎 实现上的细微差别之外，它们之间并没有什么不同。</p>
<h4 id="抽象相等"><a href="#抽象相等" class="headerlink" title="抽象相等"></a>抽象相等</h4><p>规定如果两个值的类型相同，就仅比较它们是否相等。例如，42 等于 42，”abc” 等于 “abc”。</p>
<p>特殊情况 NaN 不等于 NaN，+0 等于 -0。</p>
<p>以 x 和 y 为值进行 x == y 比较会产生的结果可为 true 或 false。比较的执行步骤如下：</p>
<ol>
<li>若 Type(x) 与 Type(y) 相同， 则<ol>
<li>若 Type(x) 为 Undefined， 返回 true。</li>
<li>若 Type(x)为 Null， 返回 true。</li>
<li>若 Type(x)为 Number，则<ol>
<li>若 x 为 NaN，返回 false。</li>
<li>若 y 为 NaN，返回 false。</li>
<li>若 x 与 y 为相等数值，返回 true。</li>
<li>若 x 为 +0 且 y 为 −0，返回 true。</li>
<li>若 x 为 −0 且 y 为 +0，返回 true。</li>
<li>返回 false。</li>
</ol>
</li>
<li>若 Type(x) 为 String，则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。否则，返回 false。</li>
<li>若 Type(x) 为 Boolean，当 x 和 y 为同为 true 或者同为 false 时返回 true。否则，返回 false。</li>
<li>当 x 和 y 为引用同一对象时返回 true。否则，返回 false。</li>
</ol>
</li>
<li>若 x 为 null 且 y 为 undefined，返回 true。</li>
<li>若 x 为 undefined 且 y 为 null，返回 true。</li>
<li>若 Type(x) 为 Number 且 Type(y) 为 String，返回 x == ToNumber(y) 的结果。</li>
<li>若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。</li>
<li>若 Type(x) 为 Boolean，返回比较 ToNumber(x) == y 的结果。</li>
<li>若 Type(y) 为 Boolean，返回比较 x == ToNumber(y) 的结果。</li>
<li>若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。</li>
<li>若 Type(x) 为 Object 且 Type(y) 为 String 或 Number，返回比较 ToPrimitive(x) == y 的结果。</li>
<li>返回 false。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;42&quot;</span>;</span><br><span class="line">a === b; <span class="comment">// false</span></span><br><span class="line">a == b;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line">a == b; <span class="comment">// false 1==42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="literal">false</span>;</span><br><span class="line">x == y; <span class="comment">// false 42==0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="number">42</span> ];</span><br><span class="line">a == b; <span class="comment">// true 42==42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>( a ); <span class="comment">// same as `new String( a )`</span></span><br><span class="line">a === b;    <span class="comment">// false</span></span><br><span class="line">a == b;     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>( a ); <span class="comment">// same as `Object()`</span></span><br><span class="line">a == b;     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>( c ); <span class="comment">// same as `Object()`</span></span><br><span class="line">c == d;     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">Object</span>( e ); <span class="comment">// same as `new Number( e )`</span></span><br><span class="line">e == f;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>无论什么情况下都不要使用 == true 和 == false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会失败</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会失败</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好</span></span><br><span class="line"><span class="keyword">if</span> (!!a) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也很好</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>( a )) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><p>更改内置原生原型会导致奇怪效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">2</span> ) == <span class="number">3</span>; <span class="comment">// true，因为valueOf返回3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况也会发生，如下</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 让 a.valueOf() 每次调用都产生副作用，第一次返回 2，第二次返回 3</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> i++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;Yep, this happened.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">null</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">undefined</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">false</span>;   <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">NaN</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="number">0</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="string">&quot;&quot;</span>;    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">NaN</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>;    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&quot;&quot;</span>;   <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="literal">false</span> == [];   <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="literal">false</span> == &#123;&#125;;   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">null</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">undefined</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">NaN</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="number">0</span>;    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == [];    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == &#123;&#125;;    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">NaN</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == [];    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="number">0</span> == &#123;&#125;;    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>有 7 种注释了“UH OH!”，因为它们属于假阳(false positive)的情况，里面坑很多。 “” 和 0 明显是两个不同的值，它们之间的强制类型转换很容易搞错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[] == ![] <span class="comment">// true,根据toBoolean变成[]==false</span></span><br><span class="line"><span class="number">2</span> == [<span class="number">2</span>];  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == [<span class="literal">null</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>，== 右边的值 <code>[2]</code> 和 <code>[null]</code> 会进行 ToPrimitive 强制类型转换， 以便能够和左边的基本类型值(2 和 “”)进行比较。因为数组的 valueOf() 返回数组本身， 所以强制类型转换过程中数组会进行字符串化。<br>第一行中的 <code>[2]</code> 会转换为 <code>&quot;2&quot;</code>，然后通过 ToNumber 转换为 2。第二行中的 <code>[null]</code> 会直接转 换为 “”。<br>所以最后的结果就是 <code>2 == 2</code> 和 <code>&quot;&quot; == &quot;&quot;</code>。</p>
<p>安全运用隐式强制转换，遵循以下两个原则：</p>
<ul>
<li>如果两边的值中有 true 或者 false，千万不要使用 ==。</li>
<li>如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。</li>
</ul>
<p><strong>最好用 === 来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。</strong></p>
<h3 id="抽象关系比较"><a href="#抽象关系比较" class="headerlink" title="抽象关系比较"></a>抽象关系比较</h3><p>比较双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。</p>
<p>如果比较双方都是字符串，则按字母顺序来进行比较:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">42</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="string">&quot;43&quot;</span> ];</span><br><span class="line"></span><br><span class="line">a &lt; b; <span class="comment">// true  42&lt;43</span></span><br><span class="line">b &lt; a; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [ <span class="string">&quot;42&quot;</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="string">&quot;043&quot;</span> ];</span><br><span class="line"></span><br><span class="line">a &lt; b; <span class="comment">// false  字符串，&quot;42&quot; &lt; &quot;043&quot; 4&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [ <span class="number">4</span>, <span class="number">2</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span> ];</span><br><span class="line">a &lt; b; <span class="comment">// false &#x27;4,2&#x27; &lt; &#x27;0,4,3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line">a &lt; b; <span class="comment">// false &#x27;[object Object]&#x27; &lt; &#x27;[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下很奇怪</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line"></span><br><span class="line">a &lt; b; <span class="comment">// false</span></span><br><span class="line">a == b; <span class="comment">// false</span></span><br><span class="line">a &gt; b; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a &lt;= b; <span class="comment">// true</span></span><br><span class="line">a &gt;= b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>JS中 <code>&lt;=</code> 是“不大于”的意思(即 !(a &gt; b)，处理为 !(b &lt; a))。同理 a &gt;= b 处理为 !(a&lt;b)。</p>
<p>要避免a &lt; b中发生隐式强制类型转换，我们只能确保a和b为相同的类型， 除此之外别无他法。</p>
<p>为了保证安全，应该对关系比较中的值进行显式强制类型转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">42</span> ];</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;043&quot;</span>;</span><br><span class="line"></span><br><span class="line">a &lt; b;      <span class="comment">// false -- string comparison!</span></span><br><span class="line"><span class="built_in">Number</span>( a ) &lt; <span class="built_in">Number</span>( b ); <span class="comment">// true -- number comparison!</span></span><br></pre></td></tr></table></figure>

<h3 id="小结类型转换"><a href="#小结类型转换" class="headerlink" title="小结类型转换"></a>小结类型转换</h3><p>了解显示隐式转换</p>
<p>一般编码规范的项目都会要求强制类型转换</p>
<p>再加上用了TS之后，要求更高了。</p>
<p>不过还是要知其然，更要知其所以然。</p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>精读</tag>
      </tags>
  </entry>
  <entry>
    <title>React和Vue</title>
    <url>/posts/React%20%E5%92%8CVue/</url>
    <content><![CDATA[<h1 id="在jsx文件中为什么一定要引用react"><a href="#在jsx文件中为什么一定要引用react" class="headerlink" title="在jsx文件中为什么一定要引用react"></a>在jsx文件中为什么一定要引用react</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSX 语法就是用React.createElement()来构建 React 元素的。</span><br><span class="line">它接受三个参数，第一个参数可以是一个标签名。</span><br><span class="line">如div、span，或者 React 组件。</span><br><span class="line">第二个参数为传入的属性。</span><br><span class="line">第三个以及之后的参数，皆作为组件的子组件。</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement()</span><br><span class="line"></span><br><span class="line">React.cloneElement()与React.createElement()相似，</span><br><span class="line">不同的是它传入的第一个参数是一个 React</span><br><span class="line">元素，而不是标签名或组件。</span><br><span class="line">新添加的属性会并入原有的属性，</span><br><span class="line">传入到返回的新元素中，而就的子元素奖杯替换。</span><br><span class="line"></span><br><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h1><p>React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。</p>
<h2 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass()"></a>React.createClass()</h2><p>React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Greeting &#x3D; React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h2><p>ES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Greeting extemds React.Component&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="无状态函数"><a href="#无状态函数" class="headerlink" title="无状态函数"></a>无状态函数</h1><p>无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。</p>
<h1 id="元素与组件的区别"><a href="#元素与组件的区别" class="headerlink" title="元素与组件的区别"></a>元素与组件的区别</h1><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="componentWillReceiveProps应用场景"><a href="#componentWillReceiveProps应用场景" class="headerlink" title="componentWillReceiveProps应用场景"></a>componentWillReceiveProps应用场景</h1><p>如果子组件需要的数据是直接由父组件通过props传递过来就不需要在componentwillreceiveprops中setState，但是如果子组件有自己的状态，同时这个状态依赖于父组件的数据，那么就需要子组件单独进行setState操作，否则无法完成子组件的更新。同时有一点，在componentwillreceiveprops中写setState不会再次触发子组件的render。解释一下：父组件setState时会触发子组件的render，此时如果在子组件的componentwillreceiveprops里setState，给人的感觉是会再一次触发子组件的render（加上前面的一次就是两次），实际情况是不会的</p>
<h1 id="vuex和redux使用有什么不同"><a href="#vuex和redux使用有什么不同" class="headerlink" title="vuex和redux使用有什么不同"></a>vuex和redux使用有什么不同</h1><p>Vuex 其实是一个针对 Vue 特化的 Flux，主要是为了配合 Vue 本身的响应式机制。当然吸取了一些 Redux 的特点，比如单状态树和便于测试和热重载的 API，但是也选择性的放弃了一些在 Vue 的场景下并不契合的特性，比如强制的 immutability（在保证了每一次状态变化都能追踪的情况下强制的 immutability 带来的收益就很有限了）、为了同构而设计得较为繁琐的 API、必须依赖第三方库才能相对高效率地获得状态树的局部状态等等（相比之下 Vuex 直接用 Vue 本身的计算属性就可以）所以 Vue + Vuex 会更简洁，也不需要考虑性能问题，代价就是 Vuex 只能和 Vue 配合。Vue + Redux 也不是不可以，但是 Redux 作为一个泛用的实现和 Vue 的契合度肯定不如 Vuex。</p>
<h1 id="nextTick的作用，原理，用api的场景"><a href="#nextTick的作用，原理，用api的场景" class="headerlink" title="nextTick的作用，原理，用api的场景"></a>nextTick的作用，原理，用api的场景</h1><p>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</p>
<p>也许有人会问，我在 Vue 实例方法中修改了数据，然后再在 $nextTick 回调中获取该数据在相应 DOM 元素所绑定的内容（或属性）殊无必要，我为什么需要这样的 API 呢？</p>
<p>考虑这样一种场景，你有一个 jQuery 插件，希望在 DOM 元素中某些属性发生变化之后重新应用该插件，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。</p>
<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</p>
<p>原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。</p>
<p>当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    example: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; modify data</span><br><span class="line">      this.message &#x3D; &#39;changed&#39;</span><br><span class="line">      &#x2F;&#x2F; DOM is not updated yet</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; DOM is now updated</span><br><span class="line">        &#x2F;&#x2F; &#96;this&#96; is bound to the current instance</span><br><span class="line">        this.doSomethingElse()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</p>
<h1 id="vue的props，state-compute区别"><a href="#vue的props，state-compute区别" class="headerlink" title="vue的props，state, compute区别"></a>vue的props，state, compute区别</h1><p>data: Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。</p>
<p>props: 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
<p>两个的区别就是data是响应式的？</p>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p>注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>
<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。</p>
<h1 id="react-native-和原生的怎么通信"><a href="#react-native-和原生的怎么通信" class="headerlink" title="react native 和原生的怎么通信"></a>react native 和原生的怎么通信</h1><h1 id="pure-component"><a href="#pure-component" class="headerlink" title="pure component"></a>pure component</h1><p>React15.3中新加了一个 PureComponent 类， 也就是纯组件，取代其前身 PureRenderMixin , PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，</p>
<p>可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。</p>
<h1 id="React-Native-与-原生交互"><a href="#React-Native-与-原生交互" class="headerlink" title="React Native 与 原生交互"></a>React Native 与 原生交互</h1><p><a href="https://www.jianshu.com/p/41dd77a83c13">链接</a></p>
<h1 id="vue-js-和vue-runtime-js区别"><a href="#vue-js-和vue-runtime-js区别" class="headerlink" title="vue.js 和vue.runtime.js区别"></a>vue.js 和vue.runtime.js区别</h1><p>vue.js</p>
<p>完整版：同时包含编译器和运行时的版本。</p>
<p>runtime.js</p>
<p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p>
<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p>
<h1 id="高阶组件？？-解决了什么问题"><a href="#高阶组件？？-解决了什么问题" class="headerlink" title="高阶组件？？ 解决了什么问题"></a>高阶组件？？ 解决了什么问题</h1><p><a href="https://segmentfault.com/a/1190000010371752">链接</a></p>
<p>适配器模式，</p>
<p>高阶函数的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。</p>
<p>对于高阶组件，它描述的便是接受React组件作为输入，输出一个新的React组件的组件。</p>
<p>高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的React组件，供其他组件调用。</p>
<p>高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用。</p>
<h1 id="setState源码剖析，多次调用解密"><a href="#setState源码剖析，多次调用解密" class="headerlink" title="setState源码剖析，多次调用解密"></a>setState源码剖析，多次调用解密</h1><p>setState流程还是很复杂的，设计也很精巧，<br>避免了重复无谓的刷新组件。它的主要流程如下</p>
<ol>
<li><p>enqueueSetState将state放入队列中，并调用enqueueUpdate处理要更新的Component</p>
</li>
<li><p>如果组件当前正处于update事务中，则先将Component存入dirtyComponent中。否则调用batchedUpdates处理。</p>
</li>
<li><p>batchedUpdates发起一次transaction.perform()事务<br>开始执行事务初始化，运行，结束三个阶段</p>
<p> 1 初始化：事务初始化阶段没有注册方法，故无方法要执行</p>
<p> 2 运行：执行setSate时传入的callback方法，一般不会传callback参数</p>
<p> 3 结束：更新isBatchingUpdates为false，并执行FLUSH_BATCHED_UPDATES这个wrapper中的close方法<br>FLUSH_BATCHED_UPDATES在close阶段，会循环遍历所有的dirtyComponents，调用updateComponent刷新组件，并执行它的pendingCallbacks, 也就是setState中设置的callback。</p>
</li>
</ol>
<p>会调用到batchedUpdates进行批处理更新，<br>React以事务的方式处理组件update，事务处理完后会调用wrapper.close(),</p>
<h1 id="react-diff"><a href="#react-diff" class="headerlink" title="react diff"></a>react diff</h1><p><a href="https://github.com/purplebamboo/blog/issues/3">链接</a></p>
<p>三大要点</p>
<ul>
<li>tree diff<br>  两棵树只会对同一层次的节点进行比较。</li>
<li>component diff<br>  判断是否是同一类型组件</li>
<li>element diff<br>  同一节点 插入，删除，移动属性</li>
</ul>
<p>在reactjs中我们需要更新时都是调用的setState</p>
<p>setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。</p>
<p>就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新。</p>
<p>会合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了。</p>
<p>本质上还是递归调用receiveComponent的过程。</p>
<p>这里注意两个函数：</p>
<p>inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。</p>
<p>_shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。</p>
<p>==简单回顾下reactjs的差异算法：==</p>
<p>首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。</p>
<p>react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。</p>
<p>每个类型的元素都要处理好自己的更新：</p>
<p>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</p>
<p>text节点的更新很简单，直接更新文案。</p>
<p>浏览器基本元素的更新，分为两块：</p>
<p>先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。</p>
<p>然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。<br>整个reactjs的差异算法就是这个样子。</p>
<p>最核心的两个_shouldUpdateReactComponent以及diff,patch算法。</p>
<p>//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</p>
<p>_patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</p>
<p><a href="https://zhuanlan.zhihu.com/p/20346379?refer=purerender">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"></span><br><span class="line">React 通过制定大胆的 diff 策略，将 O(n3)</span><br><span class="line">复杂度的问题转换成 O(n) 复杂度的问题；</span><br><span class="line"></span><br><span class="line">React 通过分层求异的策略，对 tree diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">React 通过相同类生成相似树形结构，</span><br><span class="line">不同类生成不同树形结构的策略，</span><br><span class="line">对 component diff 进行算法优化；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">React 通过设置唯一 key的策略，</span><br><span class="line">对 element diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">建议，在开发组件时，保持稳定的 DOM</span><br><span class="line">结构会有助于性能的提升；</span><br><span class="line"></span><br><span class="line">建议，在开发过程中，尽量减少类似将最后一个节点移</span><br><span class="line">动到列表首部的操作，当节点数量过大或更新操作</span><br><span class="line">过于频繁时，在一定程度上会影响 React 的渲染性能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree diff</span><br><span class="line"></span><br><span class="line">React 对树的算法进行了简洁明了的优化，</span><br><span class="line">即对树进行分层比较，两棵树只会对同一层次的</span><br><span class="line">节点进行比较。</span><br><span class="line"></span><br><span class="line">component diff</span><br><span class="line"></span><br><span class="line">如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</span><br><span class="line"></span><br><span class="line">如果不是，则将该组件判断为 dirty component，</span><br><span class="line">从而替换整个组件下的所有子节点。</span><br><span class="line"></span><br><span class="line">对于同一类型的组件，有可能其 Virtual DOM</span><br><span class="line">没有任何变化，如果能够确切的知道这点那可以</span><br><span class="line">节省大量的 diff 运算时间，因此 React 允许用户通过</span><br><span class="line">shouldComponentUpdate() 来判断该组件是否需要进行 diff。</span><br><span class="line"></span><br><span class="line">element diff</span><br><span class="line"></span><br><span class="line">当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</span><br><span class="line"></span><br><span class="line">INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</span><br><span class="line"></span><br><span class="line">MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild&#x3D;nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</span><br><span class="line"></span><br><span class="line">REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</span><br><span class="line"></span><br><span class="line">React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。</span><br><span class="line"></span><br><span class="line">针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="设计组件"><a href="#设计组件" class="headerlink" title="设计组件"></a>设计组件</h1><p>组件尽量只做渲染，逻辑处理放到reducer中</p>
<h1 id="redux-中的action"><a href="#redux-中的action" class="headerlink" title="redux 中的action"></a>redux 中的action</h1><p>Action Creator 的唯一功能就是返回一个Action供 dispatch 进行调用。</p>
<p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件：</p>
<p>是一个纯文本对象</p>
<p>只具备 type 、payload、error 和 meta 中的一个或者多个属性。</p>
<p>type 字段不可缺省，其它字段可缺省</p>
<p>若 Action 报错，error 字段不可缺省，切必须为 true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">在 redux 全家桶中，可以利用 redux-actions 来创建符合 FSA 规范的Action：</span><br><span class="line"></span><br><span class="line">import &#123;creatAction&#125; from &#39;redux-actions&#39;;</span><br><span class="line"></span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO)</span><br><span class="line">&#x2F;&#x2F;same as</span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO,data&#x3D;&gt;data)</span><br><span class="line"></span><br><span class="line">Redux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件：</span><br><span class="line"></span><br><span class="line">redux-thunk</span><br><span class="line">redux-promise</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用connect将组件绑定到redux</span><br><span class="line">export const ButtonContainer &#x3D; connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Buttons);</span><br><span class="line"></span><br><span class="line">容器组件实现 mapStateToProps()（用于将状态映射到数据）</span><br><span class="line">和 mapDispatchToProps()（用于将状态映射到行为）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</span><br><span class="line"></span><br><span class="line">操作发起时的 Action</span><br><span class="line">操作成功时的 Action</span><br><span class="line">操作失败时的 Action</span><br><span class="line"></span><br><span class="line">操作开始时，送出一个 Action，触发 State 更新为&quot;正在操作&quot;状态，View 重新渲染</span><br><span class="line"></span><br><span class="line">用户触发第一个 Action，这个跟同步操作一样，没有问题；</span><br><span class="line">如何才能在操作结束时，系统自动送出第二个 Action 呢？</span><br><span class="line"></span><br><span class="line">Action 是由store.dispatch方法发送的。</span><br><span class="line">而store.dispatch方法正常情况下，参数只能是对象，</span><br><span class="line">不能是函数。</span><br><span class="line"></span><br><span class="line">这时，就要使用中间件redux-thunk。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fetchPosts &#x3D; postTitle &#x3D;&gt; (dispatch, getState) &#x3D;&gt; &#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  return fetch(&#96;&#x2F;some&#x2F;API&#x2F;$&#123;postTitle&#125;.json&#96;)</span><br><span class="line">    .then(response &#x3D;&gt; response.json())</span><br><span class="line">    .then(json &#x3D;&gt; dispatch(receivePosts(postTitle, json)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法一</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;));</span><br><span class="line">&#x2F;&#x2F; 使用方法二</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;)).then(() &#x3D;&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">看这里，返回的是Promise，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>==用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。==</p>
<p>store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。</p>
<p>Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，</p>
<p>Redux的单向数据流是同步操作，驱动Redux流程的是action对象，每一个action对象被派发到Store上之后，同步地被分配给所有的reducer函数，每个reducer都是纯函数，纯函数不产生任何副作用，自然是完成数据操作之后立刻同步返回，reducer返回的结果又被同步地拿去更新Store上的状态数据，更新状态数据的操作会立刻被同步给监听Store状态改变的函数，从而引发作为视图的React组件更新过程。</p>
<p>这个过程从头到尾，Redux马不停蹄地一路同步执行，根本没有执行异步操作的机会，那应该在哪里插入访问服务器的异步操作呢？</p>
<p>Redux创立之初就意识到了这种问题，所以提供了thunk这种解决方法，但是thunk并没有作为Redux的一部分一起发布，而是存在一个独立的redux-thunk发布包中，</p>
<p>redux-thunk只是Redux中异步操作的解决方法之一</p>
<p>在Redux架构下，一个action对象在通过store.dispatch派发，在调用reducer函数之前，会先经过一个中间件的环节，这就是产生异步操作的机会，实际上redux-thunk提供的就是一个Redux中间件，我们需要在创建Store时用上这个中间件。</p>
<h1 id="异步action对象"><a href="#异步action对象" class="headerlink" title="异步action对象"></a>异步action对象</h1><h2 id="非常好的讲解"><a href="#非常好的讲解" class="headerlink" title="非常好的讲解"></a><a href="http://geek.csdn.net/news/detail/202352">非常好的讲解</a></h2><p>当我们想要让Redux帮忙处理一个异步操作的时候，代码一样也要派发一个action对象，毕竟Redux单向数据流就是由action对象驱动的。但是这个引发异步操作的action对象比较特殊，我们叫它们“异步action对象”。</p>
<p>前面例子中的action构造函数返回的都是一个普通的对象，这个对象包含若干字段，其中必不可少的字段是type，但是“异步action对象”不是一个普通JavaScript对象，而是一个函数。</p>
<p>如果没有redux-thunk中间件的存在，这样一个函数类型的action对象被派发出来会一路发送到各个reducer函数，reducer函数从这些实际上是函数的action对象上是无法获得type字段的，所以也做不了什么实质的处理。</p>
<p>不过，有了redux-thunk中间件之后，这些action对象根本没有机会触及到reducer函数，在中间件一层就被redux-thunk截获。</p>
<p>redux-thunk的工作是检查action对象是不是函数，如果不是函数就放行，完成普通action对象的生命周期，而如果发现action对象是函数，那就执行这个函数，并把Store的dispatch函数和getState函数作为参数传递到函数中去，处理过程到此为止，不会让这个异步action对象继续往前派发到reducer函数。</p>
<p>举一个并不涉及网络API访问的异步操作例子，在Counter组件中存在一个普通的同步增加计数的action构造函数increment，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const increment &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  type: ActionTypes.INCREMENT,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>派发increment执行返回的action对象，Redux会同步更新Store状态和视图，但是我们现在想要创造一个功能，能够发出一个“让Counter组件在1秒之后计数加一”的指令，这就需要定义一个新的异步action构造函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const incrementAsync &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      dispatch(increment());</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">异步action构造函数incrementAsync返回的是一个新的函数，这样一个函数被dispatch函数派发之后，会被redux-thunk中间件执行，于是setTimeout函数就会发生作用，在1秒之后利用参数dispatch函数派发出同步action构造函数increment的结果。</span><br><span class="line"></span><br><span class="line">这就是异步action的工作机理，这个例子虽然简单，但是可以看得出来，异步action最终还是要产生同步action派发才能对Redux系统产生影响。</span><br><span class="line"></span><br><span class="line">redux-thunk要做的工作也就不过如此，但因为引入了一次函数执行，而且这个函数还能够访问到dispatch和getState，就给异步操作带来了可能。</span><br><span class="line"></span><br><span class="line">action对象函数中完全可以通过fetch发起一个对服务器的异步请求，当得到服务器结果之后，通过参数dispatch，把成功或者失败的结果当做action对象再派发出去。这一次派发的是普通的action对象，就不会被redux-thunk截获，而是直接被派发到reducer，最终驱动Store上状态的改变。</span><br><span class="line"></span><br><span class="line">通常我们在组件的componentDidMount函数中做请求服务器的事情，因为当生命周期函数componentDidMount被调用的时候，表明装载过程已经完成，组件需要渲染的内容已经在DOM树上出现，对服务器的请求可能依赖于已经渲染的内容，在componentDidMount函数中发送对服务器请求是一个合适的时机。</span><br><span class="line"></span><br><span class="line">fetch函数执行会立刻返回，返回一个Promise类型的对象，所以后面会跟上一大串then和catch的语句。每个Promise成功的时候，对应的then中的回调函数会被调用；如果失败，对应catch中的回调函数也被调用。</span><br><span class="line"></span><br><span class="line"># vue声明组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一、全局注册<br>// 注册<br>Vue.component(‘my-component’, {<br>  template: ‘<div>A custom component!</div>‘<br>})</p>
<p>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</p>
<p>用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？</p>
<p>// 创建根实例<br>new Vue({<br>  el: ‘#example’<br>})</p>
<p>二、局部注册<br>var Child = {<br>  template: ‘<div>A custom component!</div>‘<br>}</p>
<p>new Vue({<br>  // …<br>  components: {<br>    // <my-component> 将只在父组件模板中可用<br>    ‘my-component’: Child<br>  }<br>})</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 检测变化的注意事项</span><br><span class="line"></span><br><span class="line">Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</span><br><span class="line"></span><br><span class="line">Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</span><br><span class="line"></span><br><span class="line">Vue.set(vm.someObject, &#39;b&#39;, 2)</span><br><span class="line"></span><br><span class="line">this.$set(this.someObject,&#39;b&#39;,2)</span><br><span class="line"></span><br><span class="line">想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代替 &#96;Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)&#96;</span><br><span class="line">this.someObject &#x3D; Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># watch 深度监听</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;deep： true&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</span><br><span class="line"></span><br><span class="line">不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue &#x3D;&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    a: function (val, oldVal) {<br>      console.log(‘new: %s, old: %s’, val, oldVal)<br>    },<br>    // 方法名<br>    b: ‘someMethod’,<br>    // 深度 watcher<br>    c: {<br>      handler: function (val, oldVal) { /* … <em>/ },<br>      deep: true<br>    },<br>    // 该回调将会在侦听开始之后被立即调用<br>    d: {<br>      handler: function (val, oldVal) { /</em> … <em>/ },<br>      immediate: true<br>    },<br>    e: [<br>      function handle1 (val, oldVal) { /</em> … <em>/ },<br>      function handle2 (val, oldVal) { /</em> … <em>/ }<br>    ],<br>    // watch vm.e.f’s value: {g: 5}<br>    ‘e.f’: function (val, oldVal) { /</em> … */ }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 异步更新队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>this.$nextTick(function () {<br>    console.log(this.$el.textContent) // =&gt; ‘更新完成’<br>  })</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性 computed</span><br><span class="line"></span><br><span class="line">对于任何复杂逻辑，你都应当使用计算属性。</span><br><span class="line"></span><br><span class="line">当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;方法和计算属性：&#x3D;&#x3D; 两种方式的最终结果确实是完全相同的。</span><br><span class="line"></span><br><span class="line">不同的是计算属性是基于它们的依赖进行缓存的。</span><br><span class="line"></span><br><span class="line">计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage</span><br><span class="line">计算属性会立即返回之前的计算结果，而不必再次执行函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>computed: {<br>    // 计算属性的 getter<br>    reversedMessage: function () {<br>      // <code>this</code> 指向 vm 实例<br>      return this.message.split(‘’).reverse().join(‘’)<br>    }<br>}</p>
<p>  console.log(vm.reversedMessage) // =&gt; ‘olleH’<br>vm.message = ‘Goodbye’<br>console.log(vm.reversedMessage) // =&gt; ‘eybdooG’</p>
<p>// 在组件中<br>methods: {<br>  reversedMessage: function () {<br>    return this.message.split(‘’).reverse().join(‘’)<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性的 setter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// …<br>computed: {<br>  fullName: {<br>    // getter<br>    get: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>    },<br>    // setter<br>    set: function (newValue) {<br>      var names = newValue.split(‘ ‘)<br>      this.firstName = names[0]<br>      this.lastName = names[names.length - 1]<br>    }<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># watch 侦听器</span><br><span class="line"></span><br><span class="line">虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</span><br><span class="line"></span><br><span class="line">使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    // 如果 <code>question</code> 发生改变，这个函数就会运行<br>    question: function (newQuestion, oldQuestion) {<br>      this.answer = ‘Waiting for you to stop typing…’<br>      this.getAnswer()<br>    }<br>},</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># getters作用</span><br><span class="line"></span><br><span class="line">Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</span><br><span class="line"></span><br><span class="line">this.$store.getters.doneTodosCount</span><br><span class="line"></span><br><span class="line"># mapGetters 辅助函数</span><br><span class="line"></span><br><span class="line">mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</span><br><span class="line"></span><br><span class="line"># 提交 mutation 的另一种方式是直接使用包含 type 属性的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>store.commit({<br>  type: ‘increment’,<br>  amount: 10<br>})</p>
<p>store.commit(‘increment’, {<br>  amount: 10<br>})<br>可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，<br>或者使用 mapMutations 辅助函数将组件中的 methods<br>映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 分发 Action</span><br><span class="line"></span><br><span class="line">Action 通过 store.dispatch 方法触发：</span><br><span class="line"></span><br><span class="line">store.dispatch(&#39;increment&#39;)</span><br><span class="line"></span><br><span class="line"># vue组件类型, 怎么定义一个组件</span><br><span class="line"></span><br><span class="line"># vue切换路由</span><br><span class="line"></span><br><span class="line">其他方式 不留痕迹</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">一、router.push(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&lt;router-link :to&#x3D;&quot;...&quot;&gt; router.push(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const userId &#x3D; 123</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">二、 router.replace(location, onComplete?, onAbort?)</span><br><span class="line">跟 router.push 很像，唯一的不同就是，它不会向 history</span><br><span class="line">添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</span><br><span class="line"></span><br><span class="line">三、router.go(n)</span><br><span class="line">在 history 记录中向前或者后退多少步，</span><br><span class="line">类似 window.history.go(n)。</span><br></pre></td></tr></table></figure>

<h1 id="vue-router传参方式"><a href="#vue-router传参方式" class="headerlink" title="vue-router传参方式"></a>vue-router传参方式</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">query 和params</span><br><span class="line"> &#123; <span class="attr">path</span>: <span class="string">&#x27;/news/:id&#x27;</span>, <span class="attr">component</span>: NewsDetail &#125;,</span><br><span class="line">      &lt;span&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line"><span class="number">1</span>、用法</span><br><span class="line">    query要用path来引入，params要用name来引入，</span><br><span class="line">    接收参数都是类似的，</span><br><span class="line">    分别是<span class="built_in">this</span>.$route.query.name和<span class="built_in">this</span>.$route.params.name。</span><br><span class="line"></span><br><span class="line">    接收参数时，已经是$route而不是$router了哦！！</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、展示</span><br><span class="line">　　query更加类似于我们ajax中get传参，params则类似于post，</span><br><span class="line">　　说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</span><br><span class="line"></span><br><span class="line">query:</span><br><span class="line">params:</span><br></pre></td></tr></table></figure>

<h1 id="受控组件-非受控组件"><a href="#受控组件-非受控组件" class="headerlink" title="受控组件 非受控组件"></a>受控组件 非受控组件</h1><h1 id="没有任何嵌套关系的组件之间传值"><a href="#没有任何嵌套关系的组件之间传值" class="headerlink" title="没有任何嵌套关系的组件之间传值"></a>没有任何嵌套关系的组件之间传值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) Event Emitter&#x2F;Target&#x2F;Dispatcher</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.addEventListener(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.dispatchEvent(‘click’);</span><br><span class="line"></span><br><span class="line">(2) Publish &#x2F; Subscribe</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">globalBroadcaster.subscribe(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">globalBroadcaster.publish(‘click’);</span><br><span class="line"></span><br><span class="line">(3) Signals</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.clicked.add(function() &#123; alert(‘click’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.clicked.dispatch();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="this-setState-参数"><a href="#this-setState-参数" class="headerlink" title="this.setState()参数"></a>this.setState()参数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个函数接受两个参数，</span><br><span class="line">第一个参数表示上一个状态值，</span><br><span class="line">第二参数表示当前的 props，</span><br><span class="line">第二个参数是 state 导致的页面变化完成后的回调，等价于componentDidUpdate。</span><br><span class="line"></span><br><span class="line">this.setState((prevState, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">setState的关键点:</span><br><span class="line"></span><br><span class="line">setState不会立刻改变React组件中state的值；</span><br><span class="line">setState通过引发一次组件的更新过程来引发重新绘制；</span><br><span class="line">多次setState函数调用产生的效果会合并。</span><br><span class="line"></span><br><span class="line">当setState被调用时，能驱动组件的更新过程，引发componentDidUpdate、render等一系列函数的调用。</span><br></pre></td></tr></table></figure>

<h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><p>主要分为三段，mount（挂载）、update（更新）、unmount（卸载）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、mount，即挂载阶段，</span><br><span class="line">    第一次让组件出现在页面中的过程，React会将render的返回值插入到页面中，</span><br><span class="line">    这个过程会暴露以下几个钩子（hook）：</span><br><span class="line"></span><br><span class="line">    constructor()       &#x2F;&#x2F; 初始化props和state</span><br><span class="line"></span><br><span class="line">    　　初始化getDefaultProps()和getInitialState()</span><br><span class="line"></span><br><span class="line">    　　getDefaultProps: 执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的</span><br><span class="line">这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制</span><br><span class="line"></span><br><span class="line">getInitialState : 控件加载之前执行，返回值会被用于state的初始化值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    　　初始化</span><br><span class="line">    componentWillMount()    &#x2F;&#x2F; 将要被插入</span><br><span class="line"></span><br><span class="line">    执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次</span><br><span class="line"></span><br><span class="line">    render()    &#x2F;&#x2F; 将return的内容插入到页面里</span><br><span class="line">    componentDidMount()   &#x2F;&#x2F; 插入完成后的动作</span><br><span class="line">        在组件被装配后立即调用。</span><br><span class="line">        初始化使得DOM节点应该进行到这里。</span><br><span class="line">        若你需要从远端加载数据，</span><br><span class="line">        这是一个适合实现网络请求的地方。</span><br><span class="line">        在该方法里设置状态将会触发重渲。</span><br><span class="line"></span><br><span class="line">二、update，即更新阶段，如果数据有任何变动就会来这一阶段，这个过程有5个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillReceiveProps( nextprops )   &#x2F;&#x2F; 接受需要更新的props</span><br><span class="line">    　　在装配了的组件接收到新属性前调用。</span><br><span class="line">    　　若你需要更新状态响应属性改变（例如，重置它），</span><br><span class="line">    　　你可能需对比this.props和nextProps</span><br><span class="line">    　　并在该方法中使用this.setState()处理状态改变。</span><br><span class="line"></span><br><span class="line">    注意即使属性未有任何改变，React可能也会调用该方法，因此若你想要处理改变，请确保比较当前和之后的值。这可能会发生在当父组件引起你的组件重渲。</span><br><span class="line"></span><br><span class="line">　　shouldComponentUpdate( nextProps, nextState )   &#x2F;&#x2F; 请问要不要更新组件 true&#x2F;false</span><br><span class="line"></span><br><span class="line">        接收到新属性或状态时，</span><br><span class="line">        shouldComponentUpdate() 在渲染前被调用。默认为true。</span><br><span class="line">        该方法并不会在初始化渲染或当使用forceUpdate()时被调用。</span><br><span class="line">        当他们状态改变时，返回false 并不能阻止子组件重渲。</span><br><span class="line">        若shouldComponentUpdate()返回false，componentWillUpdate()将不会被调用。</span><br><span class="line">　　componentWillUpdate()  &#x2F;&#x2F; 准备更新组件啦</span><br><span class="line"></span><br><span class="line">　　render() &#x2F;&#x2F; 更新</span><br><span class="line"></span><br><span class="line">　　componentDidUpdate()   &#x2F;&#x2F; 更新完成</span><br><span class="line">    该方法并不会在初始化渲染时调用。</span><br><span class="line">三、unmount，即卸载过程，当一个组件要从页面移除时，会进入这个过程，其中有一个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillUnmount()    &#x2F;&#x2F; 要卸载啦</span><br><span class="line">    可以在该方法里处理任何必要的清理工作，</span><br><span class="line">    例如解绑定时器，取消网络请求，</span><br><span class="line">    清理任何在componentDidMount环节创建的DOM元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一般我们只在这几个钩子里setState：</span><br><span class="line"></span><br><span class="line">componentWillMount()</span><br><span class="line"></span><br><span class="line">componentDidMount()</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redux原理"><a href="#Redux原理" class="headerlink" title="Redux原理"></a>Redux原理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Redux 和 React 没有直接关系，</span><br><span class="line">它瞄准的目标是应用状态管理。</span><br><span class="line"></span><br><span class="line">核心概念是 Map&#x2F;Reduce 中的 Reduce。</span><br><span class="line">且 Reducer 的执行是同步，</span><br><span class="line">产生的 State 是 Immutable 的。</span><br><span class="line"></span><br><span class="line">改变 State 只能通过向 Reducer dispatch actions 来完成。</span><br><span class="line"></span><br><span class="line">State 的不同字段，可以通过不同的 Reducers 来分别维护。</span><br><span class="line">combineReducers 负责组合这些 Reducers，</span><br><span class="line">前提是每个 Reducer 只能维护自己关心的字段。</span><br><span class="line"></span><br><span class="line">Action 对象只能是 Javascript Plain Object，</span><br><span class="line">但是通过在 store 上装载 middleware，</span><br><span class="line">则可以任意定义 action 对象的形式，</span><br><span class="line">反正会有特定的 middleware 负责</span><br><span class="line">将此 action 对象变为 Javascript Plain Object。</span><br><span class="line"></span><br><span class="line">可以以middleware 链条为集中点实现很多控制逻辑，</span><br><span class="line">例如 Log，Undo, ErrorHandler 等。</span><br><span class="line"></span><br><span class="line">Redux 仅仅专注于应用状态的维护，</span><br><span class="line">reducer、dispatch&#x2F;middleware 是两个常用扩展点、</span><br><span class="line">Higher-order Store 则仅针对需要扩展全部 Store 功能时使用。</span><br><span class="line"></span><br><span class="line">react-redux 是 Redux 针对 React&#x2F;React-Native 的 Binding，</span><br><span class="line">connect&#x2F;selector 是扩展点，</span><br><span class="line">负责将 store 中的状态添加到 React component 的 props 中。</span><br><span class="line"></span><br><span class="line">Redux 借用了很多函数式编程的思想，</span><br><span class="line">了解函数式编程会利于理解其实现原理，</span><br><span class="line">虽然使用它不需要了解很多函数式编程的概念。</span><br><span class="line">和 Flux 相比，Redux 的概念更精简、约定更严格、状态更确定、而是扩展却更灵活。</span><br><span class="line"></span><br><span class="line">通过 https:&#x2F;&#x2F;github.com&#x2F;xgrommx&#x2F;awesome-redux 可以获得大量参考。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;3334467e4b32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redux有三大准则</span><br><span class="line"></span><br><span class="line">单一数据源</span><br><span class="line">整个应用状态，都应该被存储在单一store的对象树中。</span><br><span class="line"></span><br><span class="line">只读状态</span><br><span class="line">唯一可以修改状态的方式，</span><br><span class="line">就是发送（dispatch）一个动作（Action），</span><br><span class="line">通俗来讲，就是说只有getter，没有setter。</span><br><span class="line"></span><br><span class="line">使用纯函数去修改状态</span><br><span class="line">纯函数保障了状态的稳定性，</span><br><span class="line">不会因不同环境导致应用程序出现不同情况，</span><br><span class="line">听说是redux真正的精髓，日后可以深入了解。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="谈谈MVVM模式"><a href="#谈谈MVVM模式" class="headerlink" title="谈谈MVVM模式"></a>谈谈MVVM模式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</span><br><span class="line"></span><br><span class="line">DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</span><br><span class="line"></span><br><span class="line">MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</span><br><span class="line"></span><br><span class="line">在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</span><br><span class="line"></span><br><span class="line">ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-mvvm和mvc区别"><a href="#2-mvvm和mvc区别" class="headerlink" title="2:mvvm和mvc区别"></a>2:mvvm和mvc区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvc和mvvm其实区别并不大。都是一种设计思想。</span><br><span class="line">主要就是mvc中Controller演变成mvvm中的viewModel。</span><br><span class="line">mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，</span><br><span class="line">加载速度变慢，影响用户体验。</span><br><span class="line">和当 Model 频繁发生变化，开发者需要主动更新到View 。</span><br></pre></td></tr></table></figure>

<h1 id="让CSS只在当前组件中起作用"><a href="#让CSS只在当前组件中起作用" class="headerlink" title="让CSS只在当前组件中起作用"></a>让CSS只在当前组件中起作用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将当前组件的&lt;style&gt;修改为&lt;style scoped&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Vue中使用插件的步骤"><a href="#Vue中使用插件的步骤" class="headerlink" title="Vue中使用插件的步骤"></a>Vue中使用插件的步骤</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件</span><br><span class="line">使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, &#123; someOption: true &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件的使用和自己创建公用组件"><a href="#组件的使用和自己创建公用组件" class="headerlink" title="组件的使用和自己创建公用组件"></a>组件的使用和自己创建公用组件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：在components目录新建你的组件文件（indexPage.vue），</span><br><span class="line">    script一定要export default &#123;&#125;</span><br><span class="line">第二步：在需要用的页面（组件）中导入：</span><br><span class="line">    import indexPage from &#39;@&#x2F;components&#x2F;indexPage.vue&#39;</span><br><span class="line">第三步：注入到vue的子组件的components属性上面,components:&#123;indexPage&#125;</span><br><span class="line">第四步：在template视图view中使用，</span><br><span class="line">问题有indexPage命名，使用的时候则index-page。</span><br></pre></td></tr></table></figure>

<h1 id="vue如何实现按需加载配合webpack设置"><a href="#vue如何实现按需加载配合webpack设置" class="headerlink" title="vue如何实现按需加载配合webpack设置"></a>vue如何实现按需加载配合webpack设置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。</span><br><span class="line">不进行页面按需加载引入方式：import  home   from &#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;</span><br><span class="line">进行页面按需加载的引入方式：const  home &#x3D; r &#x3D;&gt; require.ensure( [], () &#x3D;&gt; r (require(&#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;)))</span><br></pre></td></tr></table></figure>

<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a><keep-alive></keep-alive>作用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</span><br></pre></td></tr></table></figure>

<h1 id="vue-route模式"><a href="#vue-route模式" class="headerlink" title="vue-route模式"></a>vue-route模式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认为hash，但是用hash模式的话，页面地址会加#</span><br><span class="line"></span><br><span class="line">所以一般采用 history模式</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># vue阻止事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　.stop 阻止事件冒泡<br>　.prevent 阻止默认事件<br>　.capture　阻止事件捕获<br>　.once 只触发一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># router传参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>routes: [<br>    {<br>        path: ‘/linkParams/:name’,<br>        name:’linkParams’,<br>        component: linkParams<br>    }<br>]</p>
<p>获取name</p>
<p>let name = this.$route.params.name</p>
<p>// 字符串,这里的字符串是路径path匹配噢，不是router配置里的name<br>this.$router.push(‘home’)</p>
<p>// 对象<br>this.$router.push({ path: ‘home’ })</p>
<p>// 命名的路由 这里会变成 /user/123<br>this.$router.push({ name: ‘user’, params: { userId: 123 }})</p>
<p>// 带查询参数，变成 /register?plan=private<br>this.$router.push({ path: ‘register’, query: { plan: ‘private’ }})</p>
<p>router.beforeEach((to, from, next)=&gt;{<br>  //do something<br>  next();<br>});<br>router.afterEach((to, from, next) =&gt; {<br>    console.log(to.path);<br>});</p>
<p>每个钩子方法接收三个参数：</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p>
<p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
<p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
<p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SSR实现原理</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。<br>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。<br>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。<br>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端。</p>
<p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Vue实例初始化的过程中实现依赖管理的分析</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com&#x2F;a&#x2F;vue&#x2F;2018&#x2F;0301&#x2F;1795.html)</span><br><span class="line"></span><br><span class="line">大致的总结下就是：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initState的过程中，<br>将props,computed,data等属性通过Object.defineProperty<br>来改造其getter/setter属性，<br>并为每一个响应式属性实例化一个observer观察者。<br>这个observer内部dep记录了这个响应式属性的所有依赖。</p>
<p>当响应式属性调用setter函数时，<br>通过dep.notify()方法去遍历所有的依赖，<br>调用watcher.update()去完成数据的动态响应。</p>
<p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，<br>通过Object.defineProperty()来劫持各个属性的setter，getter，<br>在数据变动时发布消息给订阅者，<br>触发相应的监听回调。</p>
<p>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，<br>包括子属性对象的属性，<br>都加上 setter和getter<br>这样的话，<br>给这个对象的某个值赋值，就会触发setter，<br>那么就能监听到了数据变化</p>
<p>第二步：compile解析模板指令，<br>将模板中的变量替换成数据，<br>然后初始化渲染页面视图，<br>并将每个指令对应的节点绑定更新函数，<br>添加监听数据的订阅者，一旦数据有变动，<br>收到通知，更新视图</p>
<p>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，<br>主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，<br>能调用自身的update()方法，<br>并触发Compile中绑定的回调，则功成身退。</p>
<p>第四步：MVVM作为数据绑定的入口，<br>整合Observer、Compile和Watcher三者，<br>通过Observer来监听自己的model数据变化，<br>通过Compile来解析编译模板指令，<br>最终利用Watcher搭起Observer和Compile之间的通信桥梁，<br>达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Vue声明组件的state是用data方法，那为什么data是通过一个function来返回一个对象，而不是直接写一个对象呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：从语法上说，如果不用function返回就会出现语法错误导致编译不通过。从原理上的话，大概就是组件可以被多次创建，如果不使用function就会使所有调用该组件的页面公用同一个数据域，这样就失去了组件的概念了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># vuex</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> State、 Getter、Mutation 、Action、 Module<br>通过状态（数据源）集中管理驱动组件的变化<br>（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中；<br>改变状态的方式是提交mutations，<br>这是个同步的事物； 异步逻辑应该封装在action中。</p>
<p>一、Action 类似于 mutation，不同在于：<br>二、Action 提交的是 mutation，而不是直接变更状态。<br>三、Action 可以包含任意异步操作</p>
<p>一、getters 可以对State进行计算操作，它就是Store的计算属性<br>二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>三、 如果一个状态只在一个组件内使用，是可以不用getters</p>
<p>二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 说下vue组件之间的通信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：<br>非父子组件间通信，Vue 有提供 Vuex，以状态共享方式来实现通信</p>
<p>prop 向下传递，事件向上传递。<br>还可以通过$emit方法出发一个消息，然后$on接收这个消息</p>
<p>兄弟组件间的数据通讯，它们将会 寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法 。</p>
<p>var Event = new Vue()<br>//父组件<br> Event.$on(“a-msg”, function (a) {<br>    this.a = a;<br>  }.bind(this));</p>
<p>// 子组件<br> Event.$emit(“a-msg”, this.a);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Vue 生命周期</span><br><span class="line"></span><br><span class="line"># 简单描述每个周期具体适合哪些场景</span><br><span class="line"></span><br><span class="line">Create  Mount  Update  Destroy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>beforeCreate（创建前）,<br>created（创建后）,</p>
<p>beforeMount(载入前),<br>mounted（载入后）,</p>
<p>beforeUpdate（更新前）,<br>updated（更新后）,</p>
<p>beforeDestroy（销毁前）,<br>destroyed（销毁后）</p>
<p>每个钩子函数都在啥时间触发</p>
<p>beforeCreate<br>在实例初始化之后，<br>数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>
<p>created<br>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>beforeMount<br>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p>mounted<br>挂载元素，获取到DOM节点<br>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。<br>如果 root 实例挂载了一个文档内元素，<br>当 mounted 被调用时 vm.$el 也在文档内。</p>
<p>beforeUpdate<br>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p>updated<br>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。<br>然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<p>beforeDestroy<br>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p>destroyed<br>Vue 实例销毁后调用。<br>调用后，Vue 实例指示的所有东西都会解绑定，<br>所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
<p>生命周期钩子的一些常见使用方法：</p>
<p>beforecreate : 可以在这加个loading事件，<br>在加载实例时触发</p>
<p>created : 初始化完成时需要执行的事件写在这里，<br>如在这结束loading事件，异步请求也适宜在这里调用</p>
<p>mounted: 在这发起后端请求，拿回数据，配合路由钩子做一些事情</p>
<p>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框 你确认删除XX吗？<br>nextTick : 更新数据后立即操作dom<br>activated::keep-alive组件激活时调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># v-show和v-if指令的共同点和不同点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏<br>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</p>
<p>v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。<br>因此，如果需要频繁切换 v-show 较好，<br>如果在运行时条件不大可能改变 v-if 较好。</p>
<p>1.v-if 指令可以应用于template包装元素上，<br>而v-show不支持template<br>2.将v-show应用在组件上时，因为指令的优先级<br>v-else 会出现问题，<br>解决办法就是用另一个 v-show 替换 v-else</p>
<p>// 错误<br><custom-component v-show="condition"></custom-component></p>
<p v-else>这可能也是一个组件</p>
     // 正确做法
<custom-component v-show="condition"></custom-component>
<p v-show="!condition">这可能也是一个组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># vue 父子组件嵌套时，组件内部的各个生命周期钩子触发先后顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
顺序是 先创建父组件(父组件beforeMount)，然后才创建子组件，当子组件创建完成并且实体dom挂载完成后(子组件先mounted)父组件才挂载完成(父组件mounted)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># h函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
它来自单词 hyperscript，
这个单词通常用在 virtual-dom 的实现中。
Hyperscript 本身是指

<p>生成HTML 结构的 script 脚本，<br>因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言）</p>
<p>个人理解：<br>createElement 函数是用来生成 HTML DOM<br>元素的，也就是上文中的 generate HTML<br>structures，也就是 Hyperscript，<br>这样作者才把 createElement 简写成 h。</p>
<p>大概的翻译下：<br>render: h =&gt; h(App) 是下面内容的缩写：</p>
<p>render: function (createElement) {<br>    return createElement(App);<br>}<br>进一步缩写为(ES6 语法)：</p>
<p>render (createElement) {<br>    return createElement(App);<br>}<br>再进一步缩写为：</p>
<p>render (h){<br>    return h(App);<br>}<br>按照 ES6 箭头函数的写法，就得到了：</p>
<p>render: h =&gt; h(App);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># react-redux中connect函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010188279)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>connect方法做的事情是<br>将state和dispatch绑定到Connect组件的参数上，<br>然后Connect组件将你当前的App组件封装起来，<br>使得App组件可以通过props获取到父<br>组件Connect传递的state和props。</p>
<p>Provider是顶层组件的作用，<br>将store作为上下文提供给全局共享，<br>而Connect组件是局部组件，将某个react组件包装起来，<br>传递指定的state和props给该组件访问。</p>
<p>connect()返回值是Connect组件（请注意大小写的区别）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Vue和React区别</span><br><span class="line"></span><br><span class="line">### 相同</span><br><span class="line"></span><br><span class="line">- 使用 Virtual DOM</span><br><span class="line">- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</span><br><span class="line">- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</span><br><span class="line"></span><br><span class="line">都是JavaScript的UI框架，专注于创造前端的富应用。</span><br><span class="line">不同于早期的JavaScript框架“功能齐全”，</span><br><span class="line"></span><br><span class="line">### 区别</span><br><span class="line"></span><br><span class="line">- **性能**</span><br><span class="line"></span><br><span class="line">    计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。</span><br><span class="line"></span><br><span class="line">    Vue可以更快地计算出Virtual DOM的差异，</span><br><span class="line">    这是由于它在渲染过程中，</span><br><span class="line">    会跟踪每一个组件的依赖关系，</span><br><span class="line">    不需要重新渲染整个组件树。</span><br><span class="line"></span><br><span class="line">    而对于React而言，每当应用的状态被改变时，</span><br><span class="line">    全部子组件都会重新渲染。</span><br><span class="line">    当然，这可以通过shouldComponentUpdate</span><br><span class="line">    这个生命周期方法来进行控制，</span><br><span class="line">    但Vue将此视为默认的优化。</span><br><span class="line"></span><br><span class="line">- **JSX和Templates**</span><br><span class="line"></span><br><span class="line">    React 中，所有的组件的渲染功能都依靠 JSX</span><br><span class="line">    可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。</span><br><span class="line"></span><br><span class="line">    模板比起 JSX 读写起来更自然。</span><br><span class="line">    基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。</span><br><span class="line">    可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。</span><br><span class="line"></span><br><span class="line">    vue的模板语法去除了往视图&#x2F;组件中添加逻辑的诱惑，保持了关注点分离。</span><br><span class="line"></span><br><span class="line">    与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已。</span><br><span class="line"></span><br><span class="line">- **组件作用域内的 CSS**</span><br><span class="line"></span><br><span class="line">    Vue 设置样式的默认方法是单文件组件里类似 style 的标签。</span><br><span class="line">    可选 scoped 属性会自动添加一个唯一的属性</span><br><span class="line"></span><br><span class="line">    CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的</span><br><span class="line"></span><br><span class="line">- **Props**</span><br><span class="line"></span><br><span class="line">    JSX库中，数据通过props传到子组件中去。</span><br><span class="line"></span><br><span class="line">    在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”</span><br><span class="line"></span><br><span class="line">    在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。</span><br><span class="line"></span><br><span class="line">- **构建工具**</span><br><span class="line"></span><br><span class="line">    React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。</span><br><span class="line"></span><br><span class="line">- **配套框架**</span><br><span class="line"></span><br><span class="line">    Vue的核心团队维护着vue-router和vuex，</span><br><span class="line">    它们由官方维护支持且与核心库同步更新的。</span><br><span class="line">    而React的react-router和react-redux则是由社区成员维护，</span><br><span class="line">    创建了一个更分散的生态系统</span><br><span class="line"></span><br><span class="line">- **向下扩展**</span><br><span class="line"></span><br><span class="line">    React 学习曲线陡峭，学 React 前，你需要知道 JSX 和 ES2015，</span><br><span class="line"></span><br><span class="line">- **原生渲染**</span><br><span class="line"></span><br><span class="line">    Weex 还在积极发展，成熟度也不能和 React Native 相抗衡。</span><br><span class="line"></span><br><span class="line">&lt;https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5a9b8417518825558251ce15&gt;</span><br><span class="line"></span><br><span class="line"># redux原理</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000004236064)</span><br><span class="line"></span><br><span class="line"># redux流程</span><br><span class="line"></span><br><span class="line">[Redux 入门教程](http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;2016&#x2F;09&#x2F;redux_tutorial_part_one_basic_usages.html)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// store<br>// Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>//数据集合，就叫做 State<br>const state = store.getState();</p>
<p>// Action Creator定义一个函数来生成 Action<br>const ADD_TODO = ‘添加 TODO’;</p>
<p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p>
<p>const action = addTodo(‘Learn Redux’);</p>
<p>//store.dispatch()是 View 发出 Action 的唯一方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>store.dispatch({<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>});</p>
<p>store.dispatch(addTodo(‘Learn Redux’));</p>
<p>//Reducer State 的计算过程就叫做 Reducer。<br>接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<p>const reducer = function (state, action) {<br>  // …<br>  return new_state;<br>};</p>
<p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }<br>};</p>
<p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2<br>});</p>
<p>Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p>
<p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p>
<p>reducer最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<p>不得改写参数<br>不能调用系统 I/O 的API<br>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</p>
<p>必须返回一个全新的对象<br>// State 是一个对象<br>function reducer(state, action) {<br>  return Object.assign({}, state, { thingToChange });<br>  // 或者<br>  return { …state, …newState };<br>}</p>
<p>// State 是一个数组<br>function reducer(state, action) {<br>  return […state, newItem];<br>}</p>
<pre><code></code></pre>
]]></content>
      <tags>
        <tag>jQuery</tag>
        <tag>插件</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise深度解析</title>
    <url>/posts/Promise%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>这一章节就是整理了<code>45</code>道<code>Promise</code>的笔试题让大家爽一爽 😁。</p>
<p>这篇文章是一篇比较纯的<code>Promise</code>笔试文章，是我自己在做题的时候，根据题目想要的考点来反敲知识点，然后再由这个知识点编写从浅到深的的题目。</p>
<p>本文的题目没有到特别深入，不过应该覆盖了大部分的考点，另外为了不把大家绕混，答案也没有考虑在<code>Node</code>的执行结果，执行结果全为浏览器环境下。</p>
<p>OK👌， 来看看通过阅读本篇文章你可以学到：</p>
<ul>
<li>Promise的几道基础题</li>
<li>Promise结合setTimeout</li>
<li>Promise中的then、catch、finally</li>
<li>Promise中的all和race</li>
<li>async/await的几道题</li>
<li>async处理错误</li>
<li>综合题</li>
<li>几道大厂的面试题</li>
</ul>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在做下面👇的题目之前，我希望你能清楚几个知识点。</p>
<p>(如果你感觉一上来不想看这些列举的知识点的话，直接看后面的例子再来理解它们也可以)</p>
<p><strong><code>event loop</code>它的执行顺序：</strong></p>
<ul>
<li>一开始整个脚本作为一个宏任务执行</li>
<li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li>
<li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完</li>
<li>执行浏览器UI线程的渲染工作</li>
<li>检查是否有<code>Web Worker</code>任务，有则执行</li>
<li>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</li>
</ul>
<p><strong>微任务包括：</strong><code>MutationObserver</code>、<code>Promise.then()或catch()</code>、<code>Promise为基础开发的其它技术，比如fetch API</code>、<code>V8</code>的垃圾回收过程、<code>Node独有的process.nextTick</code>。</p>
<p><strong>宏任务包括</strong>：<code>script</code> 、<code>setTimeout</code>、<code>setInterval</code> 、<code>setImmediate</code> 、<code>I/O</code> 、<code>UI rendering</code>。</p>
<p><strong>注意</strong>⚠️：在所有任务开始的时候，由于宏任务中包括了<code>script</code>，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如<code>setTimeout</code>)将被放到下一轮宏任务中来执行。</p>
<h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><h4 id="1-1-题目一"><a href="#1-1-题目一" class="headerlink" title="1.1 题目一"></a>1.1 题目一</h4><pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  console.log(&#39;promise1&#39;)
&#125;)
console.log(&#39;1&#39;, promise1);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code></li>
<li>然后执行同步代码<code>1</code>，此时<code>promise1</code>没有被<code>resolve</code>或者<code>reject</code>，因此状态还是<code>pending</code></li>
</ul>
<p>结果：</p>
<pre><code>&#39;promise1&#39;
&#39;1&#39; Promise&#123;&lt;pending&gt;&#125;
复制代码</code></pre>
<h4 id="1-2-题目二"><a href="#1-2-题目二" class="headerlink" title="1.2 题目二"></a>1.2 题目二</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  resolve(&#39;success&#39;)
  console.log(2);
&#125;);
promise.then(() =&gt; &#123;
  console.log(3);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行其中的同步代码<code>1</code></li>
<li>再遇到<code>resolve(&#39;success&#39;)</code>， 将<code>promise</code>的状态改为了<code>resolved</code>并且将值保存下来</li>
<li>继续执行同步代码<code>2</code></li>
<li>跳出<code>promise</code>，往下执行，碰到<code>promise.then</code>这个微任务，将其加入微任务队列</li>
<li>执行同步代码<code>4</code></li>
<li>本轮宏任务全部执行完毕，检查微任务队列，发现<code>promise.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>
</ul>
<p>结果：</p>
<pre><code>1 2 4 3
复制代码</code></pre>
<h4 id="1-3-题目三"><a href="#1-3-题目三" class="headerlink" title="1.3 题目三"></a>1.3 题目三</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  console.log(2);
&#125;);
promise.then(() =&gt; &#123;
  console.log(3);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析</p>
<ul>
<li>和题目二相似，只不过在<code>promise</code>中并没有<code>resolve</code>或者<code>reject</code></li>
<li>因此<code>promise.then</code>并不会执行，它只有在被改变了状态之后才会执行。</li>
</ul>
<p>结果：</p>
<pre><code>1 2 4
复制代码</code></pre>
<h4 id="1-4-题目四"><a href="#1-4-题目四" class="headerlink" title="1.4 题目四"></a>1.4 题目四</h4><pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  console.log(&#39;promise1&#39;)
  resolve(&#39;resolve1&#39;)
&#125;)
const promise2 = promise1.then(res =&gt; &#123;
  console.log(res)
&#125;)
console.log(&#39;1&#39;, promise1);
console.log(&#39;2&#39;, promise2);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code></li>
<li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来</li>
<li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列</li>
<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code></li>
<li>执行同步代码<code>1</code>， 同时打印出<code>promise1</code>的状态是<code>resolved</code></li>
<li>执行同步代码<code>2</code>，同时打印出<code>promise2</code>的状态是<code>pending</code></li>
<li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>
</ul>
<p>结果：</p>
<pre><code>&#39;promise1&#39;
&#39;1&#39; Promise&#123;&lt;resolved&gt;: &#39;resolve1&#39;&#125;
&#39;2&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;resolve1&#39;
复制代码</code></pre>
<h4 id="1-5-题目五"><a href="#1-5-题目五" class="headerlink" title="1.5 题目五"></a>1.5 题目五</h4><p>接下来看看这道题：</p>
<pre><code>const fn = () =&gt; (new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  resolve(&#39;success&#39;)
&#125;))
fn().then(res =&gt; &#123;
  console.log(res)
&#125;)
console.log(&#39;start&#39;)
复制代码</code></pre>
<p>这道题里最先执行的是<code>&#39;start&#39;</code>吗 🤔️ ？</p>
<p>请仔细看看哦，<code>fn</code>函数它是直接返回了一个<code>new Promise</code>的，而且<code>fn</code>函数的调用是在<code>start</code>之前，所以它里面的内容应该会先执行。</p>
<p>结果：</p>
<pre><code>1
&#39;start&#39;
&#39;success&#39;
复制代码</code></pre>
<h4 id="1-6-题目六"><a href="#1-6-题目六" class="headerlink" title="1.6 题目六"></a>1.6 题目六</h4><p>如果把<code>fn</code>的调用放到<code>start</code>之后呢？</p>
<pre><code>const fn = () =&gt;
  new Promise((resolve, reject) =&gt; &#123;
    console.log(1);
    resolve(&quot;success&quot;);
  &#125;);
console.log(&quot;start&quot;);
fn().then(res =&gt; &#123;
  console.log(res);
&#125;);
复制代码</code></pre>
<p>是的，现在<code>start</code>就在<code>1</code>之前打印出来了，因为<code>fn</code>函数是之后执行的。</p>
<p><strong>注意⚠️</strong>：之前我们很容易就以为看到new Promise()就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。</p>
<p>答案：</p>
<pre><code>&quot;start&quot;
1
&quot;success&quot;
复制代码</code></pre>
<p>好嘞，学完了这几道基础题，让我们来用个表情包压压惊。</p>
<h3 id="2-Promise结合setTimeout"><a href="#2-Promise结合setTimeout" class="headerlink" title="2. Promise结合setTimeout"></a>2. Promise结合setTimeout</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><pre><code>console.log(&#39;start&#39;)
setTimeout(() =&gt; &#123;
  console.log(&#39;time&#39;)
&#125;)
Promise.resolve().then(() =&gt; &#123;
  console.log(&#39;resolve&#39;)
&#125;)
console.log(&#39;end&#39;)
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出<code>start</code>和<code>end</code>。</li>
<li><code>setTimout</code>作为一个宏任务被放入宏任务队列(下一个)</li>
<li><code>Promise.then</code>作为一个微任务被放入微任务队列</li>
<li>本次宏任务执行完，检查微任务，发现<code>Promise.then</code>，执行它</li>
<li>接下来进入下一个宏任务，发现<code>setTimeout</code>，执行。</li>
</ul>
<p>结果：</p>
<pre><code>&#39;start&#39;
&#39;end&#39;
&#39;resolve&#39;
&#39;time&#39;
复制代码</code></pre>
<h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  setTimeout(() =&gt; &#123;
    console.log(&quot;timerStart&quot;);
    resolve(&quot;success&quot;);
    console.log(&quot;timerEnd&quot;);
  &#125;, 0);
  console.log(2);
&#125;);
promise.then((res) =&gt; &#123;
  console.log(res);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析：</p>
<p>和题目<code>1.2</code>很像，不过在<code>resolve</code>的外层加了一层<code>setTimeout</code>定时器。</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>1</code></li>
<li>然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行</li>
<li>执行同步代码<code>2</code></li>
<li>跳出<code>promise</code>函数，遇到<code>promise.then</code>，但其状态还是为<code>pending</code>，这里理解为先不执行</li>
<li>执行同步代码<code>4</code></li>
<li>一轮循环过后，进入第二次宏任务，发现延迟队列中有<code>setTimeout</code>定时器，执行它</li>
<li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列</li>
<li>继续执行同步代码<code>timerEnd</code></li>
<li>宏任务全部执行完毕，查找微任务队列，发现<code>promise.then</code>这个微任务，执行它。</li>
</ul>
<p>因此执行结果为：</p>
<pre><code>1
2
4
&quot;timerStart&quot;
&quot;timerEnd&quot;
&quot;success&quot;
复制代码</code></pre>
<h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么：</p>
<p><strong>(1)</strong>:</p>
<pre><code>setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;);
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer3&#39;)
  &#125;, 0)
&#125;, 0)
setTimeout(() =&gt; &#123;
  console.log(&#39;timer2&#39;)
&#125;, 0)
console.log(&#39;start&#39;)
复制代码</code></pre>
<p><strong>(2)</strong>:</p>
<pre><code>setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;);
  Promise.resolve().then(() =&gt; &#123;
    console.log(&#39;promise&#39;)
  &#125;)
&#125;, 0)
setTimeout(() =&gt; &#123;
  console.log(&#39;timer2&#39;)
&#125;, 0)
console.log(&#39;start&#39;)
复制代码</code></pre>
<p><strong>执行结果：</strong></p>
<pre><code>&#39;start&#39;
&#39;timer1&#39;
&#39;timer2&#39;
&#39;timer3&#39;
复制代码

&#39;start&#39;
&#39;timer1&#39;
&#39;promise&#39;
&#39;timer2&#39;
复制代码</code></pre>
<p>这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。</p>
<p>一个是为定时器<code>timer3</code>，一个是为<code>Promise.then</code></p>
<p>但是如果是定时器<code>timer3</code>的话，它会在<code>timer2</code>后执行，而<code>Promise.then</code>却是在<code>timer2</code>之前执行。</p>
<p>你可以这样理解，<code>Promise.then</code>是微任务，它会被加入到本轮中的微任务列表，而定时器<code>timer3</code>是宏任务，它会被加入到下一轮的宏任务中。</p>
<p>理解完这两个案例，可以来看看下面一道比较难的题目了。</p>
<h4 id="2-3-题目三-1"><a href="#2-3-题目三-1" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><pre><code>Promise.resolve().then(() =&gt; &#123;
  console.log(&#39;promise1&#39;);
  const timer2 = setTimeout(() =&gt; &#123;
    console.log(&#39;timer2&#39;)
  &#125;, 0)
&#125;);
const timer1 = setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;)
  Promise.resolve().then(() =&gt; &#123;
    console.log(&#39;promise2&#39;)
  &#125;)
&#125;, 0)
console.log(&#39;start&#39;);
复制代码</code></pre>
<p>这道题稍微的难一些，在<code>promise</code>中执行定时器，又在定时器中执行<code>promise</code>；</p>
<p>并且要注意的是，这里的<code>Promise</code>是直接<code>resolve</code>的，而之前的<code>new Promise</code>不一样。</p>
<p>(偷偷告诉你，这道题往下一点有流程图)</p>
<p>因此过程分析为：</p>
<ul>
<li>刚开始整个脚本作为第一次宏任务来执行，我们将它标记为<strong>宏1</strong>，从上至下执行</li>
<li>遇到<code>Promise.resolve().then</code>这个微任务，将<code>then</code>中的内容加入第一次的微任务队列标记为<strong>微1</strong></li>
<li>遇到定时器<code>timer1</code>，将它加入下一次宏任务的延迟列表，标记为<strong>宏2</strong>，等待执行(先不管里面是什么内容)</li>
<li>执行<strong>宏1</strong>中的同步代码<code>start</code></li>
<li>第一次宏任务(<strong>宏1</strong>)执行完毕，检查第一次的微任务队列(<strong>微1</strong>)，发现有一个<code>promise.then</code>这个微任务需要执行</li>
<li>执行打印出<strong>微1</strong>中同步代码<code>promise1</code>，然后发现定时器<code>timer2</code>，将它加入<strong>宏2</strong>的后面，标记为<strong>宏3</strong></li>
<li>第一次微任务队列(<strong>微1</strong>)执行完毕，执行第二次宏任务(<strong>宏2</strong>)，首先执行同步代码<code>timer1</code></li>
<li>然后遇到了<code>promise2</code>这个微任务，将它加入此次循环的微任务队列，标记为<strong>微2</strong></li>
<li><strong>宏2</strong>中没有同步代码可执行了，查找本次循环的微任务队列(<strong>微2</strong>)，发现了<code>promise2</code>，执行它</li>
<li>第二轮执行完毕，执行<strong>宏3</strong>，打印出<code>timer2</code></li>
</ul>
<p>所以结果为：</p>
<pre><code>&#39;start&#39;
&#39;promise1&#39;
&#39;timer1&#39;
&#39;promise2&#39;
&#39;timer2&#39;
复制代码</code></pre>
<p>如果感觉有点绕的话，可以看下面这张图，就一目了然了。</p>
<p>![](<a href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="664"></svg>)</p>
<h4 id="2-4-题目四"><a href="#2-4-题目四" class="headerlink" title="2.4 题目四"></a>2.4 题目四</h4><pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)
const promise2 = promise1.then(() =&gt; &#123;
  throw new Error(&#39;error!!!&#39;)
&#125;)
console.log(&#39;promise1&#39;, promise1)
console.log(&#39;promise2&#39;, promise2)
setTimeout(() =&gt; &#123;
  console.log(&#39;promise1&#39;, promise1)
  console.log(&#39;promise2&#39;, promise2)
&#125;, 2000)
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先执行第一个<code>new Promise</code>中的函数，碰到<code>setTimeout</code>将它加入下一个宏任务列表</li>
<li>跳出<code>new Promise</code>，碰到<code>promise1.then</code>这个微任务，但其状态还是为<code>pending</code>，这里理解为先不执行</li>
<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code></li>
<li>执行同步代码<code>console.log(&#39;promise1&#39;)</code>，且打印出的<code>promise1</code>的状态为<code>pending</code></li>
<li>执行同步代码<code>console.log(&#39;promise2&#39;)</code>，且打印出的<code>promise2</code>的状态为<code>pending</code></li>
<li>碰到第二个定时器，将其放入下一个宏任务列表</li>
<li>第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务</li>
<li>先执行第一个定时器里的内容，将<code>promise1</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise1.then</code>推入微任务队列</li>
<li>该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是<code>promise1.then</code>，它抛出了一个错误，且将<code>promise2</code>的状态设置为了<code>rejected</code></li>
<li>第一个定时器执行完毕，开始执行第二个定时器中的内容</li>
<li>打印出<code>&#39;promise1&#39;</code>，且此时<code>promise1</code>的状态为<code>resolved</code></li>
<li>打印出<code>&#39;promise2&#39;</code>，且此时<code>promise2</code>的状态为<code>rejected</code></li>
</ul>
<p>完整的结果为：</p>
<pre><code>&#39;promise1&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;promise2&#39; Promise&#123;&lt;pending&gt;&#125;
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
&#39;promise1&#39; Promise&#123;&lt;resolved&gt;: &quot;success&quot;&#125;
&#39;promise2&#39; Promise&#123;&lt;rejected&gt;: Error: error!!!&#125;
复制代码</code></pre>
<h4 id="2-5-题目五"><a href="#2-5-题目五" class="headerlink" title="2.5 题目五"></a>2.5 题目五</h4><p>如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案：</p>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&quot;success&quot;);
    console.log(&quot;timer1&quot;);
  &#125;, 1000);
  console.log(&quot;promise1里的内容&quot;);
&#125;);
const promise2 = promise1.then(() =&gt; &#123;
  throw new Error(&quot;error!!!&quot;);
&#125;);
console.log(&quot;promise1&quot;, promise1);
console.log(&quot;promise2&quot;, promise2);
setTimeout(() =&gt; &#123;
  console.log(&quot;timer2&quot;);
  console.log(&quot;promise1&quot;, promise1);
  console.log(&quot;promise2&quot;, promise2);
&#125;, 2000);
复制代码</code></pre>
<p>结果：</p>
<pre><code>&#39;promise1里的内容&#39;
&#39;promise1&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;promise2&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;timer1&#39;
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
&#39;timer2&#39;
&#39;promise1&#39; Promise&#123;&lt;resolved&gt;: &quot;success&quot;&#125;
&#39;promise2&#39; Promise&#123;&lt;rejected&gt;: Error: error!!!&#125;
复制代码</code></pre>
<h3 id="3-Promise中的then、catch、finally"><a href="#3-Promise中的then、catch、finally" class="headerlink" title="3. Promise中的then、catch、finally"></a>3. Promise中的then、catch、finally</h3><p>额，可能你看到下面👇这么多的<code>1，2，3</code>脾气就上来了，不是说好了本篇文章没什么屁话嘛，怎么还是这么多一二三四。</p>
<p>😂，你要理解我的用心良苦啊，我这是帮你把知识点都列举出来，做个总结而已。当然，你也可以先不看，先去做后面的题，然后再回过头来看这些，你就觉得这些点都好好懂啊，甚至都不需要记。</p>
<p><strong>总结：</strong></p>
<ol>
<li><code>Promise</code>的状态一经改变就不能再改变。(见3.1)</li>
<li><code>.then</code>和<code>.catch</code>都会返回一个新的<code>Promise</code>。(上面的👆1.4证明了)</li>
<li><code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。(见3.2)</li>
<li>在<code>Promise</code>中，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，例如<code>return 2</code>会被包装为<code>return Promise.resolve(2)</code>。</li>
<li><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次, 但如果<code>Promise</code>内部的状态一经改变，并且有了一个值，那么后续每次调用<code>.then</code>或者<code>.catch</code>的时候都会直接拿到该值。(见3.5)</li>
<li><code>.then</code> 或者 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获。(见3.6)</li>
<li><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。(见3.7)</li>
<li><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。(见3.8)</li>
<li><code>.then</code>方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为<code>catch</code>是<code>.then</code>第二个参数的简便写法。(见3.9)</li>
<li><code>.finally</code>方法也是返回一个<code>Promise</code>，他在<code>Promise</code>结束的时候，无论结果为<code>resolved</code>还是<code>rejected</code>，都会执行里面的回调函数。</li>
</ol>
<h4 id="3-1-题目一"><a href="#3-1-题目一" class="headerlink" title="3.1 题目一"></a>3.1 题目一</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  resolve(&quot;success1&quot;);
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
&#125;);
promise
.then(res =&gt; &#123;
    console.log(&quot;then: &quot;, res);
  &#125;).catch(err =&gt; &#123;
    console.log(&quot;catch: &quot;, err);
  &#125;)
复制代码</code></pre>
<p>结果：</p>
<pre><code>&quot;then: success1&quot;
复制代码</code></pre>
<p>构造函数中的 <code>resolve</code> 或 <code>reject</code> 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，<code>Promise</code>的状态一经改变就不能再改变。</p>
<h4 id="3-2-题目二"><a href="#3-2-题目二" class="headerlink" title="3.2 题目二"></a>3.2 题目二</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
&#125;);
promise
.then(res =&gt; &#123;
    console.log(&quot;then1: &quot;, res);
  &#125;).then(res =&gt; &#123;
    console.log(&quot;then2: &quot;, res);
  &#125;).catch(err =&gt; &#123;
    console.log(&quot;catch: &quot;, err);
  &#125;).then(res =&gt; &#123;
    console.log(&quot;then3: &quot;, res);
  &#125;)
复制代码</code></pre>
<p>结果：</p>
<pre><code>&quot;catch: &quot; &quot;error&quot;
&quot;then3: &quot; undefined
复制代码</code></pre>
<p>验证了第三个结论，<code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。</p>
<p>至于<code>then3</code>也会被执行，那是因为<code>catch()</code>也会返回一个<code>Promise</code>，且由于这个<code>Promise</code>没有返回值，所以打印出来的是<code>undefined</code>。</p>
<h4 id="3-3-题目三"><a href="#3-3-题目三" class="headerlink" title="3.3 题目三"></a>3.3 题目三</h4><pre><code>Promise.resolve(1)
  .then(res =&gt; &#123;
    console.log(res);
    return 2;
  &#125;)
  .catch(err =&gt; &#123;
    return 3;
  &#125;)
  .then(res =&gt; &#123;
    console.log(res);
  &#125;);
复制代码</code></pre>
<p>结果：</p>
<pre><code>1
2
复制代码</code></pre>
<p><code>Promise</code>可以链式调用，不过<code>promise</code> 每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 <code>promise</code>，从而实现了链式调用, 它并不像一般我们任务的链式调用一样<code>return this</code>。</p>
<p>上面的输出结果之所以依次打印出<code>1</code>和<code>2</code>，那是因为<code>resolve(1)</code>之后走的是第一个<code>then</code>方法，并没有走<code>catch</code>里，所以第二个<code>then</code>中的<code>res</code>得到的实际上是第一个<code>then</code>的返回值。</p>
<p>且<code>return 2</code>会被包装成<code>resolve(2)</code>。</p>
<h4 id="3-4-题目四"><a href="#3-4-题目四" class="headerlink" title="3.4 题目四"></a>3.4 题目四</h4><p>如果把<code>3.3</code>中的<code>Promise.resolve(1)</code>改为<code>Promise.reject(1)</code>又会怎么样呢？</p>
<pre><code>Promise.reject(1)
  .then(res =&gt; &#123;
    console.log(res);
    return 2;
  &#125;)
  .catch(err =&gt; &#123;
    console.log(err);
    return 3
  &#125;)
  .then(res =&gt; &#123;
    console.log(res);
  &#125;);
复制代码</code></pre>
<p>结果：</p>
<pre><code>1
3
复制代码</code></pre>
<p>结果打印的当然是 <code>1 和 3</code>啦，因为<code>reject(1)</code>此时走的就是<code>catch</code>，且第二个<code>then</code>中的<code>res</code>得到的就是<code>catch</code>中的返回值。</p>
<h4 id="3-5-题目五"><a href="#3-5-题目五" class="headerlink" title="3.5 题目五"></a>3.5 题目五</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer&#39;)
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)
const start = Date.now();
promise.then(res =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)
promise.then(res =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)
复制代码</code></pre>
<p>执行结果：</p>
<pre><code>&#39;timer&#39;
&#39;success&#39; 1001
&#39;success&#39; 1002
复制代码</code></pre>
<p>当然，如果你足够快的话，也可能两个都是<code>1001</code>。</p>
<p><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次，但这里 <code>Promise</code> 构造函数只执行一次。或者说 <code>promise</code> 内部状态一经改变，并且有了一个值，那么后续每次调用 <code>.then</code> 或者 <code>.catch</code> 都会直接拿到该值。</p>
<h4 id="3-6-题目六"><a href="#3-6-题目六" class="headerlink" title="3.6 题目六"></a>3.6 题目六</h4><pre><code>Promise.resolve().then(() =&gt; &#123;
  return new Error(&#39;error!!!&#39;)
&#125;).then(res =&gt; &#123;
  console.log(&quot;then: &quot;, res)
&#125;).catch(err =&gt; &#123;
  console.log(&quot;catch: &quot;, err)
&#125;)
复制代码</code></pre>
<p>猜猜这里的结果输出的是什么 🤔️ ？</p>
<p>你可能想到的是进入<code>.catch</code>然后被捕获了错误。</p>
<p>结果并不是这样的，它走的是<code>.then</code>里面：</p>
<pre><code>&quot;then: &quot; &quot;Error: error!!!&quot;
复制代码</code></pre>
<p>这也验证了第4点和第6点，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>。</p>
<p>当然如果你抛出一个错误的话，可以用下面👇两的任意一种：</p>
<pre><code>return Promise.reject(new Error(&#39;error!!!&#39;));
// or
throw new Error(&#39;error!!!&#39;)
复制代码</code></pre>
<h4 id="3-7-题目七"><a href="#3-7-题目七" class="headerlink" title="3.7 题目七"></a>3.7 题目七</h4><pre><code>const promise = Promise.resolve().then(() =&gt; &#123;
  return promise;
&#125;)
promise.catch(console.err)
复制代码</code></pre>
<p><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>
<p>因此结果会报错：</p>
<pre><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
复制代码</code></pre>
<h4 id="3-8-题目八"><a href="#3-8-题目八" class="headerlink" title="3.8 题目八"></a>3.8 题目八</h4><pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
复制代码</code></pre>
<p>这道题看着好像很简单，又感觉很复杂的样子，怎么这么多个<code>.then</code>啊… 😅</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/28/1708baaf2b1e9075?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>其实你只要记住<strong>原则8</strong>：<code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。</p>
<p>第一个<code>then</code>和第二个<code>then</code>中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个<code>then</code>里。</p>
<p>所以输出结果为：</p>
<pre><code>1
复制代码</code></pre>
<h4 id="3-9-题目九"><a href="#3-9-题目九" class="headerlink" title="3.9 题目九"></a>3.9 题目九</h4><p>下面来介绍一下<code>.then</code>函数中的两个参数。</p>
<p>第一个参数是用来处理<code>Promise</code>成功的函数，第二个则是处理失败的函数。</p>
<p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p>
<p>让我们来看看这个例子🌰：</p>
<pre><code>Promise.reject(&#39;err!!!&#39;)
  .then((res) =&gt; &#123;
    console.log(&#39;success&#39;, res)
  &#125;, (err) =&gt; &#123;
    console.log(&#39;error&#39;, err)
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;catch&#39;, err)
  &#125;)
复制代码</code></pre>
<p>这里的执行结果是：</p>
<pre><code>&#39;error&#39; &#39;error!!!&#39;
复制代码</code></pre>
<p>它进入的是<code>then()</code>中的第二个参数里面，而如果把第二个参数去掉，就进入了<code>catch()</code>中：</p>
<pre><code>Promise.reject(&#39;err!!!&#39;)
  .then((res) =&gt; &#123;
    console.log(&#39;success&#39;, res)
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;catch&#39;, err)
  &#125;)
复制代码</code></pre>
<p>执行结果：</p>
<pre><code>&#39;catch&#39; &#39;error!!!&#39;
复制代码</code></pre>
<p>但是有一个问题，如果是这个案例呢？</p>
<pre><code>Promise.resolve()
  .then(function success (res) &#123;
    throw new Error(&#39;error!!!&#39;)
  &#125;, function fail1 (err) &#123;
    console.log(&#39;fail1&#39;, err)
  &#125;).catch(function fail2 (err) &#123;
    console.log(&#39;fail2&#39;, err)
  &#125;)
复制代码</code></pre>
<p>由于<code>Promise</code>调用的是<code>resolve()</code>，因此<code>.then()</code>执行的应该是<code>success()</code>函数，可是<code>success()</code>函数抛出的是一个错误，它会被后面的<code>catch()</code>给捕获到，而不是被<code>fail1</code>函数捕获。</p>
<p>因此执行结果为：</p>
<pre><code>fail2 Error: error!!!
   at success
复制代码</code></pre>
<h4 id="3-10-题目十"><a href="#3-10-题目十" class="headerlink" title="3.10 题目十"></a>3.10 题目十</h4><p>接着来看看<code>.finally()</code>，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。</p>
<p>其实你只要记住它三个很重要的知识点就可以了：</p>
<ol>
<li><code>.finally()</code>方法不管<code>Promise</code>对象最后的状态如何都会执行</li>
<li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是没法知道<code>Promise</code>最终的状态是<code>resolved</code>还是<code>rejected</code>的</li>
<li>它最终返回的默认会是一个<strong>上一次的Promise对象值</strong>，不过如果抛出的是一个异常则返回异常的<code>Promise</code>对象。</li>
</ol>
<p>来看看这个简单的例子🌰：</p>
<pre><code>Promise.resolve(&#39;1&#39;)
  .then(res =&gt; &#123;
    console.log(res)
  &#125;)
  .finally(() =&gt; &#123;
    console.log(&#39;finally&#39;)
  &#125;)
Promise.resolve(&#39;2&#39;)
  .finally(() =&gt; &#123;
    console.log(&#39;finally2&#39;)
   return &#39;我是finally2返回的值&#39;
  &#125;)
  .then(res =&gt; &#123;
    console.log(&#39;finally2后面的then函数&#39;, res)
  &#125;)
复制代码</code></pre>
<p>这两个<code>Promise</code>的<code>.finally</code>都会执行，且就算<code>finally2</code>返回了新的值，它后面的<code>then()</code>函数接收到的结果却还是<code>&#39;2&#39;</code>，因此打印结果为：</p>
<pre><code>&#39;1&#39;
&#39;finally2&#39;
&#39;finally&#39;
&#39;finally2后面的then函数&#39; &#39;2&#39;
复制代码</code></pre>
<p>至于为什么<code>finally2</code>的打印要在<code>finally</code>前面，请看下一个例子中的解析。</p>
<p>不过在此之前让我们再来确认一下，<code>finally</code>中要是抛出的是一个异常是怎样的：</p>
<pre><code>Promise.resolve(&#39;1&#39;)
  .finally(() =&gt; &#123;
    console.log(&#39;finally1&#39;)
    throw new Error(&#39;我是finally中抛出的异常&#39;)
  &#125;)
  .then(res =&gt; &#123;
    console.log(&#39;finally后面的then函数&#39;, res)
  &#125;)
  .catch(err =&gt; &#123;
    console.log(&#39;捕获错误&#39;, err)
  &#125;)
复制代码</code></pre>
<p>执行结果为：</p>
<pre><code>&#39;finally1&#39;
&#39;捕获错误&#39; Error: 我是finally中抛出的异常
复制代码</code></pre>
<p>但是如果改为<code>return new Error(&#39;我是finally中抛出的异常&#39;)</code>，打印出来的就是<code>&#39;finally后面的then函数 1&#39;</code></p>
<p>OK，👌，让我们来看一个比较难的例子🌰：</p>
<pre><code>function promise1 () &#123;
  let p = new Promise((resolve) =&gt; &#123;
    console.log(&#39;promise1&#39;);
    resolve(&#39;1&#39;)
  &#125;)
  return p;
&#125;
function promise2 () &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    reject(&#39;error&#39;)
  &#125;)
&#125;
promise1()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .finally(() =&gt; console.log(&#39;finally1&#39;))

promise2()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .finally(() =&gt; console.log(&#39;finally2&#39;))
复制代码</code></pre>
<p>执行过程：</p>
<ul>
<li>首先定义了两个函数<code>promise1</code>和<code>promise2</code>，先不管接着往下看。</li>
<li><code>promise1</code>函数先被调用了，然后执行里面<code>new Promise</code>的同步代码打印出<code>promise1</code></li>
<li>之后遇到了<code>resolve(1)</code>，将<code>p</code>的状态改为了<code>resolved</code>并将结果保存下来。</li>
<li>此时<code>promise1</code>内的函数内容已经执行完了，跳出该函数</li>
<li>碰到了<code>promise1().then()</code>，由于<code>promise1</code>的状态已经发生了改变且为<code>resolved</code>因此将<code>promise1().then()</code>这条微任务加入本轮的微任务列表(<strong>这是第一个微任务</strong>)</li>
<li>这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将<code>.finally</code>加入微任务列表，那是因为<code>.then</code>本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管<code>.finally()</code></li>
<li>再往下走碰到了<code>promise2()</code>函数，其中返回的<code>new Promise</code>中并没有同步代码需要执行，所以执行<code>reject(&#39;error&#39;)</code>的时候将<code>promise2</code>函数中的<code>Promise</code>的状态变为了<code>rejected</code></li>
<li>跳出<code>promise2</code>函数，遇到了<code>promise2().catch()</code>，将其加入当前的微任务队列(<strong>这是第二个微任务</strong>)，且链式调用后面的内容得等该任务执行完后才执行，和<code>.then()</code>一样。</li>
<li>OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在<code>promise1().then()</code>，执行它，打印出<code>1</code>，然后遇到了<code>.finally()</code>这个微任务将它加入微任务列表(<strong>这是第三个微任务</strong>)等待执行</li>
<li>再执行<code>promise2().catch()</code>打印出<code>error</code>，执行完后将<code>finally2</code>加入微任务加入微任务列表(<strong>这是第四个微任务</strong>)</li>
<li>OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行<code>finally1</code>和<code>finally2</code>。</li>
</ul>
<p>结果：</p>
<pre><code>&#39;promise1&#39;
&#39;1&#39;
&#39;error&#39;
&#39;finally1&#39;
&#39;finally2&#39;
复制代码</code></pre>
<p>在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为<strong>链式调用</strong>后面的内容需要等前一个调用执行完才会执行。</p>
<p>就像是这里的<code>finally()</code>会等<code>promise1().then()</code>执行完才会将<code>finally()</code>加入微任务队列，其实如果这道题中你把<code>finally()</code>换成是<code>then()</code>也是这样的:</p>
<pre><code>function promise1 () &#123;
  let p = new Promise((resolve) =&gt; &#123;
    console.log(&#39;promise1&#39;);
    resolve(&#39;1&#39;)
  &#125;)
  return p;
&#125;
function promise2 () &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    reject(&#39;error&#39;)
  &#125;)
&#125;
promise1()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .then(() =&gt; console.log(&#39;finally1&#39;))

promise2()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .then(() =&gt; console.log(&#39;finally2&#39;))
复制代码</code></pre>
<h3 id="4-Promise中的all和race"><a href="#4-Promise中的all和race" class="headerlink" title="4. Promise中的all和race"></a>4. Promise中的all和race</h3><p>在做下面👇的题目之前，让我们先来了解一下<code>Promise.all()</code>和<code>Promise.race()</code>的用法。</p>
<p>通俗来说，<code>.all()</code>的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。</p>
<p><code>.race()</code>的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</p>
<p>来看看题目一。</p>
<h4 id="4-1-题目一"><a href="#4-1-题目一" class="headerlink" title="4.1 题目一"></a>4.1 题目一</h4><p>我们知道如果直接在脚本文件中定义一个<code>Promise</code>，它构造函数的第一个参数是会立即执行的，就像这样：</p>
<pre><code>const p1 = new Promise(r =&gt; console.log(&#39;立即打印&#39;))
复制代码</code></pre>
<p>控制台中会立即打印出 “立即打印”。</p>
<p>因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了：</p>
<pre><code>function runP1 () &#123;
    const p1 = new Promise(r =&gt; console.log(&#39;立即打印&#39;))
    return p1
&#125;

runP1() // 调用此函数时才执行
复制代码</code></pre>
<p>OK 👌， 让我们回归正题。</p>
<p>现在来构建这么一个函数：</p>
<pre><code>function runAsync (x) &#123;
    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
    return p
&#125;
复制代码</code></pre>
<p>该函数传入一个值<code>x</code>，然后间隔一秒后打印出这个<code>x</code>。</p>
<p>如果我用<code>.all()</code>来执行它会怎样呢？</p>
<pre><code>function runAsync (x) &#123;
    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
    return p
&#125;
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt; console.log(res))
复制代码</code></pre>
<p>先来想想此段代码在浏览器中会如何执行？</p>
<p>没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出<code>1, 2, 3</code>，还有一个数组<code>[1, 2, 3]</code>。</p>
<pre><code>1
2
3
[1, 2, 3]
复制代码</code></pre>
<p>所以你现在能理解这句话的意思了吗：<strong>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。</strong></p>
<p><code>.all()</code>后面的<code>.then()</code>里的回调函数接收的就是所有异步操作的结果。</p>
<p>而且这个结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致！！！</p>
<blockquote>
<p>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p>
</blockquote>
<h4 id="4-2-题目二"><a href="#4-2-题目二" class="headerlink" title="4.2 题目二"></a>4.2 题目二</h4><p>我新增了一个<code>runReject</code>函数，它用来在<code>1000 * x</code>秒后<code>reject</code>一个错误。</p>
<p>同时<code>.catch()</code>函数能够捕获到<code>.all()</code>里最先的那个异常，并且只执行一次。</p>
<p>想想这道题会怎样执行呢 🤔️？</p>
<pre><code>function runAsync (x) &#123;
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
&#125;
function runReject (x) &#123;
  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x))
  return p
&#125;
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
复制代码</code></pre>
<p>不卖关子了 😁，让我来公布答案：</p>
<pre><code>// 1s后输出
1
3
// 2s后输出
2
Error: 2
// 4s后输出
4
复制代码</code></pre>
<p>没错，就像我之前说的，<code>.catch</code>是会捕获最先的那个异常，在这道题目中最先的异常就是<code>runReject(2)</code>的结果。</p>
<p>另外，如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。</p>
<p>注意，为什么不说是不进入<code>.then()</code>中呢 🤔️？</p>
<p>哈哈，大家别忘了<code>.then()</code>方法的第二个参数也是可以捕获错误的：</p>
<pre><code>Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt; console.log(res), 
  err =&gt; console.log(err))
复制代码</code></pre>
<h4 id="4-3-题目三"><a href="#4-3-题目三" class="headerlink" title="4.3 题目三"></a>4.3 题目三</h4><p>接下来让我们看看另一个有趣的方法<code>.race</code>。</p>
<p>让我看看你们的英语水平如何？</p>
<p>快！一秒钟告诉我<code>race</code>是什么意思？</p>
<p>![](<a href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="294" height="221"></svg>)</p>
<p>好吧…你们果然很强…</p>
<p><code>race</code>，比赛，赛跑的意思。</p>
<p>所以使用<code>.race()</code>方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过<code>race</code>已经不管那些任务的结果了。</p>
<p>来，改造一下<code>4.1</code>这道题：</p>
<pre><code>function runAsync (x) &#123;
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
&#125;
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt; console.log(&#39;result: &#39;, res))
  .catch(err =&gt; console.log(err))
复制代码</code></pre>
<p>执行结果为：</p>
<pre><code>1
&#39;result: &#39; 1
2
3
复制代码</code></pre>
<blockquote>
<p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p>
</blockquote>
<h4 id="4-4-题目四"><a href="#4-4-题目四" class="headerlink" title="4.4 题目四"></a>4.4 题目四</h4><p>改造一下题目<code>4.2</code>：</p>
<pre><code>function runAsync(x) &#123;
  const p = new Promise(r =&gt;
    setTimeout(() =&gt; r(x, console.log(x)), 1000)
  );
  return p;
&#125;
function runReject(x) &#123;
  const p = new Promise((res, rej) =&gt;
    setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)
  );
  return p;
&#125;
Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt; console.log(&quot;result: &quot;, res))
  .catch(err =&gt; console.log(err));
复制代码</code></pre>
<p>遇到错误的话，也是一样的，在这道题中，<code>runReject(0)</code>最先执行完，所以进入了<code>catch()</code>中：</p>
<pre><code>0
&#39;Error: 0&#39;
1
2
3
复制代码</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>好的，让我们来总结一下<code>.then()</code>和<code>.race()</code>吧，😄</p>
<ul>
<li><code>Promise.all()</code>的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。</li>
<li><code>.race()</code>的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</li>
<li><code>Promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致。</li>
<li><code>all和race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被<code>then</code>的第二个参数或者后面的<code>catch</code>捕获；但并不会影响数组中其它的异步任务的执行。</li>
</ul>
<h3 id="5-async-await的几道题"><a href="#5-async-await的几道题" class="headerlink" title="5. async/await的几道题"></a>5. async/await的几道题</h3><p>既然谈到了<code>Promise</code>，那就肯定得再说说<code>async/await</code>，在很多时候<code>async</code>和<code>Promise</code>的解法差不多，又有些不一样。不信你来看看题目一。</p>
<h4 id="5-1-题目一"><a href="#5-1-题目一" class="headerlink" title="5.1 题目一"></a>5.1 题目一</h4><pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;
async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;
async1();
console.log(&#39;start&#39;)
复制代码</code></pre>
<p>这道基础题输出的是啥？</p>
<p>答案：</p>
<pre><code>&#39;async1 start&#39;
&#39;async2&#39;
&#39;start&#39;
&#39;async1 end&#39;
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置</li>
<li>发现<code>async1</code>函数被调用了，然后去看看调用的内容</li>
<li>执行函数中的同步代码<code>async1 start</code>，之后碰到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code></li>
<li>跳出<code>async1</code>函数后，执行同步代码<code>start</code></li>
<li>在一轮宏任务全部执行完之后，再来执行刚刚<code>await</code>后面的内容<code>async1 end</code>。</li>
</ul>
<p>在这里，你可以理解为「紧跟着await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中」。</p>
<p>让我们来看看将<code>await</code>转换为<code>Promise.then</code>的伪代码：</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  // 原来代码
  // await async2();
  // console.log(&quot;async1 end&quot;);

  // 转换后代码
  new Promise(resolve =&gt; &#123;
    console.log(&quot;async2&quot;)
    resolve()
  &#125;).then(res =&gt; console.log(&quot;async1 end&quot;))
&#125;
async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;
async1();
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>转换后的伪代码和前面的执行结果是一样的。(感谢评论区<a href="https://juejin.im/user/57e0f2738ac2470061745306">Wing93</a>和<a href="https://juejin.im/user/5602aa7360b2521f381a3873">Jexxie</a>小伙伴的指出)</p>
<p>另外关于<code>await</code>和<code>Promise</code>的区别，如果我们把<code>await async2()</code>换成一个<code>new Promise</code>呢？</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  new Promise(resolve =&gt; &#123;
    console.log(&#39;promise&#39;)
  &#125;)
  console.log(&quot;async1 end&quot;);
&#125;
async1();
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>此时的执行结果为：</p>
<pre><code>&#39;async start&#39;
&#39;promise&#39;
&#39;async1 end&#39;
&#39;start&#39;
复制代码</code></pre>
<p>可以看到<code>new Promise()</code>并不会阻塞后面的同步代码<code>async1 end</code>的执行。</p>
<h4 id="5-2-题目二"><a href="#5-2-题目二" class="headerlink" title="5.2 题目二"></a>5.2 题目二</h4><p>现在将<code>async</code>结合定时器看看。</p>
<p>给题目一中的 <code>async2</code>函数中加上一个定时器：</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;
async function async2() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer&#39;)
  &#125;, 0)
  console.log(&quot;async2&quot;);
&#125;
async1();
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。</p>
<p>答案：</p>
<pre><code>&#39;async1 start&#39;
&#39;async2&#39;
&#39;start&#39;
&#39;async1 end&#39;
&#39;timer&#39;
复制代码</code></pre>
<h4 id="5-3-题目三"><a href="#5-3-题目三" class="headerlink" title="5.3 题目三"></a>5.3 题目三</h4><p>来吧，小伙伴们，让我们多加几个定时器看看。😁</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer1&#39;)
  &#125;, 0)
&#125;
async function async2() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer2&#39;)
  &#125;, 0)
  console.log(&quot;async2&quot;);
&#125;
async1();
setTimeout(() =&gt; &#123;
  console.log(&#39;timer3&#39;)
&#125;, 0)
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>思考一下🤔，执行结果会是什么？</p>
<p>其实如果你能做到这里了，说明你前面的那些知识点也都掌握了，我就不需要太过详细的步骤分析了。</p>
<p>直接公布答案吧：</p>
<pre><code>&#39;async1 start&#39;
&#39;async2&#39;
&#39;start&#39;
&#39;async1 end&#39;
&#39;timer2&#39;
&#39;timer3&#39;
&#39;timer1&#39;
复制代码</code></pre>
<p>定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是<code>0</code>，所以只要关注谁先被调用的。。</p>
<h4 id="5-4-题目四"><a href="#5-4-题目四" class="headerlink" title="5.4 题目四"></a>5.4 题目四</h4><p>正常情况下，<code>async</code>中的<code>await</code>命令是一个<code>Promise</code>对象，返回该对象的结果。</p>
<p>但如果不是<code>Promise</code>对象的话，就会直接返回对应的值，相当于<code>Promise.resolve()</code></p>
<pre><code>async function fn () &#123;
  // return await 1234
  // 等同于
  return 123
&#125;
fn().then(res =&gt; console.log(res))
复制代码</code></pre>
<p>结果：</p>
<pre><code>123
复制代码</code></pre>
<h4 id="5-5-题目五"><a href="#5-5-题目五" class="headerlink" title="5.5 题目五"></a>5.5 题目五</h4><pre><code>async function async1 () &#123;
  console.log(&#39;async1 start&#39;);
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
  &#125;)
  console.log(&#39;async1 success&#39;);
  return &#39;async1 end&#39;
&#125;
console.log(&#39;srcipt start&#39;)
async1().then(res =&gt; console.log(res))
console.log(&#39;srcipt end&#39;)
复制代码</code></pre>
<p>这道题目比较有意思，大家要注意了。</p>
<p>在<code>async1</code>中<code>await</code>后面的<code>Promise</code>是没有返回值的，也就是它的状态始终是<code>pending</code>状态，因此相当于一直在<code>await</code>，<code>await</code>，<code>await</code>却始终没有响应…</p>
<p>![](<a href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="255" height="255"></svg>)</p>
<p>所以在<code>await</code>之后的内容是不会执行的，也包括<code>async1</code>后面的 <code>.then</code>。</p>
<p>答案为：</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;promise1&#39;
&#39;script end&#39;
复制代码</code></pre>
<h4 id="5-6-题目六"><a href="#5-6-题目六" class="headerlink" title="5.6 题目六"></a>5.6 题目六</h4><p>让我们给<code>5.5</code>中的<code>Promise</code>加上<code>resolve</code>：</p>
<pre><code>async function async1 () &#123;
  console.log(&#39;async1 start&#39;);
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
    resolve(&#39;promise1 resolve&#39;)
  &#125;).then(res =&gt; console.log(res))
  console.log(&#39;async1 success&#39;);
  return &#39;async1 end&#39;
&#125;
console.log(&#39;srcipt start&#39;)
async1().then(res =&gt; console.log(res))
console.log(&#39;srcipt end&#39;)
复制代码</code></pre>
<p>现在<code>Promise</code>有了返回值了，因此<code>await</code>后面的内容将会被执行：</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;promise1&#39;
&#39;script end&#39;
&#39;promise1 resolve&#39;
&#39;async1 success&#39;
&#39;async1 end&#39;
复制代码</code></pre>
<h4 id="5-7-题目七"><a href="#5-7-题目七" class="headerlink" title="5.7 题目七"></a>5.7 题目七</h4><pre><code>async function async1 () &#123;
  console.log(&#39;async1 start&#39;);
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
    resolve(&#39;promise resolve&#39;)
  &#125;)
  console.log(&#39;async1 success&#39;);
  return &#39;async1 end&#39;
&#125;
console.log(&#39;srcipt start&#39;)
async1().then(res =&gt; &#123;
  console.log(res)
&#125;)
new Promise(resolve =&gt; &#123;
  console.log(&#39;promise2&#39;)
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer&#39;)
  &#125;)
&#125;)
复制代码</code></pre>
<p>这道题应该也不难，不过有一点需要注意的，在<code>async1</code>中的<code>new Promise</code>它的<code>resovle</code>的值和<code>async1().then()</code>里的值是没有关系的，很多小伙伴可能看到<code>resovle(&#39;promise resolve&#39;)</code>就会误以为是<code>async1().then()</code>中的返回值。</p>
<p>因此这里的执行结果为：</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;promise1&#39;
&#39;promise2&#39;
&#39;async1 success&#39;
&#39;async1 end&#39;
&#39;timer&#39;
复制代码</code></pre>
<h4 id="5-8-题目八"><a href="#5-8-题目八" class="headerlink" title="5.8 题目八"></a>5.8 题目八</h4><p>我们再来看一道头条曾经的面试题：</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;

async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;

console.log(&quot;script start&quot;);

setTimeout(function() &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);

async1();

new Promise(function(resolve) &#123;
  console.log(&quot;promise1&quot;);
  resolve();
&#125;).then(function() &#123;
  console.log(&quot;promise2&quot;);
&#125;);
console.log(&#39;script end&#39;)
复制代码</code></pre>
<p>有了上面👆几题做基础，相信你很快也能答上来了。</p>
<p>![](<a href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="300" height="300"></svg>)</p>
<p>自信的写下你们的答案吧。</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;async2&#39;
&#39;promise1&#39;
&#39;script end&#39;
&#39;async1 end&#39;
&#39;promise2&#39;
&#39;setTimeout&#39;
复制代码</code></pre>
<p>(这道题最后<code>async1 end</code>和<code>promise2</code>的顺序其实在网上饱受争议，我这里使用浏览器<code>Chrome V80</code>，<code>Node v12.16.1</code>的执行结果都是上面这个答案)</p>
<h4 id="5-9-题目九"><a href="#5-9-题目九" class="headerlink" title="5.9 题目九"></a>5.9 题目九</h4><p>好的👌，<code>async/await</code>大法已练成，咱们继续：</p>
<pre><code>async function testSometing() &#123;
  console.log(&quot;执行testSometing&quot;);
  return &quot;testSometing&quot;;
&#125;

async function testAsync() &#123;
  console.log(&quot;执行testAsync&quot;);
  return Promise.resolve(&quot;hello async&quot;);
&#125;

async function test() &#123;
  console.log(&quot;test start...&quot;);
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
&#125;

test();

var promise = new Promise(resolve =&gt; &#123;
  console.log(&quot;promise start...&quot;);
  resolve(&quot;promise&quot;);
&#125;);
promise.then(val =&gt; console.log(val));

console.log(&quot;test end...&quot;);
复制代码</code></pre>
<p>答案：</p>
<pre><code>&#39;test start...&#39;
&#39;执行testSometing&#39;
&#39;promise start...&#39;
&#39;test end...&#39;
&#39;testSometing&#39;
&#39;执行testAsync&#39;
&#39;promise&#39;
&#39;hello async&#39;
&#39;testSometing&#39; &#39;hello async&#39;
复制代码</code></pre>
<h3 id="6-async处理错误"><a href="#6-async处理错误" class="headerlink" title="6. async处理错误"></a>6. async处理错误</h3><h4 id="6-1-题目一"><a href="#6-1-题目一" class="headerlink" title="6.1 题目一"></a>6.1 题目一</h4><p>在<code>async</code>中，如果 <code>await</code>后面的内容是一个异常或者错误的话，会怎样呢？</p>
<pre><code>async function async1 () &#123;
  await async2();
  console.log(&#39;async1&#39;);
  return &#39;async1 success&#39;
&#125;
async function async2 () &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    console.log(&#39;async2&#39;)
    reject(&#39;error&#39;)
  &#125;)
&#125;
async1().then(res =&gt; console.log(res))
复制代码</code></pre>
<p>例如这道题中，<code>await</code>后面跟着的是一个状态为<code>rejected</code>的<code>promise</code>。</p>
<p><strong>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p>
<p>所以答案为：</p>
<pre><code>&#39;async2&#39;
Uncaught (in promise) error
复制代码</code></pre>
<p>如果改为<code>throw new Error</code>也是一样的：</p>
<pre><code>async function async1 () &#123;
  console.log(&#39;async1&#39;);
  throw new Error(&#39;error!!!&#39;)
  return &#39;async1 success&#39;
&#125;
async1().then(res =&gt; console.log(res))
复制代码</code></pre>
<p>结果为：</p>
<pre><code>&#39;async1&#39;
Uncaught (in promise) Error: error!!!
复制代码</code></pre>
<h4 id="6-2-题目二"><a href="#6-2-题目二" class="headerlink" title="6.2 题目二"></a>6.2 题目二</h4><p>如果想要使得错误的地方不影响<code>async</code>函数后续的执行的话，可以使用<code>try catch</code></p>
<pre><code>async function async1 () &#123;
  try &#123;
    await Promise.reject(&#39;error!!!&#39;)
  &#125; catch(e) &#123;
    console.log(e)
  &#125;
  console.log(&#39;async1&#39;);
  return Promise.resolve(&#39;async1 success&#39;)
&#125;
async1().then(res =&gt; console.log(res))
console.log(&#39;script start&#39;)
复制代码</code></pre>
<p>这里的结果为：</p>
<pre><code>&#39;script start&#39;
&#39;error!!!&#39;
&#39;async1&#39;
&#39;async1 success&#39;
复制代码</code></pre>
<p>或者你可以直接在<code>Promise.reject</code>后面跟着一个<code>catch()</code>方法：</p>
<pre><code>async function async1 () &#123;
  // try &#123;
  //   await Promise.reject(&#39;error!!!&#39;)
  // &#125; catch(e) &#123;
  //   console.log(e)
  // &#125;
  await Promise.reject(&#39;error!!!&#39;)
    .catch(e =&gt; console.log(e))
  console.log(&#39;async1&#39;);
  return Promise.resolve(&#39;async1 success&#39;)
&#125;
async1().then(res =&gt; console.log(res))
console.log(&#39;script start&#39;)
复制代码</code></pre>
<p>运行结果是一样的。</p>
<h3 id="7-综合题"><a href="#7-综合题" class="headerlink" title="7. 综合题"></a>7. 综合题</h3><p>上面👆的题目都是被我拆分着说一些功能点，现在让我们来做一些比较难的综合题吧。</p>
<h4 id="7-1-题目一"><a href="#7-1-题目一" class="headerlink" title="7.1 题目一"></a>7.1 题目一</h4><pre><code>const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;
    console.log(3);
    let p = new Promise((resolve, reject) =&gt; &#123;
        console.log(7);
        setTimeout(() =&gt; &#123;
            console.log(5);
            resolve(6);
            console.log(p)
        &#125;, 0)
        resolve(1);
    &#125;);
    resolve(2);
    p.then((arg) =&gt; &#123;
        console.log(arg);
    &#125;);
&#125;));
first().then((arg) =&gt; &#123;
    console.log(arg);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在<code>4</code>之前，所以可以来看看<code>first</code>函数里面的内容了。(这一步有点类似于题目<code>1.5</code>)</li>
<li>函数<code>first</code>返回的是一个<code>new Promise()</code>，因此先执行里面的同步代码<code>3</code></li>
<li>接着又遇到了一个<code>new Promise()</code>，直接执行里面的同步代码<code>7</code></li>
<li>执行完<code>7</code>之后，在<code>p</code>中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走</li>
<li>碰到了<code>resolve(1)</code>，这里就把<code>p</code>的状态改为了<code>resolved</code>，且返回值为<code>1</code>，不过这里也先不执行</li>
<li>跳出<code>p</code>，碰到了<code>resolve(2)</code>，这里的<code>resolve(2)</code>，表示的是把<code>first</code>函数返回的那个<code>Promise</code>的状态改了，也先不管它。</li>
<li>然后碰到了<code>p.then</code>，将它加入本次循环的微任务列表，等待执行</li>
<li>跳出<code>first</code>函数，遇到了<code>first().then()</code>，将它加入本次循环的微任务列表(<code>p.then</code>的后面执行)</li>
<li>然后执行同步代码<code>4</code></li>
<li>本轮的同步代码全部执行完毕，查找微任务列表，发现<code>p.then</code>和<code>first().then()</code>，依次执行，打印出<code>1和2</code></li>
<li>本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码<code>5</code></li>
<li>然后又遇到了一个<code>resolve(6)</code>，它是放在<code>p</code>里的，但是<code>p</code>的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说<code>resolve(6)</code>相当于没任何用处，因此打印出来的<code>p</code>为<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>。(这一步类似于题目<code>3.1</code>)</li>
</ul>
<p>结果：</p>
<pre><code>3
7
4
1
2
5
Promise&#123;&lt;resolved&gt;: 1&#125;
复制代码</code></pre>
<p>做对了的小伙伴奖励自己一朵小<code>(大)</code>红<code>(嘴)</code>花<code>(巴)</code>吧，😄</p>
<p>![](<a href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="360" height="360"></svg>)</p>
<h4 id="7-2-题目二"><a href="#7-2-题目二" class="headerlink" title="7.2 题目二"></a>7.2 题目二</h4><pre><code>const async1 = async () =&gt; &#123;
  console.log(&#39;async1&#39;);
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer1&#39;)
  &#125;, 2000)
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
  &#125;)
  console.log(&#39;async1 end&#39;)
  return &#39;async1 success&#39;
&#125; 
console.log(&#39;script start&#39;);
async1().then(res =&gt; console.log(res));
console.log(&#39;script end&#39;);
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res =&gt; console.log(res))
setTimeout(() =&gt; &#123;
  console.log(&#39;timer2&#39;)
&#125;, 1000)
复制代码</code></pre>
<p>注意的知识点：</p>
<ul>
<li><code>async</code>函数中<code>await</code>的<code>new Promise</code>要是没有返回值的话则不执行后面的内容(类似题<code>5.5</code>)</li>
<li><code>.then</code>函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题<code>3.8</code> )</li>
<li>注意定时器的延迟时间</li>
</ul>
<p>因此本题答案为：</p>
<pre><code>&#39;script start&#39;
&#39;async1&#39;
&#39;promise1&#39;
&#39;script end&#39;
1
&#39;timer2&#39;
&#39;timer1&#39;
复制代码</code></pre>
<h4 id="7-3-题目三"><a href="#7-3-题目三" class="headerlink" title="7.3 题目三"></a>7.3 题目三</h4><pre><code>const p1 = new Promise((resolve) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;resolve3&#39;);
    console.log(&#39;timer1&#39;)
  &#125;, 0)
  resolve(&#39;resovle1&#39;);
  resolve(&#39;resolve2&#39;);
&#125;).then(res =&gt; &#123;
  console.log(res)
  setTimeout(() =&gt; &#123;
    console.log(p1)
  &#125;, 1000)
&#125;).finally(res =&gt; &#123;
  console.log(&#39;finally&#39;, res)
&#125;)
复制代码</code></pre>
<p>注意的知识点：</p>
<ul>
<li><code>Promise</code>的状态一旦改变就无法改变(类似题目<code>3.5</code>)</li>
<li><code>finally</code>不管<code>Promise</code>的状态是<code>resolved</code>还是<code>rejected</code>都会执行，且它的回调函数是接收不到<code>Promise</code>的结果的，所以<code>finally()</code>中的<code>res</code>是一个迷惑项(类似<code>3.10</code>)。</li>
<li>最后一个定时器打印出的<code>p1</code>其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个<code>Promise</code>的返回值(<code>3.10</code>中也有提到), 而这道题中<code>.finally</code>上一个<code>Promise</code>是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以<code>p1</code>打印出来的<code>Promise</code>的值会是<code>undefined</code>，如果你在定时器的<strong>下面</strong>加上一个<code>return 1</code>，则值就会变成<code>1</code>(感谢掘友<a href="https://juejin.im/user/5b1487eee51d4506e1748613">JS丛中过</a>的指出)。</li>
</ul>
<p>答案：</p>
<pre><code>&#39;resolve1&#39;
&#39;finally&#39; undefined
&#39;timer1&#39;
Promise&#123;&lt;resolved&gt;: undefined&#125;
复制代码</code></pre>
<h3 id="8-几道大厂的面试题"><a href="#8-几道大厂的面试题" class="headerlink" title="8. 几道大厂的面试题"></a>8. 几道大厂的面试题</h3><h4 id="8-1-使用Promise实现每隔1秒输出1-2-3"><a href="#8-1-使用Promise实现每隔1秒输出1-2-3" class="headerlink" title="8.1 使用Promise实现每隔1秒输出1,2,3"></a>8.1 使用Promise实现每隔1秒输出1,2,3</h4><p>这道题比较简单的一种做法是可以用<code>Promise</code>配合着<code>reduce</code>不停的在<code>promise</code>后面叠加<code>.then</code>，请看下面的代码：</p>
<pre><code>const arr = [1, 2, 3]
arr.reduce((p, x) =&gt; &#123;
  return p.then(() =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; r(console.log(x)), 1000)
    &#125;)
  &#125;)
&#125;, Promise.resolve())
复制代码</code></pre>
<p>或者你可以更简单一点写：</p>
<pre><code>const arr = [1, 2, 3]
arr.reduce((p, x) =&gt; p.then(() =&gt; new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve())
复制代码</code></pre>
<p>参考链接：<a href="https://segmentfault.com/q/1010000010748967">如何让异步操作顺序执行</a></p>
<p><strong>拓展题</strong></p>
<p>这道拓展题来自于“万物皆可爱的<a href="https://juejin.im/user/5cd2341ce51d456e5c5baba3">LINGLONG</a> ”小姐姐，炒鸡棒 😁👍。</p>
<p>题目是这样的，她把我上面👆写的箭头函数版本改造了一下：</p>
<pre><code>const arr = [1, 2, 3];
const result = arr.reduce((p, x) =&gt; p.then(new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve());
复制代码</code></pre>
<p>眼尖的小伙伴看出区别了吗？😁</p>
<p><code>p.then</code>里的代码由<code>() =&gt; new Promise(...)</code>变成了<code>new Promise(...)</code>。</p>
<p>现在执行结果就大不相同了。</p>
<p><strong>在一秒后按顺序同时打印出<code>1、2、3</code>:</strong></p>
<pre><code>1
2
3
复制代码</code></pre>
<p>咦 🤔️？为什么会这样呢 🤔️？</p>
<p>只是一个小小的改变却有大大的区别。</p>
<p>其实刚开始看到的时候霖呆呆我也愣了那么几秒😂。不过等我们一步一步拆分并对想不通的地方写了几个案例来看就理解了。</p>
<p>评论区和小姐姐扯了一大堆，结果把她越弄越糊😂。后来我改变了一种思路来描述，觉得应该直接上伪代码：</p>
<pre><code>const arr = [1, 2, 3]
arr.reduce((p, x) =&gt; p.then(() =&gt; new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve())
复制代码</code></pre>
<p>转换为伪代码就是这样：</p>
<p>(相当于是用<code>reduce</code>不停的往后面叠加<code>.then</code>)</p>
<pre><code>Promise.resolve()
  .then(() =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; &#123;
        r(console.log(1))
      &#125;, 1000)
    &#125;)
  &#125;)
  .then(r =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; &#123;
        r(console.log(2))
      &#125;, 1000)
    &#125;)
  &#125;)
  .then(r =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; &#123;
        r(console.log(3))
      &#125;, 1000)
    &#125;)
  &#125;)
复制代码</code></pre>
<p>可以看到，每一个<code>.then</code>都是依赖于上一个<code>new Promise</code>何时被<code>resolve</code>了才会执行的，例如第二个<code>.then()</code>，它要等<code>r(console.log(1)</code>这段代码执行了，才会执行。</p>
<p>那么<code>r(console.log(1))</code>什么时候执行呢？就是在第一个定时器(也就是一秒后)触发的时候才执行。这样就保证了后面接着的<code>.then()</code>要等前一个定时器执行完才能执行，也就是隔一秒输出。</p>
<p>而如果是这样写的话：</p>
<pre><code>const arr = [1, 2, 3];
const result = arr.reduce((p, x) =&gt; p.then(new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve());
复制代码</code></pre>
<p>它的伪代码就是这样：</p>
<p>(每个<code>then</code>里面的第一个参数不是一个函数)</p>
<pre><code>Promise.resolve()
  .then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(1))
    &#125;, 1000)
  &#125;))
  .then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(2))
    &#125;, 1000)
  &#125;))
  .then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(3))
    &#125;, 1000)
  &#125;))
复制代码</code></pre>
<p><code>p.then()</code>里面的参数如果不是函数的话，会发生透传，这个在<code>3.8</code>中已经提过了。但是发生透传，<code>.then()</code>里的代码就不执行了吗？</p>
<p>并不是的，我们来看这个例子：</p>
<pre><code>const p = Promise.resolve(1).then(console.log(&#39;我不关心结果&#39;))
console.log(p)
p.then((res) =&gt; console.log(res))
复制代码</code></pre>
<p>很明显这里也发生了透传，但是<code>&#39;我不关心结果&#39;</code>也还是被打印出来了，并且由于透传，<code>p.then()</code>里获取到的<code>res</code>就是<code>1</code>，因此会打印出：</p>
<pre><code>&#39;我不关心结果&#39;
Promise&#123;
[[PromiseStatus]]: &quot;resolved&quot;
[[PromiseValue]]: 1
&#125;
1
复制代码</code></pre>
<p>(第二行打印出<code>Promise&#123;&lt;pending&gt;&#125;</code>的小伙伴请把这个对象展开来看)</p>
<p>这个例子表明，就算发生了透传，<code>p.then()</code>中的代码依旧也是会执行的。</p>
<p>所以回到</p>
<pre><code>.then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(1))
    &#125;, 1000)
  &#125;))
复制代码</code></pre>
<p>中，现在<code>.then()</code>中就相当于是执行一段同步代码：</p>
<pre><code>new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(1))
    &#125;, 1000)
  &#125;)
复制代码</code></pre>
<p>而这段代码的作用是向延迟队列中<code>push</code>一个一秒后执行的定时器任务。</p>
<p>并且在<code>push</code>完定时器之后，代码就马上进入了下一个<code>.then</code>(因为既然第一个<code>.then</code>已经是透传的了就没有必要等它的执行结果了)</p>
<p>下一个<code>.then</code>竟然也是一个透传，OK，那我继续<code>push</code>这个定时器，然后再执行第三个<code>.then</code>。</p>
<p>三个<code>.then</code>已经执行完成了，现在我们的延迟队列中已经有了三个定时器等待执行，**并且三个定时器的延迟时间都是1000ms!!!**。</p>
<p>所以等到了时间之后，就会同时打印出来了<code>1、2、3</code>。（其实准确来说，不是同时打印的，不过中间相差的时间非常非常短，大可忽略它）</p>
<p>现在你是否理解了其中的区别呢 😝。</p>
<h4 id="8-2-使用Promise实现红绿灯交替重复亮"><a href="#8-2-使用Promise实现红绿灯交替重复亮" class="headerlink" title="8.2 使用Promise实现红绿灯交替重复亮"></a>8.2 使用Promise实现红绿灯交替重复亮</h4><p>红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：</p>
<pre><code>function red() &#123;
    console.log(&#39;red&#39;);
&#125;
function green() &#123;
    console.log(&#39;green&#39;);
&#125;
function yellow() &#123;
    console.log(&#39;yellow&#39;);
&#125;
复制代码</code></pre>
<p>答案：</p>
<pre><code>function red() &#123;
  console.log(&quot;red&quot;);
&#125;
function green() &#123;
  console.log(&quot;green&quot;);
&#125;
function yellow() &#123;
  console.log(&quot;yellow&quot;);
&#125;
const light = function (timer, cb) &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(() =&gt; &#123;
      cb()
      resolve()
    &#125;, timer)
  &#125;)
&#125;
const step = function () &#123;
  Promise.resolve().then(() =&gt; &#123;
    return light(3000, red)
  &#125;).then(() =&gt; &#123;
    return light(2000, green)
  &#125;).then(() =&gt; &#123;
    return light(1000, yellow)
  &#125;).then(() =&gt; &#123;
    return step()
  &#125;)
&#125;

step();
复制代码</code></pre>
<h4 id="8-3-实现mergePromise函数"><a href="#8-3-实现mergePromise函数" class="headerlink" title="8.3 实现mergePromise函数"></a>8.3 实现mergePromise函数</h4><p>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。</p>
<pre><code>const time = (timer) =&gt; &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(() =&gt; &#123;
      resolve()
    &#125;, timer)
  &#125;)
&#125;
const ajax1 = () =&gt; time(2000).then(() =&gt; &#123;
  console.log(1);
  return 1
&#125;)
const ajax2 = () =&gt; time(1000).then(() =&gt; &#123;
  console.log(2);
  return 2
&#125;)
const ajax3 = () =&gt; time(1000).then(() =&gt; &#123;
  console.log(3);
  return 3
&#125;)

function mergePromise () &#123;
  // 在这里写代码
&#125;

mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; &#123;
  console.log(&quot;done&quot;);
  console.log(data); // data 为 [1, 2, 3]
&#125;);

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]
复制代码</code></pre>
<p>这道题有点类似于<code>Promise.all()</code>，不过<code>.all()</code>不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。</p>
<p>解题思路：</p>
<ul>
<li>定义一个数组<code>data</code>用于保存所有异步操作的结果</li>
<li>初始化一个<code>const promise = Promise.resolve()</code>，然后循环遍历数组，在<code>promise</code>后面添加执行<code>ajax</code>任务，同时要将添加的结果重新赋值到<code>promise</code>上。</li>
</ul>
<p>答案：</p>
<pre><code>function mergePromise (ajaxArray) &#123;
  // 存放每个ajax的结果
  const data = [];
  let promise = Promise.resolve();
  ajaxArray.forEach(ajax =&gt; &#123;
   // 第一次的then为了用来调用ajax
   // 第二次的then是为了获取ajax的结果
    promise = promise.then(ajax).then(res =&gt; &#123;
      data.push(res);
      return data; // 把每次的结果返回
    &#125;)
  &#125;)
  // 最后得到的promise它的值就是data
  return promise;
&#125;
复制代码</code></pre>
<h4 id="8-4-根据promiseA-实现一个自己的promise"><a href="#8-4-根据promiseA-实现一个自己的promise" class="headerlink" title="8.4 根据promiseA+实现一个自己的promise"></a>8.4 根据promiseA+实现一个自己的promise</h4><p>说真的，这道题被问到的概率还是挺高的，而且要说的内容也很多…</p>
<p>霖呆呆这里偷个懒，不想细说了…</p>
<p>不过哈，我保证，下下题我一定仔细说 😼.</p>
<p>![](<a href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="440" height="440"></svg>)</p>
<p>来吧，给你们一些好的宝典：</p>
<ul>
<li>[《Promise不会？？看这里！！！史上最通俗易懂的Promise！！！》](<a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b">https://juejin.im/post/5afe6d3bf265da0b9e654c4b</a> rel=)</li>
<li><a href="https://zhuanlan.zhihu.com/p/23312442">《写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise》</a></li>
</ul>
<h4 id="8-5-封装一个异步加载图片的方法"><a href="#8-5-封装一个异步加载图片的方法" class="headerlink" title="8.5 封装一个异步加载图片的方法"></a>8.5 封装一个异步加载图片的方法</h4><p>这个相对简单一些，只需要在图片的<code>onload</code>函数中，使用<code>resolve</code>返回一下就可以了。</p>
<p>来看看具体代码：</p>
<pre><code>function loadImg(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    const img = new Image();
    img.onload = function() &#123;
      console.log(&quot;一张图片加载完成&quot;);
      resolve(img);
    &#125;;
    img.onerror = function() &#123;
     reject(new Error(&#39;Could not load image at&#39; + url));
    &#125;;
    img.src = url;
  &#125;);
复制代码</code></pre>
<h4 id="8-6-限制异步操作的并发个数并尽可能快的完成全部"><a href="#8-6-限制异步操作的并发个数并尽可能快的完成全部" class="headerlink" title="8.6 限制异步操作的并发个数并尽可能快的完成全部"></a>8.6 限制异步操作的并发个数并尽可能快的完成全部</h4><p>有8个图片资源的url，已经存储在数组<code>urls</code>中。</p>
<p><code>urls</code>类似于<code>[&#39;https://image1.png&#39;, &#39;https://image2.png&#39;, ....]</code></p>
<p>而且已经有一个函数<code>function loadImg</code>，输入一个<code>url</code>链接，返回一个<code>Promise</code>，该<code>Promise</code>在图片下载完成的时候<code>resolve</code>，下载失败则<code>reject</code>。</p>
<p>但有一个要求，任何时刻同时下载的链接<strong>数量不可以超过3个</strong>。</p>
<p>请写一段代码实现这个需求，要求<strong>尽可能快速</strong>地将所有图片下载完成。</p>
<pre><code>var urls = [
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;,
];
function loadImg(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    const img = new Image();
    img.onload = function() &#123;
      console.log(&quot;一张图片加载完成&quot;);
      resolve(img);
    &#125;;
    img.onerror = function() &#123;
     reject(new Error(&#39;Could not load image at&#39; + url));
    &#125;;
    img.src = url;
  &#125;);
复制代码</code></pre>
<p>看到这道题时，我最开始的想法是：</p>
<ul>
<li>拿到<code>urls</code>，然后将这个数组每3个<code>url</code>一组创建成一个二维数组</li>
<li>然后用<code>Promise.all()</code>每次加载一组<code>url</code>（也就是并发3个），这一组加载完再加载下一组。</li>
</ul>
<p>这个想法从技术上说并不难实现，有点类似于第三题。不过缺点也明显，那就是每次都要等到上一组全部加载完之后，才加载下一组，那如果上一组有<code>2</code>个已经加载完了，还有<code>1</code>个特别慢，还在加载，要等这个慢的也加载完才能进入下一组。这明显会照常卡顿，影响加载效率。</p>
<p>但是开始没有考虑这么多，因此有了第一个版本。</p>
<p><strong>如果你有兴趣可以看看想法一的代码，虽然对你没什么帮助，想直接知道比较好的做法的小伙伴请跳到想法二</strong></p>
<p>![](<a href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="320" height="259"></svg>)</p>
<p><strong>想法一</strong>💡：</p>
<pre><code>function limitLoad (urls, handler, limit) &#123;
  const data = []; // 存储所有的加载结果
  let p = Promise.resolve();
  const handleUrls = (urls) =&gt; &#123; // 这个函数是为了生成3个url为一组的二维数组
    const doubleDim = [];
    const len = Math.ceil(urls.length / limit); // Math.ceil(8 / 3) = 3
    console.log(len) // 3, 表示二维数组的长度为3
    for (let i = 0; i &lt; len; i++) &#123;
      doubleDim.push(urls.slice(i * limit, (i + 1) * limit))
    &#125;
    return doubleDim;
  &#125;
  const ajaxImage = (urlCollect) =&gt; &#123; // 将一组字符串url 转换为一个加载图片的数组
    console.log(urlCollect)
    return urlCollect.map(url =&gt; handler(url))
  &#125;
  const doubleDim = handleUrls(urls); // 得到3个url为一组的二维数组
  doubleDim.forEach(urlCollect =&gt; &#123;
    p = p.then(() =&gt; Promise.all(ajaxImage(urlCollect))).then(res =&gt; &#123;
      data.push(...res); // 将每次的结果展开，并存储到data中 (res为：[img, img, img])
      return data;
    &#125;)
  &#125;)
  return p;
&#125;
limitLoad(urls, loadImg, 3).then(res =&gt; &#123;
  console.log(res); // 最终得到的是长度为8的img数组: [img, img, img, ...]
  res.forEach(img =&gt; &#123;
    document.body.appendChild(img);
  &#125;)
&#125;);
复制代码</code></pre>
<p><strong>想法二</strong>💡：</p>
<p>参考<a href="https://www.jianshu.com/p/4bb1521343ba">LHH大翰仔仔-Promise面试题</a></p>
<p>既然题目的要求是保证每次并发请求的数量为3，那么我们可以先请求<code>urls</code>中的前面三个(下标为<code>0,1,2</code>)，并且请求的时候使用<code>Promise.race()</code>来同时请求，三个中有一个先完成了(例如下标为<code>1</code>的图片)，我们就把这个当前数组中已经完成的那一项(第<code>1</code>项)换成还没有请求的那一项(<code>urls</code>中下标为<code>3</code>)。</p>
<p>直到<code>urls</code>已经遍历完了，然后将最后三个没有完成的请求(也就是状态没有改变的<code>Promise</code>)用<code>Promise.all()</code>来加载它们。</p>
<p>不多说，流程图都给你画好了，你可以结合流程图再来看代码。</p>
<p>为了方便你查看，我截了个图，不过代码在后面也有</p>
<p>(说真的，要我看这一大长串代码我也不愿意…)</p>
<p>代码：</p>
<pre><code>function limitLoad(urls, handler, limit) &#123;
  let sequence = [].concat(urls); // 复制urls
  // 这一步是为了初始化 promises 这个&quot;容器&quot;
  let promises = sequence.splice(0, limit).map((url, index) =&gt; &#123;
    return handler(url).then(() =&gt; &#123;
      // 返回下标是为了知道数组中是哪一项最先完成
      return index;
    &#125;);
  &#125;);
  // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用
  return sequence
    .reduce((pCollect, url) =&gt; &#123;
      return pCollect
        .then(() =&gt; &#123;
          return Promise.race(promises); // 返回已经完成的下标
        &#125;)
        .then(fastestIndex =&gt; &#123; // 获取到已经完成的下标
         // 将&quot;容器&quot;内已经完成的那一项替换
          promises[fastestIndex] = handler(url).then(
            () =&gt; &#123;
              return fastestIndex; // 要继续将这个下标返回，以便下一次变量
            &#125;
          );
        &#125;)
        .catch(err =&gt; &#123;
          console.error(err);
        &#125;);
    &#125;, Promise.resolve()) // 初始化传入
    .then(() =&gt; &#123; // 最后三个用.all来调用
      return Promise.all(promises);
    &#125;);
&#125;
limitLoad(urls, loadImg, 3)
  .then(res =&gt; &#123;
    console.log(&quot;图片全部加载完毕&quot;);
    console.log(res);
  &#125;)
  .catch(err =&gt; &#123;
    console.error(err);
  &#125;);
复制代码</code></pre>
<h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_37719279/article/details/80950713">《ES6之Promise常见面试题》</a></li>
<li><a href="https://segmentfault.com/q/1010000010748967">《如何让异步操作顺序执行》</a></li>
<li><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html">《大白话讲解Promise（一）</a></li>
<li><a href="https://www.jianshu.com/p/4bb1521343ba">《LHH大翰仔仔-Promise面试题》</a></li>
<li><a href="https://blog.csdn.net/guolinengineer/article/details/85067924">《今日头条async/await面试题执行顺序》</a></li>
<li><a href="https://juejin.im/post/5dd8b3a851882572f56b578f">《(2.4w字,建议收藏)😇原生JS灵魂之问(下), 冲刺🚀进阶最后一公里(附个人成长经验分享)》</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Webpack 基础教程</title>
    <url>/posts/Webpack-%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<blockquote>
<p>慢慢来 其实比较快<br> 学习尽量做到知其然知其所以然</p>
</blockquote>
<ul>
<li><a href="http://jspang.com/post/webpack4x.html">视频教程来源</a><br>这篇笔记是jspang教程的学习笔记</li>
</ul>
<h2 id="第01节：认识WebPack的作用"><a href="#第01节：认识WebPack的作用" class="headerlink" title="第01节：认识WebPack的作用"></a>第01节：认识WebPack的作用</h2><h2 id="什么是WebPack"><a href="#什么是WebPack" class="headerlink" title="什么是WebPack"></a>什么是WebPack</h2><blockquote>
<p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在4.0出现后，Webpack还肩负起了优化项目的责任。</p>
</blockquote>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol>
<li>打包：可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。</li>
<li>转换：把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。</li>
<li>优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。</li>
</ol>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>必须先安装node(node -v来查看node安装情况和版本)</p>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>webpack官方<strong>不推荐全局安装</strong>。这会将您项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g webpack</span><br></pre></td></tr></table></figure>

<h3 id="对项目目录进行安装"><a href="#对项目目录进行安装" class="headerlink" title="对项目目录进行安装"></a>对项目目录进行安装</h3><ol>
<li>先对项目进行初始化</li>
<li>然后在项目目录中进行安装</li>
<li>用webpack -v 查看版本</li>
</ol>
<blockquote>
<p>–save 保存到package.json文件中<br>  dev 保存到开发环境中而生产环境中不使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line"></span><br><span class="line">npm install --save-dev webpack webpack-cli</span><br><span class="line">npm install --D webpack webpack-cli</span><br><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line">npm install webpack@4.16.5</span><br></pre></td></tr></table></figure>

<p>查看webpack版本<br><code>npx webpack -v</code></p>
<h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><p>解决的主要问题就是调用项目内部安装的模块,还能避免全局安装的模块</p>
<p>npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。</p>
<p>由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</p>
<p>4.39.3</p>
<h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><p><strong>开发环境and生产环境：</strong></p>
<blockquote>
<p>开发环境：在开发时需要的环境，这里指在开发时需要依赖的包。<br>生产环境：程序开发完成，开始运行后的环境，这里指要使项目运行，所需要的依赖包。</p>
</blockquote>
<h2 id="第二节-快速上手一个Demo"><a href="#第二节-快速上手一个Demo" class="headerlink" title="第二节 快速上手一个Demo"></a>第二节 快速上手一个Demo</h2><h2 id="建立基本项目结构"><a href="#建立基本项目结构" class="headerlink" title="建立基本项目结构"></a>建立基本项目结构</h2><p>创建一个项目目录，进入后在根目录建立两个文件夹，分别是src文件夹和dist文件夹：</p>
<blockquote>
<p>src文件夹：用来存放我们编写的javascript代码(源代码)<br>dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包成的文件。</p>
</blockquote>
<ol>
<li><p>在dist中新建index.html</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack tutorials<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在src中新建entry.js</p>
</li>
</ol>
<p>src/entery.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;title&#x27;</span>).innerHTML=<span class="string">&#x27;Hello Webpack&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个文件的代码很简单，就是在&lt;div id=”title”&gt;&lt;/div&gt;标签里写入Hello Webpack这句话。</p>
</blockquote>
<h3 id="第一次Webpack打包"><a href="#第一次Webpack打包" class="headerlink" title="第一次Webpack打包"></a>第一次Webpack打包</h3><p>在终端中用命令行打包。 语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">webpack &#123;entry file&#125; &#123;destination <span class="keyword">for</span> bundled file&#125;</span><br></pre></td></tr></table></figure>

<p>在这个项目中，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack src/entry.js dist/bundle.js</span><br></pre></td></tr></table></figure>

<p>执行成功后，会在dist文件夹中出现bundle.js,用浏览器查看index.html可以查看效果</p>
<h2 id="总结-第2节"><a href="#总结-第2节" class="headerlink" title="总结-第2节"></a>总结-第2节</h2><p>从这个Demo中你会了解到webpack的基本用法和使用过程，</p>
<p>并学会了命令行打包的方法。</p>
<p>在这节文章的最后，还是要强调，你一定要把本节内容在自己的电脑上敲一遍，这样你才能深入了解。</p>
<h2 id="在浏览器中用live-server访问文件"><a href="#在浏览器中用live-server访问文件" class="headerlink" title="在浏览器中用live-server访问文件"></a>在浏览器中用live-server访问文件</h2><h3 id="用命令行"><a href="#用命令行" class="headerlink" title="用命令行"></a>用命令行</h3><ol>
<li><p>安装live-server</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g live-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该项目中用命令行</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">live-server</span><br></pre></td></tr></table></figure>

<p>即可在浏览器中访问文件</p>
<h3 id="用webpack的scripts命令封装"><a href="#用webpack的scripts命令封装" class="headerlink" title="用webpack的scripts命令封装"></a>用webpack的scripts命令封装</h3><ol>
<li><p>在package.json的scripts中</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;server&quot;: &quot;live-server ./ --port=9090&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run server</span><br></pre></td></tr></table></figure>

<h2 id="第03节：配置文件：入口和出口"><a href="#第03节：配置文件：入口和出口" class="headerlink" title="第03节：配置文件：入口和出口"></a>第03节：配置文件：入口和出口</h2><p>这节课我们就学习配置文件的大体结构和入口出口文件的配置。</p>
<h2 id="配置文件webpack-config-js"><a href="#配置文件webpack-config-js" class="headerlink" title="配置文件webpack.config.js"></a>配置文件webpack.config.js</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 出口文件的配置项</span></span><br><span class="line">    output: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 模块,例如编译css,js,转换图片，压缩，合并</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 插件，用于生产模板和各项功能</span></span><br><span class="line">    plugins: [],</span><br><span class="line">    <span class="comment">// 配置webpack开发服务功能</span></span><br><span class="line">    devServer: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>entry：配置入口文件的地址，可以是单一入口，也可以是多入口。<br>output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。<br>module：配置模块，主要是解析CSS和图片转换压缩等功能。<br>plugins：配置插件，根据你的需要配置不同功能的插件。<br>devServer：配置开发服务功能。</p>
</blockquote>
<h2 id="entry选项（入口配置）"><a href="#entry选项（入口配置）" class="headerlink" title="entry选项（入口配置）"></a>entry选项（入口配置）</h2><p>配置要压缩的文件。一般是JavaScript，也可以是CSS文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口文件配置</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    <span class="comment">// 里面的entry可以随便起名字，外面的是固定的</span></span><br><span class="line">    entry: <span class="string">&#x27;./src/entry.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="output-出口配置"><a href="#output-出口配置" class="headerlink" title="output(出口配置)"></a>output(出口配置)</h2><p>配置webpack最后打包文件的地址和名称。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出口文件配置</span></span><br><span class="line">output: &#123;</span><br><span class="line">    <span class="comment">// 打包的文件位置</span></span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">    <span class="comment">// 打包的文件名称</span></span><br><span class="line">    filename: &#x27;bundle.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在webpack.config.js头部引入path</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>path.resolve(__dirname, ‘dist’) 获取项目的绝对路径<br>filename: 打包后的文件名称。</p>
</blockquote>
<h3 id="webpack单文件入口配置代码"><a href="#webpack单文件入口配置代码" class="headerlink" title="webpack单文件入口配置代码"></a>webpack单文件入口配置代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    entry: <span class="string">&#x27;./src/entry.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 出口文件的配置项</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 模块,例如编译css,js,转换图片，压缩，合并</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 插件，用于生产模板和各项功能</span></span><br><span class="line">    plugins: [],</span><br><span class="line">    <span class="comment">// 配置webpack开发服务功能</span></span><br><span class="line">    devServer: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后，在终端直接输入webpack就会打包</p>
<h2 id="多入口、多出口配置"><a href="#多入口、多出口配置" class="headerlink" title="多入口、多出口配置"></a>多入口、多出口配置</h2><p>在entry配置多个文件，</p>
<p>在output处配置文件名为动态的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        entry: <span class="string">&#x27;./src/entry.js&#x27;</span>,</span><br><span class="line">        entry2: <span class="string">&#x27;./src/entry2.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 出口文件的配置项</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">// 输出的路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        publicPath: <span class="string">&#x27;http://www.cdn.com/assets/&#x27;</span>,</span><br><span class="line">        <span class="comment">// 输出文件的名称</span></span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 模块,例如编译css,js,转换图片，压缩，合并</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 插件，用于生产模板和各项功能</span></span><br><span class="line">    plugins: [],</span><br><span class="line">    <span class="comment">// 配置webpack开发服务功能</span></span><br><span class="line">    devServer: &#123;&#125;,</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[mode]: webpack中新增的配置，分为开发，线上。可以在命令行后面添加如: <code>webpack --mode=development</code><br>[publicPath]: 自动将cdn路径添加到代码里的资源链接上<br>[plugin]: 可以在webpack运行到某个时刻时，帮你做一些事情<br>[name]： 根据入口文件的名称，打包成相同的名称，有几个入口文件，就打包成几个文件。</p>
<h2 id="总结-第3节"><a href="#总结-第3节" class="headerlink" title="总结-第3节"></a>总结-第3节</h2><p>任何项目的webpack都要执行这些操作。需要牢记</p>
<blockquote>
<p>小知识</p>
</blockquote>
<ol>
<li>调试js文件</li>
</ol>
<p>在js中写console.log()</p>
<p>直接在命令行</p>
<p>node index.js，</p>
<p>即可在终端查看打印内容</p>
<h2 id="第4节：-配置文件：服务和热更新"><a href="#第4节：-配置文件：服务和热更新" class="headerlink" title="第4节： 配置文件：服务和热更新"></a>第4节： 配置文件：服务和热更新</h2><p>热更新：所见即所得</p>
<h2 id="设置webpack-dev-server"><a href="#设置webpack-dev-server" class="headerlink" title="设置webpack-dev-server"></a>设置webpack-dev-server</h2><ol>
<li>先安装webpack-dev-server</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>

<ol>
<li>配置devServer</li>
</ol>
<p>webpack.config.js</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    <span class="comment">// 设置基本目录结构</span></span><br><span class="line">    contentBase: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">    <span class="comment">// 服务器的IP地址，可以是IP也可以是localhost</span></span><br><span class="line">    host: &#x27;localhost&#x27;,</span><br><span class="line">    <span class="comment">// 服务端压缩是否开启</span></span><br><span class="line">    compress: true,</span><br><span class="line">    <span class="comment">// 配置服务端口</span></span><br><span class="line">    port: 8089,</span><br><span class="line">    <span class="comment">// 默认打开浏览器，可以用字符串代替用哪个浏览器打开. &#x27;Google Chrome&#x27;, 可以代替--open</span></span><br><span class="line">    open: true,</span><br><span class="line">    <span class="comment">// 路由代理打到前端框架</span></span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    <span class="comment">// 开启hotModuleReplace</span></span><br><span class="line">    hot: true,</span><br><span class="line">    <span class="comment">// 如果打包报错，直接在页面上展示错误，而不是在终端展示错误</span></span><br><span class="line">    overlay: true,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>配置scripts</li>
</ol>
<p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="在这里直接设置-–open即可自动打开浏览器"><a href="#在这里直接设置-–open即可自动打开浏览器" class="headerlink" title="在这里直接设置 –open即可自动打开浏览器"></a>在这里直接设置 –open即可自动打开浏览器</h3><ol>
<li>在终端里输入npm run server 打开服务器，在浏览器中输入<a href="http://localhost:8089/">http://localhost:8089</a>即可看到结果</li>
</ol>
<h3 id="historyApiFallback"><a href="#historyApiFallback" class="headerlink" title="historyApiFallback"></a>historyApiFallback</h3><p>webpack不配置这个的话，正常的react请求会直接请求到服务端，不会走react内部的路由</p>
<p><a href="https://www.webpackjs.com/configuration/dev-server/#devserver-historyapifallback">historyApiFallback</a>就是解决这个问题</p>
<p>TODO<br>到了线上要配置NGINX，让路由打到项目里</p>
<h2 id="支持热更新"><a href="#支持热更新" class="headerlink" title="支持热更新"></a>支持热更新</h2><p>npm run server 启动后，有一种监控机制(watch), 监控修改源码，并立即在浏览器里更新。</p>
<p><strong>注意</strong>：webpack 3.6版本以后内置热更新功能，不需要额外操作。</p>
<p>proxy设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">&#x27;/react/api&#x27;</span>: <span class="string">&#x27;http://www.dell-lee.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/react/api&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;http://www.dell-lee.com&#x27;</span></span><br><span class="line">        <span class="comment">// https接口需要配置这个</span></span><br><span class="line">        secure: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 解决某些网站对源限制</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 在配置里请求转发，代码里请求header.json，实际去请求demo.json，省去修改代码里接口的麻烦</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">            <span class="string">&#x27;header.json&#x27;</span>: <span class="string">&#x27;demo.json&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第5节：-模块：CSS文件打包"><a href="#第5节：-模块：CSS文件打包" class="headerlink" title="第5节： 模块：CSS文件打包"></a>第5节： 模块：CSS文件打包</h2><p>webpack在生产环境中的作用之一：减少http请求数，把多个文件打包到一个js文件中，请求数可以减少好多。</p>
<p>学习css文件打包之前，<strong>需要先对webpack.config.js里的Loaders配置项进行了解</strong>。</p>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>Loaders是Webpack最重要的功能之一，也是如此盛行的原因。</p>
<p>通过配置不同的Loaders，Webpack可以用脚本和工具对不同的文件格式进行特定的处理。</p>
<p>例子：</p>
<blockquote>
<p>可以把less, sass转换成css,而不使用其他工具<br> 写代码时，可以用ES6, ES7语法，转换成大多数浏览器兼容的代码<br> 可以把React中的jsx转换成JavaScript代码</p>
</blockquote>
<p><strong>注意：</strong><br>所有Loaders都要在npm中单独安装，并在webpack.config.js中配置，下面对几种配置型简单梳理。</p>
<blockquote>
<p>test: 用于匹配处理文件扩展名的表达式，【必须设置】；<br> use: loader名称，【必须配置，否则报错】；<br> include/exclude: 手动添加必须处理的文件/文件夹，或屏蔽不需要处理的文件/文件夹,【可选】；<br> query: 为loaders提供额外的设置选项，【可选】。</p>
</blockquote>
<h2 id="打包CSS文件"><a href="#打包CSS文件" class="headerlink" title="打包CSS文件"></a>打包CSS文件</h2><h3 id="建立index-css文件"><a href="#建立index-css文件" class="headerlink" title="建立index.css文件"></a>建立index.css文件</h3><p>在src/css 目录下，建一个index.css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>css 文件建立好后，需要引入到入口文件中，才可以打包到dist中。</p>
<p>这里引入到entry.js中</p>
<p>src/entry.js首行加入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">&#x27;./css/index.css&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="这里行末一定要加分号，没加就无法编译CSS文件报错"><a href="#这里行末一定要加分号，没加就无法编译CSS文件报错" class="headerlink" title="这里行末一定要加分号，没加就无法编译CSS文件报错"></a>这里行末一定要加分号，没加就无法编译CSS文件报错</h3><p>CSS 引入后，需要使用loader来解析CSS文件，这里用到style-loader,css-loader.</p>
<h3 id="style-loader-官网"><a href="#style-loader-官网" class="headerlink" title="style-loader 官网"></a>style-loader <a href="https://www.npmjs.com/package/style-loader">官网</a></h3><p>用来处理css文件中的url()等。</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install style-loader --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="css-loader-官网"><a href="#css-loader-官网" class="headerlink" title="css-loader 官网"></a>css-loader <a href="https://www.npmjs.com/package/css-loader">官网</a></h3><p>用来将css插入到页面的style标签。<br>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install css-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>两个都安装好后，开始配置loaders</p>
<h3 id="loaders配置"><a href="#loaders配置" class="headerlink" title="loaders配置"></a>loaders配置</h3><p>修改webpack.config.js中的module属性，代码如下：</p>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        importLoaders: <span class="number">2</span>,</span><br><span class="line">                        modules: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><code>modules: true</code> 使用css模块化<br><code>importLoaders</code>: 在 css-loader 前应用的 loader 的数量， 用于在css文件中引入css文件，让loader也去处理引入文件中的样式</p>
<h3 id="loader三种写法"><a href="#loader三种写法" class="headerlink" title="loader三种写法"></a>loader三种写法</h3><ol>
<li><p>直接用use</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把use换成loader</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        loader: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用use+loader</p>
</li>
</ol>
<p>这种最常用，因为每个都有不同的配置项！！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;<span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用哪种写法都可以，可以看出webpack的扩展和灵活性非常强"><a href="#用哪种写法都可以，可以看出webpack的扩展和灵活性非常强" class="headerlink" title="用哪种写法都可以，可以看出webpack的扩展和灵活性非常强"></a>用哪种写法都可以，可以看出webpack的扩展和灵活性非常强</h4><p>最重要的是： 看见别人项目的其他写法也不要慌张，自己试试，有可能Get到新知识。</p>
<h2 id="总结-第5节"><a href="#总结-第5节" class="headerlink" title="总结-第5节"></a>总结-第5节</h2><p>loader的使用决定了webpack水平的高低，一定要重视和练习。</p>
<h2 id="第6节：-插件配置：-配置JS压缩"><a href="#第6节：-插件配置：-配置JS压缩" class="headerlink" title="第6节： 插件配置： 配置JS压缩"></a>第6节： 插件配置： 配置JS压缩</h2><h2 id="压缩JS代码"><a href="#压缩JS代码" class="headerlink" title="压缩JS代码"></a>压缩JS代码</h2><p>引入uglifyjs-webpack-plugin(js压缩插件，简称uglify)</p>
<p>注意： 虽然uglifyjs是插件，但webpack版本已默认集成，不需要再次安装。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在webpack.config.js中引入插件，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>引入后，在plugins配置里new一个uglify对象。代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> uglify()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里执行webpack是可以打包成功的</p>
<h3 id="但是执行npm-run-server时，报错-原因还待查-已找到"><a href="#但是执行npm-run-server时，报错-原因还待查-已找到" class="headerlink" title="但是执行npm run server时，报错,原因还待查     已找到 ***"></a>但是执行npm run server时，报错,原因<del>还待查</del>     已找到 ***</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> entry.js <span class="keyword">from</span> UglifyJs</span><br><span class="line">Unexpected token: name (urlParts) [entry.js:<span class="number">317</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">ERROR <span class="keyword">in</span> entry2.js <span class="keyword">from</span> UglifyJs</span><br><span class="line">Unexpected token: name (urlParts) [entry2.js:<span class="number">317</span>,<span class="number">4</span>]</span><br><span class="line">webpack: Failed to compile.</span><br></pre></td></tr></table></figure>

<p>首先要先弄清楚什么是开发环境， 什么是生产环境。</p>
<p>开发环境基本不会对js进行压缩，在开发预览时，需要明确的报错行数和错误信息，所以没有必要压缩JavaScript代码。</p>
<p>生产环境才会压缩js代码，用于加快程序的工作效率。</p>
<p>devServer用于开发环境，而压缩js用于生产环境，</p>
<p>在开发环境中做生产环境的事情所以<strong>webpack设置冲突报错</strong></p>
<h2 id="第7节：-插件配置：-HTML文件发布"><a href="#第7节：-插件配置：-HTML文件发布" class="headerlink" title="第7节： 插件配置： HTML文件发布"></a>第7节： 插件配置： HTML文件发布</h2><p>之前的index.html是直接放在dist文件夹中的，这是不对的。应该放在src目录中。</p>
<p>这节就学习如何把HTML文件打包到生产路径下。</p>
<h3 id="打包HTML文件"><a href="#打包HTML文件" class="headerlink" title="打包HTML文件"></a>打包HTML文件</h3><p>先将dist中的index.html剪切到src目录中，并去掉js引入代码(webpack会自动引入entry入口配置的js)，</p>
<p>因为这才是真实工作的目录结构。</p>
<h3 id="npm安装html-webpack-plugin-官网"><a href="#npm安装html-webpack-plugin-官网" class="headerlink" title="npm安装html-webpack-plugin 官网"></a>npm安装html-webpack-plugin <a href="https://www.npmjs.com/package/html-webpack-plugin">官网</a></h3><p>htmlWebpackPlugin会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个HTML文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>

<h3 id="配置webpack-config-js"><a href="#配置webpack-config-js" class="headerlink" title="配置webpack.config.js"></a>配置webpack.config.js</h3><p>引入html-webpack-plugin插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="在plugins里进行插件的配置，代码如下"><a href="#在plugins里进行插件的配置，代码如下" class="headerlink" title="在plugins里进行插件的配置，代码如下"></a>在plugins里进行插件的配置，代码如下</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlPlugin(&#123;</span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        hash: <span class="literal">true</span>,</span><br><span class="line">        template: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<blockquote>
<p>minify：是对html文件进行压缩，removeAttrubuteQuotes是去掉属性的双引号。<br> hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。<br> template：是要打包的html模版路径和文件名称。</p>
</blockquote>
<h2 id="打包出错"><a href="#打包出错" class="headerlink" title="打包出错"></a>打包出错</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span>   Error: Parse Error: &lt;!DOCTYPE&gt;</span><br><span class="line">  &lt;html&gt;</span><br></pre></td></tr></table></figure>

<p>原因，html页面的声明，必须是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// <span class="meta">&lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>html文件的打包可以有效的区分开发目录和生产目录，在webpack的配置中也要搞清楚哪些配置用于生产环境，哪些配置用于开发环境，避免两种环境的配置冲突。</p>
<h2 id="第8节：-图片迈坑：-css中的图片处理"><a href="#第8节：-图片迈坑：-css中的图片处理" class="headerlink" title="第8节： 图片迈坑： css中的图片处理"></a>第8节： 图片迈坑： css中的图片处理</h2><p>webpack打包时遇到css中的图片处理坑。</p>
<blockquote>
<p>在开发环境中找得到图片，一打包后就找不到<br>  不知道如何正确引入HTML或CSS中的图片</p>
</blockquote>
<h3 id="3节课彻底走出webpack图片的坑"><a href="#3节课彻底走出webpack图片的坑" class="headerlink" title="3节课彻底走出webpack图片的坑"></a>3节课彻底走出webpack图片的坑</h3><p>找张图片，在src目录新建一个images的文件夹。把图片放入images文件夹。</p>
<p>在index.html中增加一个div，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#img</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/img.png);</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack 直接编译，报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> ./src/images/img.png</span><br><span class="line">Module parse failed: Unexpected character <span class="string">&#x27;�&#x27;</span> (1:0)</span><br><span class="line">You may need an appropriate loader to handle this file <span class="built_in">type</span>.</span><br><span class="line">(Source code omitted <span class="keyword">for</span> this binary file)</span><br></pre></td></tr></table></figure>

<h2 id="file-loader-url-loader"><a href="#file-loader-url-loader" class="headerlink" title="file-loader, url-loader"></a>file-loader, url-loader</h2><h2 id="1-命令行安装"><a href="#1-命令行安装" class="headerlink" title="1. 命令行安装"></a>1. 命令行安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure>

<h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>解决引用路径的问题，拿background样式用url引用背景图来说，webpack会将各个模块打包成一个文件，因此我们源代码样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在路径。这会导致图片引入失败。</p>
<p>这就是file-loader解决的。</p>
<p>file-loader可以解析项目中的url引入(不局限于css), 根据配置，将图片拷贝到相应的路径，再根据配置，打包后文件引用路径，使之指向正确的文件。</p>
<p>打包以后文件名保持不变，加hash值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                name: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">                outputPath: <span class="string">&#x27;images/&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>如果图片较多，会发送很多http请求，降低页面性能。</p>
<p>可以用url-loader解决。</p>
<p>url-loader会将引入的图片编码，生成DataURL(把图片转成一串字符),再把这串字符打包到文件中，最终只要引入这个文件就能访问图片。</p>
<p>图片较大，编码会消耗性能。url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURL,大于limit的会使用file-loader进行copy</p>
<h2 id="2-配置url-loader"><a href="#2-配置url-loader" class="headerlink" title="2. 配置url-loader"></a>2. 配置url-loader</h2><p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|gif)/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">500000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>test:/.(png|jpg|gif)/是匹配图片文件后缀名称。<br> use：是指定使用的loader和loader的配置参数。<br> limit：是把小于500000B的文件打成Base64的格式，写入JS。</p>
</blockquote>
<p>现在就可以使用webpack打包了~~~~</p>
<p>用npm run server ，可以在页面查看元素，查看图片的编码</p>
<h2 id="为什么配置中只用了url-loader"><a href="#为什么配置中只用了url-loader" class="headerlink" title="为什么配置中只用了url-loader"></a>为什么配置中只用了url-loader</h2><p>为什么在配置中只用了url-loader，依然打包成功？</p>
<p>需要了解url-loader和file-loader关系</p>
<p>url-loader封装了file-loader，url-loader不依赖file-loader，即 使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。</p>
<p>url-loader工作分两种情况：</p>
<ol>
<li>文件大小小于limit，url-loader将文件转为DataURL(Base64格式)</li>
<li>文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader</li>
</ol>
<p>也就是说，安装一个url-loader即可，但是为了以后操作方便，顺便安装了file-loader。</p>
<h2 id="总结-第8节"><a href="#总结-第8节" class="headerlink" title="总结-第8节"></a>总结-第8节</h2><p>本节学习了将小图打包成Base64格式， 对webpack图片打包有了基本的了解</p>
<h2 id="第9节-图片迈坑：-CSS分离与图片路径处理"><a href="#第9节-图片迈坑：-CSS分离与图片路径处理" class="headerlink" title="第9节 图片迈坑： CSS分离与图片路径处理"></a>第9节 图片迈坑： CSS分离与图片路径处理</h2><p>主要学习</p>
<ol>
<li>把CSS从JavaScript代码中分离出来，</li>
<li>如何处理分离出来后的CSS中的图片路径不对的问题。</li>
</ol>
<h2 id="CSS分离：-extract-text-webpack-plugin-官网"><a href="#CSS分离：-extract-text-webpack-plugin-官网" class="headerlink" title="CSS分离： extract-text-webpack-plugin 官网"></a>CSS分离： extract-text-webpack-plugin <a href="https://www.npmjs.com/package/extract-text-webpack-plugin">官网</a></h2><p>之前的css是打包到JavaScript代码中的。</p>
<p>有些页面，JavaScript代码很少，而css很多，要求将css单独提取出来，方便以后更改，遇到这种需求，</p>
<p>解决办法就是extract-text-webpack-plugin</p>
<p>这个插件可以完美解决提取CSS的需求。但webpack官网不建议这样做，他们认为css就应该打包到JavaScript中以减少http请求数。</p>
<p>但现实中的需求我们无法控制，有些需求是我们不能控制的，分离css就是这样一个既合理又不合理的需求。</p>
<h3 id="1-npm-安装"><a href="#1-npm-安装" class="headerlink" title="1. npm 安装"></a>1. npm 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure>

<h3 id="2-引入"><a href="#2-引入" class="headerlink" title="2. 引入"></a>2. 引入</h3><p>安装完成后，需要先require引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-设置Plugins"><a href="#3-设置Plugins" class="headerlink" title="3. 设置Plugins"></a>3. 设置Plugins</h3><p>引入成功后，需要在plugins属性中进行配置。这里只要new一下这个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlPlugin(&#123;</span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        hash: <span class="literal">true</span>,</span><br><span class="line">        template: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(<span class="string">&#x27;css/index.css&#x27;</span>)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>这里的/css/index.css是分离后的路径位置。注意： 这里路径前面不要加/,否则引用css的路径，会多一个/</p>
<h3 id="4-修改原来的stye-loader-css-loader"><a href="#4-修改原来的stye-loader-css-loader" class="headerlink" title="4. 修改原来的stye-loader, css-loader"></a>4. 修改原来的stye-loader, css-loader</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                use: <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|gif)/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">500000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>完成4步操作后，可以用webpack打包。</p>
<h3 id="打包结果"><a href="#打包结果" class="headerlink" title="打包结果"></a>打包结果</h3><ul>
<li>css被单独提取到css/index.css文件</li>
<li>图片也被Base64编码到index.css文件</li>
<li>index.html文件中引入了index.css</li>
</ul>
<h2 id="图片路径问题"><a href="#图片路径问题" class="headerlink" title="图片路径问题"></a>图片路径问题</h2><p>利用extract-text-wbpack-plugin 轻松的把css文件分离了出来，但css路径并不正确。</p>
<p>可以在这里先build一下看下效果。图片不会显示</p>
<blockquote>
<p><strong>最好的解决方案，使用publicPath解决</strong></p>
</blockquote>
<p>publicPath: 是在webpack.config.js文件中的output选项中，主要作用就是处理静态文件路径的。</p>
<h3 id="1-处理前，在webpack-config-js上方声明一个对象，叫website"><a href="#1-处理前，在webpack-config-js上方声明一个对象，叫website" class="headerlink" title="1. 处理前，在webpack.config.js上方声明一个对象，叫website"></a>1. 处理前，在webpack.config.js上方声明一个对象，叫website</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 教程里这里写的是IP地址</span></span><br><span class="line"><span class="keyword">const</span> website = &#123;</span><br><span class="line">    publicPath: <span class="string">&#x27;http://localhost:8089/&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的ip和端口是本机的IP或DevServer配置的ip和端口。</p>
<h4 id="后面加-不加-，测试了一下不加-，可以查看css或图片路径，是不正确的"><a href="#后面加-不加-，测试了一下不加-，可以查看css或图片路径，是不正确的" class="headerlink" title="后面加/ 不加/，测试了一下不加/，可以查看css或图片路径，是不正确的"></a>后面加/ 不加/，测试了一下不加/，可以查看css或图片路径，是不正确的</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 错误的</span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">http</span>://<span class="selector-tag">localhost</span><span class="selector-pseudo">:8089images</span>/313455<span class="selector-tag">c00642024bfd21003ced8bf0e6</span><span class="selector-class">.png</span>);</span><br><span class="line">// 正确的</span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">http</span>://<span class="selector-tag">localhost</span><span class="selector-pseudo">:8089</span>/<span class="selector-tag">images</span>/313455<span class="selector-tag">c00642024bfd21003ced8bf0e6</span><span class="selector-class">.png</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-在output选项中引用这个对象的publicPath属性"><a href="#2-在output选项中引用这个对象的publicPath属性" class="headerlink" title="2. 在output选项中引用这个对象的publicPath属性"></a>2. 在output选项中引用这个对象的publicPath属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    <span class="comment">// 输出的路径</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="comment">// 输出文件的名称</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    publicPath: website.publicPath</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="3-用webpack打包"><a href="#3-用webpack打包" class="headerlink" title="3. 用webpack打包"></a>3. 用webpack打包</h3><p>可以看到，文件中的相对路径被替换成绝对路径。这样来讲速度更快。</p>
<h2 id="总结-第9节"><a href="#总结-第9节" class="headerlink" title="总结-第9节"></a>总结-第9节</h2><p>实现了css分离，并处理了分离后图片路径不对的问题。</p>
<p>处理的方法要充分理解，在工作中经常用到。</p>
<h3 id="更改webpack-config-js文件-不会热更新"><a href="#更改webpack-config-js文件-不会热更新" class="headerlink" title="更改webpack.config.js文件 不会热更新"></a>更改webpack.config.js文件 不会热更新</h3><h2 id="第10节：-图片迈坑：-处理HTML中的图片"><a href="#第10节：-图片迈坑：-处理HTML中的图片" class="headerlink" title="第10节： 图片迈坑： 处理HTML中的图片"></a>第10节： 图片迈坑： 处理HTML中的图片</h2><p>在webpack中不推荐使用img来引入图片，但我们通常都用这种写法。为此有人开发了：<br><strong>html-withimg-loader</strong> <a href="https://www.npmjs.com/package/html-withimg-loader">官网</a></p>
<p>可以很好的处理在HTML中引入图片的问题。</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure>

<h3 id="2-配置loader"><a href="#2-配置loader" class="headerlink" title="2. 配置loader"></a>2. 配置loader</h3><p>webpack.config.js</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(html|html)$/i,</span><br><span class="line">    use: [&#x27;html-withimg-loader&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-执行打包"><a href="#3-执行打包" class="headerlink" title="3. 执行打包"></a>3. 执行打包</h3><p>可以发现images被很好的打包了。并且路径也完全正确</p>
<h2 id="总结-第10节"><a href="#总结-第10节" class="headerlink" title="总结-第10节"></a>总结-第10节</h2><p>三节课的时间，讲了webpack图片中的坑，所有问题应该都可以解决了.</p>
<h2 id="小知识-npm-run-build"><a href="#小知识-npm-run-build" class="headerlink" title="小知识 npm run build"></a>小知识 npm run build</h2><h3 id="没有打包npm-run-build，直接npm-run-server-无法看到最新结果"><a href="#没有打包npm-run-build，直接npm-run-server-无法看到最新结果" class="headerlink" title="没有打包npm run build，直接npm run server,无法看到最新结果"></a>没有打包npm run build，直接npm run server,无法看到最新结果</h3><h3 id="只有项目安装了webpack，如何打包"><a href="#只有项目安装了webpack，如何打包" class="headerlink" title="只有项目安装了webpack，如何打包"></a>只有项目安装了webpack，如何打包</h3><p>如果全局没有安装webpack的话，直接在命令行执行webpack会报错。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>在package.json中配置scripts选项，增加一个build命令，进行打包项目使用。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;,</span><br><span class="line">    &quot;build&quot;:&quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>配置完后，在终端输入<strong>npm run build</strong> 即可打包</p>
<h3 id="如何把图片放到指定的文件夹下"><a href="#如何把图片放到指定的文件夹下" class="headerlink" title="如何把图片放到指定的文件夹下"></a>如何把图片放到指定的文件夹下</h3><p>前面打包的图片并没有放到images文件夹下，要放到images里，需配置url-loader ==outputPath==选项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: extractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                use: <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|gif)/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">5000</span>,</span><br><span class="line">                        outputPath: <span class="string">&#x27;images/&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这样再执行打包，图片都被打包到images文件里。</p>
<h2 id="第11节：-CSS-进阶：-Less-文件的打包和分离"><a href="#第11节：-CSS-进阶：-Less-文件的打包和分离" class="headerlink" title="第11节： CSS 进阶： Less 文件的打包和分离"></a>第11节： CSS 进阶： Less 文件的打包和分离</h2><p>第5节中已经讲了CSS打包，分离。这节讲Less文件如何打包和分离。</p>
<p>Less是一门CSS预处理语言，扩展了CSS语言，增加了变量，Mixin，函数等特性，使CSS更易维护和扩展。</p>
<h2 id="打包Less文件"><a href="#打包Less文件" class="headerlink" title="打包Less文件"></a>打包Less文件</h2><h3 id="1-安装-官网"><a href="#1-安装-官网" class="headerlink" title="1. 安装 官网"></a>1. 安装 <a href="https://www.npmjs.com/package/less-loader">官网</a></h3><p>安装less服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less</span><br></pre></td></tr></table></figure>

<p>安装less-loader供打包使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less-loader</span><br></pre></td></tr></table></figure>

<p>也可以一条命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br></pre></td></tr></table></figure>

<h3 id="2-loader配置"><a href="#2-loader配置" class="headerlink" title="2. loader配置"></a>2. loader配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: <span class="string">&quot;style-loader&quot;</span> <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        loader: <span class="string">&quot;less-loader&quot;</span> <span class="comment">// compiles Less to CSS</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-编写一个less文件"><a href="#3-编写一个less文件" class="headerlink" title="3. 编写一个less文件"></a>3. 编写一个less文件</h3><p>css/black.less</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@base: #000;</span><br><span class="line"><span class="selector-id">#gogo</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: @base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-引入到entry-js"><a href="#4-引入到entry-js" class="headerlink" title="4. 引入到entry.js"></a>4. 引入到entry.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> less <span class="keyword">from</span> <span class="string">&#x27;./css/black.less&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以打包看效果<br>发现打包到了entry.js中，没有提取到css文件中</p>
<h2 id="把Less文件分离"><a href="#把Less文件分离" class="headerlink" title="把Less文件分离"></a>把Less文件分离</h2><p>之前讲了extract-text-webpack-plugin插件，分离Less也是用这个</p>
<h3 id="配置less的loader"><a href="#配置less的loader" class="headerlink" title="配置less的loader"></a>配置less的loader</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// use style-loader in development</span></span><br><span class="line">        fallback: <span class="string">&quot;style-loader&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>会看到less被打包到index.css文件中</p>
<p>此外，在官网看到了，修改后缀名的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> extractLess = <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">    filename: <span class="string">&quot;[name].[contenthash].css&quot;</span>,</span><br><span class="line">    disable: process.env.NODE_ENV === <span class="string">&quot;development&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="总结-第11节"><a href="#总结-第11节" class="headerlink" title="总结-第11节"></a>总结-第11节</h2><p>通过这节课， 就可以很轻松的编写less文件啦</p>
<h2 id="第12节：-CSS进阶：-SASS文件的打包和分离-官网"><a href="#第12节：-CSS进阶：-SASS文件的打包和分离-官网" class="headerlink" title="第12节： CSS进阶： SASS文件的打包和分离  官网"></a>第12节： CSS进阶： SASS文件的打包和分离  <a href="https://www.npmjs.com/package/sass-loader">官网</a></h2><p>上节学了less的打包，这节开始学习SASS打包</p>
<h3 id="1-安装两个包node-sass，sass-loader"><a href="#1-安装两个包node-sass，sass-loader" class="headerlink" title="1. 安装两个包node-sass，sass-loader"></a>1. 安装两个包<strong>node-sass，sass-loader</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass webpack --save-dev</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>npm安装时，这个loader很容易安装失败。多次安装失败，最好把node_modules文件夹删除，再重新安装。</p>
<h3 id="2-编写loader配置"><a href="#2-编写loader配置" class="headerlink" title="2. 编写loader配置"></a>2. 编写loader配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: <span class="string">&quot;style-loader&quot;</span> <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        loader: <span class="string">&quot;sass-loader&quot;</span> <span class="comment">// compiles Sass to CSS</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意loader的加载有先后顺序(从下到上，从右到左),可以直接从官网拷贝</p>
<h3 id="3-SASS-文件的编写"><a href="#3-SASS-文件的编写" class="headerlink" title="3.SASS 文件的编写"></a>3.SASS 文件的编写</h3><p>nav.scss,别忘了引入到entry.js中</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nav-color</span>: <span class="number">#FFF</span>;</span><br><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">    <span class="variable">$width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    backround-<span class="attribute">color</span>: <span class="variable">$nav-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sass <span class="keyword">from</span> <span class="string">&#x27;./css/nav.scss&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，可以npm run server 查看效果。</p>
<h3 id="4-把SASS文件分离"><a href="#4-把SASS文件分离" class="headerlink" title="4. 把SASS文件分离"></a>4. 把SASS文件分离</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: <span class="string">&quot;sass-loader&quot;</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// use style-loader in development</span></span><br><span class="line">        fallback: <span class="string">&quot;style-loader&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，可以愉快的写sass代码了。</p>
<h2 id="小知识-D"><a href="#小知识-D" class="headerlink" title="小知识-D"></a>小知识-D</h2><p>-D 等于–save-dev</p>
<h2 id="第13节：CSS进阶：-自动处理CSS3属性前缀"><a href="#第13节：CSS进阶：-自动处理CSS3属性前缀" class="headerlink" title="第13节：CSS进阶： 自动处理CSS3属性前缀"></a>第13节：CSS进阶： 自动处理CSS3属性前缀</h2><p>css3属性不同浏览器对应的前缀名称不同，太多的话代码冗余工作繁杂。</p>
<p>这节学习如何用postcss-loader给css3属性自动添加前缀。</p>
<h2 id="什么是属性前缀"><a href="#什么是属性前缀" class="headerlink" title="什么是属性前缀"></a>什么是属性前缀</h2><p>CSS 属性前的-webkit,-ms,-moz这些前缀。为了兼容各个浏览器版本。</p>
<h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><p>css的处理平台，可以实现css的很多功能，这里只介绍一个加前缀的功能。</p>
<h3 id="1-安装-1"><a href="#1-安装-1" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>需要安装两个包postcss-loader， autoprefixer(自动添加前缀的插件)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure>

<h3 id="2-postcss-config-js"><a href="#2-postcss-config-js" class="headerlink" title="2. postcss.config.js"></a>2. postcss.config.js</h3><p>PostCSS推荐在项目根目录(和webpack.config.js同级)，建一个postcss.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入了autoprefixer插件，让postCSS拥有添加前缀的能力。</p>
<h3 id="3-编写loader"><a href="#3-编写loader" class="headerlink" title="3. 编写loader"></a>3. 编写loader</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">&quot;style-loader&quot;</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                 modules: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">              loader: <span class="string">&quot;postcss-loader&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这里是提取css的loader配置"><a href="#这里是提取css的loader配置" class="headerlink" title="这里是提取css的loader配置"></a>这里是提取css的loader配置</h4><p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>, <span class="attr">options</span>: &#123; <span class="attr">importLoaders</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">            <span class="string">&#x27;postcss-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="5-在index-css中添加css样式"><a href="#5-在index-css中添加css样式" class="headerlink" title="5. 在index.css中添加css样式"></a>5. 在index.css中添加css样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#img</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../images/img.png);</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">25</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包，运行可以看到新加的样式都加上了前缀。</p>
<h2 id="第14节：-CSS进阶：-消除未使用的CSS"><a href="#第14节：-CSS进阶：-消除未使用的CSS" class="headerlink" title="第14节： CSS进阶： 消除未使用的CSS"></a>第14节： CSS进阶： 消除未使用的CSS</h2><blockquote>
<p>引用别的库如BootStrap这样的框架，会带很多CSS，但项目中只用了一部分。<br> 随项目进展，CSS越来越多，开发时只考虑新增，造成CSS冗余</p>
</blockquote>
<p>这节学习 用webpack消除未使用的CSS。</p>
<h2 id="PurifyCSS"><a href="#PurifyCSS" class="headerlink" title="PurifyCSS"></a>PurifyCSS</h2><p>PurifyCSS可以大大减少CSS冗余，比如我们经常使用的BootStrap(140KB)就可以减少到只有35KB大小。这在实际开发当中是非常有用的。</p>
<h3 id="1-安装PurifyCSS-webpack-官网"><a href="#1-安装PurifyCSS-webpack-官网" class="headerlink" title="1. 安装PurifyCSS-webpack 官网"></a>1. 安装PurifyCSS-webpack <a href="https://www.npmjs.com/package/purifycss-webpack">官网</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D purifycss-webpack purify-css</span><br></pre></td></tr></table></figure>

<p>-D 是–save-dev的缩写</p>
<h3 id="2-引入glob"><a href="#2-引入glob" class="headerlink" title="2. 引入glob"></a>2. 引入glob</h3><p>node的glob模块可以根据配置的规则，获取对应的文件。</p>
<p>在webpack.config.js引入glob。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引入purifycss-webpack</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> purifyCSSPlugin = <span class="built_in">require</span>(<span class="string">&#x27;purifycss-webpack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-配置plugins"><a href="#3-配置plugins" class="headerlink" title="3.配置plugins"></a>3.配置plugins</h3><p>在webpack.config.js的plugins里增加配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="comment">// new uglify()</span></span><br><span class="line">    <span class="keyword">new</span> htmlPlugin(&#123;</span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        hash: <span class="literal">true</span>,</span><br><span class="line">        template: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(<span class="string">&#x27;css/index.css&#x27;</span>),</span><br><span class="line">    <span class="keyword">new</span> purifyCSSPlugin(&#123;</span><br><span class="line">        paths: glob.sync(path.join(__dirname, <span class="string">&#x27;src/*.html&#x27;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>这里的paths主要是寻找HTML模板，purifycss会根据这个配置遍历文件，查找哪些css被使用了。</p>
<p><strong>注意</strong>：使用这个插件必须配合extract-text-webpack-plugin插件。</p>
<h3 id="4-在index-css中添加一些没用的css"><a href="#4-在index-css中添加一些没用的css" class="headerlink" title="4.在index.css中添加一些没用的css"></a>4.在index.css中添加一些没用的css</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 多余的css */</span></span><br><span class="line"><span class="selector-class">.bu</span>&#123;</span><br><span class="line">    <span class="attribute">backface-visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hefd</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行打包，查看dist中的index.css内容，会发现没有多余的css.</p>
<h3 id="css文件代码分割"><a href="#css文件代码分割" class="headerlink" title="css文件代码分割"></a>css文件代码分割</h3><p>把css单独打包到CSS文件中，webpack默认把css打包到js中。即css-in-js.<br><a href="https://webpack.js.org/plugins/mini-css-extract-plugin/#root">MiniCssExtractPlugin</a></p>
<p>压缩打包出的css代码<a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin">optimize-css-assets-webpack-plugin</a></p>
<p>不能与</p>
<h2 id="总结-第14节"><a href="#总结-第14节" class="headerlink" title="总结-第14节"></a>总结-第14节</h2><p>工作中一定要用这个插件，决定你的代码质量，非常有用。</p>
<h2 id="第15节：-给webpack增加babel配置"><a href="#第15节：-给webpack增加babel配置" class="headerlink" title="第15节： 给webpack增加babel配置"></a>第15节： 给webpack增加babel配置</h2><p>虽然webpack4增加了ES6的语法支持，但实际效果并不好。<br>所以还是要加babel-loader配置。</p>
<p>这节学习如何增加Babel配置。</p>
<h2 id="babel是什么-官网"><a href="#babel是什么-官网" class="headerlink" title="babel是什么 官网"></a>babel是什么 <a href="https://babeljs.io/">官网</a></h2><p>Babel 是一个 JavaScript 编译器。用他可以</p>
<blockquote>
<p>使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。<br> 使用基于JavaScript进行了扩展的语言，比如React的JSX。</p>
</blockquote>
<p>高级: 了解babel怎么把高级语法转换成浏览器能识别的代码</p>
<h3 id="1-Babel安装"><a href="#1-Babel安装" class="headerlink" title="1. Babel安装"></a>1. Babel安装</h3><p>先一次性安装所有依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-loader @babel/core @babel/preset-env</span><br><span class="line"><span class="comment"># 避免polyfill 污染全局变量，会以闭包形式引入</span></span><br><span class="line">npm install -D @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure>

<p>这些包分别是：核心包 babel-loader 8.x | babel 7.x</p>
<h3 id="2-在webpack中配置Babel"><a href="#2-在webpack中配置Babel" class="headerlink" title="2.在webpack中配置Babel"></a>2.在webpack中配置Babel</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            presets: [</span><br><span class="line">               <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">            <span class="comment">//    用到哪个，加哪个polyfill</span></span><br><span class="line">                [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123;</span><br><span class="line">                    useBuiltIns: <span class="string">&#x27;usage&#x27;</span></span><br><span class="line">                &#125;]</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// 代码只是业务代码不用引入，如果是类库的代码，需要引入</span></span><br><span class="line">            plugins: [<span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>presets: 渲染器</p>
<p>不能转换所有的js，去除掉node_modules，</p>
<h3 id="3-在entry-js中修改代码"><a href="#3-在entry-js中修改代码" class="headerlink" title="3.在entry.js中修改代码"></a>3.在entry.js中修改代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">&#x27;./css/index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> less <span class="keyword">from</span> <span class="string">&#x27;./css/black.less&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sass <span class="keyword">from</span> <span class="string">&#x27;./css/nav.scss&#x27;</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;Hello Webpack&#x27;</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;title&#x27;</span>).innerHTML = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在打包可以看到let被转为var,做了兼容处理。<br>如果不适用babel转换的话，不会处理。</p>
<h3 id="babelrc配置"><a href="#babelrc配置" class="headerlink" title=".babelrc配置"></a>.babelrc配置</h3><p>babel的配置通常单独写在.babelrc文件里</p>
<p>在项目根目录新建.babelrc文件，把配置写到文件里。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">&quot;loose&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;6.9&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js的loader配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">       loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ENV-官网"><a href="#ENV-官网" class="headerlink" title="ENV 官网"></a>ENV <a href="https://www.npmjs.com/package/babel-preset-env">官网</a></h2><blockquote>
<p>babel-preset-env 是一个新的 preset，可以根据配置的目标运行环境（environment）自动启用需要的 babel 插件。<br>目前我们写 javascript 代码时，需要使用 N 个 preset，比如：babel-preset-es2015、babel-preset-es2016。es2015 可以把 ES6 代码编译为 ES5，es2016 可以把 ES2016 代码编译为 ES6。babel-preset-latest 可以编译 stage 4 进度的 ECMAScript 代码。</p>
<p>问题是我们几乎每个项目中都使用了非常多的 preset，包括不必要的。例如很多浏览器支持 ES6 的 generator，如果我们使用 babel-preset-es2015 的话，generator 函数就会被编译成 ES5 代码。</p>
<p>babel-preset-env 的工作方式类似 babel-preset-latest，唯一不同的就是 babel-preset-env 会根据配置的 env 只编译那些还不支持的特性。</p>
</blockquote>
<h3 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure>

<p>修改.babelrc里的配置文件，只要把es2015换成env就可以了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react&quot;</span>, <span class="string">&quot;env&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-第15节"><a href="#总结-第15节" class="headerlink" title="总结-第15节"></a>总结-第15节</h2><p>这里学了怎么配置babel支持，并且动态支持最新配置。</p>
<h2 id="第16节：-打包后如何调试"><a href="#第16节：-打包后如何调试" class="headerlink" title="第16节： 打包后如何调试"></a>第16节： 打包后如何调试</h2><p>webpack打包后，代码无法调试。怎么解决？</p>
<h3 id="webpack支持生成sourceMap来方便调试"><a href="#webpack支持生成sourceMap来方便调试" class="headerlink" title="webpack支持生成sourceMap来方便调试"></a>webpack支持生成sourceMap来方便调试</h3><p>使用webpack通过简单的devtool配置，webpack会自动生成source map文件，map文件是一种对应编译文件和源文件的方法，方便调试。</p>
<h2 id="四种选项"><a href="#四种选项" class="headerlink" title="四种选项"></a>四种选项</h2><p>在配置devtool时，webpack提供了4种选项</p>
<h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>在一个单独的文件中生成一个完整且功能完全的文件。这个文件有最好的source map，但是它会减慢打包速度</p>
<p>出错信息–包括行，列 独立(每个文件对应一个map)</p>
<h3 id="cheap-module-source-map"><a href="#cheap-module-source-map" class="headerlink" title="cheap-module-source-map"></a>cheap-module-source-map</h3><p>在一个单独的文件中产生一个不带映射列的map，不带映射列提高了打包速度，但也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列(符号)，会对调试造成不便。</p>
<p>出错信息–只有行，没有列 独立</p>
<h3 id="eval-source-map"><a href="#eval-source-map" class="headerlink" title="eval-source-map"></a>eval-source-map</h3><p>使用eval打包源文件模块，在同一个文件中生产干净的完整版sourcemap，但对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段可以使用，生产阶段一定不要开启这个选项</p>
<p>出错信息– 行 列 不独立</p>
<h3 id="cheap-module-eval-source-map"><a href="#cheap-module-eval-source-map" class="headerlink" title="cheap-module-eval-source-map"></a>cheap-module-eval-source-map</h3><p>这是在打包文件时最快生成sourcemap的方法，生成的sourcemap会和打包后的JavaScript同行显示，没有映射列，和eval-source-map有相似的缺点</p>
<p>出错信息– 列</p>
<h4 id="四种打包模式，由上到下越来越快。快的同时，也意味着对代码调试的困难越大"><a href="#四种打包模式，由上到下越来越快。快的同时，也意味着对代码调试的困难越大" class="headerlink" title="四种打包模式，由上到下越来越快。快的同时，也意味着对代码调试的困难越大"></a>四种打包模式，由上到下越来越快。快的同时，也意味着对代码调试的困难越大</h4><p>建议：</p>
<p>如果大型项目可以使用source-map,中小型项目使用eval-source-map就可以完全应对。</p>
<p>强调：source-map只适用于开发阶段，上线一定要修改这些配置。</p>
<h3 id="推荐线上用的cheap-module-source-map-方便线上出问题找原因"><a href="#推荐线上用的cheap-module-source-map-方便线上出问题找原因" class="headerlink" title="推荐线上用的cheap-module-source-map, 方便线上出问题找原因"></a>推荐线上用的cheap-module-source-map, 方便线上出问题找原因</h3><p>带module的为把module的代码也打入代码中<br>带inline的，会把打包的代码放到代码中<br>cheap,只考虑业务代码，不考虑module里的代码</p>
<h2 id="配置webpack-config-js的devtool"><a href="#配置webpack-config-js的devtool" class="headerlink" title="配置webpack.config.js的devtool"></a>配置webpack.config.js的devtool</h2><p>可以根据不同情况修改对应的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    <span class="comment">// 输出的路径</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="comment">// 输出文件的名称</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    publicPath: website.publicPath</span><br><span class="line">&#125;,</span><br><span class="line">devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br></pre></td></tr></table></figure>

<h2 id="总结-第16节"><a href="#总结-第16节" class="headerlink" title="总结-第16节"></a>总结-第16节</h2><p>这节学习了配置devtool，方便在开发环境调试代码。<br><a href="http://www.cnblogs.com/hhhyaaon/p/5657469.html">一篇讲的不错的博客</a></p>
<p><a href="http://webpack.github.io/docs/configuration.html#devtool">官网地址</a></p>
<h2 id="第17节：-实战技巧：-开发和生产并行配置"><a href="#第17节：-实战技巧：-开发和生产并行配置" class="headerlink" title="第17节： 实战技巧： 开发和生产并行配置"></a>第17节： 实战技巧： 开发和生产并行配置</h2><p>这节讲开发和生产不同环境的不同配置</p>
<h2 id="依赖不同"><a href="#依赖不同" class="headerlink" title="依赖不同"></a>依赖不同</h2><p>开发环境和生产环境的依赖是不同的</p>
<blockquote>
<p>开发依赖<br>    只在开发中用来帮助你进行开发，简化代码，或生成兼容设置的依赖包。在package.json中devDependencies中的包是开发使用的。在生产环境用不到。<br>生产依赖<br>    一些框架的核心代码，比如vue, element-ui, react,<br>    这些包在dependencies中</p>
</blockquote>
<h2 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h2><p>假如项目中使用jQuery库，一般有三种安装法。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jquery</span><br></pre></td></tr></table></figure>

<p>安装完成后，package.json中并没有这个包的依赖。如果别人协同开发，直接npm install，项目无法正常运行，不推荐。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jquery --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，在package.json的dependencies中。是生产环境需要依赖的包。上线时需要依赖。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jquery --save-dev</span><br></pre></td></tr></table></figure>

<p>安装完成后，在package.json的devDevpendencies中,是开发环境依赖的包，上线不需要这些包的依赖。</p>
<h3 id="安装全部依赖包"><a href="#安装全部依赖包" class="headerlink" title="安装全部依赖包"></a>安装全部依赖包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>会安装package.json中的所有包</p>
<h3 id="安装生产环境依赖包"><a href="#安装生产环境依赖包" class="headerlink" title="安装生产环境依赖包"></a>安装生产环境依赖包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --production</span><br></pre></td></tr></table></figure>

<h2 id="配置生产和开发并行"><a href="#配置生产和开发并行" class="headerlink" title="配置生产和开发并行"></a>配置生产和开发并行</h2><p>以前的配置中设置了一个变量website,用于静态资源找到正确路径。如果生产环境和测试环境不一样，需要来回切换，这时候可用下面的方法配置。</p>
<h3 id="修改package-json命令"><a href="#修改package-json命令" class="headerlink" title="修改package.json命令"></a>修改package.json命令</h3><p>添加dev何止，通过环境变量来区分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;liveserver&quot;</span>: <span class="string">&quot;live-server ./ --port=9090&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;set type=dev&amp;webpack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;set type=build&amp;webpack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;server&quot;</span>: <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="修改webpack-config-js文件"><a href="#修改webpack-config-js文件" class="headerlink" title="修改webpack.config.js文件"></a>修改webpack.config.js文件</h3><p>利用node的语法读取type的值，然后根据type的值进行判断设置不同的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(process.env.type === <span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> website = &#123;</span><br><span class="line">        publicPath: <span class="string">&#x27;http://localhost:8089/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> website = &#123;</span><br><span class="line">        publicPath: <span class="string">&#x27;http://localhost:8089/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想看某个值，可以console.log打印出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.env.type)</span><br></pre></td></tr></table></figure>

<p>打印console.log( encodeURIComponent(process.env.type) );发现报错</p>
<p>mac下的package.json设置<br>mac电脑需要把set换成export，并且多加一个&amp;,具体代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;server&quot;</span>: <span class="string">&quot;webpack-dev-server --open&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;export type=dev&amp;&amp;webpack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;export type=build&amp;&amp;webpack&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="总结-第17节"><a href="#总结-第17节" class="headerlink" title="总结-第17节"></a>总结-第17节</h2><p>通过配置不同的参数来区分不同的环境，从而达到不同环境打包不同代码。</p>
<h2 id="第18节：-实战技巧：-webpack模块化配置"><a href="#第18节：-实战技巧：-webpack模块化配置" class="headerlink" title="第18节： 实战技巧： webpack模块化配置"></a>第18节： 实战技巧： webpack模块化配置</h2><p>所有配置文件都放在webpack.config.js中会显得代码冗余，不利于维护。</p>
<p>如何进行模块化？</p>
<p>可以把生产环境的写到一个模块中，开发环境、测试环境都分开放到一个文件中。</p>
<p>这节学习如何将webpack.config.js模块化</p>
<h2 id="js的模块化实现"><a href="#js的模块化实现" class="headerlink" title="js的模块化实现"></a>js的模块化实现</h2><p>先看一下es6中的模块化代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertMsg</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;info: &#x27;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = alertMsg;</span><br></pre></td></tr></table></figure>

<p>声明一个alertMsg方法，并把这个方法用module.exports暴露出去。</p>
<p>然后在其他文件中用import引入，并使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> alertMsg <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span></span><br><span class="line">alertMsg();</span><br></pre></td></tr></table></figure>

<p>了解了JavaScript的模块化后，来写webpack的模块化</p>
<h2 id="webpack模块化"><a href="#webpack模块化" class="headerlink" title="webpack模块化"></a>webpack模块化</h2><p>这里用webpack.config.js中的entry入口哦文件进行模块化设置，单独做成一个模块</p>
<h3 id="1-在根目录建一个webpackConfig文件夹，新建entry-webpack-js，如下"><a href="#1-在根目录建一个webpackConfig文件夹，新建entry-webpack-js，如下" class="headerlink" title="1. 在根目录建一个webpackConfig文件夹，新建entry_webpack.js，如下"></a>1. 在根目录建一个webpackConfig文件夹，新建entry_webpack.js，如下</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明entry 变量</span></span><br><span class="line"><span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line"><span class="comment">// 声明路径属性</span></span><br><span class="line">entry.path = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/entry.js&#x27;</span>,</span><br><span class="line">    entry2: <span class="string">&#x27;./src/entry2.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里还可以写其他的</span></span><br><span class="line"><span class="comment">// entry.env.type之类的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模块化导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = entry;</span><br></pre></td></tr></table></figure>

<h3 id="2-在webpack-config-js中引入，这里只能用require引入"><a href="#2-在webpack-config-js中引入，这里只能用require引入" class="headerlink" title="2. 在webpack.config.js中引入，这里只能用require引入"></a>2. 在webpack.config.js中引入，这里只能用require引入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> entry = <span class="built_in">require</span>(<span class="string">&#x27;./webpackConfig/entry_webpack.js&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在入口处修改如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: entry.path,</span><br></pre></td></tr></table></figure>

<p>这时可以运行npm run dev进行测试，会发现正常运行</p>
<h2 id="总结-第18节"><a href="#总结-第18节" class="headerlink" title="总结-第18节"></a>总结-第18节</h2><p>模块化是必不可少的操作，一定要动手练习。</p>
<h2 id="第19节：-实战技巧：-优雅打包第三方类库-shimming"><a href="#第19节：-实战技巧：-优雅打包第三方类库-shimming" class="headerlink" title="第19节： 实战技巧： 优雅打包第三方类库-shimming"></a>第19节： 实战技巧： 优雅打包第三方类库-shimming</h2><p>有时候避免不了打包第三方类库，这时候该怎么操作。</p>
<p>这节学习如何优雅正确的用webpack引入第三方库。讲两种方法</p>
<h2 id="引入jQuery"><a href="#引入jQuery" class="headerlink" title="引入jQuery"></a>引入jQuery</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><h3 id="安装jquery"><a href="#安装jquery" class="headerlink" title="安装jquery"></a>安装jquery</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save jquery</span><br></pre></td></tr></table></figure>

<p>juqery要在生产环境和开发环境用，所以要用–save安装</p>
<h3 id="修改entry-js文件"><a href="#修改entry-js文件" class="headerlink" title="修改entry.js文件"></a>修改entry.js文件</h3><p>安装好需要引入到entry.js中，这里直接用import引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里不需要写相对路径，因为jquery的包是在node_modules里，只要写一个包名，系统就会自动为我们查找。</p>
<p>引入jQuery后就可以在文件中，使用jQuery，修改代码，测试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#gogo&#x27;</span>).animate(&#123;<span class="attr">height</span> : <span class="string">&quot;150&quot;</span> &#125; , <span class="number">1000</span> )</span><br><span class="line">    .animate(&#123;<span class="attr">width</span> : <span class="string">&quot;300&quot;</span> &#125; , <span class="number">1000</span> )</span><br><span class="line">    .hide(<span class="number">2000</span>)</span><br><span class="line">    .animate(&#123;<span class="attr">height</span> : <span class="string">&quot;show&quot;</span> , <span class="attr">width</span> : <span class="string">&quot;show&quot;</span> , <span class="attr">opacity</span> : <span class="string">&quot;show&quot;</span> &#125; , <span class="number">1000</span> )</span><br><span class="line">    .animate(&#123;<span class="attr">height</span> : <span class="string">&quot;500&quot;</span>&#125; , <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>

<p>代码顺利运行，可以看到jQuery库引用成功。</p>
<p>注意：不仅可以在入口处引入，还可以在任何需要的js中引入。<br>webpack不会重复打包，他只打包一次。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><h3 id="用plugin引入"><a href="#用plugin引入" class="headerlink" title="用plugin引入"></a>用plugin引入</h3><p>上面的方法，只是普通的引入，webpack只负责打包，没有全局感。</p>
<p>这个方法在webpack.config.js中配置，不需要在入库文件中引入，而是webpack自动作全局引入。</p>
<p>这个插件是<strong>ProvicePlugin</strong> <a href="http://webpack.github.io/docs/shimming-modules.html#plugin-provideplugin">文档</a></p>
<p>ProvicePlugin是webpack自带的插件，要现在webpack.config.js中引入webpack。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在plugins中配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">&#x27;jQuery&#x27;</span>,</span><br><span class="line">    _: <span class="string">&#x27;lodash&#x27;</span>,</span><br><span class="line">    _join: [<span class="string">&#x27;lodash&#x27;</span>, <span class="string">&#x27;join&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置好后，就可以在其他文件直接使用$, 而不用在每个组件引入jQuery。</p>
<p>这种全局的引入，在实际工作中也可以很好的规范项目所使用的第三方库。</p>
<h2 id="总结-第19节"><a href="#总结-第19节" class="headerlink" title="总结-第19节"></a>总结-第19节</h2><p>每个项目都可能引入第三方类库。像一些成熟的框架都有自己的webpack框架，如vue-cli。</p>
<p>很多情况下，我们还是要手动更改这些配置好的webpack来适用于我们自己的项目。</p>
<p>所以这节课的内容也非常重要。</p>
<h2 id="第20节：-实战技巧：-watch的正确使用方法"><a href="#第20节：-实战技巧：-watch的正确使用方法" class="headerlink" title="第20节： 实战技巧： watch的正确使用方法"></a>第20节： 实战技巧： watch的正确使用方法</h2><p>在初级开发阶段，使用webpack-dev-server可以充当服务器和完成打包任务，但随着项目的进一步完善，可能需要前后联调或两个前端合并代码时，就需要一个公共的服务器。这时候，每次手动打包显然效率太低，我们希望的场景是代码发生变化后，只要保存，webpack就自动为我们进行打包。</p>
<p>这个工具就是watch。</p>
<p>这节课学完后，会发现在开发中更加得心应手了。</p>
<h2 id="watch设置"><a href="#watch设置" class="headerlink" title="watch设置"></a>watch设置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watchOptions: &#123;</span><br><span class="line">    <span class="comment">// 检测修改的时间，以毫秒为单位</span></span><br><span class="line">    poll: <span class="number">100</span>,</span><br><span class="line">    <span class="comment">// 防止重复保存而发生编译错误。这里设置的500是半秒内重复保存，不进行打包</span></span><br><span class="line">    aggregeateTimeout: <span class="number">500</span>,</span><br><span class="line">    <span class="comment">// 不监听的目录</span></span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>注意ignored这里不能用双引号</p>
<p>没有配置的情况下，直接webpack –watch   (-w) 是不起作用的</p>
<p>配置好后，就可以痛快的使用watch了。大大加快了开发效率，不用反复手动打包。</p>
<h2 id="BannerPlugin插件"><a href="#BannerPlugin插件" class="headerlink" title="BannerPlugin插件"></a>BannerPlugin插件</h2><p>工作中每个人的代码都要写备注，方便发生问题时，可以找到写代码的人，有时候也用于版权声明。</p>
<p>这个插件就是BannerPlugin,使用后会在js中加上我们的版权或开发者声明</p>
<p>在webpack.config.js的plugins里配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;版权所有，仅限学习使用~~&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意： 用这个插件，需要提前引入webpack.<br>编译后，在每个文件的头部，会有编译信息。</p>
<h2 id="第21节：-实战技巧：-webpack优化黑技能"><a href="#第21节：-实战技巧：-webpack优化黑技能" class="headerlink" title="第21节： 实战技巧： webpack优化黑技能"></a>第21节： 实战技巧： webpack优化黑技能</h2><p>无论写什么程序，都要有颗不断优化的心。</p>
<p>这节课来学习工作中常用的webpack优化黑技能。</p>
<h2 id="ProvidePlugin和import"><a href="#ProvidePlugin和import" class="headerlink" title="ProvidePlugin和import"></a>ProvidePlugin和import</h2><p>在第19节中学习了如何引入第三方类库，并引入了jQuery。在引入jQuery时，用了2种方法。第一种是import，第二种是用ProvidePlugin插件。这两种方法有什么区别呢？</p>
<blockquote>
<p>import方法： 引用后不管在代码中用不用，都会把这个类库打包，这样有时会产生代码冗余。<br> ProvideP方法： 引用后只有在类库使用时，才按需打包，所以建议工作中使用插件的方式进行引入。</p>
</blockquote>
<p>具体打包差别可以自行练习，查看打包结果。差距明显。</p>
<h2 id="抽离jQuery"><a href="#抽离jQuery" class="headerlink" title="抽离jQuery"></a>抽离jQuery</h2><p>上面只是优化的第一步，工作中会发现，不使用的类库我们也不会引入，所以上面只是必要操作的一步。往往把第三类类库抽离出来，才是最好的解决办法。</p>
<h3 id="第一步：-修改入口文件"><a href="#第一步：-修改入口文件" class="headerlink" title="第一步： 修改入口文件"></a>第一步： 修改入口文件</h3><p>抽离的第一步是修改入口文件，把jQuery加入到入口文件中，看下面代码。<br>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry.path = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/entry.js&#x27;</span>,</span><br><span class="line">    jquery: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">    entry2: <span class="string">&#x27;./src/entry2.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：引入插件"><a href="#第二步：引入插件" class="headerlink" title="第二步：引入插件"></a>第二步：引入插件</h3><p>需要引入optimize优化插件，插件里是需要配置的，具体代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    <span class="comment">// name对应入口文件中的名字，这里是jquery</span></span><br><span class="line">    name: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">    <span class="comment">// 把文件打包到哪里，路径地址</span></span><br><span class="line">    filename: <span class="string">&#x27;assets/js/jquery.min.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 最小打包的文件模块数，这里直接写2</span></span><br><span class="line">    minChunks: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>minChunks是固定配置，不写不行，会打包失败</li>
<li>filename可以省略，直接打包到根目录下，这里直接打包到dist目录下</li>
</ul>
<p>配置完成后可以先删掉原来的dist目录，再用webpack打包，会发现jQuery被抽离了出来，并且entry.js变的很小。</p>
<h2 id="多个第三方库抽离"><a href="#多个第三方库抽离" class="headerlink" title="多个第三方库抽离"></a>多个第三方库抽离</h2><p>会了jquery抽离，在实际开发中，会引用不止一个第三方类库，也需要抽离。</p>
<p>这里用引入Vue举例，看看如何抽离出来。</p>
<h3 id="第一步：-先用npm进行安装"><a href="#第一步：-先用npm进行安装" class="headerlink" title="第一步： 先用npm进行安装"></a>第一步： 先用npm进行安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p>注意这里是–save，不是–save-dev，因为生产环境也要用到</p>
<h3 id="第二步：-在入口配置中引入Vue和jquery"><a href="#第二步：-在入口配置中引入Vue和jquery" class="headerlink" title="第二步： 在入口配置中引入Vue和jquery"></a>第二步： 在入口配置中引入Vue和jquery</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry.path = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/entry.js&#x27;</span>,</span><br><span class="line">    jquery: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">    vue: <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">    entry2: <span class="string">&#x27;./src/entry2.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只比上边多了个vue</p>
<h3 id="第三步：修改CommonsChunkPlugin配置"><a href="#第三步：修改CommonsChunkPlugin配置" class="headerlink" title="第三步：修改CommonsChunkPlugin配置"></a>第三步：修改CommonsChunkPlugin配置</h3><p>需要修改两个位置：</p>
<ul>
<li>在name属性里把原来的字符串改为数组。因为要引用多个模块， 所以是数组。</li>
<li>在filename属性中把输出的文件名改为匹配符[name],这项操作就是打包出来的名字跟随我们打包前的模块名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    <span class="comment">// name对应入口文件中的名字，这里是jquery</span></span><br><span class="line">    name: [<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">    <span class="comment">// 把文件打包到哪里，路径地址</span></span><br><span class="line">    filename: <span class="string">&#x27;assets/js/[name].js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 最小打包的文件模块数，这里直接写2</span></span><br><span class="line">    minChunks: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>配置好后，在控制台用npm run build 打包。jquery和Vue被抽离出来了。</p>
<h2 id="总结-第21节"><a href="#总结-第21节" class="headerlink" title="总结-第21节"></a>总结-第21节</h2><p>在项目开发中，会使用很多第三方类库，比较好的做法就是把这些第三方类库全部抽离处理，这样在项目维护和性能上都是不错的选择。学了这个技巧后，在工作中要会使用。</p>
<p>jquery作为插件引入后，在其他文件中怎么用呢<br>还是需要有 providePlugin来支撑的，不能去掉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<h2 id="第22节：-实战技巧：-静态资源集中输出"><a href="#第22节：-实战技巧：-静态资源集中输出" class="headerlink" title="第22节： 实战技巧： 静态资源集中输出"></a>第22节： 实战技巧： 静态资源集中输出</h2><p>工作中会有一些已经存在但在项目中没有引用的图片资源或者其他静态资源（比如设计图、开发文档），这些静态资源有可能是文档，也有可能是一些额外的图片。项目组长会要求你打包时保留这些静态资源，直接打包到指定文件夹。其实打包这些资源只需要用到copy-webpack-plugin。</p>
<h2 id="使用copy-webpack-plugin"><a href="#使用copy-webpack-plugin" class="headerlink" title="使用copy-webpack-plugin"></a>使用copy-webpack-plugin</h2><p>copy-webpack-plugin就是专门为我们做静态资源转移的插件，不过它需要安装。</p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev copy-webpack-plugin</span><br></pre></td></tr></table></figure>

<h3 id="引入插件"><a href="#引入插件" class="headerlink" title="引入插件"></a>引入插件</h3><p>安装好后，需要在webpack.config.js的头部引入这个插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>在plugins里进行配置,注意这里是数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> copyWebpackPlugin([&#123;</span><br><span class="line">    <span class="keyword">from</span>: __dirname+ <span class="string">&#x27;/src/public&#x27;</span>,</span><br><span class="line">    to: <span class="string">&#x27;./public&#x27;</span></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>

<ul>
<li>from: 要打包的静态资源目录地址，__dirname指项目目录，可以直接定位到本机的项目目录。</li>
<li>to: 要打包到的文件路径，跟随output配置的目录。所以这里不用加__dirname.</li>
</ul>
<p>配置好后，运行webpack，会发现图片按照配置打包到了指定目录。</p>
<h2 id="总结-第22节"><a href="#总结-第22节" class="headerlink" title="总结-第22节"></a>总结-第22节</h2><p>现在学起来已经很容易了，已经掌握了webpack的基本知识，剩下的就是不断练习和在实际项目中发现新的需求，然后找到新的loader或者plugin来解决问题。</p>
<h2 id="第23节：-实战技巧：-JSON配置文件的使用"><a href="#第23节：-实战技巧：-JSON配置文件的使用" class="headerlink" title="第23节： 实战技巧： JSON配置文件的使用"></a>第23节： 实战技巧： JSON配置文件的使用</h2><p>在实际工作中，我们的项目都会配置一个json的文件或API文件，作为项目的配置文件。有时也会从后台读取一个json文件。</p>
<p>这节课就学习如何在webpack环境中使用JSON.</p>
<p>在webpack1或webpack2中，需要加载一个json-loader的loader，但在webpack4.x中，不需要额外引入。</p>
<h2 id="读取JSON内容"><a href="#读取JSON内容" class="headerlink" title="读取JSON内容"></a>读取JSON内容</h2><ol>
<li><p>在index.html中加个div，并给个id.</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;jsonArea&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到src文件夹下，找到入口文件，entry.js,修改代码。如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="built_in">require</span>(<span class="string">&#x27;../config.json&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;jsonArea&#x27;</span>).innerHTML = json.name;</span><br></pre></td></tr></table></figure>

<p> 引入json文件，并插入到dom中。</p>
</li>
<li><p>运行npm run server ，就可以看到效果。</p>
</li>
</ol>
<h2 id="说说热更新"><a href="#说说热更新" class="headerlink" title="说说热更新"></a>说说热更新</h2><p>在devServer中配置<code>hot: true</code><br><code>hotOnly: true</code> 热更新失败时，不刷新整个页面</p>
<p>在webpack4.x中，启用热加载很容易，只要加入HotModuleReplacementPlugin这个插件就可以了。</p>
<p>在plugin里配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在，启动npm run server后，修改index.html中的内容，浏览器就可以自动更新最新页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果某个js模块更新了，只更新某个模块，而不是所有模块都更新</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./number&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        number();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="这里的热更新和平时写程序的热加载不是一回事，比如说我们Vue和React中的热更新，并不是刷新整个页面，而是一个局部的更新，而这里的更新是刷新了整个页面"><a href="#这里的热更新和平时写程序的热加载不是一回事，比如说我们Vue和React中的热更新，并不是刷新整个页面，而是一个局部的更新，而这里的更新是刷新了整个页面" class="headerlink" title="这里的热更新和平时写程序的热加载不是一回事，比如说我们Vue和React中的热更新，并不是刷新整个页面，而是一个局部的更新，而这里的更新是刷新了整个页面"></a>这里的热更新和平时写程序的热加载不是一回事，比如说我们Vue和React中的热更新，并不是刷新整个页面，而是一个局部的更新，而这里的更新是刷新了整个页面</h3><p>这个区别要搞清楚。</p>
<h2 id="第24节：-剧终：-webpack自学技巧传授"><a href="#第24节：-剧终：-webpack自学技巧传授" class="headerlink" title="第24节： 剧终： webpack自学技巧传授"></a>第24节： 剧终： webpack自学技巧传授</h2><p>这节课学一些自学webpack的技巧，让大家可以在本教程结束后继续自行精进。</p>
<h2 id="学习推荐"><a href="#学习推荐" class="headerlink" title="学习推荐"></a>学习推荐</h2><ul>
<li><p><a href="https://webpack.js.org/">webpack 官网</a></p>
</li>
<li><p><a href="https://doc.webpack-china.org/">中文官网</a></p>
</li>
<li><p><a href="http://webpack.wuhaolin.cn/">深入浅出 Webpack</a></p>
</li>
</ul>
<h2 id="Webpack插件"><a href="#Webpack插件" class="headerlink" title="Webpack插件"></a>Webpack插件</h2><ul>
<li><a href="https://www.npmjs.com/package/hard-source-webpack-plugin">hard-source-webpack-plugin</a><br>提升打包效率非常明显</li>
</ul>
<h2 id="webpack之监测配置文件的修改而自动构建"><a href="#webpack之监测配置文件的修改而自动构建" class="headerlink" title="webpack之监测配置文件的修改而自动构建"></a>webpack之监测配置文件的修改而自动构建</h2><p>在webpack的自动构建中，一般情况下我们只是监测到源文件的变化，如果修改webpack的配置文件就不会发生自动构建。通过使用node的nodemon模块来达到目的。</p>
<p>一、安装nodemon</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局安装</span></span><br><span class="line">npm install -g nodemon</span><br><span class="line"><span class="comment">// 本地安装</span></span><br><span class="line">npm install --save-dev nodemon</span><br></pre></td></tr></table></figure>

<p>二、使用nodemon</p>
<p><code>nodemon --watch ./config/webpack.dev.js</code></p>
<p>解释：</p>
<p>– watch config 表示监测config目录下的文件变化<br>– dev.js则为webpack本来的通过 node dev.js形式执行的构建起始文件<br>总体意思就是：监测config中的文件变化并重新执行dev.js文件</p>
<p>如果nodemon是本地安装需要如下处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在package.json中scripts中加如下配置</span></span><br><span class="line"><span class="string">&quot;startNodemon&quot;</span>:<span class="string">&quot;nodemon --watch config dev.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在命令行中执行</span></span><br><span class="line">npm run startNodemon</span><br></pre></td></tr></table></figure>

<p>在package.json中的配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack ...&quot;</span></span><br><span class="line">        <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;nodemon --watch config dev.js --exec npm run start&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ul>
<li>–exec 配置运行的命令</li>
<li>–watch 监听些文件变化，当变化的时候自动重启</li>
</ul>
<p>node服务器app.js自动重启</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;nodemon  app.js &quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>实际使用中，如果package.json中的main配置了，但是路径不对，会报错找不到文件导致无法自动重启</p>
<h2 id="webpack-npm-install-报错解决"><a href="#webpack-npm-install-报错解决" class="headerlink" title="webpack npm install 报错解决"></a>webpack npm install 报错解决</h2><p>执行<code>npm install</code> 报错: <code>npm ERR! Cannot read property &#39;match&#39; of undefined</code></p>
<p>解决办法:</p>
<p>依次执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules</span><br><span class="line">rm package-lock.json</span><br><span class="line">npm cache clear --force</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="Clean-plugin-for-webpack"><a href="#Clean-plugin-for-webpack" class="headerlink" title="Clean plugin for webpack"></a><a href="https://github.com/johnagan/clean-webpack-plugin">Clean plugin for webpack</a></h3><p>在打包之前清除打包文件</p>
<p><code>npm install --save-dev clean-webpack-plugin</code></p>
<p>用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>

<h3 id="自己实现webpack-dev-server"><a href="#自己实现webpack-dev-server" class="headerlink" title="自己实现webpack-dev-server"></a>自己实现webpack-dev-server</h3><p><a href="https://webpack.js.org/api/node/">在node中使用webpack</a></p>
<p><code>npm install express webpack-dev-middleware -D</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>);</span><br><span class="line"><span class="comment">// 用webpack结合config编译代码</span></span><br><span class="line"><span class="keyword">const</span> complier = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(complier), &#123;</span><br><span class="line">    publicPath: config.output.publicPath</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server is running&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>webpack.config.js 配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">    <span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;node server.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><p>只支持ES Module!!!</p>
<p><code>import &#123; add &#125; from &#39;./math.js&#39;;</code></p>
<p>底层是静态引入方式</p>
<p>不支持</p>
<p><code>const add = require(&#39;./math.js);</code></p>
<p>commonJs 是动态引入, 不支持tree shaking</p>
<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    usedExports: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在package.json中</p>
<p>对哪个文件不做筛选，在<code>sideEffects</code>里以数组的方式加入<br>对css文件不做处理<br><code>sideEffects: [&#39;*.css&#39;]</code></p>
<p><code>false</code>为对所有文件筛选</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;sideEffects&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mode: 为development时，打包不会删除代码，会删除导出</p>
<h2 id="webpack区分-开发模式和-production模式"><a href="#webpack区分-开发模式和-production模式" class="headerlink" title="webpack区分 开发模式和 production模式"></a>webpack区分 开发模式和 production模式</h2><p>依赖webpack-merge</p>
<p><code>npm install webpack-merge -D</code></p>
<p>webpack.common.js 公共的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    output: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.prod.js, 保留线上独有的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">    mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    devtool: <span class="string">&#x27;cheap-module-source-map&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, prodConfig);</span><br></pre></td></tr></table></figure>

<p>webpack.dev.js, 保留开发环境独有的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> commConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.common.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        hot: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, devConfig);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把所有配置文件都放到<code>build</code>文件夹里, 需要改package.json里的配置(output, scripts等)</p>
<p>检查打包位置对不对，清除文件对不对</p>
<h2 id="Code-Splitting–有疑问"><a href="#Code-Splitting–有疑问" class="headerlink" title="Code Splitting–有疑问"></a>Code Splitting–有疑问</h2><p><a href="https://webpack.js.org/plugins/split-chunks-plugin/#root">SplitChunksPlugin</a></p>
<p>拆分代码，提升项目性能</p>
<p>比如引入lodash之类的类库，打包生成的文件会多1MB左右</p>
<p>将2MB的文件拆分成两个1MB的文件加载</p>
<p>当业务逻辑发生改变时，只加载业务逻辑代码，不加载基础类库的代码</p>
<p>在webpack.config.js中增加配置—-同步代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        chunks: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步代码（import,无需做任何配置会自动进行代码分割）</p>
<p>代码支持异步import</p>
<p><code>npm install babel-plugin-dynamic-import-webpack --save-dev</code></p>
<h2 id="Lazy-Loading-懒加载，Chunk-是什么–有疑问"><a href="#Lazy-Loading-懒加载，Chunk-是什么–有疑问" class="headerlink" title="Lazy Loading 懒加载，Chunk 是什么–有疑问"></a>Lazy Loading 懒加载，Chunk 是什么–有疑问</h2><p>通过import异步加载模块</p>
<p>可以让页面加载更快</p>
<p><code>babel-plugin-syntax-dynamic-import</code></p>
<p>点击页面才会加载getComponent</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/** webpackChunkName: &quot;lodash&quot; */</span> <span class="string">&#x27;lodash&#x27;</span>).then(&#123; <span class="attr">default</span>: _ &#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        element.innerHTML = _.join([<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;22&#x27;</span>], <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    getComponent().then(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/** webpackChunkName: &quot;lodash&quot; */</span> <span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;22&#x27;</span>], <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打包分析，Preloading-Prefetching"><a href="#打包分析，Preloading-Prefetching" class="headerlink" title="打包分析，Preloading, Prefetching"></a>打包分析，Preloading, Prefetching</h2><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis">官方工具链接</a></p>
<p>webpack分析工具<a href="https://github.com/webpack/analyse">analyse</a></p>
<p>生成打包描述文件<br>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">    &quot;analyze&quot;: &#x27;webpack --profile --json &gt; stats.json&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://webpack.github.com/analyse">分析网站，需科学上网</a></p>
<p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a></p>
<h3 id="小知识-文件利用率"><a href="#小知识-文件利用率" class="headerlink" title="小知识-文件利用率"></a>小知识-文件利用率</h3><p>command+shift+p 搜索coverage, 可以看文件利用率</p>
<p>提高代码的使用率</p>
<p>多写异步代码，性能才能得到提升</p>
<p>chunks: ‘async’ 才能真正提升网站性能</p>
<h2 id="webpack与浏览器缓存-Caching"><a href="#webpack与浏览器缓存-Caching" class="headerlink" title="webpack与浏览器缓存(Caching)"></a>webpack与浏览器缓存(Caching)</h2><p><code>performace: false</code> 可以不提示性能问题</p>
<p>通过文件名添加hash值来缓存</p>
<p>生产环境</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].[contenthash].js&#x27;</span>,</span><br><span class="line">    chunkFilename: <span class="string">&#x27;[name].[contenthash].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="library打包"><a href="#library打包" class="headerlink" title="library打包"></a>library打包</h2><p><a href="https://webpack.js.org/configuration/output/#outputlibrarytarget">文档地址</a></p>
<p><a href="https://webpack.js.org/configuration/externals/#root">externals</a><br>开发类库的打包，供第三方以不同的方式(import, require, script)引入使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line"><span class="comment">// 如果遇到lodash库，不打包到代码里，业务里要用的话，先引用lodash，再引用library</span></span><br><span class="line">externals: [<span class="string">&#x27;lodash&#x27;</span>],</span><br><span class="line">output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;library.js&#x27;</span></span><br><span class="line">    <span class="comment">// 以script方式引入</span></span><br><span class="line">    library: <span class="string">&#x27;library&#x27;</span>,</span><br><span class="line">    <span class="comment">// 以import和require方式引入</span></span><br><span class="line">    libraryTarget: <span class="string">&#x27;umd&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">main: &quot;./dist/index.js&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm adduser</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure>

<h2 id="PWA打包配置"><a href="#PWA打包配置" class="headerlink" title="PWA打包配置"></a>PWA打包配置</h2><p>网站访问过一次之后，可以一直被缓存, serviceWorker</p>
<p><a href="https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin">workbox-webpack-plugin</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inside of webpack.config.js:</span></span><br><span class="line"><span class="keyword">const</span> &#123;GenerateSW&#125; = <span class="built_in">require</span>(<span class="string">&#x27;workbox-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// Other webpack config...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// Other plugins...</span></span><br><span class="line">    <span class="keyword">new</span> GenerateSW(&#123;</span><br><span class="line">      option: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript-打包配置"><a href="#TypeScript-打包配置" class="headerlink" title="TypeScript 打包配置"></a>TypeScript 打包配置</h2><p><code>npm install ts-loader typescript -D</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">    use: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>tsconfig.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>npm install @types/lodash --save-dev</code><br>这样在代码中typescript可以识别lodash中的方法，并提示语法不规范等错误</p>
<p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a></p>
<h2 id="webpack性能优化"><a href="#webpack性能优化" class="headerlink" title="webpack性能优化"></a>webpack性能优化</h2><ol>
<li><p>跟上技术的迭代(npm, yarn, Node版本升级)</p>
</li>
<li><p>在尽可能少的模块上用loader<br> excludes或include</p>
</li>
<li><p>plugin尽可能少，并保证可靠性</p>
</li>
<li><p>resolve参数合理配置</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    extendsions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>],</span><br><span class="line">    <span class="comment">// 从哪个文件导入模块, 不要配置过多的</span></span><br><span class="line">    mainFields: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;main&#x27;</span>],</span><br><span class="line">    <span class="comment">// 创建 import 或 require 的别名</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">        <span class="string">&#x27;utils&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;../utils&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;assets&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;../assets&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> extendsions: 不要把所有后缀都加到这里, 如css, jpg等, 会增加文件查找复杂度</p>
</li>
<li><p>使用DLLPlugin提高打包速度</p>
<p> 每一次引入第三方包都会进行分析，消耗时间</p>
<p> webpack.dll.js</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        vendors: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">        lodash: [<span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>),</span><br><span class="line">        <span class="comment">// 可以在控制台使用的变量,通过全局变量暴露出来</span></span><br><span class="line">        library: <span class="string">&#x27;[name]&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.dllPlugin(&#123;</span><br><span class="line">            name: <span class="string">&#x27;[name]&#x27;</span>,</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">&#x27;../dll/[name].manifest.json&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> webpack.common.js</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> addAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">        root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>));</span><br><span class="line">files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/.*\.dll.js/</span>.test(file)) &#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> addAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filePath: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>,file)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/.*\.manifest.json/</span>.test(file)) &#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">            manifest: path.solve(__dirname, <span class="string">&#x27;../dll/&#x27;</span>, file)</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    entry: &#123;</span><br><span class="line">        vendors: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">        lodash: [<span class="string">&#x27;lodash&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;..dll&#x27;</span>),</span><br><span class="line">        <span class="comment">// 可以在控制台使用的变量,通过全局变量暴露出来</span></span><br><span class="line">        library: <span class="string">&#x27;[name]&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>npm install add-asset-html-webpack-plugin --save</code></p>
<p> 目标：<br> 第一次打包时把常用的库放到一个文件，再次引用不再从node_modules里找</p>
<p> 第三方模块只打包一次<br> 引入第三方模块时，用dll文件引入<br> 先打包<code>npm run build:dll</code> 打包<code>webpack.dll.js</code>，再运行<code>npm run build</code></p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;build&quot;: &quot;webpack --progress --colors --devtool cheap-module-source-map&quot;,</span><br><span class="line">&quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制包文件大</p>
</li>
<li><p>thread-loader, paraller-webpack, happypack多进程打包</p>
</li>
<li><p>合理使用sourceMap</p>
</li>
<li><p>结合stats分析打包结果</p>
</li>
<li><p>开发环境内存编译</p>
</li>
<li><p>开发环境无用插件剔除(开发环境没必要压缩之类的)</p>
</li>
</ol>
<h2 id="多页面打包配置"><a href="#多页面打包配置" class="headerlink" title="多页面打包配置"></a>多页面打包配置</h2><p>多个entry对应多个html文件</p>
<p>webpack.common.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> makePlugins = <span class="function">(<span class="params">configs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> plugins = [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>], &#123;</span><br><span class="line">            root: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ];</span><br><span class="line">    <span class="built_in">Object</span>.keys(configs.entry).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        plugins.push(</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">&#x27;src/index.html&#x27;</span>,</span><br><span class="line">            filename: <span class="string">`<span class="subst">$&#123;item&#125;</span>.html`</span>,</span><br><span class="line">            chunks: [<span class="string">&#x27;runtime&#x27;</span>, <span class="string">&#x27;vendors&#x27;</span>, item]</span><br><span class="line">        &#125;),</span><br><span class="line">        )</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// dllplugins</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plugins;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> configs = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        list: <span class="string">&#x27;./src/list.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">config.plugins = makePlugins(config);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>

<h2 id="如何编写一个loader"><a href="#如何编写一个loader" class="headerlink" title="如何编写一个loader"></a>如何编写一个loader</h2><p>常用功能: 国际化替换中英文, 捕获异常(在function外加trycatch)</p>
<p><a href="https://www.webpackjs.com/api/loaders/">loader API</a></p>
<p>replaceLoader.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">&#x27;loader-utils&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = loaderUtils.getOptions();</span><br><span class="line">    <span class="keyword">const</span> result = source.replace(<span class="string">&#x27;hello &#x27;</span>, options.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等于 return result</span></span><br><span class="line">    <span class="built_in">this</span>.callback(<span class="literal">null</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">    <span class="comment">// path.resolve(__dirname, &#x27;./loaders/replaceLoader.js)可以不用写这么多,直接写name</span></span><br><span class="line">    modules: [<span class="string">&#x27;node_modules&#x27;</span>, <span class="string">&#x27;./loaders&#x27;</span>]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.js/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: <span class="string">&#x27;replaceLoader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                name: <span class="string">&#x27;lee&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂的replaceLoader.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">&#x27;loader-utils&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = loaderUtils.getOptions();</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = source.replace(<span class="string">&#x27;dell&#x27;</span>, options.name);</span><br><span class="line">        callback(<span class="literal">null</span>, result);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何编写一个Plugin"><a href="#如何编写一个Plugin" class="headerlink" title="如何编写一个Plugin"></a>如何编写一个Plugin</h2><p>打包的某个时刻，是插件生效的场景，比如打包之前，清除dist目录<br><a href="https://www.webpackjs.com/api/compiler-hooks">compiler hooks</a><br>copyright-webpack-plugin.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyrightWebpackPlugin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;插件被使用了&#x27;</span>, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 同步写法</span></span><br><span class="line">        compiler.hooks.emit.tap(<span class="string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//  异步写法</span></span><br><span class="line">        compiler.hooks.emit.tapAsync(<span class="string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, cb</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// compilation.assets为打包后的文件</span></span><br><span class="line">            compilation.assets[<span class="string">&#x27;copyright.txt&#x27;</span>] = &#123;</span><br><span class="line">                source: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;copyright by hello world&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一定要加回调</span></span><br><span class="line">            cb();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = CopyrightWebpackPlugin;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copyrightWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;./plugins/copyright-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> copyrightWebpackPlugin(&#123;</span><br><span class="line">        name: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="用node调试工具调试webpack"><a href="#用node调试工具调试webpack" class="headerlink" title="用node调试工具调试webpack"></a>用node调试工具调试webpack</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;debug&quot;: &quot;node --inspect --inspect-brk node_modules/webpack/bin/webpack.jss&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在插件中写debugger，会自动跳到该断点</p>
<h2 id="CreateReactApp-https-github-com-facebook-create-react-app）项目Webpack解析"><a href="#CreateReactApp-https-github-com-facebook-create-react-app）项目Webpack解析" class="headerlink" title="[CreateReactApp](https://github.com/facebook/create-react-app）项目Webpack解析"></a>[CreateReactApp](<a href="https://github.com/facebook/create-react-app%EF%BC%89%E9%A1%B9%E7%9B%AEWebpack%E8%A7%A3%E6%9E%90">https://github.com/facebook/create-react-app）项目Webpack解析</a></h2><p><code>npm run eject</code>查看webpack配置</p>
<h2 id="Vue项目配置"><a href="#Vue项目配置" class="headerlink" title="Vue项目配置"></a><a href="https://cli.vuejs.org/config/#global-cli-config">Vue项目配置</a></h2><p>新建vue.config.js配置</p>
]]></content>
      <tags>
        <tag>Webpack</tag>
        <tag>学习笔记</tag>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title>前端经验积累</title>
    <url>/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h1 id="判断一个对象是不是数组"><a href="#判断一个对象是不是数组" class="headerlink" title="判断一个对象是不是数组"></a>判断一个对象是不是数组</h1><ol>
<li>instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;;</span><br><span class="line">var b&#x3D;[];</span><br><span class="line">console.log(a instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">console.log(b instanceof Array);&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">注意！！！！！！</span><br><span class="line">console.log(b instanceof Object);&#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Array.isArray()</p>
</li>
<li><p>使用Object.prototype上的原生toString()方法判断。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(a));&#x2F;&#x2F;[object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(b));&#x2F;&#x2F;[object Array]</span><br><span class="line">同理判断一个对象是否是函数：</span><br><span class="line">console.log(Object.prototype.toString.call(obj)&#x3D;&#x3D;&#x3D;&#39;[object Function]&#39;)    &#x2F;&#x2F;true或false</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>obj.constructor===Array   //true</li>
</ol>
<h1 id="真值-假值（Truthy-Falsy）"><a href="#真值-假值（Truthy-Falsy）" class="headerlink" title="真值 / 假值（Truthy / Falsy）"></a>真值 / 假值（Truthy / Falsy）</h1><p>以下为false</p>
<ul>
<li>false</li>
<li>0</li>
<li>“”（空字符串）</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!0 &#x2F;&#x2F; true -- 0 is false, 所以返回true</span><br><span class="line">!!0 &#x2F;&#x2F; false -- 0 is falsy so !0 returns true so !(!0) returns false</span><br><span class="line">!!&quot;&quot; &#x2F;&#x2F; false -- empty string is falsy so NOT (NOT false) equals false</span><br><span class="line"></span><br><span class="line">new Boolean(0) &#x2F;&#x2F; false</span><br><span class="line">new Boolean(1) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let a &#x3D; [] &#x3D;&#x3D; true &#x2F;&#x2F; a is false since [].toString() give &quot;&quot; back.</span><br><span class="line">let b &#x3D; [1] &#x3D;&#x3D; true &#x2F;&#x2F; b is true since [1].toString() give &quot;1&quot; back.</span><br><span class="line">let c &#x3D; [2] &#x3D;&#x3D; true &#x2F;&#x2F; c is false since [2].toString() give &quot;2&quot; back.</span><br><span class="line"></span><br><span class="line">在内部，当一个对象与布尔值比较时，</span><br><span class="line">比如[] &#x3D;&#x3D; true，它其实进行的是[].toString() &#x3D;&#x3D; true。</span><br></pre></td></tr></table></figure>

<h1 id="JS语句为什么不能以“function”和大括号开头"><a href="#JS语句为什么不能以“function”和大括号开头" class="headerlink" title="JS语句为什么不能以“function”和大括号开头"></a>JS语句为什么不能以“function”和大括号开头</h1><ul>
<li>以function开头，但必须是一个函数声明语句</li>
<li>以大括号开头，但该大括号不再被当做一个对象处理，而是当做一个语句块处理</li>
<li>综上两条说明，JS语句可以以function，也可以以大括号作为开头，前提是必须符合JS中的语法规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;a: &#39;a&#39;&#125;.a;   &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line">function()&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token (</span><br><span class="line">&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line"></span><br><span class="line">“&#123;&#125;.toString();” 等同于: “; .toString();” 未通过对象主体调用“toString”方法，不符合JS中期待的表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Object-assign-JSON-stringify是深拷贝吗"><a href="#Object-assign-JSON-stringify是深拷贝吗" class="headerlink" title="Object.assign, JSON.stringify是深拷贝吗"></a>Object.assign, JSON.stringify是深拷贝吗</h1><p>不是的话怎么解决</p>
<p>shallowCopy（浅拷贝）或 deepCopy（深拷贝）</p>
<p>深拷贝造成了 CPU 和内存的浪费</p>
<p>深拷贝如果是只有最底层一个元素改变，会造成性能影响，怎么解决? immutable</p>
<p>Object.assign()可以对非嵌套对象进行深拷贝的方法,<br>如果对象中出现嵌套情况,那么其对被嵌套对象的行为就成了普通的浅拷贝.<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。</p>
<p>对象解构运算，也是浅拷贝。</p>
<p>JSON对象中包含两个方法, stringify()和parse(),前者可以将对象JSON化,而后者可以将JSON格式转换为对象.这是一种可以实现深拷贝的方法.<br>但这种方法的缺陷是会破坏原型链,并且无法拷贝属性值为function的属性<br>所以如果只是想单纯复制一个嵌套对象,可以使用此方法</p>
<p>缺点是你创建一个临时的，可能很大的字符串，只是为了把它重新放回解析器。另一个缺点是这种方法不能处理循环对象。而且循环对象经常发生。例如，当您构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const x &#x3D; &#123;&#125;;</span><br><span class="line">const y &#x3D; &#123;x&#125;;</span><br><span class="line">x.y &#x3D; y; &#x2F;&#x2F; Cycle: x.y.x.y.x.y.x.y.x...</span><br><span class="line">const copy &#x3D; JSON.parse(JSON.stringify(x)); &#x2F;&#x2F; throws!</span><br><span class="line"></span><br><span class="line">let bar &#x3D; JSON.parse(JSON.stringify(foo));</span><br><span class="line">Object.assign(&#123;&#125;, foo);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a: 0,</span><br><span class="line">    b: 20,</span><br><span class="line">&#125;</span><br><span class="line">obj &#x3D; &#123;...obj, a: obj.a + 1&#125;</span><br><span class="line"></span><br><span class="line">Structured Clone 结构化克隆算法</span><br><span class="line">MessageChannel</span><br><span class="line">缺点是它是异步的。虽然这并无大碍，</span><br><span class="line">但是有时候你需要使用同步的方式来深度拷贝一个对象</span><br><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;port1, port2&#125; &#x3D; new MessageChannel();</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#x2F;* ... *&#x2F;;</span><br><span class="line">const clone &#x3D; await structuralClone(obj);</span><br></pre></td></tr></table></figure>

<p>es7 … 的方式<br>直接{…obj}赋值属于浅复制，在修改值时{…obj,a:1}就起到了类深复制的效果<br>更新一个 Object</p>
<h3 id="immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"><a href="#immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发" class="headerlink" title="immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"></a>immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发</h3><p> <a href="https://github.com/camsong/blog/issues/3">链接</a></p>
<p> Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。</p>
<p>为什么immutable比较两个对象不同会快？原因如下：<br>和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。用法：is(map1,map2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是原来的 reducer：</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    newState &#x3D; Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        apples: [</span><br><span class="line">            ...state.apples.slice(0, action.payload),</span><br><span class="line">            Object.assign(&#123;&#125;, state.apples[action.payload], &#123; isEaten: true &#125;),</span><br><span class="line">            ...state.apples.slice(action.payload + 1)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">    return newState;</span><br><span class="line"></span><br><span class="line">这是使用 immutable.js 库的reducer :</span><br><span class="line"></span><br><span class="line">import &#123; fromJS &#125; from &#39;immutable&#39;;</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    return fromJS(state).setIn([&#39;apples&#39;,action.payload,&#39;isEaten&#39;], true).toJS();</span><br><span class="line"></span><br><span class="line">团队约定 state 都用 immutable 内部的数据类型，就可以连 fromJS 和 toJS 的转化都省了，超级方便！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="JSONP-后端返回alert-data-，前端会执行吗"><a href="#JSONP-后端返回alert-data-，前端会执行吗" class="headerlink" title="JSONP 后端返回alert(data)，前端会执行吗"></a>JSONP 后端返回alert(data)，前端会执行吗</h1><p>因为后端把回调方法名转成另一个名字将data包在里边，所以不会执行alert。</p>
<p>为什么是jsonp, img, iframe也可以，为什么？</p>
<p>jsonp全名叫做json with padding<br>函数调用，数据都被包裹传递到参数中了，</p>
<p>将服务端的数据用padding包起来，所谓的padding就相当于一个函数。假设我们原来有数据 {“data”,”something”}，用一个名为callback的padding包起来之后 就成了 callback({“data”:”something”})，这样将script标签加载完毕之后，会立马执行这个函数，并将数据当做参数传了进去。如果我们可以事先在前端事先指定一个函数名，并定义这个函数。然后告诉后端，用这个函数名作为padding包裹数据。那么当前端动态创建script标签之后，script加载完毕了就会执行这个函数，这样我们就成功的跨域获得了数据~</p>
<p>从开发者工具里面可以看到实际发送的请求</p>
<p>Request URL:<a href="https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924">https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924</a></p>
<p>这里可以看出来jQuery自动生成的padding是jsonp1430727166924返回的数据：;jsonp1430727166924({“rating”:{“max”:10,”numRaters”:336,”average”:”7.0”,”min”:0},”price”:”15.00元”});</p>
<h1 id="js-css执行顺序，并行串行，阻塞"><a href="#js-css执行顺序，并行串行，阻塞" class="headerlink" title="js,css执行顺序，并行串行，阻塞"></a>js,css执行顺序，并行串行，阻塞</h1><p><a href="http://blog.jobbole.com/12749/">链接</a><br>DOM文档的加载顺序是由上而下的顺序加载；</p>
<p>1、DOM加载到link标签</p>
<p>==css文件的加载是与DOM的加载并行的==，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；</p>
<p>2、DOM加载到script标签</p>
<p>由于==js文件不会与DOM并行加载==，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；</p>
<p>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现；</p>
<p>所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。至到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。</p>
<p>嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。</p>
<p>浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>
<p>3、解决方法</p>
<p>前提，js是外部脚本；</p>
<p>在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；</p>
<p>在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；</p>
<p>同时使用defer和async属性时，defer属性会失效；</p>
<p>可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。</p>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;十进制转其他</span><br><span class="line">var x&#x3D;110;  </span><br><span class="line">alert(x);</span><br><span class="line">alert(x.toString(8));  </span><br><span class="line">alert(x.toString(32));  </span><br><span class="line">alert(x.toString(16));  </span><br><span class="line">&#x2F;&#x2F;其他转十进制</span><br><span class="line">var x&#x3D;&#39;110&#39;;</span><br><span class="line">alert(parseInt(x,2));  </span><br><span class="line">alert(parseInt(x,8));  </span><br><span class="line">alert(parseInt(x,16));  </span><br><span class="line">&#x2F;&#x2F;其他转其他  </span><br><span class="line">&#x2F;&#x2F;先用parseInt转成十进制再用toString转到目标进制  </span><br><span class="line">alert(String.fromCharCode(parseInt(141,8)))  </span><br><span class="line">alert(parseInt(&#39;ff&#39;,16).toString(2));  </span><br></pre></td></tr></table></figure>

<h1 id="两个对象判断"><a href="#两个对象判断" class="headerlink" title="两个对象判断=="></a>两个对象判断==</h1><p>引用下温特大大的总结就是：<br>只要记住 null 只和undefined 相等，<br>有 number 都转 number，<br>有 boolean 也转 number，<br>有 string 都转 string，<br>对象互相不等，<br>NaN 互相不等就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log([] &#x3D;&#x3D; []) &#x2F;&#x2F; false</span><br><span class="line">console.log(![] &#x3D;&#x3D; false) &#x2F;&#x2F; false</span><br><span class="line">console.log([] &#x3D;&#x3D; false) &#x2F;&#x2F; true</span><br><span class="line">console.log(!!&#39;hello&#39;) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;hello&#39; &#x3D;&#x3D; true) &#x2F;&#x2F; &#39;hello&#39;&#x3D;&#x3D;1  false</span><br><span class="line">console.log(typeof(typeof(&#39;hello&#39;)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typeof的运算数未定义,返回的就是 “undefined”.</span><br><span class="line"></span><br><span class="line">运算数为数字 typeof(x) &#x3D; “number”</span><br><span class="line"></span><br><span class="line">字符串 typeof(x) &#x3D; “string”</span><br><span class="line"></span><br><span class="line">布尔值 typeof(x) &#x3D; “boolean”</span><br><span class="line"></span><br><span class="line">对象,数组和null typeof(x) &#x3D; “object”</span><br><span class="line"></span><br><span class="line">函数 typeof(x) &#x3D; “function”</span><br></pre></td></tr></table></figure>

<h1 id="FOUC无样式内容闪烁"><a href="#FOUC无样式内容闪烁" class="headerlink" title="FOUC无样式内容闪烁"></a>FOUC无样式内容闪烁</h1><p>Flash of Uncompiled Content</p>
<p>原因大致为： 1，使用import方法导入样式表。 2，将样式表放在页面底部 3，有几个样式表，放在html结构的不同位置。</p>
<p>解决方法： 使用LINK标签将样式表放在文档HEAD中。</p>
<ol>
<li><p>v-cloak</p>
</li>
<li><p>用v-text</p>
</li>
<li><p>v-if, v-show</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- same as --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// <span class="tag">&lt;<span class="name">div</span>&gt;</span> 不会显示，直到编译结束。</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="js实现jQuery-clone"><a href="#js实现jQuery-clone" class="headerlink" title="js实现jQuery.clone"></a>js实现jQuery.clone</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逐级递归；</span><br><span class="line"></span><br><span class="line">递归中收集每个元素的全部信息，包括该元素上绑定的所有事件。</span><br><span class="line"></span><br><span class="line">复制时候重现按照获得的事件列表逐个加载回去。</span><br><span class="line"></span><br><span class="line">除此之外主要可能是考虑各种兼容，</span><br><span class="line">包括cloneNode方法的兼容，</span><br><span class="line">获取元素属性时候的某些标签的兼容。</span><br></pre></td></tr></table></figure>

<h1 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h1><p>（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。</p>
<h1 id="ajax参数"><a href="#ajax参数" class="headerlink" title="ajax参数"></a>ajax参数</h1><p><a href="https://www.cnblogs.com/huiyuantang/p/5458278.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.url: 发送请求的地址</span><br><span class="line">2.type: 请求方式（post或get</span><br><span class="line">3.timeout: 请求超时时间（毫秒）</span><br><span class="line">4.async: 默认设置为true，异步请求</span><br><span class="line">5.cache: 从浏览器缓存中加载请求信息</span><br><span class="line">6.data: 发送到服务器的数据</span><br><span class="line">7.dataType: xml,html, json,text</span><br><span class="line">8.beforeSend：发送请求前，执行一些操作</span><br><span class="line">9.complete：完成后调用的回调函数</span><br><span class="line">10.success：请求成功后调用的回调函数</span><br><span class="line">11.error:</span><br><span class="line">12.contentType：</span><br><span class="line">13.dataFilter：</span><br><span class="line"></span><br><span class="line">16.ifModified：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;闭包限定命名空间</span><br><span class="line">(function ($) &#123;</span><br><span class="line">    $.fn.extend(&#123;</span><br><span class="line">        &quot;highLight&quot;:function(options)&#123;</span><br><span class="line">            &#x2F;&#x2F;do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(window.jQuery);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">$(&quot;p&quot;).highLight(); &#x2F;&#x2F;调用自定义 高亮插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="exports-module-exports区别"><a href="#exports-module-exports区别" class="headerlink" title="exports, module.exports区别"></a>exports, module.exports区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports</span><br><span class="line"></span><br><span class="line">exports在module.exports 被改变后，失效。</span><br><span class="line"></span><br><span class="line">1. module.exports 初始值为一个空对象 &#123;&#125;</span><br><span class="line">2. exports 是指向的 module.exports 的引用</span><br><span class="line">3. require() 返回的是 module.exports 而不是 exports</span><br></pre></td></tr></table></figure>

<h1 id="上传文件方式"><a href="#上传文件方式" class="headerlink" title="上传文件方式"></a>上传文件方式</h1><ul>
<li><p>form表单上传文件</p>
  <form action="/test/" method="POST" enctype="multipart/form-data">
</li>
<li><p>原生js实现ajax上传文件<br>   var xml=new XMLHttpRequest();</p>
<p>  var data=new FormData; //创建formdata对象</p>
<p>  data.append(“testfile”,document.getElementById(“file_upload”).files[0]);//找到对象之后的file[0]对应的就是文件对象</p>
<p>  xml.open(“POST”,”/test/“,true);</p>
</li>
<li><p>jquery实现ajax上传文件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data&#x3D;new FormData;</span><br><span class="line">data.append(&quot;testfile&quot;,document.getElementById(&quot;file_upload&quot;).files[0]);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;&#x2F;test&#x2F;&quot;,</span><br><span class="line">    type:&quot;POST&quot;,</span><br><span class="line">    dataType:&quot;JSON&quot;,</span><br><span class="line">    data:data,</span><br><span class="line">    contentType: false,</span><br><span class="line">    processData: false,</span><br><span class="line">    success:function(rst)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>form+iframe上传文件</p>
<h1 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h1><p> @mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin通过 @include来调用。</p>
<p> @mixin通过 @include调用后解析出来的样式是以拷贝形式存在的，而继承则是以联合声明的方式存在的，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;sass style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">@mixin center-block &#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br><span class="line">.demo&#123;</span><br><span class="line">    @include center-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;css style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">.demo&#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，session 在服务器端，</span><br><span class="line">    cookie 在客户端（浏览器）</span><br><span class="line">2，session 默认被存在在服务器</span><br><span class="line">    的一个文件里（不是内存）</span><br><span class="line">3，session 的运行依赖 session id，</span><br><span class="line">    而 session id 是存在 cookie 中的，</span><br><span class="line">    也就是说，如果浏览器禁用了 cookie ，</span><br><span class="line">    同时 session 也会失效</span><br><span class="line">    （但是可以通过其它方式实现，</span><br><span class="line">    比如在 url 中传递 session_id）</span><br><span class="line">4，session 可以放在 文件、数据库、或内存中都可以。</span><br><span class="line">5，用户验证这种场合一般会用 session</span><br><span class="line">因此，维持一个会话的核心就是</span><br><span class="line">客户端的唯一标识，即 session id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="AMD-CMD-CommonJS"><a href="#AMD-CMD-CommonJS" class="headerlink" title="AMD, CMD, CommonJS"></a>AMD, CMD, CommonJS</h1><p>==记忆方法==</p>
<p>AR<br>AMD– require.js</p>
<p>CS<br>CMD– sea.js</p>
<p>A AMD A在前，提前加载</p>
<p>C CMD C在后，延迟加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node的module遵循CommonJS规范，</span><br><span class="line">requirejs遵循AMD，seajs遵循CMD，</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------- node -----------</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  a : function() &#123;&#125;,</span><br><span class="line">  b : &#39;xxx&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------- AMD or CMD ----------------</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  module.exports &#x3D; &#123;</span><br><span class="line">    a : function() &#123;&#125;,</span><br><span class="line">    b : &#39;xxx&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。</span><br><span class="line">它采用异步方式加载模块，模块的加载不影响它后面语句的运行。</span><br><span class="line">所有依赖这个模块的语句，都定义在一个回调函数中，</span><br><span class="line">等到加载完成之后，这个回调函数才会运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line"></span><br><span class="line">1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</span><br><span class="line">不过 RequireJS 从 2.0 开始，</span><br><span class="line">也改成可以延迟执行（根据写法不同，处理方式不同）。</span><br><span class="line">CMD 推崇 as lazy as possible.</span><br><span class="line"></span><br><span class="line">2. CMD 推崇依赖就近，AMD 推崇依赖前置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="import引入模块"><a href="#import引入模块" class="headerlink" title="import引入模块"></a>import引入模块</h3><p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>注意:import必须放在文件的最开始.import命令是编译阶段执行的，在代码运行之前,表达式和变量只有在运行时才能得到结果的语法结构。import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）所以import中不能含有表达式或者变量,因此无法实现动态加载.<br>因此，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。<br>这样的设计，有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br></pre></td></tr></table></figure>

<h1 id="position取值"><a href="#position取值" class="headerlink" title="position取值"></a>position取值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ralative是指相对定位</span><br><span class="line">元素仍保持其未定位前的形状，它原本所占的空间仍保留。</span><br><span class="line"></span><br><span class="line">absolute是指绝对定位</span><br><span class="line">    即完全离开文档流, 相关于position属性非static值的比来父级元素进行偏移。</span><br><span class="line">    如果不存在这样的父对象，则依据body对象。而其层叠通过z-index属性定义</span><br><span class="line">fixed: 固定定位</span><br><span class="line">    固定定位：即完全离开文档流，相关于视区进行偏移。</span><br><span class="line">static：元素框正常生成</span><br><span class="line">inherit：继承值，对象将继承其父对象相应的值。</span><br></pre></td></tr></table></figure>

<h1 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="call和apply-bind区别"><a href="#call和apply-bind区别" class="headerlink" title="call和apply, bind区别"></a>call和apply, bind区别</h1><p>这三个参数的返回值区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作用完全一样，唯一的区别就在参数上</span><br><span class="line"></span><br><span class="line">call 接收的参数不固定，</span><br><span class="line">第一个参数是函数体内 this 的指向，</span><br><span class="line">第二个参数以下是依次传入的参数。</span><br><span class="line"></span><br><span class="line">apply接收两个参数，</span><br><span class="line">第一个参数也是函数体内 this 的指向。</span><br><span class="line">第二个参数是一个集合对象（数组或者类数组）</span><br><span class="line"></span><br><span class="line">记忆方法：</span><br><span class="line"></span><br><span class="line">apply ---- array 要传数组</span><br><span class="line">call  ---- 逗号隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三个的使用区别：</span><br><span class="line">都是用来改变函数的this对象的指向的；</span><br><span class="line">第一个参数都是this要指向的对象；</span><br><span class="line">都可以利用后续参数传参；</span><br><span class="line">bind是返回对应函数，便于稍后调用，apply、call是立即调用；</span><br><span class="line">bind（）--也是改变函数体内this的指向;</span><br><span class="line">bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let obj1&#x3D;&#123;</span><br><span class="line">    a:222</span><br><span class="line">&#125;;</span><br><span class="line">let obj2&#x3D;&#123;</span><br><span class="line">    a:111,</span><br><span class="line">    fn:function()&#123;</span><br><span class="line">        alert(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.fn.call(obj1);&#x2F;&#x2F;222</span><br><span class="line"></span><br><span class="line">call 和 apply 两个主要用途就是</span><br><span class="line"></span><br><span class="line">1.改变 this 的指向（把 this 从 obj2 指向到 obj1 ）</span><br><span class="line"></span><br><span class="line">2.方法借用（ obj1 没有 fn ，只是借用 obj2 方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="箭头函数怎么绑定全局this"><a href="#箭头函数怎么绑定全局this" class="headerlink" title="箭头函数怎么绑定全局this"></a>箭头函数怎么绑定全局this</h1><p>箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () &#x3D;&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  &#x2F;&#x2F; undefined window&#123;...&#125;</span><br><span class="line"></span><br><span class="line">作为方法的箭头函数this指向全局window对象，</span><br><span class="line">而普通函数则指向调用它的对象</span><br></pre></td></tr></table></figure>

<h1 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h1><p><a href="http://caibaojian.com/es6-features.html">链接</a></p>
<h1 id="foreach-map-reduce-filter区别"><a href="#foreach-map-reduce-filter区别" class="headerlink" title="foreach, map, reduce, filter区别"></a>foreach, map, reduce, filter区别</h1><h1 id="函数声明-amp-函数表达式的区别"><a href="#函数声明-amp-函数表达式的区别" class="headerlink" title="函数声明&amp;函数表达式的区别"></a>函数声明&amp;函数表达式的区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数声明中函数名是必须的；函数表达式中则是可选的</span><br><span class="line"> &#x2F;&#x2F;函数声明</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(1, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数表达式</span><br><span class="line">&#x2F;* var s &#x3D; function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2)); *&#x2F;</span><br><span class="line"></span><br><span class="line">var s &#x3D; function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2));</span><br><span class="line">&#x2F;&#x2F;以上两种都可以</span><br><span class="line"></span><br><span class="line">二、用函数声明定义的函数,函数可以在函数声明之前调用,而用函数表达式定义的函数只能在声明之后调用。</span><br><span class="line"></span><br><span class="line">【根本原因在于解析器对这两种定义方式读取的顺序不同:解析器会事先读取函数声明，即函数声明放在任意位置都可以被调用；</span><br><span class="line"></span><br><span class="line">对于函数表达式，解析器只有在读到函数表达式所在那行的时候才执行】</span><br><span class="line"></span><br><span class="line">使用var 表达式定义函数， 只有变量声明提前了，变量初始化代码仍然在原来的位置</span><br></pre></td></tr></table></figure>

<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段</p>
<h5 id="addEventListener-evtype-fn-useCapture"><a href="#addEventListener-evtype-fn-useCapture" class="headerlink" title="addEventListener(evtype,fn,useCapture)"></a>addEventListener(evtype,fn,useCapture)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useCapture是true，则事件处理函数在捕获阶段被执行，否则 在冒泡阶段执行</span><br><span class="line"></span><br><span class="line">因为如果被监听的元素没有子元素，那么哪个监听代码写在前面，就先执行哪个！</span><br><span class="line"></span><br><span class="line">&lt;label&gt;Click me &lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#39;label&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;)</span><br><span class="line">    document.querySelector(&#39;input&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">因为label和input是有绑定的</span><br><span class="line">点击label后，浏览器自动帮你再点击一次label</span><br><span class="line">过程就是先进行一次事件机制，这一次对内部input元素的事件监听是不管不问的，所以先打出1</span><br><span class="line">结束后，再进行一次事件机制，这一次，按照正常事件机制流程走，所以接着打出了2,1</span><br></pre></td></tr></table></figure>

<p>阻止冒泡<br>window.event.cancelBubble = true</p>
<p>e.preventDefault();</p>
<p>return false</p>
<p>都能阻止<br> stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。<br>stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡</p>
<h1 id="git-问题"><a href="#git-问题" class="headerlink" title="git 问题"></a>git 问题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git回退到某个commit版本</span><br><span class="line"></span><br><span class="line">git reset --hard commitId</span><br><span class="line">强制提交</span><br><span class="line">git push -f origin master</span><br><span class="line">删除分支</span><br><span class="line">git branch -d branchname  </span><br><span class="line"></span><br><span class="line">git 删除远程分支</span><br><span class="line">git push origin branchname</span><br><span class="line"></span><br><span class="line">rebase 和 merge区别</span><br><span class="line"></span><br><span class="line">rebase，合并的结果好看，一条线，但合并过程中出现冲突的话，比较麻烦（rebase过程中，一个commit出现冲突，下一个commit也极有可能出现冲突，一次rebase可能要解决多次冲突）；merge，合并结果不好看，一堆线交错，但合并有冲突的话，只要解一次就行了；</span><br><span class="line"></span><br><span class="line">commit 粒度把握得好，就直接 merge，把握不好，先 rebase 把粒度调整好了，再 merge。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="let-var-const-区别"><a href="#let-var-const-区别" class="headerlink" title="let var const 区别"></a>let var const 区别</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let 的「创建」过程被提升了，但是初始化没有提升。</span><br><span class="line"></span><br><span class="line">let在未定义之前使用，会报错</span><br><span class="line"></span><br><span class="line">var 的「创建」和「初始化」都被提升了。</span><br><span class="line"></span><br><span class="line">function 的「创建」「初始化」和「赋值」都被提升了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let 声明的变量的作用域是块级的；</span><br><span class="line">let 不能重复声明已存在的变量；</span><br><span class="line">let 有暂时死区，不会被提升。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域</span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) &#123; 循环体 &#125; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mqyqingfeng/Blog">js链接</a></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">链接</a></p>
<p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。</p>
<p>在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>最大用处有两个，<br>一是可以读取函数内部的变量，<br>（创建局部变量，保护局部变量不会被访问和修改）。<br>另一个就是让这些变量的值始终保持在内存中。</p>
<p>闭包常见用途：</p>
<p>创建特权方法用于访问控制<br>事件处理程序及回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let add&#x3D;(function()&#123;</span><br><span class="line">let now&#x3D;0;</span><br><span class="line">return &#123;</span><br><span class="line"> doAdd:function()&#123;</span><br><span class="line">    now++;</span><br><span class="line">    console.log(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">add.doAdd() &#x2F;&#x2F;1</span><br><span class="line">add.doAdd() &#x2F;&#x2F;2</span><br><span class="line">add.doAdd() &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">now 这个变量，并没有随着函数的执行完毕而被回收，</span><br><span class="line">而是继续保存在内存里面。</span><br><span class="line"></span><br><span class="line">由于 add 里面有函数是依赖于 now 这个变量。所以 now 不会被销毁，回收。</span><br><span class="line">由于 now 在外面访问不到</span><br><span class="line"></span><br><span class="line"> var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于方法里有this.name, 这里的this的是window，所以这里是The Window</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that &#x3D; this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line">　　</span><br><span class="line">&#x2F;&#x2F; 这里的that指向object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(typeof Array.isArray&#x3D;&#x3D;&#x3D;&quot;undefined&quot;)&#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg)&#123;</span><br><span class="line">        return Object.prototype.toString.call(arg)&#x3D;&#x3D;&#x3D;&quot;[object Array]&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="找出数组中的最大值"><a href="#找出数组中的最大值" class="headerlink" title="找出数组中的最大值"></a>找出数组中的最大值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;Math.max.apply(null,a);</span><br><span class="line">console.log(max);</span><br><span class="line">&#x2F;&#x2F;第二种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;eval(&#39;Math.max(&#39;+a.toString()+&#39;)&#39;);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">Math.max(...[-1, 5, 11, 3])</span><br><span class="line"> Math.max.apply(Math, [-1, 5, 11, 3])</span><br></pre></td></tr></table></figure>

<h1 id="Javascript的this用法"><a href="#Javascript的this用法" class="headerlink" title="Javascript的this用法"></a>Javascript的this用法</h1><p><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">链接</a><br><a href="http://blog.csdn.net/yangbingbinga/article/details/61424363">链接2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this是Javascript语言的一个关键字。</span><br><span class="line"></span><br><span class="line">它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</span><br><span class="line"></span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window</p>
<p>问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢?</p>
<p>用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针!</p>
<p>也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  test: function() &#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(this.a);</span><br><span class="line">    &#125;.bind(this), 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.test();  &#x2F;&#x2F;  2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setTimeout不止两个参数</span><br><span class="line">setTimeout(function(a, b)&#123;</span><br><span class="line">  console.log(a);   &#x2F;&#x2F; 3</span><br><span class="line">  console.log(b);   &#x2F;&#x2F; 4</span><br><span class="line">&#125;,0, 3, 4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">箭头函数比较特殊，没有自己的this，它使用封闭执行上下文(函数或是global)的 this 值。</span><br><span class="line"></span><br><span class="line">var x&#x3D;11;</span><br><span class="line">var obj&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say:()&#x3D;&gt;&#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();&#x2F;&#x2F; 11</span><br><span class="line">obj.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 11</span><br><span class="line">x &#x3D; 14</span><br><span class="line">obj.say() &#x2F;&#x2F; 14</span><br><span class="line">&#x2F;&#x2F;对比一下</span><br><span class="line">var obj2&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say() &#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.say();&#x2F;&#x2F; 22</span><br><span class="line">obj2.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 13</span><br></pre></td></tr></table></figure>

<h3 id="一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global"><a href="#一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global" class="headerlink" title="一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global"></a>一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global</h3><p>在严格模式下，默认绑定会将 this 指向 undefined</p>
<h3 id="二、作为对象方法的调用-this就指这个上级对象"><a href="#二、作为对象方法的调用-this就指这个上级对象" class="headerlink" title="二、作为对象方法的调用    this就指这个上级对象"></a>二、作为对象方法的调用    this就指这个上级对象</h3><h3 id="三-作为构造函数调用"><a href="#三-作为构造函数调用" class="headerlink" title="三 作为构造函数调用"></a>三 作为构造函数调用</h3><p>   所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
<h3 id="四-apply调用"><a href="#四-apply调用" class="headerlink" title="四 apply调用"></a>四 apply调用</h3><p>  this指的就是这第一个参数。<br>  apply()的参数为空时，默认调用全局对象。</p>
<h3 id="五-this指向绑定事件的dom元素"><a href="#五-this指向绑定事件的dom元素" class="headerlink" title="五 this指向绑定事件的dom元素"></a>五 this指向绑定事件的dom元素</h3><p>document.querySelector(“#id”).onclick =function(){<br>    this == document.querySelector(“#id”)<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(!(&quot;a&quot; in window))&#123;</span><br><span class="line">    var a &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; window.hasOwnProperty(&quot;a&quot;) &#x3D;&#x3D;&#x3D; true ..</span><br><span class="line">&#x2F;&#x2F;不用多说了. a 还真存在原型链上</span><br><span class="line">&#x2F;&#x2F; 值是 Location 这个 API 的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">console.log(typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; true , 这个不用解释了</span><br><span class="line"></span><br><span class="line">console.log(!!typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及到就是优先级和布尔值的问题</span><br><span class="line">&#x2F;&#x2F; typeof count 就是字符串&quot;number&quot;</span><br><span class="line">&#x2F;&#x2F; !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true</span><br><span class="line">&#x2F;&#x2F; 最后才&#x3D;&#x3D;&#x3D; 比较 , true &#x3D;&#x3D;&#x3D; &quot;number&quot; , return false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var a &#x3D; b &#x3D; 3;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(typeof a &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(&#x3D;号自左向右)</span><br><span class="line">&#x2F;&#x2F; 那个函数可以拆成这样</span><br><span class="line"></span><br><span class="line">(function()</span><br><span class="line">  var a; &#x2F;* 局部变量,外部没法访问*&#x2F;</span><br><span class="line">  b &#x3D; 3; &#x2F;* 全局变量,so . window.b &#x3D;&#x3D;&#x3D; 3 , 外部可以访问到*&#x2F;</span><br><span class="line">  a &#x3D; b;</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 注意a只有在闭包里才能访问(a&#x3D;3)，在外部是undefined  !!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若是改成这样,这道题应该是对的</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D;3</span><br><span class="line">); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">  this.a &#x3D; something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(2)</span><br><span class="line"></span><br><span class="line">console.log(obj1.a) &#x2F;&#x2F; 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2,3); &#x2F;&#x2F; 用 call 强行改变上下文为 obj2内</span><br><span class="line">console.log(obj2.a); &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">var  bar &#x3D; new obj1.foo(4); &#x2F;&#x2F; 这里产生了一个实例</span><br><span class="line">console.log(obj1.a); &#x2F;&#x2F; 2</span><br><span class="line">console.log(bar.a); &#x2F;&#x2F; 4;  new的绑定比隐式和显式绑定优先级更高</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-设计模式你了解多少"><a href="#Q-设计模式你了解多少" class="headerlink" title="Q: 设计模式你了解多少"></a>Q: 设计模式你了解多少</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cnblogs.com&#x2F;tugenhua0707&#x2F;p&#x2F;5198407.html</span><br></pre></td></tr></table></figure>

<h1 id="Q-JS-的基本数据类型有哪些"><a href="#Q-JS-的基本数据类型有哪些" class="headerlink" title="Q: JS 的基本数据类型有哪些"></a>Q: JS 的基本数据类型有哪些</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object</span><br><span class="line">Undefined</span><br><span class="line">Null</span><br><span class="line">Number</span><br><span class="line">Boolean</span><br><span class="line">String</span><br><span class="line">Symbol (ECMAScript 6 新定义)</span><br><span class="line"></span><br><span class="line"> 5 种原始类型即</span><br><span class="line"> Undefined</span><br><span class="line"> Null</span><br><span class="line"> Number</span><br><span class="line"> Boolean</span><br><span class="line"> String</span><br><span class="line"></span><br><span class="line"> 除了Object和Symbol不是，其他都是</span><br></pre></td></tr></table></figure>

<h1 id="Q-null-和-undefined-的差异"><a href="#Q-null-和-undefined-的差异" class="headerlink" title="Q: null 和 undefined 的差异"></a>Q: null 和 undefined 的差异</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大体说一下,想要知其所以然请引擎搜索</span><br><span class="line"></span><br><span class="line">相同点:</span><br><span class="line"></span><br><span class="line">在 if 判断语句中,值都默认为 false</span><br><span class="line">大体上两者都是代表 无 ,具体看差异</span><br><span class="line">差异:</span><br><span class="line"></span><br><span class="line">null 转为数字类型值为0,而 undefined 转为数字类型为 NaN(Not a Number)</span><br><span class="line">undefined 是代表调用一个值而该值却没有赋值,这时候默认则为 undefined</span><br><span class="line">null 是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)</span><br><span class="line">设置为 null 的变量或者对象会被内存收集器回收</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-清除浮动的方式有哪些-比较好的是哪一种"><a href="#Q-清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="Q: 清除浮动的方式有哪些?比较好的是哪一种"></a>Q: 清除浮动的方式有哪些?比较好的是哪一种</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用的一般为三种 .clearfix , clear:both , overflow:hidden ;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  content:&quot;&quot;;&#x2F;&#x2F;设置内容为空</span><br><span class="line">　height:0;&#x2F;&#x2F;高度为0</span><br><span class="line">　line-height:0;&#x2F;&#x2F;行高为0</span><br><span class="line">　display:block;&#x2F;&#x2F;将文本转为块级元素</span><br><span class="line">　visibility:hidden;&#x2F;&#x2F;将元素隐藏</span><br><span class="line">　clear:both&#x2F;&#x2F;清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另一种写法</span><br><span class="line"></span><br><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line"> content:&quot;&quot;;</span><br><span class="line"> display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line"> clear:both;</span><br><span class="line"> overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;&#x2F;&#x2F; 为了兼容IE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">用display:table 是为了避免外边距margin重叠导致的margin塌陷,</span><br><span class="line">内部元素默认会成为 table-cell 单元格的形式</span><br><span class="line">--&gt;</span><br><span class="line">clear:both :若是用在同一个容器内相邻元素上,那是贼好的...有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</span><br><span class="line"></span><br><span class="line">overflow:hidden :这种若是用在同个容器内,可以形成 BFC 避免浮动造成的元素塌陷</span><br></pre></td></tr></table></figure>

<h1 id="Q-跨域问题"><a href="#Q-跨域问题" class="headerlink" title="Q: 跨域问题"></a>Q: 跨域问题</h1><p><a href="https://www.imooc.com/article/21976">详情</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我一般用这三种, cors , nginx反向代理 , jsonp</span><br><span class="line"></span><br><span class="line">jsonp : 单纯的 get 一些数据,局限性很大...就是利用script标签的src属性来实现跨域。</span><br><span class="line"></span><br><span class="line">浏览器支持好</span><br><span class="line">调用失败不会返回各种HTTP状态码</span><br><span class="line">给后端传json格式的数据会报415错误，请求格式不正确</span><br><span class="line">callback添加恶意script标签，造成xss漏洞</span><br><span class="line">只能够实现get请求</span><br><span class="line">参数可见</span><br><span class="line"></span><br><span class="line">nginx 反向代理 : 主要就是用了 nginx.conf 内的 proxy_pass http:&#x2F;&#x2F;xxx.xxx.xxx</span><br><span class="line">,会把所有请求代理到那个域名,有利也有弊吧..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cors</span><br><span class="line"></span><br><span class="line">可控性较强,需要前后端都设置,兼容性 IE10+ ,</span><br><span class="line">CORS需要浏览器和服务器同时支持。IE8+：IE8&#x2F;9需要使用XDomainRequest对象来支持CORS。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example &#x2F;&#x2F; 子域乃至整个域名或所有域名是否允许访问</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS &#x2F;&#x2F; 允许那些行为方法</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type &#x2F;&#x2F; 允许的头部字段</span><br><span class="line">Access-Control-Max-Age: 86400 &#x2F;&#x2F; 有效期</span><br><span class="line">cros 的配置不仅仅这些,还有其他一些,具体引擎吧....</span><br><span class="line"></span><br><span class="line">若是我们要用 nginx 或者 express 配置 cors 应该怎么搞起? 来个简易版本的</span><br><span class="line"></span><br><span class="line">nginx</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   # 检查域名后缀</span><br><span class="line">    add_header Access-Control-Allow-Origin xx.xx.com;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;</span><br><span class="line">    add_header Access-Control-Max-Age 86400;</span><br><span class="line">&#125;</span><br><span class="line">express, 当然这货也有一些别人封装好的 cors 中间件,操作性更强...</span><br><span class="line">let express &#x3D; require(&#39;express&#39;);  </span><br><span class="line">let app &#x3D; express();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置所有请求的头部</span><br><span class="line">app.all(&#39;*&#39;, (req, res, next) &#x3D;&gt;  &#123;  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  </span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br><span class="line">有些还会跟你死磕,,除了这些还有其他姿势么...我说了一个HTML5的 postMessage ....</span><br><span class="line"></span><br><span class="line">..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下</span><br><span class="line"></span><br><span class="line">这货用于 iframe 传递消息居多, 大体有这么两步步</span><br><span class="line"></span><br><span class="line">window 打开一个实例,传递一个消息到一个x域名</span><br><span class="line">x 域名下监听 message 事件,获取传递的消息</span><br><span class="line">这货的兼容性没那么好,而且没考虑周全的下容易遭受 CSRF 攻击</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-对于XSS-和-CSRF-如何防范"><a href="#Q-对于XSS-和-CSRF-如何防范" class="headerlink" title="Q: 对于XSS 和 CSRF 如何防范"></a>Q: 对于XSS 和 CSRF 如何防范</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> XSS主要是指跨脚本攻击, 其实就相当于执行js脚本.</span><br><span class="line"></span><br><span class="line">XSS的防范</span><br><span class="line"></span><br><span class="line">1. 验证用户输入的内容, 是否符合规则.</span><br><span class="line">2. 转义 &lt;&gt; 造成代码直接运行的的标签..</span><br><span class="line">    轮询或者正则替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而面试官说这种的效率最低下,找相关资料</span><br><span class="line">若是有用到 cookie ,设置为 http-only ,避免客户端的篡改</span><br><span class="line"></span><br><span class="line">CSP(Content Security Policy)</span><br><span class="line">以白名单的机制对网站加载或执行的资源起作用。</span><br><span class="line">在网页中，这样的策略通过 HTTP 头信息或者 meta</span><br><span class="line">元素定义。CSP虽然提供了强大的安全保护，</span><br><span class="line">但是他也造成了如下问题：Eval及相关函数被禁用、</span><br><span class="line">内嵌的JavaScript代码将不会执行、</span><br><span class="line">只能通过白名单来加载远程脚本。</span><br><span class="line"></span><br><span class="line">CSRF跨域假冒请求</span><br><span class="line"></span><br><span class="line">有3个特性: 跨域, cookie, 请求方式.</span><br><span class="line">CSRF的防范一般这几种</span><br><span class="line"></span><br><span class="line">验证码,用户体验虽然不好,</span><br><span class="line">验证 HTTP Referer 字段,判断请求来源</span><br><span class="line">token加密解密 ,前端和后台双方协定一个token内容</span><br><span class="line"></span><br><span class="line">尽量使用JSON类型传输</span><br><span class="line">    form 传输的格式为:</span><br><span class="line">    Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">    而,JSON的传输类型为:</span><br><span class="line">    Content-Type: application&#x2F;json form</span><br><span class="line">    没有办法去模仿JSON类型进行传输</span><br><span class="line"></span><br><span class="line">DNS劫持, 事实上更偏向于User</span><br><span class="line">    developer实际上对这个也无能为力。</span><br><span class="line"></span><br><span class="line">HTTP(ISP) 劫持</span><br><span class="line">    使用HTTPS 加密方式传输</span><br><span class="line">    替换你的js的提供商，使用HTTPS路径进行加载。</span><br><span class="line"></span><br><span class="line">验证码造成的体验不好,</span><br><span class="line">token 滥用造成的性能问题,轮询替换造成的响应时间等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-谈谈你对-Promise-的理解-和-ajax-有关系么"><a href="#Q-谈谈你对-Promise-的理解-和-ajax-有关系么" class="headerlink" title="Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么"></a>Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么</h1><p><a href="http://imweb.io/topic/57a0760393d9938132cc8da9">链接</a></p>
<p>promise 是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>异步操作队列化，比传统的异步操作回调函数和事件更合理更强大。</p>
<p>能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p>
<p>==Promise对象三种状态：==</p>
<p>Pending（进行中）<br>Fulfilled（已完成，又称为Resolved）<br>Rejectd（已失败）</p>
<p>一些需要注意的小点,如下</p>
<p>在 Pending 转为另外两种之一的状态时候,状态不可在改变..</p>
<p>Promise 的 then 为异步.而( new Promise() )构造函数内为同步</p>
<p>Promise 的 catch 不能捕获任意情况的错误(比如 then 里面的 setTimout 内手动抛出一个 Error )</p>
<p>Promise 的 resolve 若是传入值而非函数,会发生值穿透的现象</p>
<p>Promise 还有一些自带的方法,比如 race , all ,前者有任一一个解析完毕就返回,后者所有解析完毕返回…</p>
<p>==Promise 方法：==</p>
<p>then： 用链式调用的方式执行回调函数。通过 resolve 方法把 Promise 的状态置为完成态（Resolved），这时 then 方法就能捕捉到变化，并执行“成功”情况的回调。<br>then方法返回的是一个新的Promise实例</p>
<p>reject： 把 Promise 的状态置为已失败（Rejected），这时 then 方法执行“失败”情况的回调</p>
<p>catch：和 then 的第二个参数一样，用来指定 reject 的回调   当执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么也不会报错卡死 js，而是会进到这个 catch 方法中。</p>
<p>all:  提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p>
<ul>
<li><p>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。</p>
</li>
<li><p>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
</li>
</ul>
<p>race:只要有一个异步操作执行完毕，就立刻执行 then 回调。<br>注意：其它没有执行完毕的异步操作仍然会继续执行，而不是停止。</p>
<h3 id="Promise对象两个特点"><a href="#Promise对象两个特点" class="headerlink" title="Promise对象两个特点"></a>Promise对象两个特点</h3><ol>
<li><p>对象状态只由异步操作结果决定。resolve方法会使Promise对象由pendding状态变为fulfilled状态；reject方法或者异常会使得Promise对象由pendding状态变为rejected状态。Promise状态变化只有上图这两条路径。</p>
</li>
<li><p><strong>对象状态一旦改变，任何时候都能得到这个结果。</strong> 即状态一旦进入fulfilled或者rejected，promise便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。</p>
</li>
<li><p>Promise构造方法接受一个方法作为参数，该方法传入两个参数，resolve和reject。</p>
</li>
<li><p>resolve用来将Promise对象的状态置为成功，并将异步操作结果value作为参数传给成功回调函数。</p>
</li>
<li><p>reject用来将Promise对象的状态置为失败，并将异步操作错误error作为参数传给失败回调函数。</p>
</li>
<li><p>then方法绑定两个回调函数，第一个用来处理Promise成功状态，第二个用来处理Promise失败状态。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Promise 和 ajax 没有直接关系. promise 只是为了解决&quot;回调地狱&quot;</span><br><span class="line">Promise 并不能消灭回调地狱，但是它可以使回调变得可控。</span><br><span class="line"></span><br><span class="line">异步回调的问题：</span><br><span class="line"></span><br><span class="line">嵌套层次深，难以维护</span><br><span class="line">无法正常使用return和catch throw</span><br><span class="line">多个回调之间难以建立联系，一个回调函数一旦开启，就无法对其操作</span><br><span class="line">无法正常索引堆栈信息</span><br><span class="line"></span><br><span class="line">从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... some code</span><br><span class="line">    if ( &#x2F;* 异步操作成功 *&#x2F; ) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">模拟回调函数</span><br><span class="line">function runAsync(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行完成&#39;);</span><br><span class="line">        callback(&#39;随便什么数据&#39;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getUserAdmin()</span><br><span class="line">    .then(getProjects)</span><br><span class="line">    .then(getModules)</span><br><span class="line">    .then(getInterfaces)</span><br><span class="line">    .then(procResult)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a>Promise 必知必会（十道题）</h1><p><a href="https://juejin.im/post/5a04066351882517c416715d">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># Generator 函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;cnodejs.org&#x2F;topic&#x2F;542953d42ca9451e1bf3c251)</span><br><span class="line"></span><br><span class="line">Generator 函数是一个普通函数，但是有两个特征。</span><br><span class="line"></span><br><span class="line">一是，function关键字与函数名之间有一个星号；</span><br><span class="line"></span><br><span class="line">二是，函数体内部使用yield语句，定义不同的内部状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br>}<br>var hw = helloWorldGenerator();</p>
<p>const gen = function* () {<br>  const f1 = yield readFile(‘/etc/fstab’);<br>  const f2 = yield readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>写成async函数，就是下面这样。</p>
<p>const asyncReadFile = async function () {<br>  const f1 = await readFile(‘/etc/fstab’);<br>  const f2 = await readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。<br>以后，每次调用遍历器对象的next方法，<br>就会返回一个有着value和done两个属性的对象。<br>value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；<br>done属性是一个布尔值，表示是否遍历结束。</p>
<p>上面已经介绍了说yield是暂停标志，下面对yield进行一些介绍：</p>
<p>（1）、yield后面的表达式只有当调用next时，才会执行yield后面的表达式。</p>
<p>（2）、yield表达式只能写在Generator函数中 ，而不能写在普通的函数中。</p>
<p>（3）、yield表达式如果与其他表达式相结合，必须写在()里面。</p>
<p>yield与return的异同点：</p>
<p>相同点：都可以返回紧跟后面表达式的值</p>
<p>不同点：<br>(a)、在一个函数内部只能存在一个return语句，而可以存在多个yield语句；<br>(b)、return没有记忆功能，在Generator函数中只有当遍历器对象调用next时<br>    才会返回yield后面表达式的值，<br>    当下一次调用时从上一条yield语句后开始执行，<br>    而return后面的表达式只要函数执行就立即返回。<br>(c)、正常函数只有一个返回值，而Generator函数可以有多个返回值。</p>
<p>Generator函数被执行时，返回的是指向函数内部的遍历器对象，<br>只有调用遍历器对象的next方法时，才会返回yield后面函数表达式的值，<br>但是，其实yield表达式的值一直都是undefined。<br>如果在Generator的函数中传递参数且存在多个yield表达式时，<br>那么调用next方法时就要注意传参了：<br>next()中传递的参数就是上一个yield表达式的返回值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 面试题网站</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com)</span><br><span class="line"></span><br><span class="line"># 作用域</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数和变量的可访问范围。<br>作用域分为全局作用域  函数作用域和eval作用域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 原型</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dee9f8b14771)</span><br><span class="line"></span><br><span class="line">原型其实就是上述所说的继承中的父类。</span><br><span class="line"></span><br><span class="line">原型链 :利用原型串起一个继承链，让一个引用类型继承另一个引用类型的属性和方法，再以此类推下去.</span><br><span class="line">当一个引用类型继承另一个引用类型的属性和方法时候就会产生一个原型连。</span><br><span class="line">当某个函数当成构造函数来调用时，就会产生一个构造函数的实例。这个实例上会拥有一个 __proto__ 属性，这个属性指向该实例的构造函数的原型对象(也可以称为该实例的原型对象)。</span><br><span class="line"></span><br><span class="line">定律：</span><br><span class="line"></span><br><span class="line">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line"></span><br><span class="line">原型链是依赖于__proto__，而不是prototype</span><br><span class="line"></span><br><span class="line">**实例与原型**</span><br><span class="line"></span><br><span class="line">当读取实例的属性时，</span><br><span class="line">如果找不到，就会查找与对象关联的原型中的属性，</span><br><span class="line">如果还查不到，就去找原型的原型，一直找到最顶层为止。</span><br><span class="line"></span><br><span class="line">通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。</span><br><span class="line"></span><br><span class="line">在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。</span><br><span class="line"></span><br><span class="line"> var A &#x3D; new Person();</span><br><span class="line"> Person.prototype &#x3D; A;</span><br><span class="line"></span><br><span class="line">原型对象（Person.prototype）是 构造函数（Person）的一个实例。↓</span><br><span class="line"></span><br><span class="line">#### Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### person1.__proto__ &#x3D;&#x3D; Person.prototype</span><br><span class="line"></span><br><span class="line">实例的构造函数属性（constructor）指向构造函数。↓</span><br><span class="line"></span><br><span class="line">#### person1.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null</span><br><span class="line"></span><br><span class="line">#### person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### obj.__proto__ &#x3D;&#x3D; Object.getPrototypeOf(obj)</span><br><span class="line"></span><br><span class="line"> 原型和原型链是JS实现继承的一种模型。</span><br><span class="line">原型链的形成是真正是靠__proto__ 而非prototype</span><br><span class="line"></span><br><span class="line">## 什么是原型链</span><br><span class="line"></span><br><span class="line"> 由于__proto__是任何对象都有的属性，而js里万物皆对象，</span><br><span class="line"> 所以会形成一条__proto__连起来的链条，递归访问__proto__最终到头，并且值是null</span><br><span class="line"></span><br><span class="line"> 当js引擎查找对象属性时，先查找对象本身是否存在该属性，</span><br><span class="line"> 如果不存在，会在原型链上查找，但不会查找自身的prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>var A = function()&#123;&#125;;
var a = new A();
console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null</code></pre>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>actions<br>assets<br>components<br>reducers<br>store<br>views<br>index.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># prototype问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function Foo() {<br>    getName = function () { alert (1); };<br>    return this;<br>}<br>Foo.getName = function () { alert (2);};<br>Foo.prototype.getName = function () { alert (3);};<br>var getName = function () { alert (4);};<br>function getName() { alert (5);}</p>
<p>//请写出以下输出结果：<br>Foo.getName();<br>getName();<br>Foo().getName();<br>getName();<br>new Foo.getName();<br>new Foo().getName();<br>new new Foo().getName();</p>
<p>//答案：<br>Foo.getName();//2<br>getName();//4<br>Foo().getName();//1<br>getName();//1<br>new Foo.getName();//2<br>new Foo().getName();//3<br>new new Foo().getName();//3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># var和函数的提前声明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function fn(a) {<br>  console.log(a);<br>  var a = 2;<br>  function a() {}<br>  console.log(a);<br>}</p>
<p>fn(1);<br>　　输出：function  a() {} 2<br>　　<br>　　<br>我们知道var和function是会提前声明的，<br>而且function是优先于var声明的（如果同时存在的话），<br>所以提前声明后输出的a是个function，<br>然后代码往下执行a进行重新赋值了，故第二次输出是2。</p>
<p><a href="http://www.cnblogs.com/zichi/p/4359786.html">http://www.cnblogs.com/zichi/p/4359786.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># javascript实现将多个有序数组合并为一个有序数组的算法</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010302469)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let ret=arr.reduce((arr1,arr2)=&gt;arr1.concat(arr2)).sort((a,b)=&gt;a-b);<br>ret=Array.from(new Set(ret));<br>console.log(ret);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># new操作符具体干了什么呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1、创建一个新对象<br>2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）<br>3、执行构造函数中的代码（为这个新对象添加属性）<br>4、返回新对象</p>
<p>var obj  = {};<br>obj.<strong>proto</strong> = Base.prototype;<br>Base.call(obj);</p>
<p>创建一个新对象foo；</p>
<p>并将它的<strong>proto__指向其构造函数的prototype，<br>foo.__proto</strong> = Foo.prototype;</p>
<p>动态将this指向新对象，Foo.apply(foo，arguments);</p>
<p>执行函数体中的代码；</p>
<p>放回新对象foo;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 怎么画一条0.5px的边</span><br><span class="line"></span><br><span class="line">[链接：](https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5ab65f40f265da2384408a95)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过直接设置宽高border为0.5px、<br>设置box-shadow的垂直方向的偏移量为0.5px、<br>借助线性渐变linear-gradient、<br>使用transform: scaleY(0.5)的方法，<br>使用SVG的方法。<br>最后发现transfrom scale/svg的方法兼容性和效果都是最好的，<br>svg可以支持复杂的图形，<br>所以在viewport是1的情况下，<br>可以使用transform/SVG画0.5px，<br>而如果viewport的缩放比例不是1的话，那么直接画1px即可。</p>
<p>.hairline-border {<br>  box-shadow: 0 0 0 1px;<br>}<br>@media (min-resolution: 2dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.5px;<br>  }<br>}<br>@media (min-resolution: 3dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.33333333px;<br>  }<br>}<br>@media (min-resolution: 4dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.25px;<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 从 arguments 到剩余参数</span><br><span class="line"></span><br><span class="line">如果你想在 ES5 中让函数(或方法)接受任意数量的参数，必须使用特殊变量 arguments：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function logAllArguments() {<br>    for (var i=0; i &lt; arguments.length; i++) {<br>        console.log(arguments[i]);<br>    }<br>}</p>
<p>ES6 中则可以通过 … 运算符定义一个剩余参数(在下面示例中是args)：</p>
<p>function logAllArguments(…args) {<br>    for (const arg of args) {<br>        console.log(arg);<br>    }<br>}</p>
<p>如果有一部分固定参数，剩余参数就更适用了：</p>
<p>function format(pattern, …args) {<br>    ···<br>}</p>
<p>在 ES5 中处理同样的事情有点麻烦：</p>
<p>function format(pattern) {<br>    var args = [].slice.call(arguments, 1);<br>    ···<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</span><br><span class="line"></span><br><span class="line">[连接](https:&#x2F;&#x2F;github.com&#x2F;qiu-deqing&#x2F;FE-interview#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BB%A5http%E4%B8%BA%E4%BE%8B)</span><br><span class="line"></span><br><span class="line">1. 输入url</span><br><span class="line">2. 查看缓存</span><br><span class="line">3. 解析URL</span><br><span class="line">4. 组装HTTP请求报文</span><br><span class="line">5. 获取主机ip</span><br><span class="line">6. 建立tcp连接</span><br><span class="line">7. 发送http请求</span><br><span class="line">8. 服务器检查请求头信息</span><br><span class="line">9. 响应报文通过tcp返回</span><br><span class="line">10. 关闭tcp四次握手</span><br><span class="line">11. 检查状态码</span><br><span class="line">12. 缓存</span><br><span class="line">13. 解码</span><br><span class="line">14. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</span><br><span class="line">15. 显示页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器地址栏输入URL<br>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，<br>足够新鲜直接提供给客户端，否则与服务器进行验证。<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：<br>HTTP1.0提供Expires，<br>值为一个绝对时间表示缓存新鲜日期<br>HTTP1.1增加了Cache-Control: max-age,<br>值为以秒为单位的最大新鲜时间<br>浏览器解析URL获取协议，主机，端口，path<br>浏览器组装一个HTTP（GET）请求报文<br>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存</p>
<p>DNS递归查询（可能存在负载均衡导致每次IP不一样）<br>打开一个socket与目标IP地址，端口建立TCP链接，<br>三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z<br>TCP链接建立后发送HTTP请求</p>
<p>服务器接受请求并解析，将请求转发到服务程序，<br>如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
<p>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，<br>返回304等对应状态码<br>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作<br>服务器将响应报文通过TCP连接发送回浏览器<br>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，<br>关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</p>
<p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，<br>这些情况处理与2XX不同<br>如果资源可缓存，进行缓存<br>对响应进行解码（例如gzip压缩）</p>
<p>根据资源类型决定如何处理（假设资源为HTML文档）</p>
<p>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，<br>执行js脚本，这些操作没有严格的先后顺序，以下分别解释<br>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树<br>解析过程中遇到图片、样式表、js文件，启动下载<br>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</p>
<p>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，<br>不可见节点包括：<br>1）script,meta这样本身不可见的标签。<br>2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式<br>js解析如下：<br>浏览器创建Document对象并解析HTML，<br>将解析到的元素和文本节点添加到文档中，<br>此时document.readystate为loading</p>
<p>HTML解析器遇到没有async和defer的script时，<br>将他们添加到文档中，然后执行行内或外部脚本。<br>这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。<br>这样就可以用document.write()把文本插入到输入流中。<br>同步脚本经常简单定义函数和注册事件处理程序，<br>他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。<br>脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。<br>异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</p>
<p>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，<br>禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，<br>等这些内容完成载入并且所有异步脚本完成载入和执行，<br>document.readState变为complete,window触发load事件<br>显示页面（HTML解析过程中会逐步显示页面）</p>
<h1 id="浏览器渲染主要流程"><a href="#浏览器渲染主要流程" class="headerlink" title="浏览器渲染主要流程"></a>浏览器渲染主要流程</h1><p>HTML解析出DOM Tree<br>CSS解析出Style Rules<br>将二者关联生成Render Tree<br>Layout 根据Render Tree计算每个节点的信息<br>Painting 根据计算好的信息绘制整个页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Q: 网站性能优化</span><br><span class="line"></span><br><span class="line">[原文](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000013963213#articleHeader0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码层面优化：</p>
<p>一、加载和执行</p>
<pre><code>css方面

将样式表放到页面顶部
不使用CSS表达式
使用link不使用@import
不使用IE的Filter

Javascript方面

将脚本放到页面底部,body标签内底部
将javascript和css从外部引入
压缩javascript和css
删除不需要的脚本
减少DOM访问
合理设计事件监听器


图片方面

优化图片：根据实际颜色需要选择色深、压缩
优化css精灵
合并一些小图片( css sprite )压缩图片
图片转dataUrl
不要在HTML中拉伸图片
保证favicon.ico小并且可缓存
图片编码优化</code></pre>
<p>二、 数据存取<br>    - 尽量使用字面量和局部变量<br>        （局部变量在方法运行过后会自行释放，用完手动置为null或undefined也行），<br>        减少使用对象和数组,</p>
<p>三、 DOM编程**（常见的性能瓶颈）<br>    - 最坏的方式就是在循环中操作或者访问DOM，非常消耗性能。<br>    减少DOM数量<br>    - 遍历dom<br>        querySelectorAll()是获取元素最快的API 返回的是一个NodeList<br>        querySelector() 返回的是element,<br>        querySelectorAll()还有一点就是可以同时获取两类元素</p>
<pre><code>- 重绘和重排都是代价昂贵；尽量减少
    重排何时发生：
    1.添加或删除可见DOM元素
    2.元素位置改变
    3.元素尺寸改变（内外边距、边框厚宽高等）
    4.内容改变 （内容导致尺寸变化的时候）
    5.页面渲染器初始化
    6.浏览器窗口尺寸变化</code></pre>
<p>四、 算法和流程控制<br>    - 循环<br>        (当循环体复杂度为X时，优化方案优先减少循环体的复杂度，<br>        循环体复杂度大于X时，优化方案优先减少迭代次数 )<br>    - 条件语句<br>        当条件较少时 使用if-else更易读，<br>        而当条件较多时if-else性能负担比switch大，易读性也没switch好。<br>        优化if-else的方法是：尽可能的把可能出现的条件放在首位，</p>
<p>五、 字符串和正则表达式<br>    - 字符串<br>        join是比较快的，也是大量字符串拼接的唯一高效方式</p>
<p>六、 快速响应的用户界面<br>    - 浏览器UI线程<br>        浏览器限制JavaScript任务的运行时间，限制两分钟，<br>        可以防止恶意代码不断执行来锁定你的浏览器</p>
<pre><code>    单个JavaScript操作的花费总时间应该小于等于100ms，
    这就意味着在100ms内响应用户的操作，不然就会让用户感受到迟钝感

- 定时器让出时间片断
    使用时间戳计算获得程序运行时间，
    以便快速找到运行时间较长的代码部分进行优化</code></pre>
<p>七、 Ajax<br>    - 数据传输<br>        数据的传输同样影响性能<br>    - 数据格式<br>    - Ajax性能<br>        避免不必要的请求：<br>        使Ajax可缓存：服务端设置HTTP头信息确保响应会被浏览器缓存<br>        客户端讲获取的信息存到本地避免再次请求<br>        （localstorage sessionstorage cookice）<br>        设置HTTP头信息，expiresgaosu告诉浏览器缓存多久<br>        减少HTTP请求，合并css、js、图片资源文件等或使用MXHR<br>        通过次要文件用Ajax获取可缩短页面加载时间</p>
<pre><code>    减小cookie大小
    引入资源的域名不要包含cookie</code></pre>
<p>八、编程实践<br>    - 避免双重求值<br>        eval()、Function慎用，<br>        定时器第一个参数建议函数而不是字符串都能避免字符串双重求值<br>    - 使用对象或者数组直接量<br>    - 避免重复工作<br>        A:延迟加载（懒加载）<br>        B:条件预加载<br>    - 使用JavaScript速度快的部分<br>        A.位操作<br>        B.原生方法，首先原生方法是最快的，而且浏览器会缓存部分原生方法<br>        C.复杂计算时多使用Math对象<br>        D.querySelector和querySelectorAll是查询最快的</p>
<p> 九、 构建并部署高性能JavaScript应用<br>    1.合并多个js文件<br>    2.预处理js文件<br>    3.js压缩<br>    4.js的HTTP压缩<br>    5.缓存js文件<br>    6.处理缓存问题<br>    7.使用内容分发网络（CDN）</p>
<p>移动方面</p>
<pre><code>保证组件小于25k
Pack Components into a Multipart Document

content方面

按需加载资源
非必须组件延迟加载
未来所需组件预加载
    在网站 HTML 中的链接属性上增加
    rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记。

将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
减少iframe数量
不要404

Server方面

使用CDN
减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。
方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
避免重定向：多余的中间访问
用dns-prefetch

&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//mat1.gtimg.com&quot;&gt;

动静分离
使用nginx的反向代理，对静态资源的请求直接nginx处理，或放到CDN
动态请求转发给tomcat处理

添加Expires或者Cache-Control响应头
对组件使用Gzip压缩
    Brotli 是一个比较新的文件压缩算法，目前正变得越来越受欢迎。
配置ETag
Flush Buffer Early
Ajax使用GET进行请求
避免空src的img标签</code></pre>
<p>十、 工具</p>
<pre><code>若是打包的代码尽可能切割成多个 chunk ,减少单一 chunk 过大
HTTP的缓存头使用的合理
减小第三方库的依赖
对于代码应该考虑性能来编写,比如使用 requestAnimationFrame 绘制动画,尽可能减少页面重绘(DOM 改变)
渐进升级,引入 preload 这些预加载资源
看情况用 server worker 来缓存资源(比如移动端打算搞 PWA)
比如从服务端着手:

带宽,域名解析, 多域名解析等
使用负载均衡方案 多节点部署
页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)
渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)
当然,这是这些都是很片面的点到...实际工作中去开展要复杂的多;


使用索引加速数据库查询
页面静态化CMS</code></pre>
<p>多个维度考虑,优化 DOM 绘制时间,资源加载时间,域名解析这些;</p>
<p>要全面的优化一个项目是一个大工程…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 优雅降级和渐进增强</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优雅降级：<br>Web站点在所有新式浏览器中都能正常工作，<br>如果用户使用的是老式浏览器，<br>则代码会检查以确认它们是否能正常工作。<br>针对不同版本的hack为那些无法支持功能的<br>浏览器增加候选方案，<br>使之在旧式浏览器上以某种形式降级体验<br>却不至于完全失效.</p>
<p>渐进增强：<br>从被所有浏览器支持的基本功能开始，<br>逐步地添加那些只有新式浏览器才支持的功能,<br>向页面增加无害于基础浏览器的<br>额外样式和功能的。<br>当浏览器支持时，<br>它们会自动地呈现出来并发挥作用。</p>
<p>保证所有人都能访问页面的基本内容和功能<br>同时为高级浏览器和高带宽用户提供<br>更好的用户体验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># js控制css3动画</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开始事件 AnimationStart<br>结束事件 AnimationEnd<br>重复运动事件 AnimationIteration  每次开始动画迭代都触发animationiteration</p>
<p>W3c标准：animationstart animationiteration animationend<br>Webkit：webkitAnimationStart webkitAnimationIteration webkitAnimationEnd<br>Firefox：animationstart animationiteration animationend<br>Opera：animationstart animationiteration animationend<br>IE10：MSAnimationStart MSAnimationIteration MSAnimationEnd</p>
<p>var e = document.getElementById(“left1”);  </p>
<p>e.addEventListener(“animationend”, function() {<br>    alert(‘css3运动结束！’);<br>});  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Object循环key</span><br><span class="line"></span><br><span class="line">- for...in循环：只遍历对象自身的和继承的可枚举的属性。</span><br><span class="line">    通常用for in来遍历对象的键名</span><br><span class="line">    for in更适合遍历对象，不要使用for in遍历数组。</span><br><span class="line"></span><br><span class="line">for in 循环会把数组其他扩展方法也循环</span><br><span class="line"></span><br><span class="line">- for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</span><br><span class="line"></span><br><span class="line">for-of循环是遍历实现iterator接口的成员</span><br><span class="line"></span><br><span class="line">只要是一个对象部署了Symbol.interator接口，就可以用for...of遍历该对象，同时也可以调用该接口的Symbol.interator方法调用next()方法对对象进行遍历，不同的是for..of是对该对象的值的输出，而next()返回的是对象。</span><br><span class="line"></span><br><span class="line">在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</span><br><span class="line"></span><br><span class="line">- Object.keys()：返回对象自身的所有可枚举的属性的键名。</span><br><span class="line">- JSON.stringify()：只串行化对象自身的可枚举的属性。</span><br><span class="line">- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;for...in循环出的是key，for...of循环出的是value&#x3D;&#x3D;</span><br><span class="line">- &#x3D;&#x3D;for...of不能循环普通的对象，需要通过和Object.keys()搭配使用&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">如果实在想用for...of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组</span><br><span class="line">然后遍历：</span><br><span class="line"></span><br><span class="line">## 结论</span><br><span class="line"></span><br><span class="line">1. 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。</span><br><span class="line"></span><br><span class="line">2. for...in循环出的是key，for...of循环出的是value</span><br><span class="line"></span><br><span class="line">3. 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足</span><br><span class="line"></span><br><span class="line">4. for...of不能循环普通的对象，需要通过和Object.keys()搭配使用</span><br><span class="line"></span><br><span class="line">记忆jueqiao :</span><br><span class="line"></span><br><span class="line">已核对 偶数v</span><br><span class="line"></span><br><span class="line">in h（k）对象  o 数组 value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组<br>然后遍历：</p>
<p>var student={<br>    name:’wujunchuan’,<br>    age:22,<br>    locate:{<br>    country:’china’,<br>    city:’xiamen’,<br>    school:’XMUT’<br>    }<br>}<br>for(var key of Object.keys(student)){<br>    //使用Object.keys()方法获取对象key的数组<br>    console.log(key+”: “+student[key]);<br>}</p>
<p>for in 可以遍历到myObject的原型方法method,<br>如果不想遍历原型方法和属性的话，<br>可以在循环内部判断一下,<br>hasOwnPropery方法可以判断<br>某属性是否是该对象的实例属性</p>
<p>for (var key in myObject) {<br>　　if（myObject.hasOwnProperty(key)){<br>　　　　console.log(key);<br>　　}<br>}</p>
<pre><code></code></pre>
]]></content>
      <tags>
        <tag>jQuery</tag>
        <tag>插件</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>清新冥想</title>
    <url>/posts/%E6%B8%85%E6%96%B0%E5%86%A5%E6%83%B3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="第一节–初识冥想"><a href="#第一节–初识冥想" class="headerlink" title="第一节–初识冥想"></a>第一节–初识冥想</h2><h3 id="冥想练习的特点"><a href="#冥想练习的特点" class="headerlink" title="冥想练习的特点"></a>冥想练习的特点</h3><p>冥想与任何组织宗教无关，适用于每个人<br>作用: 能够缓解压力，缓解焦虑，改善睡眠，提高工作效率，与身边的人和事建立更好的联系等</p>
<p>容易上手 轻松掌握<br>简洁有效，每天只需十分钟</p>
<p>冥想的原理是什么，通过什么发挥作用</p>
<p>答案是正念</p>
<h3 id="什么是”正念”"><a href="#什么是”正念”" class="headerlink" title="什么是”正念”"></a>什么是”正念”</h3><p>通过专注，激发心灵的力量</p>
<p>今心为念，活在当下的心就是念。</p>
<p>与之相对的，还有两种状态: 活在昨天和活在明天,是引发负面情绪的根源</p>
<p>活在昨天会想起对时间的荒废，与他人的争执，学习和工作的不顺，从而感到沮丧和后悔</p>
<p>活在明天会尝试规划未来，设想许多还没发生的事，小到家长里短，大到国家大事，倍感压力焦虑</p>
<p>如果心总在过去和未来之间摇摆，就会忽视最重要的当下</p>
<p>正念要做的就是通过刻意的引导，帮你的注意力凝聚起来，把内心从过去和未来的拉扯中解脱出来，回归当下，而不是逃避现实</p>
<p>在冥想的经典练习中，正念呼吸最容易掌握</p>
<a id="more"></a>

<h3 id="正念呼吸的练习要点"><a href="#正念呼吸的练习要点" class="headerlink" title="正念呼吸的练习要点"></a>正念呼吸的练习要点</h3><p>想象自己处于一个安静，不会被打扰的地方<br>找一个有靠背的地方坐下</p>
<p>现在闭上你的双眼，挺直上身，轻轻抬起头<br>由下至上用心感受你的腿部，臀部，腰部，背部<br>慢慢的你会感觉到肌肉的酸痛<br>这是正常的现象<br>因为痛是感知我们身体的主要方式，</p>
<p>将注意力集中到鼻子<br>让我们开始做几次深呼吸</p>
<p>让自己沉浸在此时此刻<br>深吸一口气<br>然后深深呼气<br>反复呼吸几次<br>让你现在的紧张感得到完全的释放</p>
<p>当你变的平静<br>就让呼吸回到普通状态</p>
<p>保持自然的呼吸<br>不要试图去改变呼吸的节奏<br>把注意力附属在你的呼吸上<br>顺着空气进入你的身体</p>
<p>感受身体哪个部位最强烈<br>可能是上下起伏的腹部<br>或者肺部<br>也可能是冷的或热的空气经过鼻腔</p>
<p>把注意力放在你身体感觉最强烈的部位<br>并把全部注意力放在那里</p>
<p>跟随你的呼吸<br>一直到每一次吸气的末端</p>
<p>当吸气结束的时候<br>再一路跟随呼气，直到结束</p>
<p>你可能会出现走神<br>受到一些关于过去和未来想法的干扰<br>开始不由自主的评判和思考<br>没有关系</p>
<p>当你意识到自己走神时<br>不需要评价这样是好是坏</p>
<p>只需要将注意力再转移到呼吸上</p>
<p>可以通过计数方式<br>吸气数一，呼气数二<br>一吸气，二呼气</p>
<p>请按自己喜欢的节奏呼吸一段时间<br>仔细观察每一段的呼吸的长度变化，力度变化</p>
<p>感受呼吸如何带动身体</p>
<p>现在花一点时间来留意一下身体的感觉<br>请放松心情</p>
<p>不要刻意评判这次练习的效果<br>因为这会为你增添新的负担</p>
<p>练习就是最好的学习</p>
<p>当你继续冥想学习<br>不仅练习本身会变得越来越简单<br>压力和焦虑也会逐渐消失</p>
<p>本次练习已接近尾声<br>把注意力回到你所处的环境</p>
<p>轻轻活动你的手指，脚趾<br>舒展身体<br>慢慢的睁开眼睛</p>
<p>祝贺你，你已经成功的完成了一次冥想练习</p>
<p>在过去的十分钟里<br>掌握了正念的核心思想-专注当下<br>通过呼吸练习的方式<br>完成了对身体的感知<br>和对注意力的操控</p>
<h2 id="第二节-冥想的本质"><a href="#第二节-冥想的本质" class="headerlink" title="第二节 冥想的本质"></a>第二节 冥想的本质</h2><p>当下指的是此时此刻，注意力需要集中的地方</p>
<h3 id="怎样才算“专注当下”"><a href="#怎样才算“专注当下”" class="headerlink" title="怎样才算“专注当下”"></a>怎样才算“专注当下”</h3><p>全神贯注，把注意力集中到正在做的事情上。<br>拒绝一心多用</p>
<p>人并不总是活在当下，走神是我们的常态</p>
<h3 id="导致走神的三大原因"><a href="#导致走神的三大原因" class="headerlink" title="导致走神的三大原因"></a>导致走神的三大原因</h3><p>发达的感官接收大量不需要的信息<br>丰富的联想产生源源不断的杂念<br>    –联想偶尔会带来灵感，但会耗费精力，占据时间，明明没有偷懒，手头上的事却没做多少<br>为了逃避压力，通过发呆放空自己<br>    –通过放空缓解压力，只是自我安慰，发呆的同时时间在流逝，最后工作还要做</p>
<p>今后在遇到这种情况，不要自责<br>只需要将注意力拉回到当前在做的事情上</p>
<h3 id="冥想练习的本质"><a href="#冥想练习的本质" class="headerlink" title="冥想练习的本质"></a>冥想练习的本质</h3><p>冥想练习所做的，就是反复将注意力从其他地方拽回当下。<br>因此冥想可以融入到日常生活中，无时不刻的练习。</p>
<p>练习是最好的学习</p>
<h2 id="第三节-乔布斯与冥想"><a href="#第三节-乔布斯与冥想" class="headerlink" title="第三节 乔布斯与冥想"></a>第三节 乔布斯与冥想</h2><h3 id="乔布斯的冥想过程"><a href="#乔布斯的冥想过程" class="headerlink" title="乔布斯的冥想过程"></a>乔布斯的冥想过程</h3><p>集中注意力，让思想平静</p>
<p>思想不会轻易平静，需要耐心等待</p>
<p>当平静到来，直觉就会变得灵敏，看到更加广阔的世界</p>
<h3 id="专注当下的好处"><a href="#专注当下的好处" class="headerlink" title="专注当下的好处"></a>专注当下的好处</h3><p>远离浮躁，进入平静的内心状态<br>激活直觉，获得更加灵敏的感知<br>洞察细节，通过信息差决定成败</p>
<h3 id="心怀感恩"><a href="#心怀感恩" class="headerlink" title="心怀感恩"></a>心怀感恩</h3><p>欲望持续膨胀，一味索取只会在打到目标后获得短暂的幸福，更多时间陷入了了求而不得的痛苦和焦虑当中。</p>
<p>意识到并重视我们已经拥有的一切，内心的充盈与知足，同样会带来平静和幸福。</p>
<h2 id="第四节-复习课"><a href="#第四节-复习课" class="headerlink" title="第四节 复习课"></a>第四节 复习课</h2><ol>
<li><p>正念的基本概念</p>
</li>
<li><ol>
<li>冥想练习的特点</li>
</ol>
</li>
<li><ol start="2">
<li>正念呼吸的要点</li>
</ol>
</li>
<li><p>专注当下的深处含义</p>
</li>
<li><ol>
<li>分心走神的三个原因</li>
</ol>
</li>
<li><ol start="2">
<li>冥想是一种生活方式</li>
</ol>
</li>
<li><p>乔布斯的冥想过程</p>
</li>
<li><p>1 专注当下的重要性</p>
</li>
<li><p>2 为什么要心怀感恩</p>
</li>
</ol>
<h2 id="第五节-情绪调整"><a href="#第五节-情绪调整" class="headerlink" title="第五节 情绪调整"></a>第五节 情绪调整</h2><h3 id="情绪的特点"><a href="#情绪的特点" class="headerlink" title="情绪的特点"></a>情绪的特点</h3><p>情绪的产生不适一蹴而就，而是逐渐积累<br>情绪的维持依赖于真实存在的事物<br>情绪会自发趋于平稳</p>
<h3 id="如何调整情绪"><a href="#如何调整情绪" class="headerlink" title="如何调整情绪"></a>如何调整情绪</h3><p>找到引发情绪的原因<br>用更积极的视角看待<br>让注意力与情绪隔离</p>
<p>把情绪当成无关的念头，注意力集中在有意义的事情，可以大大降低情绪对生活的影响，等空闲下来再慢慢找原因</p>
<h3 id="冥想练习对情绪调整的帮助"><a href="#冥想练习对情绪调整的帮助" class="headerlink" title="冥想练习对情绪调整的帮助"></a>冥想练习对情绪调整的帮助</h3><p>通过灵敏的感知，精确找到情绪波动的原因<br>强化对注意力的控制<br>有效的隔离以避免负面情绪的扩大</p>
<h2 id="第六节-冥想与禅"><a href="#第六节-冥想与禅" class="headerlink" title="第六节 冥想与禅"></a>第六节 冥想与禅</h2><h3 id="什么是禅"><a href="#什么是禅" class="headerlink" title="什么是禅"></a>什么是禅</h3><p>早在先秦时代，中国人就掌握了通过静坐锻炼思维、生发智慧的方法，但没有命名</p>
<p>佛教传入中国后，将这种训练称为禅</p>
<p>禅是超越宗教范围的顿悟与创见</p>
<h3 id="禅修对冥想的帮助"><a href="#禅修对冥想的帮助" class="headerlink" title="禅修对冥想的帮助"></a>禅修对冥想的帮助</h3><p>提升冥想练习的效果<br>更好的将专注当下的态度融入生活<br>为看清自我和改变生活打下思想基础</p>
<h3 id="禅心与初心"><a href="#禅心与初心" class="headerlink" title="禅心与初心"></a>禅心与初心</h3><p>禅心没有含义，怀有禅心是为了对内心与自身存在产生惊奇，并通过发掘本心回应惊奇</p>
<p>初心是初学者的心，要随时准备好去接受、去怀疑，对所有的可能性敞开</p>
<h2 id="第七节-掌控杂念"><a href="#第七节-掌控杂念" class="headerlink" title="第七节 掌控杂念"></a>第七节 掌控杂念</h2><h3 id="呼吸的意义"><a href="#呼吸的意义" class="headerlink" title="呼吸的意义"></a>呼吸的意义</h3><p>每个人都是一扇敞开的门<br>一呼一吸穿门而过，就会觉察到自我<br>呼吸是内心世界与外部世界的交汇处</p>
<h3 id="关于掌控杂念"><a href="#关于掌控杂念" class="headerlink" title="关于掌控杂念"></a>关于掌控杂念</h3><p>想要清除杂念，是因为担心被杂念干扰心绪</p>
<p>越想清除杂念，就会在杂念中越陷越深</p>
<p>最好的掌控方式就是不掌控，“无为而治”<br>自由来去的杂念并不会扰乱心绪</p>
<p>真正的混乱之源是对杂念的掌控欲和企图心</p>
<p>自由是杂念的自由，而不是意识的自由</p>
<h2 id="第八节-期待与收获"><a href="#第八节-期待与收获" class="headerlink" title="第八节 期待与收获"></a>第八节 期待与收获</h2><h3 id="期望与收获往往有落差"><a href="#期望与收获往往有落差" class="headerlink" title="期望与收获往往有落差"></a>期望与收获往往有落差</h3><p>庐山烟雨浙江潮，未至千般恨不消。<br>到得还来别无事，庐山烟雨浙江潮。</p>
<p>曾经的朝思暮想，成真时往往变成”不过如此”<br>如果不能正确对待，这种落差就会削弱我们练习的积极性，让我们无法坚持冥想</p>
<h3 id="收获不如期待怎么办"><a href="#收获不如期待怎么办" class="headerlink" title="收获不如期待怎么办"></a>收获不如期待怎么办</h3><p>不忘初心: 永远像初学者一样谦虚且开放</p>
<p>回忆小时候对长高的渴望</p>
<p>佛性与开悟</p>
<p>不做评判: 像对待杂念一样，忽视功利心</p>
<p>滴水穿石，厚积薄发</p>
<p>见山是山，见水是水<br>见山不是山，见水不是水<br>见山是山，见水是水</p>
<h2 id="第九节-避免兴奋"><a href="#第九节-避免兴奋" class="headerlink" title="第九节 避免兴奋"></a>第九节 避免兴奋</h2><h3 id="收获超出期待未必是件好事"><a href="#收获超出期待未必是件好事" class="headerlink" title="收获超出期待未必是件好事"></a>收获超出期待未必是件好事</h3><p>因为我们会产生兴奋和骄傲</p>
<p>如果不刻意的排除这两种情绪，之后的冥想练习就会逐渐向错误的方向偏离</p>
<h3 id="为什么要尽量避免兴奋"><a href="#为什么要尽量避免兴奋" class="headerlink" title="为什么要尽量避免兴奋"></a>为什么要尽量避免兴奋</h3><p>兴奋会让情绪波动</p>
<p>心绪波动是我们持之以恒练习冥想的最大阻碍</p>
<p>对于冥想本身的兴趣不是真正的兴趣，冥想的目的是激发对自己日常生活的兴趣</p>
<h2 id="第十节-冥想的方向"><a href="#第十节-冥想的方向" class="headerlink" title="第十节 冥想的方向"></a>第十节 冥想的方向</h2><h3 id="什么是修行中最重要的事"><a href="#什么是修行中最重要的事" class="headerlink" title="什么是修行中最重要的事"></a>什么是修行中最重要的事</h3><p>最重要的不是努力，而是找到一个正确的方向</p>
<p>如果你的努力指向不正确的方向，付出的努力往往就是白忙一场</p>
<h3 id="冥想的正确方向是什么"><a href="#冥想的正确方向是什么" class="headerlink" title="冥想的正确方向是什么"></a>冥想的正确方向是什么</h3><p>通常在做一件事情时，人们是有目的的，想要有所成就，得到某种结果</p>
<p>冥想的正确方向是”无目的”, 可以明确事情的目的，但不执著于目的。</p>
<h3 id="为什么不要骄傲"><a href="#为什么不要骄傲" class="headerlink" title="为什么不要骄傲"></a>为什么不要骄傲</h3><p>人的惯性思维是有目的，想要做到无目的，就需要改变思维方式，每当因达到目的而产生情绪波动时，及时察觉并予以打断。</p>
<p>在所有的情绪中，目的性最强的就是骄傲</p>
<p>我们不会无缘无故的骄傲，一定是因为做到来了某些事情，达到了某些目的，证明了自我，才会产生骄傲。</p>
<p>用淡淡的喜悦取代骄傲</p>
<h2 id="第十一节-不要惧怕失去"><a href="#第十一节-不要惧怕失去" class="headerlink" title="第十一节 不要惧怕失去"></a>第十一节 不要惧怕失去</h2><p>这世上的一切都早已存在，并将继续存在下去。</p>
<p>我们从未真正意义的拥有什么，所有也就不存在真正意义上的失去。</p>
<p>所有的得与失，只是其他存在与我们狭窄的视线恰巧发生了交错，看到时被我们误以为拥有，看不到时又被我们误以为失去。</p>
<p><strong>如果我们不去看，就不会有任何的事物从我们的目光中消失.</strong></p>
<h2 id="第十二节-复习课"><a href="#第十二节-复习课" class="headerlink" title="第十二节 复习课"></a>第十二节 复习课</h2><p>第八节回顾<br>第九节回顾<br>第十节回顾<br>第十一节回顾</p>
<h2 id="第十三节-关于沟通"><a href="#第十三节-关于沟通" class="headerlink" title="第十三节 关于沟通"></a>第十三节 关于沟通</h2><h3 id="关于沟通"><a href="#关于沟通" class="headerlink" title="关于沟通"></a>关于沟通</h3><p>沟通是探索自我的准备工作</p>
<p>沟通包括两个部分: 表达自我和倾听他人</p>
<p>良好的表达和倾听是相辅相成的</p>
<h3 id="如何进行良好的沟通"><a href="#如何进行良好的沟通" class="headerlink" title="如何进行良好的沟通"></a>如何进行良好的沟通</h3><p>表达自我时需要做到坦诚，情绪稳定和有亲和力</p>
<p>倾听他人时要注意把所有的成见和主观意见摆在一边，不要进行太多善与恶、对与错的价值判断</p>
<h2 id="第十四节-亲子沟通"><a href="#第十四节-亲子沟通" class="headerlink" title="第十四节 亲子沟通"></a>第十四节 亲子沟通</h2><h3 id="父母与子女间的沟通"><a href="#父母与子女间的沟通" class="headerlink" title="父母与子女间的沟通"></a>父母与子女间的沟通</h3><p>最常见的沟通问题，往往发生在最亲密的关系之间</p>
<p>父母对子女只有善意，但姿态却总是高高在上</p>
<p>对于父母的叮嘱，子女天然抱有抵触情绪</p>
<p>由于是最亲密的人，父母和子女间的沟通往往是不加掩饰的，因而会有丰富的个人情感浸透在表达中</p>
<h3 id="最真实的爱是沟通的基础"><a href="#最真实的爱是沟通的基础" class="headerlink" title="最真实的爱是沟通的基础"></a>最真实的爱是沟通的基础</h3><p>良好的沟通需要保持最自然的状态，表达自己最真实的感受</p>
<p>父母和子女之间，无论进行怎样的沟通，底层的感受一定是彼此的爱，因此不要吝啬对爱的表达</p>
<p>哪怕你暂时还学不会沟通技巧，不擅长倾听，只要能够把内心最真实的感受及时的传达，同样可以改善沟通</p>
<h2 id="第十五节-努力的意义"><a href="#第十五节-努力的意义" class="headerlink" title="第十五节 努力的意义"></a>第十五节 努力的意义</h2><p>“风停见花落，鸟鸣觉山静。”<br>在事情的样貌发生改变之前，我们通常意识不到它真正的样子。<br>冥想练习也是如此。专注于呼吸的时候，你的心会完全静下来，感受不到任何东西，你只是坐着。但你从练习中得到的静，却会在接下来的日常生活中发挥激励作用。</p>
<p>努力的意义，在于努力本身</p>
<p>很多人把生活当成农民种地的过程，先播种，再耕作，经过漫长的等待和不懈的努力，最后获得丰收，这其实是对生活的一种误解。</p>
<p>如果你把自己的努力定义成种地，把收获定义成丰收，那生活就只有漫长的等待和收获时短暂的快乐，你会错过每一天劳动时与自然的亲切相处，专注耕作时内心的平静，对自己的觉察，技能的熟练与提升，以及生活充实而带来的满足感。</p>
<h2 id="第十六节-习惯的力量"><a href="#第十六节-习惯的力量" class="headerlink" title="第十六节 习惯的力量"></a>第十六节 习惯的力量</h2><p>奇葩的小习惯才是成功秘诀？<br>经过科学家的研究发现，多次执行一套相同的动作和准备程序，确实可以使大脑和身体自我调整，进入执行工作的最佳状态。</p>
<p>习惯本身就是力量</p>
<p>如果你能够确定一个固定的时间段，坚持每天进行十分钟的呼吸练习，即便是冥想本身的思想还没有充分掌握，单单这个习惯本身就会为你带来大量的帮助。</p>
<h2 id="第十七节-精神的三个部分"><a href="#第十七节-精神的三个部分" class="headerlink" title="第十七节 精神的三个部分"></a>第十七节 精神的三个部分</h2><h3 id="“自我”的概念是难以捉摸的"><a href="#“自我”的概念是难以捉摸的" class="headerlink" title="“自我”的概念是难以捉摸的"></a>“自我”的概念是难以捉摸的</h3><p>每个人都有很多面，有坏脾气的时候，有温柔的时候，有特别开心的时候，也有无缘无故感到抑郁和沮丧的时候。</p>
<p>真正的自我，到底是内心的幽暗处发出声音的那个人，还是对生活充满热爱的那个人呢？如果每一面都是真实的自我，这些矛盾的存在又如何融合在一起呢？</p>
<h3 id="弗洛伊德将人的精神分为三个部分：本我，自我和超我"><a href="#弗洛伊德将人的精神分为三个部分：本我，自我和超我" class="headerlink" title="弗洛伊德将人的精神分为三个部分：本我，自我和超我"></a>弗洛伊德将人的精神分为三个部分：本我，自我和超我</h3><p>本我即原我，是指原始的自己，包含生存所需的基本欲望、冲动和生命力。本我是一切心理能量之源，本我按快乐原则行事，它不理会社会道德、外在的行为规范，它唯一的要求是获得快乐，避免痛苦，本我的目标非常简单，就是追求个体的舒适，生存及繁殖。</p>
<h2 id="第十八节-何为超我"><a href="#第十八节-何为超我" class="headerlink" title="第十八节 何为超我"></a>第十八节 何为超我</h2><p>什么是超我？<br>超我是人格系统中专管道德的司法部门。它由人的道德律法和自我理想等构成，可简单区分为“理想”、“良心”两个层次。其中“理想”中既包括自我理想，又包括社会理想。</p>
<p>自己理想中想要成为的人，以及社会主流价值观所认可的英雄人物、道德楷模的形象，会汇总融合成为一套个体为自己所设的行为价值标准，而超我就是负责监督我们按照这套标准行事的人格。</p>
<p>超我会不停的劝导我们表现的更加成熟，更加善良，追求卓越。当本我产生违反道德或社会秩序的欲望和冲动时，超我就会让这些冲动生成罪恶感和内疚，从而抑制本我。</p>
<h2 id="第十九节-自我的作用"><a href="#第十九节-自我的作用" class="headerlink" title="第十九节 自我的作用"></a>第十九节 自我的作用</h2><p>自我处于社会生活的现实要求、超我的道德追求与本我的利益追求之间，按照现实原则协调矛盾，尽可能地寻找权宜之计。</p>
<p>通俗一点来说，无论是本我还是超我，都只是提供建议，自我才是个体最终行为表现的决策者，时而管理本我，时而服从超我，既要尽量满足本我的欲望，又要顾及到超我的道德准则。</p>
<h2 id="第二十节-自我的本质"><a href="#第二十节-自我的本质" class="headerlink" title="第二十节 自我的本质"></a>第二十节 自我的本质</h2><h3 id="自我，就像水一样"><a href="#自我，就像水一样" class="headerlink" title="自我，就像水一样"></a>自我，就像水一样</h3><p>把自我比做是水。水倒在不同的杯子里面，它就是不同的形状。而我们的生活和思考，就是把水从一个杯子转移到另一个杯子。你能够感知到的，呈现出来的，自己每时每刻表现出来的行为，就是水在杯子中形成形状的过程。</p>
<h3 id="自我是什么"><a href="#自我是什么" class="headerlink" title="自我是什么"></a>自我是什么</h3><p>如果水的大部分时间，就是从一个杯子转移到另一个杯子，那水就是一团不停的转移，不停改变形状的东西。<br>自我也是如此。不同的角度，有不同的解释，但存在一种最贴切的表达：如果我们一切的想法都是围绕生活展开的，那自我就是不停的体验、思考，活在当下的那个意识。<br>这就是为什么，冥想并不鼓励大家去定义自我，而是鼓励大家发现和探索自我。只有不断的体验、思考、感受生活，自我才得以展开，呈现出不同的样子。</p>
<h2 id="第二十一节-梦的来源-1"><a href="#第二十一节-梦的来源-1" class="headerlink" title="第二十一节 梦的来源(1)"></a>第二十一节 梦的来源(1)</h2><h3 id="梦的来源-——-记忆"><a href="#梦的来源-——-记忆" class="headerlink" title="梦的来源 —— 记忆"></a>梦的来源 —— 记忆</h3><p>人们所经历、体会过的东西，是构成梦的全部原材料。记忆与梦境的联系并不是简单的重复回播，往往会通过夸大和拼接的方式呈现，把记忆中的片段变成一个新的场景或故事。</p>
<h3 id="容易出现在梦境中的记忆-——-遗忘记忆"><a href="#容易出现在梦境中的记忆-——-遗忘记忆" class="headerlink" title="容易出现在梦境中的记忆 —— 遗忘记忆"></a>容易出现在梦境中的记忆 —— 遗忘记忆</h3><p>遗忘记忆，指的就是人在梦里往往能够知道并记起一些清醒状态时所不晓或者忘却的事。这些事在梦境中出现时，不会被当成是自身已有的知识或经历，这让我们感到一头雾水，以为这是梦中自己想象或者创造出来的事物。</p>
<h2 id="第二十二节-梦的来源-2"><a href="#第二十二节-梦的来源-2" class="headerlink" title="第二十二节 梦的来源(2)"></a>第二十二节 梦的来源(2)</h2><h3 id="童年记忆"><a href="#童年记忆" class="headerlink" title="童年记忆"></a>童年记忆</h3><p>梦有一种奇妙的力量，即便是孩童时代里，那些久远的已经被我们的记忆遗失在阴暗角落里的东西，梦也能够把它们召回，重现在我们的脑海中。</p>
<p>梦不但能够将一些深藏的童年经历挖掘出来，还能保持那些特定的人物、事件和场景分毫不变，保持它们最鲜活最生动的原始状态。</p>
<h3 id="里程碑事件的小细节"><a href="#里程碑事件的小细节" class="headerlink" title="里程碑事件的小细节"></a>里程碑事件的小细节</h3><p>在梦境中，成为焦点的往往是重要事件里旁枝末节、甚至是最空洞无物的东西。那些被我们热切渴望、倾注了浓厚兴趣的事物在梦中的戏份并不多，相反，一次偶然的邂逅、不太重要的见闻或是零零碎碎的一点事物，往往成为梦中元素的真正来源。</p>
<h2 id="第二十三节-梦的来源-3"><a href="#第二十三节-梦的来源-3" class="headerlink" title="第二十三节 梦的来源(3)"></a>第二十三节 梦的来源(3)</h2><h3 id="梦是一种应激反应"><a href="#梦是一种应激反应" class="headerlink" title="梦是一种应激反应"></a>梦是一种应激反应</h3><p>一定是我们先受到了某种刺激，才会根据这种刺激产生相对应的梦境。举个例子的话，我们的梦境就像是一个餐厅的厨师做饭：记忆是各种各样的食材，而受到的刺激就是客人点餐时下的订单，厨师先收到订单，再会决定选取哪些食材，进行怎样的加工。</p>
<h3 id="外部的知觉刺激"><a href="#外部的知觉刺激" class="headerlink" title="外部的知觉刺激"></a>外部的知觉刺激</h3><p>所谓知觉刺激，就是通过外界对身体感官形成的刺激。比如一道刺眼的强光、强烈的噪音、浓烈的气味，或者身体某个部位露出被子时感受到寒冷。这种刺激能够非常明确的引发对应的梦境：当窗外公鸡报晓，梦中也许就会听到某个人在惊声尖叫。</p>
<h2 id="第二十四节-梦的来源-4"><a href="#第二十四节-梦的来源-4" class="headerlink" title="第二十四节 梦的来源(4)"></a>第二十四节 梦的来源(4)</h2><h3 id="幻想刺激"><a href="#幻想刺激" class="headerlink" title="幻想刺激"></a>幻想刺激</h3><p>幻想刺激，指的就是我们躺在床上，闭上眼后脑海中浮现的各种画面。如果这些被我们想象出来的画面一直维持到入睡的前一刻，它们就很有可能继续保持自己的样子，与梦境相结合。</p>
<h3 id="身体内部的刺激"><a href="#身体内部的刺激" class="headerlink" title="身体内部的刺激"></a>身体内部的刺激</h3><p>当某些器官处于兴奋状态或生病时，就会传递出类似疼痛的信号。与清醒时的状态相比，睡眠时的心灵对躯体所发生的变化有着更为深入而广泛的感知，接纳身体各部位的信号以及身体变化产生的感受，并通过影响梦境的方式呈现出来。</p>
<h3 id="深度思考刺激"><a href="#深度思考刺激" class="headerlink" title="深度思考刺激"></a>深度思考刺激</h3><p>日有所思，夜有所梦。如果我们在生活、学习和工作中，对某些事物的思考专注深刻，那么这种思考就很有可能渗透到潜意识当中，即便我们入睡，思考也不会停止。这种潜意识的思考不仅会体现在梦中，甚至会比清醒时更有创造力，解决那些没能解决的问题。</p>
<h2 id="第二十五节-关于梦的记忆"><a href="#第二十五节-关于梦的记忆" class="headerlink" title="第二十五节 关于梦的记忆"></a>第二十五节 关于梦的记忆</h2><h3 id="冥想对于解决难题的益处"><a href="#冥想对于解决难题的益处" class="headerlink" title="冥想对于解决难题的益处"></a>冥想对于解决难题的益处</h3><p>冥想练习能够帮助我们专注当下，产生更多的深度思考。深度思考刺激可以将我们的思维延续到梦境，比清醒时刻更有创造力，从而解决棘手的难题。</p>
<h3 id="关于梦的记忆"><a href="#关于梦的记忆" class="headerlink" title="关于梦的记忆"></a>关于梦的记忆</h3><p>通过回忆，梦可以被重新记起来。可我们总会有这样的感觉：夜里的梦包罗万象、多姿多彩，比我们能回想起来的部分要丰富得多。而且，随着时间的流逝，我们关于梦的记忆还会逐渐淡去</p>
<p>关于梦的记忆，有些深刻、有些模糊、有些则被完全遗忘，但总的来说，我们可以确认一点：相比起清醒时刻的记忆，关于梦的记忆我们有着更加强烈的遗忘趋势，而这种遗忘的趋势无法被我们自己所掌控，我们无法选择自己希望记住的梦和不想记住的梦。</p>
<h2 id="第二十六节-对梦的遗忘"><a href="#第二十六节-对梦的遗忘" class="headerlink" title="第二十六节 对梦的遗忘"></a>第二十六节 对梦的遗忘</h2><p>哪些原因导致了我们对梦境的遗忘？<br>第一点：在同一时间内，我们能够观察和接收信息的数量是非常有限的。</p>
<p>你可以把梦境理解为屏幕上的一幅图像，醒来的一瞬间，屏幕会在我们眼前闪过，然后瞬间黑屏。由于第一时间我们的视角只能集中于图像上的某一部分，我们能够记住的梦境也只有一部分。</p>
<p>第二点：大脑记忆事物是需要重复巩固的，而大部分的梦境都是独一无二，难以重温的体验。</p>
<p>第三点：大脑不擅长记忆没有联系的内容，而大多数梦不会表现的井井有条，往往是天马行空。</p>
<h2 id="第二十七节-梦境中的思维特征"><a href="#第二十七节-梦境中的思维特征" class="headerlink" title="第二十七节 梦境中的思维特征"></a>第二十七节 梦境中的思维特征</h2><p>梦境中的思维特征<br>第一个特征，指的是梦境具有一种清醒时候不具备的能力，那就是把全部的想法都用幻想出来的画面和场景展现。或者说，用幻觉取代了思维活动。</p>
<p>在梦境当中，所有的观念都会转变为幻觉，用类似于戏剧化的方式呈现出来，我们不是导演和评论家，而是演员和观众。</p>
<p>第二个特征，就是梦境中我们不会带有任何成见。不论是多么荒谬的，真实世界中绝无可能发生的事情，都有可能在梦中出现，并且被我们泰然自若的接受。</p>
<h2 id="第二十八节-梦的意义-1"><a href="#第二十八节-梦的意义-1" class="headerlink" title="第二十八节 梦的意义(1)"></a>第二十八节 梦的意义(1)</h2><p>梦存在的意义是什么<br>在生活中，自我会参考超我和本我的感受，从而作出决定。这意味着只要我们保持清醒，道德和欲望就无时不刻影响着自我。将隐蔽的本性揭示在我们面前就是梦存在的最大意义。</p>
<p>这种本性并非我们当下的真实面目，而是让我们看到在一种别样的生存方式下，我们有可能成为的样子。</p>
<h2 id="第二十九节-梦的意义-2"><a href="#第二十九节-梦的意义-2" class="headerlink" title="第二十九节 梦的意义(2)"></a>第二十九节 梦的意义(2)</h2><h3 id="突破性进步"><a href="#突破性进步" class="headerlink" title="突破性进步"></a>突破性进步</h3><p>通常情况下，我们进步的过程都是非常局限的，因为我们自己心里有一杆秤，会先判断什么是好的，什么是对的，什么是有道德的，什么是让我们开心的。换句话说，本我和超我会指引我们进步的方向，但同时也限制我们只能向一个方向前进。梦能够将人最真实的本性展现出来，让我们窥探到自己内心最私密的东西，也让我们得以绕开本我和超我的局限，实现突破性的进步。</p>
<h3 id="拓展视野"><a href="#拓展视野" class="headerlink" title="拓展视野"></a>拓展视野</h3><p>当人在梦中实现了自然状态的回归，尽情展现着自我的本能。随着心灵逐渐摆脱了已知观念的束缚，我们就能够从这个世界自然真实的一面获取更多的启发。在对事物的一切处理上，梦的本质反映出了我们自身更真实的一面，这一面的丰富程度超出了我们在清醒生活中通过观察、思考和学习了解到的全部。梦境通过真实的力量，让我们看到更广阔的世界。</p>
<h2 id="第三十节-复习课"><a href="#第三十节-复习课" class="headerlink" title="第三十节 复习课"></a>第三十节 复习课</h2><h3 id="梦的来源"><a href="#梦的来源" class="headerlink" title="梦的来源"></a>梦的来源</h3><p>人们所经历、体会过的东西，是构成梦的原材料。梦境不会让记忆重复上演，但往往会通过夸大和拼接的方式呈现，把记忆中的片段变成一个新的场景或故事。所有记忆都可能出现在梦境中，相对而言，有三类记忆出现的次数最多：遗忘记忆、童年记忆、和我们经历过的重要事件中不起眼的小细节。</p>
<h3 id="催生梦境的刺激"><a href="#催生梦境的刺激" class="headerlink" title="催生梦境的刺激"></a>催生梦境的刺激</h3><p>外界对感官形成的刺激、我们躺在床上，闭上眼后脑海中浮现的各种画面、身体器官传递出的信号、清醒时候的深度思考，都会引发对应的梦境</p>
<h3 id="为什么会遗忘梦境"><a href="#为什么会遗忘梦境" class="headerlink" title="为什么会遗忘梦境"></a>为什么会遗忘梦境</h3><p>1、  在同一时间内，我们能够观察和接收信息的数量是非常有限的，而关于梦的记忆是瞬间的大量信息。<br>2、  大脑记忆事物是需要重复巩固的，而大部分的梦境都是独一无二，难以重温的体验。<br>3、  大脑不擅长记忆没有联系的内容，而大多数梦不会表现的井井有条，往往是天马行空。</p>
<h3 id="梦境的思维特征"><a href="#梦境的思维特征" class="headerlink" title="梦境的思维特征"></a>梦境的思维特征</h3><p>梦境能够把全部的想法都用幻想出来的画面和场景展现，而且不会带有任何成见。不论是多么荒谬的，真实世界中绝无可能发生的事情，都有可能在梦中出现，并且被我们泰然自若的接受。正因如此，梦境才会将隐蔽的本性揭示在我们面前，让我们窥探到自己内心最私密的东西，也让我们得以绕开本我和超我的局限，实现突破性的进步。通过真实的力量，让我们看到更广阔的世界。</p>
<h2 id="第三十一节-人的需求（1）"><a href="#第三十一节-人的需求（1）" class="headerlink" title="第三十一节 人的需求（1）"></a>第三十一节 人的需求（1）</h2><h3 id="何为欲望"><a href="#何为欲望" class="headerlink" title="何为欲望"></a>何为欲望</h3><p>准确来说，欲望就是由人的本性产生的，想达到某种目的的需求。我们可以通过马斯洛的需求层次理论来拆分欲望。</p>
<h3 id="生理需求"><a href="#生理需求" class="headerlink" title="生理需求"></a>生理需求</h3><p>生理需求是人们最原始、最基本的需要。它是最强烈的不可避免的最底层需要，也是推动人们行动的强大动力。但当一个人的生理需求没有得到满足时，其他一切需要均退居次要地位。</p>
<h3 id="安全需求"><a href="#安全需求" class="headerlink" title="安全需求"></a>安全需求</h3><p>安全需求指的是人们对于自身安全的追求。包括人身安全、身体健康、稳定的收入、稳定的社会关系和工作等等。安全需求比生理需求更高一级，当人的生理需求得到满足以后，安全需求就会显现。</p>
<h2 id="第三十二节-人的需求（2）"><a href="#第三十二节-人的需求（2）" class="headerlink" title="第三十二节 人的需求（2）"></a>第三十二节 人的需求（2）</h2><h3 id="社交需求"><a href="#社交需求" class="headerlink" title="社交需求"></a>社交需求</h3><p>社交需求又叫归属与爱的需要，是指我们每个人对家庭、集体、朋友、同事的关怀、爱护和理解的渴望。在生活中最令我们感到美好的友情、信任、温暖和爱情，都属于社交需求的范畴。</p>
<h3 id="尊重需求"><a href="#尊重需求" class="headerlink" title="尊重需求"></a>尊重需求</h3><p>尊重需求包含内部尊重和外部尊重两种。内部尊重指的是人对于自己的评价和要求，希望自己具备较强的能力和道德，在各种不同环境中都能够适应挑战、充满信心、独立自主。外部尊重是指人们渴望自己拥有一个体面且受到承认的社会地位，有一定的威信，自己的个人能力和取得的成就能够得到他人的认可、尊重、信赖和赞誉。</p>
<h2 id="第三十三节-人的需求（3）"><a href="#第三十三节-人的需求（3）" class="headerlink" title="第三十三节 人的需求（3）"></a>第三十三节 人的需求（3）</h2><h3 id="认知需求"><a href="#认知需求" class="headerlink" title="认知需求"></a>认知需求</h3><p>认知需求，指的是人对自身和周围世界的探索、理解以及解决疑难问题的渴望。人类文明能有今天这么惊人的发展，很大程度上就是得益于认知需求的推动。当我们解决了温饱，拥有了爱情和友情，受到了尊重，发展科学技术，探索世界就会成为我们新的目标。</p>
<h3 id="审美需求"><a href="#审美需求" class="headerlink" title="审美需求"></a>审美需求</h3><p>“爱美之心人皆有之”，每个人都喜欢欣赏美的事物，无论是美丽的面孔、壮丽的风景、还是艺术家的杰作。</p>
<h3 id="自我实现需求"><a href="#自我实现需求" class="headerlink" title="自我实现需求"></a>自我实现需求</h3><p>自我实现需求是最高等级的需要，指的是人们会竭尽所能，使自己趋于完美，实现自己的理想和目标，获得成就感。自我实现需求最大的特点是我们不再把目光集中在外界，而是回归自我，不再执着于达成某种目的，生活本身就成为了最大的目的。</p>
<h2 id="第三十四节-择偶的意义"><a href="#第三十四节-择偶的意义" class="headerlink" title="第三十四节 择偶的意义"></a>第三十四节 择偶的意义</h2><h3 id="择偶行为是社会生活的中心"><a href="#择偶行为是社会生活的中心" class="headerlink" title="择偶行为是社会生活的中心"></a>择偶行为是社会生活的中心</h3><p>想要在行为层面上更好的理解欲望，需要在所有的社会活动中找到一个最广泛、最重要、最便于理解的行为，没有哪种行为能够像寻找伴侣一样，驱动着我们需求的方方面面。</p>
<p>爱情是社交需求的重要组成部分，情感关系的稳定性影响到我们的安全需求，和伴侣的彼此尊重和学习满足了认知需求和尊重需求，美好和谐的家庭有助于人的自我实现。可以说，几乎每一层次的需求，都离不开与伴侣的相处。</p>
<p>如果男性能够了解女性的诉求，女性能够代入男性的视角，性别差异带来的沟通代沟就会得到缓解。</p>
<h2 id="第三十五节-择偶偏好"><a href="#第三十五节-择偶偏好" class="headerlink" title="第三十五节 择偶偏好"></a>第三十五节 择偶偏好</h2><h3 id="是男生不用心，还是女生太挑剔"><a href="#是男生不用心，还是女生太挑剔" class="headerlink" title="是男生不用心，还是女生太挑剔"></a>是男生不用心，还是女生太挑剔</h3><p>在两性关系中，之所以女性对细节有更多要求，背后原因要追溯到上古时代。在如今这个发达的社会当中，人们的生活追求是丰富且复杂的，爱情也被赋予了浓厚的人文意义。但是，在生活贫瘠，尚未开化的年代里，人和世界上大部分生命一样，只有两种简单明确的诉求：生存和繁衍。</p>
<p>没有崇高的爱情，也缺乏完善的社会背景，在那个年代里，择偶行为是完全围绕繁衍展开的。想要孕育一个生命，男性只需要很小的成本，而女性却需要承受接近一年的孕期，这是一项不可推卸的、消耗巨大的投资。</p>
<p>正因如此，女性必须在选择伴侣时严格把关，注重细节。因为一旦做出了选择，几乎就是赌上了自己的一生。随着科学技术的发展，生育已经是可以控制的事情。人们选择伴侣也不再是只为了繁衍，甚至还有丁克家庭的出现。但祖祖代代千百年来形成的心理特征，早已融入了本能当中，不会轻易的从我们身上抹去。</p>
<h2 id="第三十六节-两种能力、三个特征"><a href="#第三十六节-两种能力、三个特征" class="headerlink" title="第三十六节 两种能力、三个特征"></a>第三十六节 两种能力、三个特征</h2><h3 id="两种天生的能力"><a href="#两种天生的能力" class="headerlink" title="两种天生的能力"></a>两种天生的能力</h3><p>女性在选择伴侣时，天然具备两种能力。第一种能力是从男性的成千上万种差异中，筛选出最具价值的少数特征。知道观察一个人的时候要重点关注哪些方面。第二种能力是把关键的特征与自己的个人需要和独特境况结合进行分析。</p>
<h3 id="三类关键特征"><a href="#三类关键特征" class="headerlink" title="三类关键特征"></a>三类关键特征</h3><p>女性关注的关键特征主要分为三类：资源、潜力和生活基础。</p>
<p>资源指的是一个男性在当下获取和控制社会资源的能力，这种能力由经济实力、社会地位和合适的年龄共同组成。</p>
<p>对经济实力的适度关注，并不是拜金主义或者攀附权贵，而是对自己和未来生活负责的本能行为。</p>
<h2 id="第三十七节-社会地位与年龄偏好"><a href="#第三十七节-社会地位与年龄偏好" class="headerlink" title="第三十七节 社会地位与年龄偏好"></a>第三十七节 社会地位与年龄偏好</h2><h3 id="看重社会地位的原因"><a href="#看重社会地位的原因" class="headerlink" title="看重社会地位的原因"></a>看重社会地位的原因</h3><p>社会地位和经济实力具有较强的相关性。社会地位更高的人普遍拥有更多财富，对经济实力的追求也会折射在社会地位之中。</p>
<p>社会地位象征着一个人是否被社会主流的价值观所承认。选择社会地位高的男性作为伴侣，其实就相当于征求了整个社会的意见，能够有效的降低做出错误判断的概率。</p>
<h3 id="年龄偏好与背后的复杂思考"><a href="#年龄偏好与背后的复杂思考" class="headerlink" title="年龄偏好与背后的复杂思考"></a>年龄偏好与背后的复杂思考</h3><p>表面上看，大叔和小鲜肉都很受女生的欢迎，年龄似乎不会影响男性的魅力。但这种喜爱，更类似于粉丝对于偶像的追捧，或是对于少数几个特征的偏好。根据心理学权威戴维巴斯教授的研究，真正到了组建家庭，敲定人生大事的时候，大部分女性倾向于选择比自己大三岁半左右的男性作为伴侣。</p>
<p>这种本能偏好的背后，其实是多种因素权衡取舍后的综合考虑：男性的年龄越大，社会地位和经济实力就越强，但发展潜力则越来越少，如果过于年长，沟通上会有代沟，夫妻二人携手共度的时光也会更短。</p>
<h2 id="第三十八节-潜力偏好"><a href="#第三十八节-潜力偏好" class="headerlink" title="第三十八节 潜力偏好"></a>第三十八节 潜力偏好</h2><h3 id="与潜力相关的特征"><a href="#与潜力相关的特征" class="headerlink" title="与潜力相关的特征"></a>与潜力相关的特征</h3><p>潜力由三个特征共同组成：分别是勤奋、情绪稳定性与才华。如果说经济实力和社会地位代表了当下掌控的资源，那么一个勤奋、情绪稳定且才华横溢的人，即便当前身无分文，也没有较高的社会地位，也会因为能够在未来长期的、持续的获取资源，同样获得女性的偏爱。</p>
<p>从长期来看，自认为工作努力，才华横溢，并且得到周围人认可的个体，比起其他人获得了更高的教育水平，拥有更高的年收入，并且预期会有更多的升职机会。</p>
<p>如果生活是一场没有变数的竞争，那么只依靠努力与才华出众就足够了。但人生总是充满了变数，保持稳定，拥抱变化的能力同样很重要，这就是情绪稳定性的作用。</p>
<p>情商的全称叫做情绪商数，跟情绪稳定性是非常类似的概念。情商高形容的并不是“会说话，会看人脸色办事”，而是指能够快速适应生活的各种变化，能够在承受压力的情况下保持常态。</p>
<h2 id="第三十九节-生活基础偏好"><a href="#第三十九节-生活基础偏好" class="headerlink" title="第三十九节 生活基础偏好"></a>第三十九节 生活基础偏好</h2><h3 id="与生活基础相关的特征"><a href="#与生活基础相关的特征" class="headerlink" title="与生活基础相关的特征"></a>与生活基础相关的特征</h3><p>生活基础由四个具体的特征共同组成，分别是和谐共处、体格、健康和对爱的承诺。</p>
<p>和谐相处，意味着性格互补、思想相似。互补的性格能够降低伴侣间发生争吵的概率，思想的相似意味着类似的生活习惯、爱好，还能确保在人生的长远追求上保持一致。</p>
<p>良好的体格和健康，既满足了审美需求，也照顾了安全需求。</p>
<p>对爱的承诺也非常重要。如果男性不能下定决心建立长期关系，他的条件再好，对于女性来说也有可能是竹篮打水一场空。这就是为什么会有求婚这个环节，而且还要用昂贵的婚戒来为这份承诺增添分量。</p>
<h3 id="在你意识不到的地方，本能也会思考"><a href="#在你意识不到的地方，本能也会思考" class="headerlink" title="在你意识不到的地方，本能也会思考"></a>在你意识不到的地方，本能也会思考</h3><p>在择偶时，我们并不会刻意去围绕这些复杂的因素逐一思考。但潜意识中无法直接感知到的心理活动会本能地进行判断，并通过情绪的方式直接传递结果。</p>
<p>这部分无法感知的自我，是探索自我之旅非常重要的研究对象。</p>
<h2 id="第四十节-两性的择偶差异"><a href="#第四十节-两性的择偶差异" class="headerlink" title="第四十节 两性的择偶差异"></a>第四十节 两性的择偶差异</h2><h3 id="女性对男性的改变"><a href="#女性对男性的改变" class="headerlink" title="女性对男性的改变"></a>女性对男性的改变</h3><p>从繁衍本能的角度出发，男性对于择偶的要求并不复杂，因为最理想的策略并不是寻找最合适的伴侣，承诺爱情和相伴终生，而是和尽可能多的女性保持亲密关系。数量比质量更重要，那么也就谈不上要筛选伴侣。</p>
<p>男性之所以变得“专一”，一方面是人不止会根据本能思考，另一方面，是因为女性不仅要求男性有资源、有潜力，还要求他对爱情进行承诺。专一的男性会更受欢迎，能够把自己专一的基因遗传下来。</p>
<h2 id="第四十一节-年轻、健康与忠诚"><a href="#第四十一节-年轻、健康与忠诚" class="headerlink" title="第四十一节 年轻、健康与忠诚"></a>第四十一节 年轻、健康与忠诚</h2><h3 id="判断健康的方式"><a href="#判断健康的方式" class="headerlink" title="判断健康的方式"></a>判断健康的方式</h3><p>在医学不发达的上古时代，只能通过观察外部特征来判断健康情况。外部特征主要有两种，一种是行为特征，比如活泼的性格、走路时轻快的步伐。另一种是身体特征，比如丰满的嘴唇、明亮的肤色、光滑的皮肤、清澈的眼神、富有光泽的头发和匀称的肌肉。这些能够体现健康的象征，恰恰也是我们在审美时的偏好。</p>
<p>爱美之心，人皆有之。从根源上来说，最初的美，就是能够反映健康状态的身体特征。当我们觉得一个人好看的时候，其实是本能通过自己的判断，认可了对方的健康状况。</p>
<h2 id="第四十二节-复习课"><a href="#第四十二节-复习课" class="headerlink" title="第四十二节 复习课"></a>第四十二节 复习课</h2><h3 id="择偶偏好的起源"><a href="#择偶偏好的起源" class="headerlink" title="择偶偏好的起源"></a>择偶偏好的起源</h3><p>生命的两个基本诉求是生存和繁衍，择偶行为是由繁衍诉求衍生出来的。为了在择偶时做出正确的判断，需要从人的成千上万种差异中，筛选出最具价值的少数特征，这些特征就是择偶偏好。</p>
<p>这种偏好不需要刻意思考，而是通过潜意识中无法直接感知到的心理活动进行判断，并通过情绪的方式直接传递结果。</p>
<h3 id="女性的择偶偏好"><a href="#女性的择偶偏好" class="headerlink" title="女性的择偶偏好"></a>女性的择偶偏好</h3><p>生育需要女性进行巨大的投入，需要伴侣给予充足的资源支持，因此女性的择偶偏好是围绕“资源”展开的。</p>
<p>女性关注的关键特征主要分为三类：资源、潜力和生活基础。</p>
<p>资源指的是一个男性在当下获取和控制社会资源的能力，这种能力由经济实力、社会地位和合适的年龄共同组成。</p>
<p>潜力指的是在未来长期、持续获取资源的能力，这种能力由三个特征共同组成：分别是勤奋、情绪稳定性与才华。</p>
<p>资源带来的生活条件的保证只是基础，人与人之间的相处是否愉悦、能否培养深厚的感情也很重要。因此，除了资源和潜力，还需要生活基础。生活基础由四个具体的特征共同组成，分别是和谐共处、体格、健康和对爱的承诺。</p>
<h3 id="男性的择偶偏好"><a href="#男性的择偶偏好" class="headerlink" title="男性的择偶偏好"></a>男性的择偶偏好</h3><p>女性很少会担心男性缺乏生育能力，择偶主要是为了找到可靠的，能够承担起父亲责任的伴侣；而男性择偶，首先要找到具备生育能力的伴侣。因此，男性的择偶偏好是围绕“生育能力”展开的。</p>
<p>男性关注的关键特征主要分为三类：健康、年轻和忠诚。</p>
<h2 id="第四十三节-何为潜意识"><a href="#第四十三节-何为潜意识" class="headerlink" title="第四十三节 何为潜意识"></a>第四十三节 何为潜意识</h2><h3 id="什么是潜意识"><a href="#什么是潜意识" class="headerlink" title="什么是潜意识"></a>什么是潜意识</h3><p>潜意识是一个心理学的专业词汇，潜是潜在、潜力的潜，最早由弗洛伊德提出，指的是人类心理活动中，不能认知或没有认知到的部分，是人们“已经发生，但没有体现在意识中的心理活动过程”。</p>
<p>弗洛伊德把潜意识具体分为了两个部分，一部分叫前意识，一部分叫无意识。前意识属于潜意识里有可能进入意识的部分；而无意识属于绝对无法感知到的那部分意识。</p>
<p>在弗洛伊德的心理学理论中，无意识、前意识和意识是三个层次不同，但又相互联系的系统结构。</p>
<h2 id="第四十四节-潜意识的短期影响"><a href="#第四十四节-潜意识的短期影响" class="headerlink" title="第四十四节 潜意识的短期影响"></a>第四十四节 潜意识的短期影响</h2><p>潜意识的短期影响<br>潜意识对生活的影响，可以从短期和长期两个角度来看。所谓短期影响，就是即时发生的，对我们行为的引导。</p>
<p>择偶偏好就是一种：潜意识会根据本能的择偶偏好，影响我们看待他人的方式。比如，哪怕对一个人还不了解的时候，有些人你会一见钟情，产生天然的好感，而有些人没有得罪过你，你却打心底里就想要和他保持距离。</p>
<h2 id="第四十五节-潜意识的长期影响"><a href="#第四十五节-潜意识的长期影响" class="headerlink" title="第四十五节 潜意识的长期影响"></a>第四十五节 潜意识的长期影响</h2><p>潜意识的长期影响 —— 均值回归<br>均值回归是一个与股票相关的概念。它的意思是：从短期来看，一个公司的股价会有波动，会有大幅度的涨和跌，难以预测，但把时间尺度放到五年十年，甚至更久，这个公司的真实价值是多少，股价就会稳定在什么水平。</p>
<p>如果不考虑非同寻常的好运或者厄运，人的一生，其实也是均值回归的过程。只从局部上看，决定人生走向的，是竞争的结果和我们选择的路径。但随着时间的推移，人终究会回到自己的均值。那个均值就是你的潜意识，是你内心最深处的冲动，是你到底是一个什么样的人。</p>
<p>人生最重要的事情就是如何清楚地认识自己：我的性格如何，我有什么优缺点，我喜欢做什么工作，我喜欢什么样的生活方式。我的梦想是改变世界，获得尊敬，还是住在一个有山有水的地方，每天遛狗、做饭、和朋友打打牌、陪自己的家人。</p>
<p>不是智商和情商，而是潜意识中的那个真实的自我，决定了你愿意为什么奋斗，决定了你对一份事业的热情和责任心，把自己放在什么样的位置是舒服的。而这些因素，最终决定了你的人生。</p>
<h2 id="第四十六节-大象与骑象人"><a href="#第四十六节-大象与骑象人" class="headerlink" title="第四十六节 大象与骑象人"></a>第四十六节 大象与骑象人</h2><h3 id="进一步探索自我-——-关于幸福"><a href="#进一步探索自我-——-关于幸福" class="headerlink" title="进一步探索自我 —— 关于幸福"></a>进一步探索自我 —— 关于幸福</h3><p>幸福是我们所有人的追求目标，却在不同的人心中有不同的定义。在接下来的课程中，我们会通过十个主题的展开，从浮躁喧嚣的环境中抽离出来，看清自己的本心。你认为幸福是什么，它就是什么。</p>
<h3 id="第一个主题-——-大象与骑象人假设"><a href="#第一个主题-——-大象与骑象人假设" class="headerlink" title="第一个主题 —— 大象与骑象人假设"></a>第一个主题 —— 大象与骑象人假设</h3><p>人的心理分为不同的两部分：我们能感知到的自我是一个骑在大象背上的人，而不能被感知到的自我，就是大象本身。骑象人手里握着缰绳，可以指挥大象转弯、停止或是前进。需要注意的是，当大象没有自己的想法时，我们才可以指挥。一旦大象真的想要做什么，它就会自顾自的走。</p>
<h2 id="第四十七节-大象的本质"><a href="#第四十七节-大象的本质" class="headerlink" title="第四十七节 大象的本质"></a>第四十七节 大象的本质</h2><h3 id="心理的两套运行机制"><a href="#心理的两套运行机制" class="headerlink" title="心理的两套运行机制"></a>心理的两套运行机制</h3><p>自我是一个由大象和骑象人共同组成的复杂组织。组织的内部包含了各种不同的角色，心灵和身体、理性和感性，以及左脑和右脑。经过了多年的研究和分析，心理学家们把两两对立的元素统一起来，将人的心理分成了两套运作机制：主动控制和自动化处理。</p>
<h3 id="大象-——-自动化处理"><a href="#大象-——-自动化处理" class="headerlink" title="大象 —— 自动化处理"></a>大象 —— 自动化处理</h3><p>大部分的心理活动会在我们没有意识到的时候自动发生，并对身体产生实质性的影响。这种自动化处理的机制，又被称为潜意识。由于意识不到，这种自动化处理的机制不够理智，但和一次只能思考一两件事情的骑象人比起来，大象的优势就是可以同时处理大量任务。</p>
<h2 id="第四十八节-人象冲突-1"><a href="#第四十八节-人象冲突-1" class="headerlink" title="第四十八节 人象冲突(1)"></a>第四十八节 人象冲突(1)</h2><h3 id="为什么杰出的人是少数"><a href="#为什么杰出的人是少数" class="headerlink" title="为什么杰出的人是少数"></a>为什么杰出的人是少数</h3><p>骑象人代表了有意识的、主动控制后的思考。大象包含我们内心的感觉、本能反应、情绪和直觉，代表了自动化的心理活动。大象和骑象人各有优势，只要配合良好，就成组成一个杰出的个体。但是，在大部分人的心中，大象和骑象人之间会产生复杂的冲突，很难形成一个良好的整体。</p>
<h3 id="人象冲突-——-当下与未来"><a href="#人象冲突-——-当下与未来" class="headerlink" title="人象冲突 —— 当下与未来"></a>人象冲突 —— 当下与未来</h3><p>骑象人目光长远，而大象只盯着当下。如果骑象人不能控制大象，人就会为了微不足道的短期利益而放弃未来更好的发展机会。</p>
<h2 id="第四十九节-人象冲突-2"><a href="#第四十九节-人象冲突-2" class="headerlink" title="第四十九节 人象冲突(2)"></a>第四十九节 人象冲突(2)</h2><p>人象冲突 —— 心理活动的循环<br>当骑象人产生一个目标，并且大象也愿意执行时，大象就会分出一部分精力用于检查目标的完成情况并加以协助，直到确认完成才停止。这种合作模式在完成实际行动时非常合适，但应用在心理活动时就很容易陷入死循环。</p>
<p>以消除杂念为例：如果骑象人的目标是消除杂念，那么大象也会开始自动检查杂念是否消除。每当骑象人把杂念清除，大象就会把杂念再拽回来，看看消除的是不是它。你越是想要清除杂念，大象就越卖力的检查，杂念反而在脑海里生根发芽。</p>
<h2 id="第五十节-人象冲突-3"><a href="#第五十节-人象冲突-3" class="headerlink" title="第五十节 人象冲突(3)"></a>第五十节 人象冲突(3)</h2><p>人象冲突 —— 骑象人的解释误区<br>我们能感知到的自我，产生的思考和意识，都是以骑象人的身份进行的。这会让我们形成一种刻板的印象：误以为我们的所有观点、情感和行为，都是骑象人先进行思考，再传达给大象。</p>
<p>但事实并非如此。很多时候，是大象自己做出了决定。骑象人所做的并不是决定，而是想办法拼凑出一些语句和道理来解释自己的所作所为。</p>
<p>如果我们总是试图用理性来解释自己的所作所为，就会在遇到那些根本无法解释的内心冲动时陷入迷茫；或者在每一次立下誓言却无法坚持的时候质疑自己的虚伪和软弱。</p>
<h2 id="第五十一节-大象很聪明"><a href="#第五十一节-大象很聪明" class="headerlink" title="第五十一节 大象很聪明"></a>第五十一节 大象很聪明</h2><p>大象很“聪明”<br>人和象的博弈看上去很像理性与感性，人性与兽性的对抗，但事实并非如此。大象不等同于不理性的自我，只是它的理性无法被直接感知。</p>
<p>心理学家通过实验发现：屏幕上飞速闪过的、无法被我们意识到的词语，依然对我们产生了影响。这说明，骑象人无法感知的细节，可以被大象感知，而且大象具备一定的认知能力。</p>
<p>能够通过感官观察世界，进行思考的，不只有被我们感知到的意识，还有一个敏感且聪明的大象。这就是为什么，我们的情绪总是会没有道理、莫名其妙的改变。而从另一个角度来看，想要改善自己的心情，不能只靠把事情想通，外部环境的细节也很重要。</p>
<h2 id="第五十二节-对幸福的理解"><a href="#第五十二节-对幸福的理解" class="headerlink" title="第五十二节 对幸福的理解"></a>第五十二节 对幸福的理解</h2><p>对幸福的三种常见理解<br>在一部分人的心中，幸福的样子是很具体的。他们把幸福与物质绑定起来，对获得财富抱有极大的热情，坚信最大的幸福来自于获得自己想要的身外之物。</p>
<p>在另一部分人的心中，幸福不是庸俗的物质，而是精神上的财富。比如他人的认可、较高的社会地位、真挚的友情，美满的家庭。</p>
<p>还有人认为，追求身外之物，或强求世事如自己所愿，最后都是一场空。真正的幸福只能来自于自己的内心，断除对身外之物的执着，对身边的一切都采取平和接受的态度。</p>
<h2 id="第五十三节-调整预期"><a href="#第五十三节-调整预期" class="headerlink" title="第五十三节 调整预期"></a>第五十三节 调整预期</h2><p>提升幸福感的技巧 —— 调整预期<br>保持进展，能够把长期目标带来的短暂幸福，变成一步一步前进的兴奋和满足。是一种锦上添花、扩大幸福的方式。但是，生活中不只有好事，难免还会遇到些厄运降临。想要提升幸福感，除了锦上添花，还需要雪中送炭，这时候就需要调整预期。</p>
<p>人对于当下处境的看待方式，高度取决于他对生活的心理预期。每个人都有自己羡慕的对象，但同样，每个人都被别人羡慕着。改变生活很难，但调整预期只需要我们换个角度。如果我们能够做到“羡慕自己“，幸福就会随之降临。</p>
<h2 id="第五十四节-对生命的理解"><a href="#第五十四节-对生命的理解" class="headerlink" title="第五十四节 对生命的理解"></a>第五十四节 对生命的理解</h2><p>你认为生命本身是什么，它就是什么”<br>“没有事实，只有感受。”世界是客观的，但你所理解的生活，你看到的事实，都是客观存在经过自己思考加工后才形成的。</p>
<p>意义是我们自己赋予的，这意味着我们也有改变意义的权力和能力，明确这一点，我们就能够明白一颗强大内心的重要：除非你觉得悲惨，否则没有什么是悲惨的；同理，除非你知足常乐，否则没有什么事能让你快乐。</p>
<p>生活本身没有任何枷锁，是悲观的解读方式建造了内心的牢笼。因此，改变预期并不只是一种技巧，究其根源，是一种更加广阔、更加包容的看待世界和生活的态度。</p>
<h2 id="第五十五节-幸福方程式"><a href="#第五十五节-幸福方程式" class="headerlink" title="第五十五节 幸福方程式"></a>第五十五节 幸福方程式</h2><h3 id="幸福由何组成"><a href="#幸福由何组成" class="headerlink" title="幸福由何组成"></a>幸福由何组成</h3><p>自弗洛伊德以来，心理学界的主流观点认为，人的个性主要受童年时期环境的影响。20世纪90年代，研究人员又在有关幸福的研究中发现：一个人快乐与否、性格如何，其实与基因的关系密切，与后天环境则不太相关。</p>
<p>人的幸福，究竟是先天决定，还是后天形成？为了回答这些疑问，积极心理学的开创人塞利格曼组织了专家研究小组，经过了长期的观察和实验，得出了幸福方程式。</p>
<h3 id="幸福方程式"><a href="#幸福方程式" class="headerlink" title="幸福方程式"></a>幸福方程式</h3><p>幸福方程式：H=S+C+V。<br>先天的幸福指数、所处环境的生活条件和看待生活的态度，这三者共同决定了我们真正感知到的幸福。这说明幸福不全是天生的，我们对幸福的追求并不是徒劳。但在追求的过程中，光注重物质，改善生活条件是不行的；只改变态度也是不行的，要尽量兼顾这两者才可以。</p>
<h2 id="第五十六节-影响幸福感的因素-1"><a href="#第五十六节-影响幸福感的因素-1" class="headerlink" title="第五十六节 影响幸福感的因素(1)"></a>第五十六节 影响幸福感的因素(1)</h2><h3 id="值得改变的外部因素-——-噪声"><a href="#值得改变的外部因素-——-噪声" class="headerlink" title="值得改变的外部因素 —— 噪声"></a>值得改变的外部因素 —— 噪声</h3><p>生活条件是无数外部因素共同组成的，在众多因素之中，有五点容易被忽视，却能显著影响生活。</p>
<p>居住环境的噪声就是其中之一：研究显示，无论过了多久，人都无法做到完全适应噪声干扰。甚至有研究显示，人有时为了适应噪声，认知功能会因而受损。各式各样、间歇出现的噪声都会干扰我们的注意力，增加我们的压力。</p>
<h3 id="值得改变的外部因素-——-通勤时间"><a href="#值得改变的外部因素-——-通勤时间" class="headerlink" title="值得改变的外部因素 —— 通勤时间"></a>值得改变的外部因素 —— 通勤时间</h3><p>很多人为了住大一点儿的房子，宁愿住到离公司较远的地方。但大房子带来的快乐是短暂的，随着预期提高，人很快就能适应空间变大的好处。但无论是自己开车的塞车之苦，还是一路挤地铁，长时间通勤的痛苦却是持续的，通勤时间的延长还意味着要牺牲睡眠和休息时间。</p>
<h2 id="第五十七节-影响幸福感的因素-2"><a href="#第五十七节-影响幸福感的因素-2" class="headerlink" title="第五十七节 影响幸福感的因素(2)"></a>第五十七节 影响幸福感的因素(2)</h2><h3 id="值得改变的外部因素-——-掌控感"><a href="#值得改变的外部因素-——-掌控感" class="headerlink" title="值得改变的外部因素 —— 掌控感"></a>值得改变的外部因素 —— 掌控感</h3><p>居住环境的噪音，和漫长的通勤时间，有一个重要的共同点，那就是这两项因素之所以让人恼火，是因为我们无法控制它们。通过实验发现，如果人们认为自己可以控制噪声，这个想法就会让他们觉得噪声没那么烦人。</p>
<p>因此，增强自己对生活的掌控感，是提升活力和快乐的一大利器。哪怕是遇到了艰巨的挑战，也要认真规划，拆解成能够掌握的小任务。</p>
<h3 id="值得改变的外部因素-——-天然的缺陷"><a href="#值得改变的外部因素-——-天然的缺陷" class="headerlink" title="值得改变的外部因素 —— 天然的缺陷"></a>值得改变的外部因素 —— 天然的缺陷</h3><p>人们有一个共识，那就是人要扬长避短，与其把精力集中在改善缺点，不如强化自己的优势，更容易在社会中取得成功。但想要追求幸福感，查漏补缺的优先级就要更高。哪怕是看似肤浅的改变，只要能掩饰自己的天然缺陷，就能立竿见影的让人感到更自信，更快乐。</p>
<h2 id="第五十八节-建立良好人际关系"><a href="#第五十八节-建立良好人际关系" class="headerlink" title="第五十八节 建立良好人际关系"></a>第五十八节 建立良好人际关系</h2><h3 id="值得改变的外部因素-——-人际关系"><a href="#值得改变的外部因素-——-人际关系" class="headerlink" title="值得改变的外部因素 —— 人际关系"></a>值得改变的外部因素 —— 人际关系</h3><p>人是社会动物。因此在影响一个人幸福与否的所有外在因素中，最重要的因素，正是人际关系的好坏及多寡。如果处于不和谐的人际关系中，就算我们没看到对方，两人之间的冲突也还是会萦绕在脑海中，持续伤害着我们的情绪，每天都会持续，让人和幸福感远离。</p>
<h3 id="建立良好人际关系的两个原则"><a href="#建立良好人际关系的两个原则" class="headerlink" title="建立良好人际关系的两个原则"></a>建立良好人际关系的两个原则</h3><p>第一条原则，是要主动。随着人类社会的发展，一个人能建立的社交网络变得越来越庞大，这意味着朋友间的常态并不是相聚，而是疏离。疏离久了，你或许就会对友情产生怀疑，如果没能及时的缓解，这种怀疑就有可能成为永久的误会，友情也就不复存在。</p>
<p>第二条原则，是不要追求公平。人际关系不能量化，也就不可能像数学中的等式那样，用一个等号来连接两个人。在人与人的交往中，付出本身就是一种快乐，只有这样理解友情，你的内心才能平和的容纳他人。</p>
<h2 id="第五十九节-逆境的好处-1"><a href="#第五十九节-逆境的好处-1" class="headerlink" title="第五十九节 逆境的好处(1)"></a>第五十九节 逆境的好处(1)</h2><h3 id="逆境的正面效应"><a href="#逆境的正面效应" class="headerlink" title="逆境的正面效应"></a>逆境的正面效应</h3><p>健康心理学方面的研究一度把重点放在逆境和压力所造成的负面影响上，并把生活中遭遇的苦难作为失去幸福的主要原因。但随着社会发展和生活环境的进步研究人员开始探讨巨大压力可能为人们带来哪些好处，也就是“创伤后成长”。</p>
<h3 id="逆境中获益-——-激发潜藏力量"><a href="#逆境中获益-——-激发潜藏力量" class="headerlink" title="逆境中获益 —— 激发潜藏力量"></a>逆境中获益 —— 激发潜藏力量</h3><p>一旦你能挺身面对人生的挑战，便可激发自己原本潜藏的能力，而这些能力会改变我们原本对自我秉持的观念。如果你遭受了以前不能想象的苦难，但最终挺过来了，你就会发现我们其实比自己以为的更坚强，而这种认知会给自己带来信心，以面对未来的挑战。</p>
<h2 id="第六十节-逆境的好处-2"><a href="#第六十节-逆境的好处-2" class="headerlink" title="第六十节 逆境的好处(2)"></a>第六十节 逆境的好处(2)</h2><h3 id="逆境中获益-——-改善人际关系"><a href="#逆境中获益-——-改善人际关系" class="headerlink" title="逆境中获益 —— 改善人际关系"></a>逆境中获益 —— 改善人际关系</h3><p>逆境就像是一个漏斗，让我们知道谁是酒肉朋友，谁是可以患难与共的好友。除此之外，逆境还会强化人际关系，让我们打开心扉。我们会对自己关心的人表现出爱意，而在患难时关心我们的人，我们会对其心存爱心与感激。</p>
<h3 id="逆境中获益-——-重新审视人生"><a href="#逆境中获益-——-重新审视人生" class="headerlink" title="逆境中获益 —— 重新审视人生"></a>逆境中获益 —— 重新审视人生</h3><p>创伤能够改变你对人生追求、对当下和对他人的看法，让你想清楚，到底什么才是最重要的事情。人们总是把名利看得比自身还重要，对于已经拥有的东西都视为理所当然，不知珍惜。但生命受到重大威胁时，人往往会幡然醒悟，这种思维上的转变，能够帮助人们用更积极更知足的态度来面对自己的处境。</p>
<h2 id="第六十一节-复习课"><a href="#第六十一节-复习课" class="headerlink" title="第六十一节 复习课"></a>第六十一节 复习课</h2><h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><p><strong>大象与骑象人：</strong>人有两套心理运行机制，骑象人代表了有意识的、主动控制后的思考。大象包含我们内心的感觉、本能反应、情绪和直觉，代表了自动化的心理活动。大象和骑象人各有优势，只要配合良好，就成组成一个杰出的个体。</p>
<p><strong>人象之间主要的三种冲突：</strong>当下与未来、心理活动的循环、骑象人的解释误区。人和象的博弈看上去很像理性与感性，人性与兽性的对抗，但大象不等同于不理性的自我，骑象人无法感知的细节可以被大象感知，而且大象具备一定的认知能力。</p>
<p><strong>提升幸福感的两个技巧：</strong>保持前进和调整预期。保持前进，指的是把远大的理想分解成一些可以完成，取得进展的小目标，每朝目标前进一步，就能够源源不断的感到兴奋和满足。改变预期不只是一种技巧，究其根源，是一种更加广阔、更加包容的看待世界和生活的态度。</p>
<p><strong>幸福方程式：</strong>先天的幸福指数、所处环境的生活条件和看待生活的态度，这三者共同决定了我们真正感知到的幸福。</p>
<p>容易被忽视，却能显著影响生活的外部因素：噪声、通勤时间、掌控感、天然缺陷和人际关系。</p>
<p><strong>逆境对于幸福的正面效应：</strong>激发潜藏力量、改善人际关系、重新审视人生。</p>
<h2 id="第六十二节-关于学习的误区-1"><a href="#第六十二节-关于学习的误区-1" class="headerlink" title="第六十二节 关于学习的误区(1)"></a>第六十二节 关于学习的误区(1)</h2><h3 id="关于学习的误区-——-一万小时定律"><a href="#关于学习的误区-——-一万小时定律" class="headerlink" title="关于学习的误区 —— 一万小时定律"></a>关于学习的误区 —— 一万小时定律</h3><p>最近几年，1万小时定律这个概念非常热门：只要把一个技能重复练习，练习时间超过一万小时，就一定成为这个行业的专家。这种认识非常片面，因为投入的时间只是基础，如果没有掌握正确的学习方法，投入再多时间，也只能达到熟练，而不能精通。</p>
<p>研究表明，一旦某个人的表现达到了熟练水平，并且可以做到自动化，那么，即使再多“练习”几年，也不会有什么进步。</p>
<h2 id="第六十三节-关于学习的误区-2"><a href="#第六十三节-关于学习的误区-2" class="headerlink" title="第六十三节 关于学习的误区(2)"></a>第六十三节 关于学习的误区(2)</h2><h3 id="关于学习的误区-——-高估天赋的作用"><a href="#关于学习的误区-——-高估天赋的作用" class="headerlink" title="关于学习的误区 —— 高估天赋的作用"></a>关于学习的误区 —— 高估天赋的作用</h3><p>人们通常以为，某个人在任何特定行业或领域内的潜力，不可避免地受到天生才能的限制，只有依靠天生就具有的一些固定潜力才能成就杰出。但事实上，潜力不只是天生的，它还能通过我们一生中经历的各种各样的事情来创造。只要善于学习，我们可以创造自己的潜力。</p>
<p>在我们当下这个时代，许多人拥有着超常的能力，那些能力胜过人类历史上任何时代的人。显然，人的身体构造没有变化，并不是因为现代人的基因有巨大改变，比上世纪的人更有天赋，而是人们更善于学习了。</p>
<h2 id="第六十四节-有目的的学习-1"><a href="#第六十四节-有目的的学习-1" class="headerlink" title="第六十四节 有目的的学习(1)"></a>第六十四节 有目的的学习(1)</h2><h3 id="有目的学习的特点-——-目标定义明确"><a href="#有目的学习的特点-——-目标定义明确" class="headerlink" title="有目的学习的特点 —— 目标定义明确"></a>有目的学习的特点 —— 目标定义明确</h3><p>没有目标的练习：每天都要练习。<br>有目标的练习：每天都要练习三个小时<br>有明确目标的练习：把练习曲连续弹奏三次，期间不犯任何错误，并且保持适当的速度。</p>
<p>所谓明确的目标，就是指你能够在学习的过程中，根据这个目标对自己进行评价，判断自己是否成功的达成了这个目标。</p>
<h3 id="有目的学习的特点-——-保持专注"><a href="#有目的学习的特点-——-保持专注" class="headerlink" title="有目的学习的特点 —— 保持专注"></a>有目的学习的特点 —— 保持专注</h3><p>提高专注度最常用的方式是隔离干扰源。比如寻找安静的学习场所、打开手机的勿扰模式、关闭网络。<br>除此之外，还可以通过一些有仪式感的动作和行为进行心理暗示，帮助自己进入到专注状态。比如学习之前给自己鼓鼓掌，喝一杯咖啡，或者进行一次冥想呼吸练习。</p>
<h3 id="有目的学习的特点-——-要有反馈"><a href="#有目的学习的特点-——-要有反馈" class="headerlink" title="有目的学习的特点 —— 要有反馈"></a>有目的学习的特点 —— 要有反馈</h3><p>在学习的过程中，你必须知道某件事情自己做得对不对，如果不对，你到底怎么错了。如果你清楚自己是在哪一个环节出问题，就可以围绕这个环节进行针对性的练习。如果你知道自己实现目标的进度，就可以灵活的调整学习计划。</p>
<h2 id="第六十五节-有目的的学习-2"><a href="#第六十五节-有目的的学习-2" class="headerlink" title="第六十五节 有目的的学习(2)"></a>第六十五节 有目的的学习(2)</h2><h3 id="有目的学习的特点-——-要走出舒适区"><a href="#有目的学习的特点-——-要走出舒适区" class="headerlink" title="有目的学习的特点 —— 要走出舒适区"></a>有目的学习的特点 —— 要走出舒适区</h3><p>走出舒适区，是有目的的练习最为重要的一个组成部分。所谓舒适区，指的就是那些不太费力，很容易就能想到，并且一定可以做到的事情。</p>
<p><strong>走出舒适区有两种方式：</strong>第一种是做很有难度，挑战自己极限的事情，第二种是尝试自己没做过的事情。前者最需要的是决心，而后者更需要的是创意。</p>
<p><strong>大家可以多问自己两个问题：</strong>1、你有没有达到自己的极限。2、你有没有尝试新的练习方法？如果两个问题的答案都是否定的，就需要提醒自己要走出舒适区。</p>
<h2 id="第六十六节-心理表征是什么"><a href="#第六十六节-心理表征是什么" class="headerlink" title="第六十六节 心理表征是什么"></a>第六十六节 心理表征是什么</h2><h3 id="心理表征是什么"><a href="#心理表征是什么" class="headerlink" title="心理表征是什么"></a>心理表征是什么</h3><p>就是指我们了解的某个物体、某个观点、某些信息或者其它任何事物在思维中对应的样子。心理表征可以是具体的视觉形象，也可以是抽象的概念。</p>
<h3 id="有效学习的本质就是建立高质量的心理表征"><a href="#有效学习的本质就是建立高质量的心理表征" class="headerlink" title="有效学习的本质就是建立高质量的心理表征"></a>有效学习的本质就是建立高质量的心理表征</h3><p>一个领域的专家，和普通人最大的区别，就是前者通过多年的有效练习，针对本行业或领域中自己可能遇到的各种不同局面，创建了高度复杂和精细的表征，这些表征使他们能够做出更快更准确的决策，并在特定的局面上更有效地应对。</p>
<h2 id="第六十七节-心理表征的作用-1"><a href="#第六十七节-心理表征的作用-1" class="headerlink" title="第六十七节 心理表征的作用(1)"></a>第六十七节 心理表征的作用(1)</h2><h3 id="心理表征有助于寻找规律"><a href="#心理表征有助于寻找规律" class="headerlink" title="心理表征有助于寻找规律"></a>心理表征有助于寻找规律</h3><p>细分来说，心理表征对规律的把握具体表现有两种，第一种是预测未来。<br>优秀球员可以通过少量细节把球场上发生的事情与记忆库中丰富的心理表征进行匹配，如果能够匹配成功，他就可以预判这件事接下来的走向，从而提前做好应对。</p>
<p>第二种是归纳和分类。以攀岩为例。攀岩者在攀爬时，会遇到不同的把手，这些把手要求采用各种不同的握法，如果在把手上运用了错误的抓握方法，就有很大可能从墙上掉下来。</p>
<p>没有经验的攀岩者，必须边爬边想，遇到每个把手都要识别和判断适合哪种抓握方法。而经验丰富的攀岩者在对各种把手建立心理表征时，会按照握法分类，再把同一种握法对应的把手归纳到同一组。他们在攀爬时就可以使用心理表征轻松做出决策。</p>
<h2 id="第六十八节-心理表征的作用（2）"><a href="#第六十八节-心理表征的作用（2）" class="headerlink" title="第六十八节 心理表征的作用（2）"></a>第六十八节 心理表征的作用（2）</h2><h3 id="心理表征有助于解释信息"><a href="#心理表征有助于解释信息" class="headerlink" title="心理表征有助于解释信息"></a>心理表征有助于解释信息</h3><p>在学习的过程中，我们会接受海量的信息。心理表征的一个重要好处在于，可以帮助我们高效的理解信息，并把它保存在记忆之中，组织它、分析它，并用它来决策。</p>
<p>如果你只是认识汉字，而没有对应的心理表征，那你在阅读的时候，只会看到不同的汉字毫无意义的随机排布，根本无法进行任何的理解。</p>
<p>如果建立了相关的心理表征，当我们看到“猫”这个字的时候，就会将这个汉字与它的发音联系到一起，并与我们常见到的一种小小的、长毛的、会发出“喵喵”叫声、通常与狗无法和谐相处的动物联系起来，从而理解这个字。</p>
<p>心理表征对于解释信息的帮助无处不在，国际象棋高手可以看懂棋谱，职业音乐家可以看懂一首新曲子的乐谱，程序员能够理解复杂对代码，也是这样的道理。</p>
<h2 id="第六十九节-心理表征的作用（3）"><a href="#第六十九节-心理表征的作用（3）" class="headerlink" title="第六十九节 心理表征的作用（3）"></a>第六十九节 心理表征的作用（3）</h2><h3 id="心理表征有助于组织信息"><a href="#心理表征有助于组织信息" class="headerlink" title="心理表征有助于组织信息"></a>心理表征有助于组织信息</h3><p>理解和解释信息需要借助心理表征。但理解只是基础，音乐家不光要会读乐谱，还要能够根据乐谱做出带有自己风格的演绎，甚至要自己作曲，这时候就需要组织信息。</p>
<p>精心创建的心理表征，主要优势就是可以在组织信息时吸收和考虑更多的信息。比如常人对于“发烧”建立的心理表征就是“由感冒引起”，而医生不会把病人的症状与其他相关数据视为相互孤立的信息，而是作为更大整体中的一部分来看待，联想到几十种上百种可能性。</p>
<h2 id="第七十节-心理表征的作用（4）"><a href="#第七十节-心理表征的作用（4）" class="headerlink" title="第七十节 心理表征的作用（4）"></a>第七十节 心理表征的作用（4）</h2><h3 id="心理表征有助于执行学习计划"><a href="#心理表征有助于执行学习计划" class="headerlink" title="心理表征有助于执行学习计划"></a>心理表征有助于执行学习计划</h3><p>有效学习的基础是有目的的学习。有目的学习有四个特点，第一点就是要有定义明确的目标。有了目标之后，我们就可以围绕目标进行细致的安排，制定一个包含进度的学习计划。具体的学习过程，其实就是执行这个计划。</p>
<p>在学习过程当中，我们最容易遇到的问题，就是学习计划的制订与实际情况并不相符，比如高估了自己的执行力和学习速度、或者遇到了许多没有预料到的突发情况，这些问题会严重阻碍我们的学习。</p>
<p>为学习目标构建更精细的心理表征，能够让目标的执行路径更明确、更有条理，指导我们有条理的执行计划，从而更准确的预见学习过程，确保学习计划能够符合实际。</p>
<h2 id="第七十一节-有效学习的基础"><a href="#第七十一节-有效学习的基础" class="headerlink" title="第七十一节 有效学习的基础"></a>第七十一节 有效学习的基础</h2><h3 id="开展有效学习的重要基础-——-寻找好导师"><a href="#开展有效学习的重要基础-——-寻找好导师" class="headerlink" title="开展有效学习的重要基础 —— 寻找好导师"></a>开展有效学习的重要基础 —— 寻找好导师</h3><p>有效学习的核心是建立精密的心理表征。自己练习时，你必须依靠自己的心理表征来监测自己的表现，并判断自己在哪些地方做得不对。</p>
<p>虽然这不是不可能做到的，但比起找一位经验丰富的导师来观察你，并向你提供反馈相比，单凭自己的力量来练习，不但艰难得多，而且效果差得多，在学习过程的早期尤其如此。</p>
<p>好的导师明白学习一项技能的最佳顺序，能够理解并示范正确的方式来展示各种技能，可以提供有效反馈，甚至还能设计一些专门用来克服特定缺陷的练习活动，在导师的指导下，激情十足、孜孜不倦的学生能够更加迅速地取得进步。</p>
<h2 id="第七十二节-如何寻找导师"><a href="#第七十二节-如何寻找导师" class="headerlink" title="第七十二节 如何寻找导师"></a>第七十二节 如何寻找导师</h2><h3 id="如何辨认好导师"><a href="#如何辨认好导师" class="headerlink" title="如何辨认好导师"></a>如何辨认好导师</h3><p>好的导师应当是在所属行业或领域之中有一定成就的人，因为大部分导师只能引导你达到他们或者他们的学生曾经达到过的水平。</p>
<p>好导师应当具备一定的教育经验。很多成就突出的人并不能胜任导师的角色，他们自己能够做出杰出的成绩，并不意味着他的技巧和经验可以复制到其他人身上。</p>
<p>选择导师时，要记得询问导师的过往经验，可以和这位导师以前或现在的学生交谈。交谈时要注意围绕三个核心问题展开：</p>
<p>1、这些学生的水平如何？</p>
<p>2、他们技能的提升，多大程度上归功于导师？</p>
<p>3、他们对导师的评价如何？</p>
<h3 id="没有导师时的替代方案"><a href="#没有导师时的替代方案" class="headerlink" title="没有导师时的替代方案"></a>没有导师时的替代方案</h3><p>想要在没有导师的时候有效地练习某种技能，有三个词非常重要：专注、反馈和纠正。</p>
<p>无论你采用什么样的练习方式，都要在练习的过程中保持专注，在练习结束后对自己进行评价记录，找到行业专家在这个练习中的表现，跟自己对比，由此制订改良的方案，并在下一次练习时根据方案来纠正自己。</p>
<h2 id="第七十三节-如何坚持学习"><a href="#第七十三节-如何坚持学习" class="headerlink" title="第七十三节 如何坚持学习"></a>第七十三节 如何坚持学习</h2><h3 id="新年决心效应"><a href="#新年决心效应" class="headerlink" title="新年决心效应"></a>新年决心效应</h3><p>俗话说万事开头难。但对于学习来说，着手做并不难，坚持不懈才是难事。很多人都有在新年时指定目标和计划的习惯，但随着时间的推移，无论你最开始有多热情，放弃的意愿都会越来越强，很少有人能够真正的达成目标。</p>
<h3 id="能否坚持的关键是动机"><a href="#能否坚持的关键是动机" class="headerlink" title="能否坚持的关键是动机"></a>能否坚持的关键是动机</h3><p>我们做一件事情的动机，包括两个组成部分：继续前行的理由和停下脚步的理由。如果停下脚步的理由战胜了继续前行的理由，失去了动机，你就很难坚持。因此，想要坚持就要保持动机，要么强化继续前行的理由，要么弱化停下脚步的理由。</p>
<h3 id="如何弱化停下脚步的理由"><a href="#如何弱化停下脚步的理由" class="headerlink" title="如何弱化停下脚步的理由"></a>如何弱化停下脚步的理由</h3><p>1、找到最舒适的学习时间，并固定下来。</p>
<p>2、找出那些可能干扰你练习的事情，想办法将它们的影响控制在最小。我们必须要明确，固定的学习时间中一定不能做其他事情，无论是不是正事。</p>
<h2 id="第七十四节-步履不停"><a href="#第七十四节-步履不停" class="headerlink" title="第七十四节 步履不停"></a>第七十四节 步履不停</h2><h3 id="如何增强继续前行的理由"><a href="#如何增强继续前行的理由" class="headerlink" title="如何增强继续前行的理由"></a>如何增强继续前行的理由</h3><p>学习一个技能最初的理由，一般有两种：发自内心的热爱和社会动机。前者比较罕见，但动力会非常强大。如果没有外力的阻挠，兴趣就会成为最好的老师，督促着我们坚持学习并乐在其中。</p>
<p>社会动机就是受到外界影响才产生的动机，比较常见但动力较弱，如果不采取相应的措施，社会动机很难支撑我们长期坚持。有两个方法，可以显著的强化社会动机，帮助我们坚持学习。</p>
<p>第一种方法，是将对同一件事情感兴趣的人聚集起来，或者加入一个现有的，所有成员有着共同目标的团体，并和集体中的其他人建立良好的人际关系。</p>
<p>第二种方法，是建立坚信自己能够成功的信念。许多复杂的技能，需要日积月累，厚积薄发的学习才能看到成效。但是，在看到成效之前，很少有人能够接受这种毫无起色的状态，转而认定自己的学习是徒劳的，从而放弃坚持。因此，哪怕是自我欺骗，我们都要坚信自己能够成功。</p>
<h2 id="第七十五节-复习课"><a href="#第七十五节-复习课" class="headerlink" title="第七十五节 复习课"></a>第七十五节 复习课</h2><p>复习课</p>
<h3 id="关于学习的两个误区"><a href="#关于学习的两个误区" class="headerlink" title="关于学习的两个误区"></a>关于学习的两个误区</h3><p>一万小时定律、高估天赋的作用。</p>
<p><strong>有效学习的基础</strong>：</p>
<p>有目的学习。</p>
<p><strong>有目的学习的四要素</strong>：</p>
<p>目标定义明确、保持专注、有反馈，走出舒适区。</p>
<p><strong>有效学习的本质</strong>：</p>
<p>建立高质量的心理表征。</p>
<p><strong>心理表征的四个特点</strong>：</p>
<p>有助于寻找规律、解释信息、组织信息和执行计划。</p>
<p><strong>好导师对学习非常重要</strong>：</p>
<p>我们可以依靠自己的心理表征来监测自己的表现，但比起找一位经验丰富的导师来观察你，并向你提供反馈相比，单凭自己的力量来练习，不但艰难得多，而且效果差得多。</p>
<p><strong>好导师的两个特征</strong>：</p>
<p>在所属领域和行业有一定的成就，并且有过成功的教育经历。</p>
<p>在选择导师时，可以和这位导师以前或现在的学生交谈，解答三个核心问题展开：1、这些学生的水平如何？2、他们技能的提升，多大程度上归功于导师？3、他们对导师的评价如何？</p>
<p><strong>没有导师的替代方案</strong>：</p>
<p><strong>三个关键词：</strong>专注、反馈、纠正。</p>
<p>无论你采用什么样的练习方式，都要在练习的过程中保持专注，在练习结束后对自己进行评价记录，找到行业专家在这个练习中的表现，跟自己对比，由此制订改良的方案，并在下一次练习时根据方案来纠正自己。</p>
<p><strong>如何坚持学习</strong>？</p>
<p>想要坚持学习，就要保持动机，要么强化继续前行的理由，要么弱化停下脚步的理由。</p>
<p><strong>如何弱化停下脚步的理由</strong>？</p>
<p>1、找到最舒适的学习时间，并固定下来。</p>
<p>2、找出那些可能干扰你练习的事情，想办法将它们的影响控制在最小。</p>
<p><strong>如何强化继续前行的理由</strong>？</p>
<p>1、将对同一件事情感兴趣的人聚集起来，或者加入一个现有的，所有成员有着共同目标的团体，并和集体中的其他人建立良好的人际关系。</p>
<p>2、建立坚信自己能够成功的信念。</p>
<h2 id="第七十六节-自控力的组成"><a href="#第七十六节-自控力的组成" class="headerlink" title="第七十六节 自控力的组成"></a>第七十六节 自控力的组成</h2><h3 id="自控力是能够提高的"><a href="#自控力是能够提高的" class="headerlink" title="自控力是能够提高的"></a>自控力是能够提高的</h3><p>高度自律似乎是一项与生俱来的天赋，不过事实并非如此。正如同学习专业技能可以不依赖天赋，自控力也是人人都能具备的能力。著名的心理学专家、斯坦福大学的麦格尼格尔教授，通过多年来对人们改变想法、情绪和习惯的观察，摸索出了一套能够切实有效提高自控力的方法。</p>
<h3 id="自控力的三种组成"><a href="#自控力的三种组成" class="headerlink" title="自控力的三种组成"></a>自控力的三种组成</h3><p>我想要：落实不想做的事（起床、工作）</p>
<p>我不要：拒绝诱惑（抵制零食和烟酒）</p>
<p>我需要：自我认知与价值判断</p>
<h2 id="第七十七节"><a href="#第七十七节" class="headerlink" title="第七十七节"></a>第七十七节</h2><h2 id="第七十八节"><a href="#第七十八节" class="headerlink" title="第七十八节"></a>第七十八节</h2><h2 id="第七十九节"><a href="#第七十九节" class="headerlink" title="第七十九节"></a>第七十九节</h2><h2 id="第八十节"><a href="#第八十节" class="headerlink" title="第八十节"></a>第八十节</h2>]]></content>
      <tags>
        <tag>冥想</tag>
      </tags>
  </entry>
</search>
