<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"believezjp.oriht.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
<meta property="og:type" content="website">
<meta property="og:title" content="believeZJP">
<meta property="og:url" content="http://believezjp.oriht.com/page/9/index.html">
<meta property="og:site_name" content="believeZJP">
<meta property="og:description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="believeZJP">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://believezjp.oriht.com/page/9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>believeZJP</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">believeZJP</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长路径</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">believeZJP</p>
  <div class="site-description" itemprop="description">积土成山，风雨兴焉；积水成渊，蛟龙生焉;</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/believeZJP" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;believeZJP" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/antDesign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/antDesign/" class="post-title-link" itemprop="url">antDesign</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-07 19:33:28" itemprop="dateCreated datePublished" datetime="2018-11-07T19:33:28+08:00">2018-11-07</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="记录踩过的坑"><a href="#记录踩过的坑" class="headerlink" title="记录踩过的坑"></a>记录踩过的坑</h2><p>数组必须要key的解决办法</p>
<p>由于有些数据没有唯一key值。需要自行添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> localCounter = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">this</span>.data.forEach(<span class="function"><span class="params">el</span>=&gt;</span>&#123;</span><br><span class="line">    el.id = localCounter++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向数组中动态添加元素时，</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...user,</span><br><span class="line">        id: localCounter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态路由，传参获取参数"><a href="#动态路由，传参获取参数" class="headerlink" title="动态路由，传参获取参数"></a>动态路由，传参获取参数</h2><p>定义路由</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;/coupons/relateProducts/:couponBatchId&#x27;</span>: &#123;</span><br><span class="line">    component: dynamicWrapper(app, [<span class="string">&#x27;coupons&#x27;</span>], <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../routes/Coupons/RelateProducts&#x27;</span>))</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在组件中获取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.match.params.couponBatchId</span><br></pre></td></tr></table></figure>

<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><h2 id="多级对象setState"><a href="#多级对象setState" class="headerlink" title="多级对象setState"></a>多级对象setState</h2><p>可以单独取出来，修改后再整体放进去</p>
<h2 id="一个组件是modal，打开就查询一次，在哪执行查询"><a href="#一个组件是modal，打开就查询一次，在哪执行查询" class="headerlink" title="一个组件是modal，打开就查询一次，在哪执行查询"></a>一个组件是modal，打开就查询一次，在哪执行查询</h2><p>在componentWillReceiveProps里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里的nextProps为修改后的状态值</span></span><br><span class="line"></span><br><span class="line">    用<span class="built_in">this</span>.props可以获取到修改之前的props</span><br><span class="line"></span><br><span class="line">    通过<span class="built_in">this</span>.props和nextProps两者对比可以看是否需要更新和操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>componentwillreceiveprops会自动接收参数，导致页面不断渲染<br>需要配合this.props使用<br>componentDidMount不会触发</p>
<p>lodash.has</p>
<h2 id="select-用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示"><a href="#select-用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示" class="headerlink" title="select 用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示"></a>select 用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示</h2><h2 id="form表单重置按钮"><a href="#form表单重置按钮" class="headerlink" title="form表单重置按钮"></a>form表单重置按钮</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleReset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.form.resetFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Select-组件使用"><a href="#Select-组件使用" class="headerlink" title="Select 组件使用"></a>Select 组件使用</h2><p>Select 赋值，用this.props.form.setFieldsValues();</p>
<p>select动态赋值给select。，只显示value，没显示label，显示label无法提交<br>类型要匹配，数字就是数字，字符串就是字符串</p>
<h2 id="a元素绑定事件"><a href="#a元素绑定事件" class="headerlink" title="a元素绑定事件"></a>a元素绑定事件</h2><p>给a绑定事件，一定要这样绑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;a onClick=&#123;<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">this</span>.showDetail(record.key)&#125;&gt;详情&lt;/a&gt;</span><br><span class="line">handleMouseOver = <span class="function">(<span class="params">key</span>) =&gt;</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">display</span>: key &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写了models一定要在common的router.js中getRouterData<br>的dynamicWrapper<br>中引入文件夹名字，才能自动引入到app._models中</p>
<p>service 中的api要添加request.</p>
<p>models中要添加reducer，</p>
<p>在页面中要用redux定义好的state，需要在connect中引入<br>@connect(({loading, coupons}) =&gt; ({<br>    data: coupons,<br>}))</p>
<p>action调用成功后，在reducer里改了状态， 打印出来发生变化了，但页面没变化。</p>
<p>在div中写的可以变化，在input或textarea中不会发生变化。</p>
<p>加了mapPropsToFields后，修改的值回响应到textarea上，</p>
<p>但所有输入框输入的值被清空了</p>
<p>不想用redux，直接用组件里的state，怎么搞？</p>
<p>在dispatch后添加callback.直接用</p>
<p>this.props.form.setFieldsValue({<br>    uids: payload.data.join()<br>});</p>
<p> 一个页面多个form，点击每个form的提交，其他form的字段会跟着提交</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Form的FormItem如果是rangePicker，则设置<span class="string">`style=&#123;&#123;width:100%&#125;&#125;`</span>，可以让输入框响应容器</span><br></pre></td></tr></table></figure>

<p>Form的label和input输入框的宽度通过调节labelCol，wrapperCol<br>来设置，总长度为24</p>
<p>啊啊啊啊大经验啊！！！！</p>
<p>nginx的proxy配置一定要前后路径一致</p>
<p><code>&#39;POST /coupon/v1/(.*)&#39;: &#39;&lt;http://10.64.38.89:8081/coupon/v1/&#39;,&gt;</code></p>
<p>前面是coupon/v1后面也一定是coupon/v1,<br>不能前面是coupon 后面是coupon/v1<br>项目一定要放在www目录下</p>

      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">思维导图笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-07 19:05:36" itemprop="dateCreated datePublished" datetime="2018-11-07T19:05:36+08:00">2018-11-07</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.要想高效的利用本书，很重要的一点就是必须加强练习！！！</p>
<p>2.左脑处理逻辑、词汇、表单、数字、线性和分析等所谓的学术活动。右脑主司节奏、想象、色彩、幻想、空间感、完整倾向(整体观念)和维度。 </p>
<p>3.鼓励人们去开发他们以前认为很弱的脑区。会产生一种协同效应，使整个脑区的智力水平都随之提高。</p>
<p>4.当我们说自己某些方面行，某些方面不行时，我们实际是指已经很成功的开发出来了的潜力和尚未开发出来的，仍然处在蛰伏状态的潜能。如果能将蛰伏状态下的潜能开发出来，大脑将释放出巨大的“能量”。</p>
<p>5.大脑每分钟约要进行10万~100万次不同的化学反应。</p>
<!---more--->


<p><a href="/img/clipboard.png">记忆曲线</a><br><img data-src="/img/clipboard.png" ></p>
<p>6.感知模型：眼睛-大脑-相机<br>        按照一般人做白日梦的样子，闭上眼睛，想象你最喜欢的物体，在你心目中已经很清晰地记住其图像后，再做下列这些练习:<br>        在面前转动它<br>从顶部看它<br>从底部看它<br>改变它的颜色，至少3次。<br>把她移开，就好像在很远处看它一样。<br>再把它移回来。<br>把它变的极大。<br>把他变小。<br>完全改变它的形状。<br>让它消失。<br>再让它出来。<br>这些活动你做起来好不费事，可是相机的零件却完全无法做到。</p>
<p>思维导图_启动大脑  33页<br>—————————————-2014/10/27 00:03   ————————————————————————–</p>
<ol start="3">
<li><p>大脑受限制的原因</p>
</li>
<li><p>与承认失败相比，更多人会说”我们只是普通人”，这种说法不足以令人信服！我们必须学习大脑是如何工作的，以便充分发挥自身无限的潜力。</p>
<p>2.我们的表现与我们甚至最小潜力不相符的原因就是，我们对自己所拥有的内在潜力一无所知，更不用说如何去充分利用了。<br>3.一个普遍并且被严重误导的神话：人类本身就有不足之处，因此，这场灾难的责任应归结于人类本身的“缺陷”。</p>
<p>4.在全世界范围的教育系统内，人们之所以几乎没有花时间去学习如何学习，是因为我们对这台生物计算机的基本操作规则一无所知。</p>
<p>《启动大脑》 是第一本“大脑使用说明书”，它是专门用来帮助你了解、充实和保养你自己的“超级生物计算机”的，并教你如何释放你所拥有的自然且非凡的智能。</p>
</li>
<li><p>更快、更有效的阅读</p>
<p>   1.我阅读存在的问题</p>
<pre><code>       阅读速度慢，阅读后会忘记、阅读的时间不能保证、阅读后当时掌握回头就会忘记、阅读的时候有些不能很快的理解</code></pre>
<p>阅读定义:“从书中捕捉作者的意图”或“吸收所写文字的内容”。<br>阅读是个人与符号信息之间发生的全部相互联系；它通常是指学习的视觉方面，并包含下述7个步骤。</p>
<pre><code>       辨识、吸收、内部整合、外部整合、保持、回忆、交流</code></pre>
<p>4.3阅读问题存在的原因<br>   答案除了我们早先对大脑缺乏认识之外，主要是因为我们早期的阅读教育方法不当。</p>
<p>眼睛在阅读时，实际是以一系列的停顿和快速跳跃的方式移动的。</p>
<p>   提高速度</p>
<pre><code>   1.消除回读----90%的回跳和回读是因为担心不能对阅读材料完全理解而引起的。
   2.每次凝视的时间可减到最低的1/4秒，------人的眼睛可以在1/100秒的时间内摄入5个单词。
   3.凝视的间隔可扩展到一次摄入3~5个单词。</code></pre>
<p>快速阅读的好处<br>   快速阅读者的优势是他的眼睛在每一页上话费的物理运动较少，不会像慢速阅读者那样，每页紧张的聚焦凝视500多次。快速阅读者每页只凝视100次，其眼肌就不会疲劳。<br>   另一个好处：能有节奏、流畅的阅读和轻松愉快的领略文章的意思。<br>4.6  对阅读的误解<br>   1.一次只能看一个单词————错。人的凝视能力就可以扩展，我们阅读的目的不是理解单个的词，而是整体意思。<br>   2.阅读速度不可能超过每分钟500个单词—-错，每次凝视可以摄入6个单词，而且每秒钟可以凝视4次。这就意味着每分钟1000个单词的阅读速度是完全能达到的。<br>   3.快速阅读者没法欣赏文章———-错。因为快速阅读者能更多的理解所读的内容，能更专注地看材料，所以他有更多的时间去回顾他认为特别有趣的和重要的部分。<br>   4.速度越快注意力就越低——-错。读的越快，得到的刺激就越多，注意力就越集中。<br>   5.一般阅读速度更自然，因此也就最好——错。因为一般阅读速度并不自然。它是早期不完善的训练，加之缺乏眼睛和大脑能以各种可能的速度阅读等方面的知识所造成的。</p>
</li>
</ol>
<p>4.7.1 高级阅读技巧——快上加快<br>        我们要做的不是叫他们把手指从书本上拿开，而是让他们更快的移动手指。它在帮助养成流畅的阅读节奏方面有着不可估量的作用。<br>        用辅助物 阅读时阅读的速度更快。<br>4.7.2                  ———扩大焦点<br>        结合视觉辅助技巧，特别适用于阅读一些轻松的材料和用来预习和复习，还可以提高正常的阅读速度。<br>            很重要的一点是必须使用视觉导引物<br>                    试着采用如斜对角线、曲线和沿书页直线向下等各种视觉导引物。<br>4.7.3  快速理解<br>        尽快从一页浏览到下一页，并尽可能多看一些单词。这种训练可增加每次凝视时摄入更大范围的单词群的能力，也适用于练习纵览和预览技巧，并能把大脑调整到适应更快速、更有效的整体阅读练习状态。</p>
<p>4.8    动机训练<br>        计算每分钟阅读速度的公式：<br>            阅读速度=（所读页数*每页平均单词书）/阅读的分钟数<br>4.9    节拍训练<br>        调整到合理的节奏、即每一拍代表视觉引导物的一次移动的话，用这种方式可以保持一种稳定、连贯的节奏、并可克服阅读开始后不久出现的阅读速度下降的问题。一旦找到最佳的节奏，就可通过每分钟偶尔加一拍的方式提高你的阅读速度。<br>————2014/10/28 00:15——————-</p>
<p>5.3  记忆趋势：在学习期间的开头和结尾记得多；多次重复、易感知、有节奏的内容记得多；突出或独特的内容记得多———–冯-雷斯托夫效应，而学习期间的中间阶段所能机翼的内容却相当少。</p>
<pre><code> 要想保持在一个相当高的水准，必须找到记忆与理解最和谐的工作点。
在正常情况下，这一点出现在学习开始的20~50分钟之间。
学习期间的短暂间隔也常用于放松、消遣。可以使集中注意力学习时紧张的肌肉和神经得以放松。
学习后的回忆量最初是上升，之后才是下降，再后是一条逐渐下降的、以水平线结尾的凹形曲线。

    短暂上升的原因：在学习结束的瞬间，大脑没有足够的时间去整合刚学的新信息，尤其是最后的部分。它需要几分钟的时间将新材料之间的相关联系牢固地连接起来，即使之“沉淀下来”。
    小幅上升之后是一个陡峻的下降，在学习一个小时之后的24小时之内，至少有80%的细节被遗忘了。</code></pre>
<p>5.5 记忆–复习的技巧和理论<br>        安排有计划的复习，而且每次复习必须安排在回忆刚开始下降之前。<br>        eg:第一次复习应该在学习1小时之后的10分钟开始，复习时间以5分钟为宜。这样可以使记忆在高位保持1天左右，然后应该进行第二次复习，时间为2~4分钟。此后，记忆将保持一周左右，然后在一个月之后再次复习约2分钟。经过这最后一次复习，此项知识将被转为长期记忆。</p>
<pre><code>    如果已经做过笔记的话，第一次复习应该是对笔记的全面修订过程，这就意味着要取代原来的笔记的“最终版本”。而第二、三和四次复习则应采用下列方式:不看整理过的笔记，用一张纸概括记下所能回忆的一切，然后将其与整理后的笔记对照，再进行修改和补充。笔记和草稿都应做成思维导图。
    合理复习最重要的一个方面是作用于学习、思维和记忆等各方面的累计效应。

    每次接触新知识时，人们对已学知识的记忆处于低谷，原有知识间自动产生的连接会解体。这样，他对新知识的理解就不能达到应有的水平，效率和速度也必然很低。这种连续的消极过程会使人感到沮丧，最终对能学好的东西也失去了信心-----只要一学新东西就会忘记，一接触新东西心理上就会感到压抑。结果是很多人在完成了正式的考试之后，就很少甚至根本不再碰书本。


    失败的复习对整体记忆同样有害，如果忽略每条新信息的话，那么它将不再保持在意识层中，也不能形成新的记忆链接。由于记忆是一个以连接和联想为基础的过程，因而“记忆库”中的东西越少，其接纳和连接新知识的可能性就越小。
    相反，复习的好处是无穷的。</code></pre>
<p>2014/10/29 10:54<br>    使用某些方法使我们能利用记忆的连接和联想能力，来把这些事项与其对应的数字关联起来。<br>   最好的方法是数字-韵律法。</p>
<p>5.7记忆的“SMASHIN” SCOPE 法<br>        在这种方法中最重要的是要保证押韵字与所要记忆的单词必须全部准确的连接起来。<br>    1.通感/感官(Synaesthesia/Sensuality)<br>            通感，指的是多种感觉的融合。<br>            视觉、听觉、嗅觉、味觉、触觉、动觉—对身体在空间中的位置与运动的感觉。<br>    2.运动(Movenment)<br>            在任何记忆的形象中，运动可以极大的增加大脑连接和记住东西的可能性。—-这里指记忆的形象的运动性。<br>    3.联想(Association)<br>            确保使它与你的内省的某些稳定不变的事物联想或连接起来。衣钩法：1=面包。<br>    4.性(Sexuality)<br>            要加以利用!<br>    5.幽默(Humour)<br>            想象越有趣、越荒谬、越愚蠢、超越现实，就越容易被记住。<br>    6.想象(Imagination)<br>            爱因斯坦说：“想象比知识更重要，因为知识是有限的，而想象却能包容全世界、促进进步、孕育革新。”<br>            在记忆中应用的想象越多，记忆就会越好。<br>    7.编号(Number)<br>            按数字编号使顺序及次序的规则更有针对性，更有效。<br>    8.符号(Symbolism)<br>            用丰富多彩的想象；可以用传统的符号，如休止符、灯泡。<br>    9.颜色(Color)<br>            在适当的地方尽可能使用各种颜色，可使你的想法色彩斑斓，更易于记忆。<br>    10.顺序和/或次序(Order and /or Seguence)<br>            结合其他规则，排列顺序和次序起到了更直接的参考作用，并增加了大脑“随机存取”的可能性。将排列顺序和次序的应用加以扩展，能使你开发记忆矩阵，如自我增强型记忆矩阵。<br>    11.“积极”的形象(Positive Images)<br>            积极愉快的形象更利于记忆，这使大脑乐于工作。<br>    12.夸张(Exageration)<br>            在所想象的情景中，夸大尺寸、形象和声音。</p>
<pre><code>    12个记忆要素很容易用它们的首字母组成的单词“SMASHIN” SCOPE 来记。</code></pre>
<p>5.8  数字–韵律法<br>        在形成头脑中的形象时，很重要的一点是,要在“心目”中看到清晰的图像。经常闭上眼睛，将想象的情景投影到你的眼脸内部，或投影到你大脑的屏幕上，并且去听、去感觉、去闻，或者用对你来说最有效的方式去体验。原书84页。<br>        所有方法中尤其有效的是基本记忆法。它能以“数字-韵律法”的方式记住1000条以上的信息，并且能给出记忆数字与日期的关键方法。“名字-面孔记忆法”能避免你在碰到曾经见过面的人时，避免尴尬。<br>5.9 不可能完成的任务<br>        记忆基本上是一个联想和连接的过程，而且很大程度上取决于关键字，以及用于恰当想象的关键概念。</p>
<p>6.思维导图–词汇与思维特征的介绍<br>6.1 练习与讨论蟋蟀</p>
<p>四象限法则<br>策略：<br>如果你总是有紧急又重要的事情要做，说明你在时间管理上存在问题，设法减少它。<br>尽可能地把时间花在重要但不紧急（第二象限）的事情上，这样才能减少第一象限的工作量。<br>对于紧急但不重要的事情的处理原则是授权，让别人去做。<br>不重要也不紧急的事情尽量少做。</p>

      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/" class="post-title-link" itemprop="url">ES6新语法积累</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-05 19:48:55" itemprop="dateCreated datePublished" datetime="2018-11-05T19:48:55+08:00">2018-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/es6/" itemprop="url" rel="index"><span itemprop="name">es6</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h2 id="es6强制让一个函数有一个默认值"><a href="#es6强制让一个函数有一个默认值" class="headerlink" title="es6强制让一个函数有一个默认值"></a>es6强制让一个函数有一个默认值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;cuowu&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><a target="_blank" rel="noopener" href="http://liubin.org/promises-book/">Promise迷你书</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/" class="post-title-link" itemprop="url">HTTP积累</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-05 19:40:58" itemprop="dateCreated datePublished" datetime="2018-11-05T19:40:58+08:00">2018-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/http/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h2 id="http-方法，每个方法分别什么情况下用"><a href="#http-方法，每个方法分别什么情况下用" class="headerlink" title="http 方法，每个方法分别什么情况下用"></a>http 方法，每个方法分别什么情况下用</h2><p>put和get有什么相同点<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce44e5f4623a">链接</a></p>
<p>trace是用来干嘛的，</p>
<p>options是用来干嘛的</p>
<p>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>OPTIONS 允许客户端查看服务器的性能。</p>
<p>TRACE 回显服务器收到的请求，主要用于测试或诊断。</p>
<p>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-18 14:38:00" itemprop="dateCreated datePublished" datetime="2018-10-18T14:38:00+08:00">2018-10-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-09-11 16:55:34" itemprop="dateModified" datetime="2020-09-11T16:55:34+08:00">2020-09-11</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>64</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome test page.<br>post to github.<br>commit new line.<br>add new line for git test.</p>

      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/hexo%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/hexo%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">搭建Hexo博客笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-10 18:05:59" itemprop="dateCreated datePublished" datetime="2018-10-10T18:05:59+08:00">2018-10-10</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[toc]</p>
<h2 id="hexo-搭建"><a href="#hexo-搭建" class="headerlink" title="hexo 搭建"></a>hexo 搭建</h2><ol>
<li><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">HEXO 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">文档</a></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>node.js git 已经安装，跳过</li>
<li>hexo 安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<!-- more  -->
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不能在文章中有&#123;&#123;&#125;&#125;,否则hexo无法见解析，会报错</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>访问 localhost:4000 即可看到网页</p>
<p>在 sources/posts 文件夹下新建一个 test.md 文件，再次访问页面，可看到新加的文章。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/hexo%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/linux%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/linux%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Linux学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-08 20:31:07" itemprop="dateCreated datePublished" datetime="2018-10-08T20:31:07+08:00">2018-10-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-03-22 20:31:07" itemprop="dateModified" datetime="2019-03-22T20:31:07+08:00">2019-03-22</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>window远程连接工具：<br>secure CRT<br>配置：<br>选项-会话选项-仿真<br>    终端：x-term  ansi颜色<br>    外观：颜色方案：黄黑<br>        光标 竖线<br>    编码：回话选项-外观-字符编码-UTF-8</p>
<h2 id="git-定时任务crontab"><a href="#git-定时任务crontab" class="headerlink" title="git 定时任务crontab"></a>git 定时任务crontab</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">链接</a></p>
<h2 id="在centos执行git-pull报错"><a href="#在centos执行git-pull报错" class="headerlink" title="在centos执行git pull报错"></a>在centos执行git pull报错</h2><p>Peer reports incompatible or unsupported protocol version.</p>
<p>解决办法：</p>
<p>yum update -y nss curl libcurl</p>
<p>执行后，可以正常运行。</p>
<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="==++文件与目录管理++=="></a>==++文件与目录管理++==</h2><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><p>mkdir</p>
<p>eg:mkdir test</p>
<p>mkdir -p test/123/abc</p>
<p>-p 递归创建目录，即使上级目录不存在。<br>还有一种情况就是如果你想要创建的目录存在的话，会提示报错，然后你加上-p参数后，就不会报错了。</p>
<h3 id="命令详情"><a href="#命令详情" class="headerlink" title="命令详情"></a>命令详情</h3><p> man rm,<br> man ls</p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>cp</p>
<p>eg: cp a b</p>
<p>cp copy的简写，即拷贝。格式为 cp [选项] [ 来源文件 ] [目的文件] ，例如我想把test1 拷贝成test2 ，这样即可 cp test1 test2，</p>
<p>-d 这里涉及到一个“连接”的概念。连接分为软连接和硬连接</p>
<p>如果不加这个-d 则拷贝软连接时会把软连接的目标文件拷贝过去，而加上后，其实只是拷贝了一个连接文件（即快捷方式）。</p>
<ul>
<li><p>-r 如果你要拷贝一个目录，必须要加-r选项，否则你是拷贝不了目录的。 omitting directory ‘d’</p>
</li>
<li><p>-i 如果遇到一个存在的文件，会问是否覆盖。</p>
</li>
<li><p>-u 该选项仅当目标文件存在时才会生效，如果源文件比目标文件新才会拷贝，否则不做任何动作</p>
</li>
</ul>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>mv 移动的意思，是move的简写。格式为 mv [ 选项 ] [源文件] [目标文件]。</p>
<ul>
<li><p>-i 和cp的-i 一样，当目标文件存在时会问用户是否要覆盖。</p>
</li>
<li><p>-u 和上边cp 命令的-u选项一个作用，当目标文件存在时才会生效，如果源文件比目标文件新才会移动，否则不做任何动作。</p>
</li>
</ul>
<p>-</p>
<p>windows下的重命名，在linux下用mv就可以搞定。</p>
<h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p> rm -rf</p>
<p> eg:rm -rf testCLI</p>
<p>rmdir 只能删除目录但不能删除文件，要想删除一个文件，则要用rm命令了。</p>
<p>-f 强制的意思，如果不加这个选项，当删除一个不存在的文件时会报错。</p>
<p>-i 这个选项的作用是，当用户删除一个文件时会提示用户是否真的删除。</p>
<p>-r 当删除目录时，加该选项，如果不加这个选项会报错。rm是可以删除不为空的目录的。</p>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>touch a</p>
<blockquote>
<p>a.txt 可以创建一个文件<br>a也是一个文件<br>vi a</p>
</blockquote>
<p>vi a /vim a 可以查看文件内容</p>
<p>输入i，进入编辑模式</p>
<p>按esc，退出编辑模式</p>
<p>输入:wq退出查看文件</p>
<h2 id="进入linux的主目录"><a href="#进入linux的主目录" class="headerlink" title="进入linux的主目录"></a><strong>进入linux的主目录</strong></h2><p>cd /home</p>
<p>pwd 这个命令打印出当前所在目录<br>./ 指的是当前目录</p>
<p>../ 指的是当前目录的上一级目录。<br>cd wwwroot/<br>ls</p>
<blockquote>
<p>绝对路径：路径的写法一定由根目录”/”写起，例如/usr/local/mysql 这就是绝对路径。</p>
</blockquote>
<p>相对路径：路径的写法不是由根目录”/”写起，例如，首先用户进入到/ 然后再进入到 home ，命令为 cd /home 然后 cd test 此时用户所在的路径为 /home/test 。第一个cd命令后跟 /home 第二个 cd 命令后跟 test ，并没有斜杠，这个test是相对于/home 目录来讲的，所以叫做相对路径。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>echo 变量<br>echo ‘abc’&gt;111 将字符输出到一个文件中<br>大于号”&gt;” 在linux中这叫做重定向，即把前面产生的输出写入到后面的文件中。<br>”&gt;&gt;”是追加的意思，而用”&gt;”，如果文件中有内容则会删除文件中内容，而”&gt;&gt;”则不会。</p>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><ul>
<li><p>cat 比较常用的一个命令，即查看一个文件的内容并显示在屏幕上<br>  -n 查看文件时，把行号也显示到屏幕上。<br>  -A 显示所有东西出来，包括特殊字符</p>
</li>
<li><p>tac 其实是cat的反写，同样的功能也是反向打印文件的内容到屏幕上。</p>
</li>
<li><p>more也是用来查看一个文件的内容。当文件内容太多，一屏幕不能占下，而你用cat肯定是看不前面的内容的，那么使用more就可以解决这个问题了。当看完一屏后按<strong>空格键</strong>继续看下一屏。但看完所有内容后就会退出。如果你想提前退出，只需按q键即可。</p>
</li>
<li><p>less作用跟more一样，但比more好在可以上翻，下翻。空格键同样可以翻页，而<strong>按”j”键可以向下移动</strong>（按一下就向下移动一行）<strong>，按”k”键向上移动</strong>。在使用more和less查看某个文件时，你可以按一下”/” 键，然后输入一个word回车，这样就可以查找这个word了。如果是多个该word可以按”n”键显示下一个。另外你也可以不按”/”而是按”?”后边同样跟word来搜索这个word，唯一不同的是，<strong>”/”是在当前行向下搜索，而”?”是在当前行向上搜索</strong>。</p>
<p>  <strong>按n向上，按N向下显示</strong>–老罗</p>
</li>
<li><p>vim</p>
</li>
<li><p>head head后直接跟文件名，则显示文件的前十行。如果加 –n 选项则显示文件前n行。</p>
</li>
<li><p>tail 和head一样，后面直接跟文件名，则显示文件最后十行。如果加-n 选项则显示文件最后n行。</p>
</li>
<li><p>-f <strong>动态显示文件的最后十行</strong>，如果文件是不断增加的，则用-f 选项。如：tail -f /var/log/messages</p>
</li>
</ul>
<p>-</p>
<h3 id="实时查看文件内容"><a href="#实时查看文件内容" class="headerlink" title="实时查看文件内容"></a>实时查看文件内容</h3><ul>
<li>tail -f catalina.out  ！！！！！！！！</li>
</ul>
<h2 id="文件的所属主以及所属组"><a href="#文件的所属主以及所属组" class="headerlink" title="文件的所属主以及所属组"></a>文件的所属主以及所属组</h2><p>所属组”就派上用场了。即，创建一个群组users，让user0和user1同属于users组，然后建立一个文件test2，且其所属组为users，那么user0和user1都可以访问test2文件。</p>
<h2 id="查看文件列表list"><a href="#查看文件列表list" class="headerlink" title="查看文件列表list"></a>查看文件列表list</h2><p>ls<br>ls -l<br>-a 全部的档案都列出，包括隐藏的。</p>
<p>-l 详细列出文件的属性信息，包括大小、创建日期、所属主所属组等等。ll 这个命令等同于ls –l 。</p>
<p>-d 后边跟目录，如果不加这个选项则列出目录下的文件，加上后只列车目录本身。</p>
<h2 id="linux-文件属性"><a href="#linux-文件属性" class="headerlink" title="linux 文件属性"></a>linux 文件属性</h2><p>用ls –l 查看当前目录下的文件时，共显示了9列内容（用空格划分列），都代表了什么含义呢？</p>
<p>第1列，包含的东西有该文件类型和所属主、所属组以及其他用户对该文件的权限。第一列共10位。其中第一位用来描述该文件的类型。上例中，我们看到的类型有”d”, “-“ ，其实除了这两种外还有”l”, “b”, “c”,”s”等。</p>
<p>d 表示该文件为目录；</p>
<ul>
<li>表示该文件为普通文件；</li>
</ul>
<p>l 表示该文件为连接文件（linux file），上边提到的软连接即为该类型；</p>
<p>b 表示该文件为块设备文件，比如磁盘分区</p>
<p>c 表示该文件为串行端口设备，例如键盘、鼠标。</p>
<p>s 表示该文件为套接字文件（socket），用于进程间通信。</p>
<p>后边的9位，每三个为一组。均为rwx 三个参数的组合。其中r 代表可读，w代表可写，x代表可执行。前三位为所属主（user）的权限，中间三位为所属组（group）的权限，最后三位为其他非本群组（others）的权限。下面拿一个具体的例子来述说一下。</p>
<p>一个文件的属性为-rwxr-xr– ，它代表的意思是，该文件为普通文件，文件拥有者可读可写可执行，文件所属组对其可读不可写可执行，其他用户对其只可读。</p>
<p>对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个目录必须要有x权限才能打开并查看该目录。例如一个目录的属性为 drwxr–r– 其所属主为root，那么除了root外的其他用户是不能打开这个目录的。</p>
<p>第2列，表示为连接占用的节点（inode），若为目录时，通常与该目录地下还有多少目录有关系，关于连接（link）在以后章节详细介绍。</p>
<p>第3列，表示该文件的所属主。</p>
<p>第4列，表示该文件的所属组。</p>
<p>第5列，表示该文件的大小。</p>
<p>第6列、第7列和第8列为该文件的创建日期或者最近的修改日期，分别为月份日期以及时间。</p>
<p>第9列，文件名。如果前面有一个. 则表示该文件为隐藏文件。</p>
<h2 id="更改文件的权限"><a href="#更改文件的权限" class="headerlink" title="更改文件的权限"></a>更改文件的权限</h2><p>==？？？太多了？？？以后再学==</p>
<h2 id="在-linux-下搜索一个文件"><a href="#在-linux-下搜索一个文件" class="headerlink" title="在 linux 下搜索一个文件"></a>在 linux 下搜索一个文件</h2><ul>
<li><p>which 用来查找可执行文件的绝对路径</p>
<p>  which只能用来查找PATH环境变量中出现的路径下的可执行文件。不知道某个命令的绝对路径，which一下就知道了。</p>
</li>
<li><p>whereis 通过预先生成的一个文件列表库去查找跟给出的文件名相关的文件。</p>
<p>  语法： whereis [-bmsu] [文件名称]</p>
<p>  -b：只找binary 文件</p>
<p>  -m：只找在说明文件manual路径下的文件</p>
<p>  -s：只找source来源文件</p>
<p>  -u：没有说明档的文件</p>
</li>
<li><p>locate 类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里。后边直接跟文件名。</p>
</li>
<li><p><strong>find</strong> 用的最多，务必要熟悉。<br>  语法： find [路径] [参数] 下面介绍几个笔者经常用的参数</p>
<p>  -atime +n ：访问或执行时间大于n天的文件</p>
<p>  -ctime +n ：写入、更改inode属性（例如更改所有者、权限或者连接）时间大于n天的文件</p>
<p>  -mtime +n ：写入时间大于n天的文件</p>
<p>  -name filename <strong>直接查找该文件名的文件，这个使用最多了。</strong></p>
<p>  -type type ：通过文件类型查找。type 包含了 f, b, c, d, l, s 等等。后续的内容还会介绍文件类型的。</p>
</li>
</ul>
<p>你对这三个time是不是有些晕了，那笔者就先给你介绍一下这三个time属性。</p>
<p>文件的 Access time，atime 是在读取文件或者执行文件时更改的。文件的 Modified time，mtime 是在写入文件时随文件内容的更改而更改的。<br>文件的 Create time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。<br>因此，更改文件的内容即会更改 mtime 和 ctime，但是文件的 ctime 可能会在 mtime 未发生任何变化时更改，例如，更改了文件的权限，但是文件内容没有变化。 如何获得一个文件的atime mtime 以及ctime ？</p>
<p>ls -l 命令可用来列出文件的 atime、ctime 和 mtime。</p>
<p>ls -lc filename         列出文件的 ctime</p>
<p>ls -lu filename         列出文件的 atime</p>
<p>ls -l filename          列出文件的 mtime</p>
<p>atime不一定在访问文件之后被修改，因为：<br>使用ext3文件系统的时候，如果在mount的时候使用了noatime参数那么就不会更新atime的信息。而这是加了 noatime 取消了, 不代表真实情況。<br>反正, 這三個 time stamp 都放在 inode 中。若 mtime, atime 修改inode 就一定會改, 既然 inode 改了, 那 ctime 也就跟著要改了。</p>
<h2 id="linux-文件类型"><a href="#linux-文件类型" class="headerlink" title="linux 文件类型"></a>linux 文件类型</h2><p>1）正规文件（regular file）：就是一般类型的文件，当用ls –l 查看某个目录时，第一个属性为”-“的文件就是正规文件，或者叫普通文件。正规文件又可分成纯文字文件（ascii）和二进制文件（binary）。纯文本文件是可以通过cat, more, less等工具直接查看内容的，而二进制文件并不能。例如我们用的命令/bin/ls 这就是一个二进制文件。</p>
<p>2）目录（directory）即文件夹,ls –l 查看第一个属性为”d”。</p>
<p>3）连接档（link）：ls –l 查看第一个属性为 “l”，类似windows下的快捷方式。</p>
<p>4）设备档（device）：与系统周边相关的一些档案，通常都集中在 /dev 这个目录之下！通常又分为两种：<br>    区块 (block) 设备档：说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的档案啦！第一个属性为 “ b “；<br>    字符 (character) 设备档：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为 “ c “。</p>
<h3 id="linux-文件后缀名"><a href="#linux-文件后缀名" class="headerlink" title="linux 文件后缀名"></a>linux 文件后缀名</h3><p>1.sh代表它是一个shell script<br>2.tar.gz 代表它是一个压缩包，<br>3.my.cnf 代表它是一个配置文件，<br>4.test.zip 代表它是一个压缩文件。<br>早期Unix系统文件名最多允许14个字符，而新的Unix或者linux系统中，文件名最长可以到达 256 个字符！</p>
<h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩 解压缩"></a>压缩 解压缩</h2><p>tar</p>
<p>  解包：tar zxvf filename.tar</p>
<p>  打包：tar czvf filename.tar dirname</p>
<p>zip命令</p>
<p>解压：unzip filename.zip</p>
<p>压缩：zip filename.zip dirname</p>
<h2 id="ln-建立连接档"><a href="#ln-建立连接档" class="headerlink" title="ln 建立连接档"></a>ln 建立连接档</h2><p>ln 语法： ln [-s] [来源文件] [目的文件]<br>ln 常用的选项就一个-s ，如果不加就是建立硬连接，加上就建立软连接。</p>
<p>Hard Link 的限制太多了，包括无法做目录的 link ，所以在用途上面是比较受限的！反而是 Symbolic Link 的使用方向较广！<br>在建立硬连接前后，空间大小不改变。<br>不能创建目录的硬连接。<br>目录是可以软连接的。<br>删除软连接对源文件没有任何影响。</p>
<h2 id="环境变量-PATH"><a href="#环境变量-PATH" class="headerlink" title="环境变量 PATH"></a>环境变量 PATH</h2><p>有两个方法。</p>
<p>一种方法是直接将 /root 的路径加入 PATH 当中！如何增加？可以使用： 　</p>
<p>PATH=”$PATH”:/root</p>
<p>另一种方式则是使用完整档名，亦即直接使用相对或绝对路径来执行，例如：</p>
<p>/root/ls</p>
<p>./ls</p>
<p>====</p>
<h3 id="vim查看版本"><a href="#vim查看版本" class="headerlink" title="vim查看版本"></a>vim查看版本</h3><p>vim</p>
<h4 id="设置vim编码"><a href="#设置vim编码" class="headerlink" title="设置vim编码"></a>设置vim编码</h4><p>vim ~/.vimrc</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="vim-编辑"><a href="#vim-编辑" class="headerlink" title="vim 编辑"></a>vim 编辑</h3><p> 按i ,进入编辑模式，</p>
<p> 编辑完成后，按esc退出编辑模式</p>
<h4 id="退出保存"><a href="#退出保存" class="headerlink" title="退出保存"></a>退出保存</h4><p> :wq</p>
<h4 id="退出不保存"><a href="#退出不保存" class="headerlink" title="退出不保存"></a>退出不保存</h4><p> :q<br>会提示: No write since last change (add ! to override)<br>再输入一次</p>
<p>:q!<br>即可</p>
<p>将以下复制到其中</p>
<p>syntax on<br>set nu!<br>set encoding=utf-8<br>set fenc=utf-8<br>set fileencodings=ucs-bom,utf-8,cp936,gb2312,gb18030</p>
<h4 id="查看系统的编码"><a href="#查看系统的编码" class="headerlink" title="查看系统的编码"></a>查看系统的编码</h4><p>echo $LANG</p>
<h2 id="乱码解决方案"><a href="#乱码解决方案" class="headerlink" title="乱码解决方案"></a>乱码解决方案</h2><ol>
<li>系统编码</li>
<li>vim的编码</li>
<li>连接服务器的终端。<ol>
<li>SecureCRT设置字条编码<br>Option–Session Option–Appearance<br>设置字符编码</li>
</ol>
</li>
</ol>
<h2 id="命令行远程登录服务器"><a href="#命令行远程登录服务器" class="headerlink" title="命令行远程登录服务器"></a>命令行远程登录服务器</h2><p>ssh <a href="mailto:&#114;&#x6f;&#x6f;&#116;&#64;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x31;&#46;&#50;&#53;">&#114;&#x6f;&#x6f;&#116;&#64;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x31;&#46;&#50;&#53;</a><br>    用户名@ip</p>
<h2 id="服务器上安装公钥"><a href="#服务器上安装公钥" class="headerlink" title="服务器上安装公钥"></a>服务器上安装公钥</h2><p>键入以下命令，在服务器上安装公钥：</p>
<p>[root@host ~]$ cd .ssh</p>
<p>[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</p>
<p>将本地的key复制到authorized_keys文件中</p>
<h3 id="从gitbash中获ssh-key"><a href="#从gitbash中获ssh-key" class="headerlink" title="从gitbash中获ssh key"></a>从gitbash中获ssh key</h3><p>  clip &lt; ~/.ssh/id_rsa.pub</p>
<p> ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOmNk1rDPVPv+DTpe/ynM9dLDj/FjG/3xkAvjz8EoxSM/QBXNLj69m0SXA4jI6LOIwuS3Pdn011qWGa14zHPDI0wY9cGzlC+AvcuAZ0s+ndppAVk5PktYM0zCfBhlpLyHCgCVNxDxv1shd1A+gG3Lbi+tJ75oOnvJ5uSWC6x6wJgwJy/zUdQHTA3od4Mfkbz/6hr1sWqnCJE3r4H9Na6XtYMbjyl+O+JnePxH4PDwT/0MVxPpojyEqAv/FE9Gb7WjqmLsT5TWEoRhb4V0pm75moh6QObgqQ+RfJLS6Cz+NIvep980qVrYaRQGQG+7bEwy3fNDZlSGXRUALgELceVP/ HP@HP-PC</p>
<h2 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h2><p> uname -r</p>
<h2 id="查看系统"><a href="#查看系统" class="headerlink" title="查看系统"></a>查看系统</h2><p>uname</p>
<h2 id="查看当前正在进行的进程"><a href="#查看当前正在进行的进程" class="headerlink" title="查看当前正在进行的进程"></a>查看当前正在进行的进程</h2><p> jobs</p>
<h2 id="启一个服务，在后台执行，并将日志输出到log"><a href="#启一个服务，在后台执行，并将日志输出到log" class="headerlink" title="启一个服务，在后台执行，并将日志输出到log"></a>启一个服务，在后台执行，并将日志输出到log</h2><p> node . &gt;log 2&gt;&amp;1 &amp;</p>
<p> tail -f log</p>
<h2 id="查找某个进程-eg-node"><a href="#查找某个进程-eg-node" class="headerlink" title="查找某个进程(eg:node)"></a>查找某个进程(eg:node)</h2><p> ps -ef|grep node</p>
<h2 id="在历史命令中查找某个命令"><a href="#在历史命令中查找某个命令" class="headerlink" title="在历史命令中查找某个命令"></a>在历史命令中查找某个命令</h2><p> history|grep cd</p>
<h2 id="写了脚本以后执行一个脚本"><a href="#写了脚本以后执行一个脚本" class="headerlink" title="写了脚本以后执行一个脚本"></a>写了脚本以后执行一个脚本</h2><p>./control.sh</p>
<h2 id="linux-查找文件"><a href="#linux-查找文件" class="headerlink" title="linux 查找文件"></a>linux 查找文件</h2><p>find / -name nginx.conf</p>
<p>find / -name php.ini</p>
<p>find / -name my.cnf</p>
<p>find / -name httpd.conf</p>
<h2 id="php-相关"><a href="#php-相关" class="headerlink" title="php 相关"></a>php 相关</h2><p> 查看php运行目录命令：<br>which php</p>
<p>which 用来查找一个命令的绝对路径</p>
<p>/usr/bin/php<br>查看php-fpm进程数：</p>
<p>ps aux | grep -c php-fpm</p>
<p>查看运行内存<br>/usr/bin/php  -i|grep mem</p>
<p>关闭PHP</p>
<p>killall php-fpm</p>
<p>php重启</p>
<p>/usr/local/php/sbin/php-fpm &amp;</p>
<h2 id="php-配置"><a href="#php-配置" class="headerlink" title="php 配置"></a>php 配置</h2><ol>
<li>端口 httpd.conf listen 80</li>
</ol>
<p>2.</p>
<h2 id="查看linux-IP"><a href="#查看linux-IP" class="headerlink" title="查看linux IP"></a>查看linux IP</h2><h3 id="公网IP"><a href="#公网IP" class="headerlink" title="公网IP"></a>公网IP</h3><p>curl members.3322.org/dyndns/getip</p>
<p>47.94.93.83</p>
<h3 id="内网IP"><a href="#内网IP" class="headerlink" title="内网IP"></a>内网IP</h3><p>ifconfig</p>
<p>inet addr:192.168.42.128</p>
<h2 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h2><p>启动：/usr/local/nginx/sbin/nginx</p>
<p>service nginx start<br>关闭：/usr/local/nginx/sbin/nginx  -s stop</p>
<p>service nginx stop</p>
<p>重启：/usr/local/nginx/sbin/nginx -s  reload</p>
<p>查看nginx状态<br> service nginx status</p>
<p>查看当前nginx目录<br>ps -ef | grep nginx<br>可以在conf目录下的nginx.conf中找到对应的配置。</p>
<p>查看一个服务是否已经启动：</p>
<p>ps -A | grep nginx</p>
<p>如果返回结果的话，说明有nginx在运行，服务已经启动</p>
<p>nginx -V 查看nginx安装目录</p>
<p>cd /usr/local/etc/nginx 里有nginx.conf</p>
<p>sudo nginx -s reload<br>Sudo nginx -s stop</p>
<p>openresty/nginx/coupon</p>
<p>./sbin/nginx -s reload</p>
<p>Nginx 命令<br>service nginx stop/start/status/reload</p>
<p>2、查看nginx.conf配置文件目录</p>
<p>输入命令</p>
<h3 id="nginx-t"><a href="#nginx-t" class="headerlink" title="nginx -t"></a>nginx -t</h3><p>返回结果包含配置文件目录<br>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</p>
<p>nginx: configuration file /etc/nginx/nginx.conf test is successful</p>
<p>检查下80端口是否被其他进程占用了。<br>lsof -i:80</p>
<h3 id="Nginx-配置实现CORS"><a href="#Nginx-配置实现CORS" class="headerlink" title="Nginx 配置实现CORS"></a>Nginx 配置实现CORS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">location ^~ &#x2F;api&#x2F;v1 &#123;</span><br><span class="line"></span><br><span class="line"> add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, PUT, DELETE, OPTIONS&#39;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type    &#39;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line"> if ($request_method &#x3D; &#39;OPTIONS&#39;) &#123;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, PUT, DELETE, OPTIONS&#39;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type    &#39;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">  add_header &#39;Access-Control-Max-Age&#39; 1728000; # 20 天</span><br><span class="line">  add_header &#39;Content-Type&#39; &#39;text&#x2F;html charset&#x3D;UTF-8&#39;;</span><br><span class="line">  add_header &#39;Content-Length&#39; 0;</span><br><span class="line">  return 200;</span><br><span class="line"> &#125;</span><br><span class="line">    # 这下面是要被代理的后端服务器，它们就不需要修改代码来支持跨域了</span><br><span class="line"> proxy_pass http:&#x2F;&#x2F;127.0.0.1:8085;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> proxy_redirect off;</span><br><span class="line"> proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"> proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"> proxy_connect_timeout 60;</span><br><span class="line"> proxy_read_timeout 60;</span><br><span class="line"> proxy_send_timeout 60;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="telnet-80-d端口ping不通"><a href="#telnet-80-d端口ping不通" class="headerlink" title="telnet 80 d端口ping不通"></a>telnet 80 d端口ping不通</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &lt;http://127.0.0.1&gt;</span><br><span class="line">curl http:oriht.com</span><br></pre></td></tr></table></figure>

<p>查看实例安全组规则  端口范围是否有80端口</p>
<p>允许自定义 TCP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">80&#x2F;80 地址段访问</span><br><span class="line">0.0.0.0&#x2F;0</span><br><span class="line">-</span><br><span class="line"></span><br><span class="line">1 2017-09-25 11:03:54</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果新配置nginx一直403 禁止访问的话</p>
<p>修改/etc/selinux/config<br>将SELINUX=enforcing 改为<br>SELINUX=disabled</p>
<h2 id="跟着吴博学linux"><a href="#跟着吴博学linux" class="headerlink" title="跟着吴博学linux"></a>跟着吴博学linux</h2><p>ls -lh</p>
<p>sudo sh updata_<a target="_blank" rel="noopener" href="http://www.sh/">www.sh</a></p>
<p>less update_<a target="_blank" rel="noopener" href="http://www.sh/">www.sh</a></p>
<p>ls -l</p>
<p>sudo su root</p>
<p>git branch -r</p>
<h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="!/bin/bash"></a>!/bin/bash</h2><p>rm www-old<br>mv ./www ./www-old<br>ln -s ./ac-www-releases/ac-www-2016-10-17/ www<br>sh git.pull.sh</p>
<p>exit</p>
<p>sudo sh update_<a target="_blank" rel="noopener" href="http://www.sh/">www.sh</a></p>
<hr>
<h2 id="找不到httpd-conf"><a href="#找不到httpd-conf" class="headerlink" title="找不到httpd.conf"></a>找不到httpd.conf</h2><p>httpd.conf的位置一般位于<br>/etc/httpd/conf/httpd.conf</p>
<p>如果没<br>执行命令<br>yum install httpd<br>重新安装一下，</p>
<h2 id="根据nginx配置，查找文件目录"><a href="#根据nginx配置，查找文件目录" class="headerlink" title="根据nginx配置，查找文件目录"></a>根据nginx配置，查找文件目录</h2><p>原本nginx配置好后，目录应该在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root &#x2F;data&#x2F;www&#x2F;hosts;</span><br></pre></td></tr></table></figure>

<p>但如果有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ^~ &#x2F; &#123;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001&#x2F;;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则应根据3001端口来找具体进程对应的进程</p>
<p>执行 如下命令找到对应进程的pid</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -nplt | grep 3001</span><br></pre></td></tr></table></figure>

<p>根据pid来找到目录，执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep 37098</span><br></pre></td></tr></table></figure>

<p>出现如下结果，则为对应的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">501      37098  0.0  0.2 1209696 42828 ?       Ssl  Aug08   8:37 node /home/nodeProjects/express/dist/index.js</span><br></pre></td></tr></table></figure>

<h2 id="跟着立斌学命令行"><a href="#跟着立斌学命令行" class="headerlink" title="跟着立斌学命令行"></a>跟着立斌学命令行</h2><p>dash<br>zsh<br>/oh-my-zsh<br>oh-my-zsh</p>
<p>sh -c “$(curl -fsSL <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</a><br>需要提前装zsh，<br> yum install zsh</p>
<h2 id="切换到zsh"><a href="#切换到zsh" class="headerlink" title="切换到zsh"></a>切换到zsh</h2><p>chsh -s /usr/local/bin/zsh</p>
<p>修改主题，目录<br>/root/.oh-my-zsh/templates/zshrc.zsh-template</p>
<p>zsh-autosuggestions</p>
<p>安装方法：<br>git clone git://github.com/zsh-users/zsh-autosuggestions <del>/.zsh/zsh-autosuggestions<br>source</del>/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh</p>
<p>看一下自己目前使用的终端是什么：</p>
<p>echo $SHELL</p>
<p>查看当前主题</p>
<p>echo $ZSH_THEME</p>
<p>我用的主题<br>robbyrussell</p>
<p> 主题修改文件路径:sudo vim ~/.zshrc</p>
<h2 id="linux-用命令启动服务不掉线"><a href="#linux-用命令启动服务不掉线" class="headerlink" title="linux 用命令启动服务不掉线"></a>linux 用命令启动服务不掉线</h2><p>创建control.sh<br>  运行./control.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">nohup npm start ./ 1&gt;&gt;<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>cat access.log | cut -d’ ‘ -f7 | sort | uniq -c | sort -nr | head -n30</p>
<hr>

      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-08 18:05:59" itemprop="dateCreated datePublished" datetime="2018-10-08T18:05:59+08:00">2018-10-08</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>367</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">网站搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-25 20:31:07" itemprop="dateCreated datePublished" datetime="2018-08-25T20:31:07+08:00">2018-08-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-03-22 20:31:07" itemprop="dateModified" datetime="2019-03-22T20:31:07+08:00">2019-03-22</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="网站创建历程"><a href="#网站创建历程" class="headerlink" title="网站创建历程"></a>网站创建历程</h2><h2 id="1-买域名"><a href="#1-买域名" class="headerlink" title="1. 买域名"></a>1. 买域名</h2><pre><code>https://wanwang.aliyun.com/domain/searchresult/

先要起名字，找到合适的域名。
找好后直接付款支付就ok了。</code></pre>
<h3 id="1-1-实名制"><a href="#1-1-实名制" class="headerlink" title="1.1  实名制"></a>1.1  实名制</h3><pre><code>需要身份证照片。
直接拍照，上传，ok，等2个工作日。</code></pre>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p> <a target="_blank" rel="noopener" href="https://cn.aliyun.com/easybuy?spm=5176.8142029.418687.2.QpC6Vr">购买地址</a></p>
<p>云服务器ECS（包年包月）<br>地域: 华北 1<br>可用区: 华北 1 可用区 B<br>I/O 优化实例: 非 I/O 优化实例<br>实例规格: 1 核 2GB<br>网络类型: 经典网络<br>带宽: 1Mbps（按固定带宽）<br>操作系统: CentOS 7.2 64位<br>系统盘: 40GB 普通云盘<br>密码: 已设置<br>实例名称: oriht</p>
<p>linux学习：<br><a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/linux-command/chap03.html">http://wiki.jikexueyuan.com/project/linux-command/chap03.html</a></p>
<p>登陆的操作：<br>ssh root@ip</p>
<p>三：连接数据库：mysql -uroot -proot //p</p>
<p>还有就是遇到死链接的问题需要</p>
<p>配置路由：‘URL_MODEL’=2;<br>或者配置为0 和3 这里需要仔细查看TP手册部署那里。</p>
<p>直接写路径就可以</p>
<p>3。chkconfig –level 35 vsftpd on4.yum -y install vsftpd;5 cd /home/wwwroot/default/6 chmod 777 /home/wwwroot/default/chmod 777 /home/wwwroot/default/ -R<br>这里要注意的是权限问题：你要把application目录权限-777例如：chmod 777 /home/wwwroot/default/ -Rchmod -R 777 /home/wwwroot/default/</p>
<p><a target="_blank" rel="noopener" href="http://www.centoscn.com/image-text/install/2014/0514/2972.html">在centos上安装git</a></p>
<h2 id="备案流程"><a href="#备案流程" class="headerlink" title="备案流程"></a>备案流程</h2><p> 网站备案信息真实性核验单 [查看样例] 请打印3份，按照样例分别填写并全部邮寄</p>
<p> 申请邮寄幕布 您自行拍照后上传</p>
<h2 id="远程拷贝"><a href="#远程拷贝" class="headerlink" title="远程拷贝"></a>远程拷贝</h2><p>拷贝远程服务器的文件到本地:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r -P 端口号 用户名@IP地址:/usr/<span class="built_in">local</span>/tomcat_airc/webapps/  /tmp/kyj/</span><br></pre></td></tr></table></figure></code></pre>
<p>拷贝本地文件到远程服务器:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /tmp/kyj/sys.war 用户名@IP地址:/usr/<span class="built_in">local</span>/tomcat_airc/webapps/</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h2><p> php的默认端口是8080<br> nginx的默认端口改成80</p>
<h2 id="https配置"><a href="#https配置" class="headerlink" title="https配置"></a>https配置</h2><p> 在阿里云买好证书，</p>
<ol>
<li><p>在nginx安装目录下新建cert目录<br>cd /usr/local/nginx<br>mkdir cert</p>
</li>
<li><p>将证书下载下来，复制到cert目录下<br> scp -r 本地文件目录 root@(ip):/usr/local/nginx/cert/<br> 这里有123.pem 和123.key,两个都要传到远程服务器</p>
</li>
<li><p>配置后不生效</p>
</li>
<li><p>curl -l <a target="_blank" rel="noopener" href="http://oriht.com/">http://oriht.com</a></p>
</li>
<li><p>wget <a target="_blank" rel="noopener" href="http://oriht.com/">http://oriht.com</a></p>
</li>
<li><p>需要进入阿里云服务器的实例里，找到安全组规则，配置443访问权限。才能访问https的端口</p>
</li>
<li><p>nginx no input file specified 查看nginx error.log, 发现是nginx之前的配置找不到路径之类的问题，先将所有的其他配置注释掉，mv **.conf **.conf.bak</p>
</li>
<li><p>又报502 Bad Gateway 说是nginx-fpm的占用内存太多，默认进程数太少</p>
</li>
</ol>
<p>1、查看php fastcgi的进程数（max_children值）</p>
<p><code>netstat -anop | grep php-cgi | wc -l</code><br>1、查看php fastcgi的进程数（max_children值）</p>
<p><code>netstat -anop | grep php-cgi | wc -l</code></p>
<p>3、调整/usr/local/php/etc/php-fpm.conf 的相关设置</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm.max_children &#x3D; 5</span><br><span class="line">request_terminate_timeout &#x3D; 60</span><br></pre></td></tr></table></figure></code></pre>
<p>部分PHP程序的执行时间超过了Nginx的等待时间，可以适当增加nginx.conf配置文件中FastCGI的timeout时间，例如：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">fastcgi_connect_timeout 300;</span><br><span class="line">fastcgi_send_timeout 300;</span><br><span class="line">fastcgi_read_timeout 300;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>

      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/" class="post-title-link" itemprop="url">前端经验积累</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-03 21:42:02" itemprop="dateCreated datePublished" datetime="2018-07-03T21:42:02+08:00">2018-07-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-11-29 21:42:02" itemprop="dateModified" datetime="2018-11-29T21:42:02+08:00">2018-11-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>37k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>34 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="判断一个对象是不是数组"><a href="#判断一个对象是不是数组" class="headerlink" title="判断一个对象是不是数组"></a>判断一个对象是不是数组</h1><ol>
<li>instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;;</span><br><span class="line">var b&#x3D;[];</span><br><span class="line">console.log(a instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">console.log(b instanceof Array);&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">注意！！！！！！</span><br><span class="line">console.log(b instanceof Object);&#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Array.isArray()</p>
</li>
<li><p>使用Object.prototype上的原生toString()方法判断。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(a));&#x2F;&#x2F;[object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(b));&#x2F;&#x2F;[object Array]</span><br><span class="line">同理判断一个对象是否是函数：</span><br><span class="line">console.log(Object.prototype.toString.call(obj)&#x3D;&#x3D;&#x3D;&#39;[object Function]&#39;)    &#x2F;&#x2F;true或false</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>obj.constructor===Array   //true</li>
</ol>
<h1 id="真值-假值（Truthy-Falsy）"><a href="#真值-假值（Truthy-Falsy）" class="headerlink" title="真值 / 假值（Truthy / Falsy）"></a>真值 / 假值（Truthy / Falsy）</h1><p>以下为false</p>
<ul>
<li>false</li>
<li>0</li>
<li>“”（空字符串）</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">!0 &#x2F;&#x2F; true -- 0 is false, 所以返回true</span><br><span class="line">!!0 &#x2F;&#x2F; false -- 0 is falsy so !0 returns true so !(!0) returns false</span><br><span class="line">!!&quot;&quot; &#x2F;&#x2F; false -- empty string is falsy so NOT (NOT false) equals false</span><br><span class="line"></span><br><span class="line">new Boolean(0) &#x2F;&#x2F; false</span><br><span class="line">new Boolean(1) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let a &#x3D; [] &#x3D;&#x3D; true &#x2F;&#x2F; a is false since [].toString() give &quot;&quot; back.</span><br><span class="line">let b &#x3D; [1] &#x3D;&#x3D; true &#x2F;&#x2F; b is true since [1].toString() give &quot;1&quot; back.</span><br><span class="line">let c &#x3D; [2] &#x3D;&#x3D; true &#x2F;&#x2F; c is false since [2].toString() give &quot;2&quot; back.</span><br><span class="line"></span><br><span class="line">在内部，当一个对象与布尔值比较时，</span><br><span class="line">比如[] &#x3D;&#x3D; true，它其实进行的是[].toString() &#x3D;&#x3D; true。</span><br></pre></td></tr></table></figure>

<h1 id="JS语句为什么不能以“function”和大括号开头"><a href="#JS语句为什么不能以“function”和大括号开头" class="headerlink" title="JS语句为什么不能以“function”和大括号开头"></a>JS语句为什么不能以“function”和大括号开头</h1><ul>
<li>以function开头，但必须是一个函数声明语句</li>
<li>以大括号开头，但该大括号不再被当做一个对象处理，而是当做一个语句块处理</li>
<li>综上两条说明，JS语句可以以function，也可以以大括号作为开头，前提是必须符合JS中的语法规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;a: &#39;a&#39;&#125;.a;   &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line">function()&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token (</span><br><span class="line">&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line"></span><br><span class="line">“&#123;&#125;.toString();” 等同于: “; .toString();” 未通过对象主体调用“toString”方法，不符合JS中期待的表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Object-assign-JSON-stringify是深拷贝吗"><a href="#Object-assign-JSON-stringify是深拷贝吗" class="headerlink" title="Object.assign, JSON.stringify是深拷贝吗"></a>Object.assign, JSON.stringify是深拷贝吗</h1><p>不是的话怎么解决</p>
<p>shallowCopy（浅拷贝）或 deepCopy（深拷贝）</p>
<p>深拷贝造成了 CPU 和内存的浪费</p>
<p>深拷贝如果是只有最底层一个元素改变，会造成性能影响，怎么解决? immutable</p>
<p>Object.assign()可以对非嵌套对象进行深拷贝的方法,<br>如果对象中出现嵌套情况,那么其对被嵌套对象的行为就成了普通的浅拷贝.<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。</p>
<p>对象解构运算，也是浅拷贝。</p>
<p>JSON对象中包含两个方法, stringify()和parse(),前者可以将对象JSON化,而后者可以将JSON格式转换为对象.这是一种可以实现深拷贝的方法.<br>但这种方法的缺陷是会破坏原型链,并且无法拷贝属性值为function的属性<br>所以如果只是想单纯复制一个嵌套对象,可以使用此方法</p>
<p>缺点是你创建一个临时的，可能很大的字符串，只是为了把它重新放回解析器。另一个缺点是这种方法不能处理循环对象。而且循环对象经常发生。例如，当您构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const x &#x3D; &#123;&#125;;</span><br><span class="line">const y &#x3D; &#123;x&#125;;</span><br><span class="line">x.y &#x3D; y; &#x2F;&#x2F; Cycle: x.y.x.y.x.y.x.y.x...</span><br><span class="line">const copy &#x3D; JSON.parse(JSON.stringify(x)); &#x2F;&#x2F; throws!</span><br><span class="line"></span><br><span class="line">let bar &#x3D; JSON.parse(JSON.stringify(foo));</span><br><span class="line">Object.assign(&#123;&#125;, foo);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a: 0,</span><br><span class="line">    b: 20,</span><br><span class="line">&#125;</span><br><span class="line">obj &#x3D; &#123;...obj, a: obj.a + 1&#125;</span><br><span class="line"></span><br><span class="line">Structured Clone 结构化克隆算法</span><br><span class="line">MessageChannel</span><br><span class="line">缺点是它是异步的。虽然这并无大碍，</span><br><span class="line">但是有时候你需要使用同步的方式来深度拷贝一个对象</span><br><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;port1, port2&#125; &#x3D; new MessageChannel();</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#x2F;* ... *&#x2F;;</span><br><span class="line">const clone &#x3D; await structuralClone(obj);</span><br></pre></td></tr></table></figure>

<p>es7 … 的方式<br>直接{…obj}赋值属于浅复制，在修改值时{…obj,a:1}就起到了类深复制的效果<br>更新一个 Object</p>
<h3 id="immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"><a href="#immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发" class="headerlink" title="immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"></a>immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发</h3><p> <a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/3">链接</a></p>
<p> Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。</p>
<p>为什么immutable比较两个对象不同会快？原因如下：<br>和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。用法：is(map1,map2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">这是原来的 reducer：</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    newState &#x3D; Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        apples: [</span><br><span class="line">            ...state.apples.slice(0, action.payload),</span><br><span class="line">            Object.assign(&#123;&#125;, state.apples[action.payload], &#123; isEaten: true &#125;),</span><br><span class="line">            ...state.apples.slice(action.payload + 1)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">    return newState;</span><br><span class="line"></span><br><span class="line">这是使用 immutable.js 库的reducer :</span><br><span class="line"></span><br><span class="line">import &#123; fromJS &#125; from &#39;immutable&#39;;</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    return fromJS(state).setIn([&#39;apples&#39;,action.payload,&#39;isEaten&#39;], true).toJS();</span><br><span class="line"></span><br><span class="line">团队约定 state 都用 immutable 内部的数据类型，就可以连 fromJS 和 toJS 的转化都省了，超级方便！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="JSONP-后端返回alert-data-，前端会执行吗"><a href="#JSONP-后端返回alert-data-，前端会执行吗" class="headerlink" title="JSONP 后端返回alert(data)，前端会执行吗"></a>JSONP 后端返回alert(data)，前端会执行吗</h1><p>因为后端把回调方法名转成另一个名字将data包在里边，所以不会执行alert。</p>
<p>为什么是jsonp, img, iframe也可以，为什么？</p>
<p>jsonp全名叫做json with padding<br>函数调用，数据都被包裹传递到参数中了，</p>
<p>将服务端的数据用padding包起来，所谓的padding就相当于一个函数。假设我们原来有数据 {“data”,”something”}，用一个名为callback的padding包起来之后 就成了 callback({“data”:”something”})，这样将script标签加载完毕之后，会立马执行这个函数，并将数据当做参数传了进去。如果我们可以事先在前端事先指定一个函数名，并定义这个函数。然后告诉后端，用这个函数名作为padding包裹数据。那么当前端动态创建script标签之后，script加载完毕了就会执行这个函数，这样我们就成功的跨域获得了数据~</p>
<p>从开发者工具里面可以看到实际发送的请求</p>
<p>Request URL:<a target="_blank" rel="noopener" href="https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924">https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924</a></p>
<p>这里可以看出来jQuery自动生成的padding是jsonp1430727166924返回的数据：;jsonp1430727166924({“rating”:{“max”:10,”numRaters”:336,”average”:”7.0”,”min”:0},”price”:”15.00元”});</p>
<h1 id="js-css执行顺序，并行串行，阻塞"><a href="#js-css执行顺序，并行串行，阻塞" class="headerlink" title="js,css执行顺序，并行串行，阻塞"></a>js,css执行顺序，并行串行，阻塞</h1><p><a target="_blank" rel="noopener" href="http://blog.jobbole.com/12749/">链接</a><br>DOM文档的加载顺序是由上而下的顺序加载；</p>
<p>1、DOM加载到link标签</p>
<p>==css文件的加载是与DOM的加载并行的==，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；</p>
<p>2、DOM加载到script标签</p>
<p>由于==js文件不会与DOM并行加载==，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；</p>
<p>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现；</p>
<p>所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。至到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。</p>
<p>嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。</p>
<p>浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>
<p>3、解决方法</p>
<p>前提，js是外部脚本；</p>
<p>在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；</p>
<p>在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；</p>
<p>同时使用defer和async属性时，defer属性会失效；</p>
<p>可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。</p>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;十进制转其他</span><br><span class="line">var x&#x3D;110;  </span><br><span class="line">alert(x);</span><br><span class="line">alert(x.toString(8));  </span><br><span class="line">alert(x.toString(32));  </span><br><span class="line">alert(x.toString(16));  </span><br><span class="line">&#x2F;&#x2F;其他转十进制</span><br><span class="line">var x&#x3D;&#39;110&#39;;</span><br><span class="line">alert(parseInt(x,2));  </span><br><span class="line">alert(parseInt(x,8));  </span><br><span class="line">alert(parseInt(x,16));  </span><br><span class="line">&#x2F;&#x2F;其他转其他  </span><br><span class="line">&#x2F;&#x2F;先用parseInt转成十进制再用toString转到目标进制  </span><br><span class="line">alert(String.fromCharCode(parseInt(141,8)))  </span><br><span class="line">alert(parseInt(&#39;ff&#39;,16).toString(2));  </span><br></pre></td></tr></table></figure>

<h1 id="两个对象判断"><a href="#两个对象判断" class="headerlink" title="两个对象判断=="></a>两个对象判断==</h1><p>引用下温特大大的总结就是：<br>只要记住 null 只和undefined 相等，<br>有 number 都转 number，<br>有 boolean 也转 number，<br>有 string 都转 string，<br>对象互相不等，<br>NaN 互相不等就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log([] &#x3D;&#x3D; []) &#x2F;&#x2F; false</span><br><span class="line">console.log(![] &#x3D;&#x3D; false) &#x2F;&#x2F; false</span><br><span class="line">console.log([] &#x3D;&#x3D; false) &#x2F;&#x2F; true</span><br><span class="line">console.log(!!&#39;hello&#39;) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;hello&#39; &#x3D;&#x3D; true) &#x2F;&#x2F; &#39;hello&#39;&#x3D;&#x3D;1  false</span><br><span class="line">console.log(typeof(typeof(&#39;hello&#39;)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typeof的运算数未定义,返回的就是 “undefined”.</span><br><span class="line"></span><br><span class="line">运算数为数字 typeof(x) &#x3D; “number”</span><br><span class="line"></span><br><span class="line">字符串 typeof(x) &#x3D; “string”</span><br><span class="line"></span><br><span class="line">布尔值 typeof(x) &#x3D; “boolean”</span><br><span class="line"></span><br><span class="line">对象,数组和null typeof(x) &#x3D; “object”</span><br><span class="line"></span><br><span class="line">函数 typeof(x) &#x3D; “function”</span><br></pre></td></tr></table></figure>

<h1 id="FOUC无样式内容闪烁"><a href="#FOUC无样式内容闪烁" class="headerlink" title="FOUC无样式内容闪烁"></a>FOUC无样式内容闪烁</h1><p>Flash of Uncompiled Content</p>
<p>原因大致为： 1，使用import方法导入样式表。 2，将样式表放在页面底部 3，有几个样式表，放在html结构的不同位置。</p>
<p>解决方法： 使用LINK标签将样式表放在文档HEAD中。</p>
<ol>
<li><p>v-cloak</p>
</li>
<li><p>用v-text</p>
</li>
<li><p>v-if, v-show</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- same as --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// <span class="tag">&lt;<span class="name">div</span>&gt;</span> 不会显示，直到编译结束。</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="js实现jQuery-clone"><a href="#js实现jQuery-clone" class="headerlink" title="js实现jQuery.clone"></a>js实现jQuery.clone</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">逐级递归；</span><br><span class="line"></span><br><span class="line">递归中收集每个元素的全部信息，包括该元素上绑定的所有事件。</span><br><span class="line"></span><br><span class="line">复制时候重现按照获得的事件列表逐个加载回去。</span><br><span class="line"></span><br><span class="line">除此之外主要可能是考虑各种兼容，</span><br><span class="line">包括cloneNode方法的兼容，</span><br><span class="line">获取元素属性时候的某些标签的兼容。</span><br></pre></td></tr></table></figure>

<h1 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h1><p>（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。</p>
<h1 id="ajax参数"><a href="#ajax参数" class="headerlink" title="ajax参数"></a>ajax参数</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huiyuantang/p/5458278.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.url: 发送请求的地址</span><br><span class="line">2.type: 请求方式（post或get</span><br><span class="line">3.timeout: 请求超时时间（毫秒）</span><br><span class="line">4.async: 默认设置为true，异步请求</span><br><span class="line">5.cache: 从浏览器缓存中加载请求信息</span><br><span class="line">6.data: 发送到服务器的数据</span><br><span class="line">7.dataType: xml,html, json,text</span><br><span class="line">8.beforeSend：发送请求前，执行一些操作</span><br><span class="line">9.complete：完成后调用的回调函数</span><br><span class="line">10.success：请求成功后调用的回调函数</span><br><span class="line">11.error:</span><br><span class="line">12.contentType：</span><br><span class="line">13.dataFilter：</span><br><span class="line"></span><br><span class="line">16.ifModified：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;闭包限定命名空间</span><br><span class="line">(function ($) &#123;</span><br><span class="line">    $.fn.extend(&#123;</span><br><span class="line">        &quot;highLight&quot;:function(options)&#123;</span><br><span class="line">            &#x2F;&#x2F;do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(window.jQuery);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">$(&quot;p&quot;).highLight(); &#x2F;&#x2F;调用自定义 高亮插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="exports-module-exports区别"><a href="#exports-module-exports区别" class="headerlink" title="exports, module.exports区别"></a>exports, module.exports区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports</span><br><span class="line"></span><br><span class="line">exports在module.exports 被改变后，失效。</span><br><span class="line"></span><br><span class="line">1. module.exports 初始值为一个空对象 &#123;&#125;</span><br><span class="line">2. exports 是指向的 module.exports 的引用</span><br><span class="line">3. require() 返回的是 module.exports 而不是 exports</span><br></pre></td></tr></table></figure>

<h1 id="上传文件方式"><a href="#上传文件方式" class="headerlink" title="上传文件方式"></a>上传文件方式</h1><ul>
<li><p>form表单上传文件</p>
  <form action="/test/" method="POST" enctype="multipart/form-data">
</li>
<li><p>原生js实现ajax上传文件<br>   var xml=new XMLHttpRequest();</p>
<p>  var data=new FormData; //创建formdata对象</p>
<p>  data.append(“testfile”,document.getElementById(“file_upload”).files[0]);//找到对象之后的file[0]对应的就是文件对象</p>
<p>  xml.open(“POST”,”/test/“,true);</p>
</li>
<li><p>jquery实现ajax上传文件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data&#x3D;new FormData;</span><br><span class="line">data.append(&quot;testfile&quot;,document.getElementById(&quot;file_upload&quot;).files[0]);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;&#x2F;test&#x2F;&quot;,</span><br><span class="line">    type:&quot;POST&quot;,</span><br><span class="line">    dataType:&quot;JSON&quot;,</span><br><span class="line">    data:data,</span><br><span class="line">    contentType: false,</span><br><span class="line">    processData: false,</span><br><span class="line">    success:function(rst)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>form+iframe上传文件</p>
<h1 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h1><p> @mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin通过 @include来调用。</p>
<p> @mixin通过 @include调用后解析出来的样式是以拷贝形式存在的，而继承则是以联合声明的方式存在的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sass style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">@mixin center-block &#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br><span class="line">.demo&#123;</span><br><span class="line">    @include center-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;css style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">.demo&#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1，session 在服务器端，</span><br><span class="line">    cookie 在客户端（浏览器）</span><br><span class="line">2，session 默认被存在在服务器</span><br><span class="line">    的一个文件里（不是内存）</span><br><span class="line">3，session 的运行依赖 session id，</span><br><span class="line">    而 session id 是存在 cookie 中的，</span><br><span class="line">    也就是说，如果浏览器禁用了 cookie ，</span><br><span class="line">    同时 session 也会失效</span><br><span class="line">    （但是可以通过其它方式实现，</span><br><span class="line">    比如在 url 中传递 session_id）</span><br><span class="line">4，session 可以放在 文件、数据库、或内存中都可以。</span><br><span class="line">5，用户验证这种场合一般会用 session</span><br><span class="line">因此，维持一个会话的核心就是</span><br><span class="line">客户端的唯一标识，即 session id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="AMD-CMD-CommonJS"><a href="#AMD-CMD-CommonJS" class="headerlink" title="AMD, CMD, CommonJS"></a>AMD, CMD, CommonJS</h1><p>==记忆方法==</p>
<p>AR<br>AMD– require.js</p>
<p>CS<br>CMD– sea.js</p>
<p>A AMD A在前，提前加载</p>
<p>C CMD C在后，延迟加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">node的module遵循CommonJS规范，</span><br><span class="line">requirejs遵循AMD，seajs遵循CMD，</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------- node -----------</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  a : function() &#123;&#125;,</span><br><span class="line">  b : &#39;xxx&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------- AMD or CMD ----------------</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  module.exports &#x3D; &#123;</span><br><span class="line">    a : function() &#123;&#125;,</span><br><span class="line">    b : &#39;xxx&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。</span><br><span class="line">它采用异步方式加载模块，模块的加载不影响它后面语句的运行。</span><br><span class="line">所有依赖这个模块的语句，都定义在一个回调函数中，</span><br><span class="line">等到加载完成之后，这个回调函数才会运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line"></span><br><span class="line">1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</span><br><span class="line">不过 RequireJS 从 2.0 开始，</span><br><span class="line">也改成可以延迟执行（根据写法不同，处理方式不同）。</span><br><span class="line">CMD 推崇 as lazy as possible.</span><br><span class="line"></span><br><span class="line">2. CMD 推崇依赖就近，AMD 推崇依赖前置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="import引入模块"><a href="#import引入模块" class="headerlink" title="import引入模块"></a>import引入模块</h3><p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>注意:import必须放在文件的最开始.import命令是编译阶段执行的，在代码运行之前,表达式和变量只有在运行时才能得到结果的语法结构。import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）所以import中不能含有表达式或者变量,因此无法实现动态加载.<br>因此，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。<br>这样的设计，有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br></pre></td></tr></table></figure>

<h1 id="position取值"><a href="#position取值" class="headerlink" title="position取值"></a>position取值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ralative是指相对定位</span><br><span class="line">元素仍保持其未定位前的形状，它原本所占的空间仍保留。</span><br><span class="line"></span><br><span class="line">absolute是指绝对定位</span><br><span class="line">    即完全离开文档流, 相关于position属性非static值的比来父级元素进行偏移。</span><br><span class="line">    如果不存在这样的父对象，则依据body对象。而其层叠通过z-index属性定义</span><br><span class="line">fixed: 固定定位</span><br><span class="line">    固定定位：即完全离开文档流，相关于视区进行偏移。</span><br><span class="line">static：元素框正常生成</span><br><span class="line">inherit：继承值，对象将继承其父对象相应的值。</span><br></pre></td></tr></table></figure>

<h1 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="call和apply-bind区别"><a href="#call和apply-bind区别" class="headerlink" title="call和apply, bind区别"></a>call和apply, bind区别</h1><p>这三个参数的返回值区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">作用完全一样，唯一的区别就在参数上</span><br><span class="line"></span><br><span class="line">call 接收的参数不固定，</span><br><span class="line">第一个参数是函数体内 this 的指向，</span><br><span class="line">第二个参数以下是依次传入的参数。</span><br><span class="line"></span><br><span class="line">apply接收两个参数，</span><br><span class="line">第一个参数也是函数体内 this 的指向。</span><br><span class="line">第二个参数是一个集合对象（数组或者类数组）</span><br><span class="line"></span><br><span class="line">记忆方法：</span><br><span class="line"></span><br><span class="line">apply ---- array 要传数组</span><br><span class="line">call  ---- 逗号隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三个的使用区别：</span><br><span class="line">都是用来改变函数的this对象的指向的；</span><br><span class="line">第一个参数都是this要指向的对象；</span><br><span class="line">都可以利用后续参数传参；</span><br><span class="line">bind是返回对应函数，便于稍后调用，apply、call是立即调用；</span><br><span class="line">bind（）--也是改变函数体内this的指向;</span><br><span class="line">bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let obj1&#x3D;&#123;</span><br><span class="line">    a:222</span><br><span class="line">&#125;;</span><br><span class="line">let obj2&#x3D;&#123;</span><br><span class="line">    a:111,</span><br><span class="line">    fn:function()&#123;</span><br><span class="line">        alert(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.fn.call(obj1);&#x2F;&#x2F;222</span><br><span class="line"></span><br><span class="line">call 和 apply 两个主要用途就是</span><br><span class="line"></span><br><span class="line">1.改变 this 的指向（把 this 从 obj2 指向到 obj1 ）</span><br><span class="line"></span><br><span class="line">2.方法借用（ obj1 没有 fn ，只是借用 obj2 方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="箭头函数怎么绑定全局this"><a href="#箭头函数怎么绑定全局this" class="headerlink" title="箭头函数怎么绑定全局this"></a>箭头函数怎么绑定全局this</h1><p>箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () &#x3D;&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  &#x2F;&#x2F; undefined window&#123;...&#125;</span><br><span class="line"></span><br><span class="line">作为方法的箭头函数this指向全局window对象，</span><br><span class="line">而普通函数则指向调用它的对象</span><br></pre></td></tr></table></figure>

<h1 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h1><p><a target="_blank" rel="noopener" href="http://caibaojian.com/es6-features.html">链接</a></p>
<h1 id="foreach-map-reduce-filter区别"><a href="#foreach-map-reduce-filter区别" class="headerlink" title="foreach, map, reduce, filter区别"></a>foreach, map, reduce, filter区别</h1><h1 id="函数声明-amp-函数表达式的区别"><a href="#函数声明-amp-函数表达式的区别" class="headerlink" title="函数声明&amp;函数表达式的区别"></a>函数声明&amp;函数表达式的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">函数声明中函数名是必须的；函数表达式中则是可选的</span><br><span class="line"> &#x2F;&#x2F;函数声明</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(1, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数表达式</span><br><span class="line">&#x2F;* var s &#x3D; function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2)); *&#x2F;</span><br><span class="line"></span><br><span class="line">var s &#x3D; function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2));</span><br><span class="line">&#x2F;&#x2F;以上两种都可以</span><br><span class="line"></span><br><span class="line">二、用函数声明定义的函数,函数可以在函数声明之前调用,而用函数表达式定义的函数只能在声明之后调用。</span><br><span class="line"></span><br><span class="line">【根本原因在于解析器对这两种定义方式读取的顺序不同:解析器会事先读取函数声明，即函数声明放在任意位置都可以被调用；</span><br><span class="line"></span><br><span class="line">对于函数表达式，解析器只有在读到函数表达式所在那行的时候才执行】</span><br><span class="line"></span><br><span class="line">使用var 表达式定义函数， 只有变量声明提前了，变量初始化代码仍然在原来的位置</span><br></pre></td></tr></table></figure>

<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段</p>
<h5 id="addEventListener-evtype-fn-useCapture"><a href="#addEventListener-evtype-fn-useCapture" class="headerlink" title="addEventListener(evtype,fn,useCapture)"></a>addEventListener(evtype,fn,useCapture)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">useCapture是true，则事件处理函数在捕获阶段被执行，否则 在冒泡阶段执行</span><br><span class="line"></span><br><span class="line">因为如果被监听的元素没有子元素，那么哪个监听代码写在前面，就先执行哪个！</span><br><span class="line"></span><br><span class="line">&lt;label&gt;Click me &lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#39;label&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;)</span><br><span class="line">    document.querySelector(&#39;input&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">因为label和input是有绑定的</span><br><span class="line">点击label后，浏览器自动帮你再点击一次label</span><br><span class="line">过程就是先进行一次事件机制，这一次对内部input元素的事件监听是不管不问的，所以先打出1</span><br><span class="line">结束后，再进行一次事件机制，这一次，按照正常事件机制流程走，所以接着打出了2,1</span><br></pre></td></tr></table></figure>

<p>阻止冒泡<br>window.event.cancelBubble = true</p>
<p>e.preventDefault();</p>
<p>return false</p>
<p>都能阻止<br> stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。<br>stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡</p>
<h1 id="git-问题"><a href="#git-问题" class="headerlink" title="git 问题"></a>git 问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git回退到某个commit版本</span><br><span class="line"></span><br><span class="line">git reset --hard commitId</span><br><span class="line">强制提交</span><br><span class="line">git push -f origin master</span><br><span class="line">删除分支</span><br><span class="line">git branch -d branchname  </span><br><span class="line"></span><br><span class="line">git 删除远程分支</span><br><span class="line">git push origin branchname</span><br><span class="line"></span><br><span class="line">rebase 和 merge区别</span><br><span class="line"></span><br><span class="line">rebase，合并的结果好看，一条线，但合并过程中出现冲突的话，比较麻烦（rebase过程中，一个commit出现冲突，下一个commit也极有可能出现冲突，一次rebase可能要解决多次冲突）；merge，合并结果不好看，一堆线交错，但合并有冲突的话，只要解一次就行了；</span><br><span class="line"></span><br><span class="line">commit 粒度把握得好，就直接 merge，把握不好，先 rebase 把粒度调整好了，再 merge。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="let-var-const-区别"><a href="#let-var-const-区别" class="headerlink" title="let var const 区别"></a>let var const 区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let 的「创建」过程被提升了，但是初始化没有提升。</span><br><span class="line"></span><br><span class="line">let在未定义之前使用，会报错</span><br><span class="line"></span><br><span class="line">var 的「创建」和「初始化」都被提升了。</span><br><span class="line"></span><br><span class="line">function 的「创建」「初始化」和「赋值」都被提升了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let 声明的变量的作用域是块级的；</span><br><span class="line">let 不能重复声明已存在的变量；</span><br><span class="line">let 有暂时死区，不会被提升。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域</span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) &#123; 循环体 &#125; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog">js链接</a></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">链接</a></p>
<p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。</p>
<p>在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>最大用处有两个，<br>一是可以读取函数内部的变量，<br>（创建局部变量，保护局部变量不会被访问和修改）。<br>另一个就是让这些变量的值始终保持在内存中。</p>
<p>闭包常见用途：</p>
<p>创建特权方法用于访问控制<br>事件处理程序及回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">let add&#x3D;(function()&#123;</span><br><span class="line">let now&#x3D;0;</span><br><span class="line">return &#123;</span><br><span class="line"> doAdd:function()&#123;</span><br><span class="line">    now++;</span><br><span class="line">    console.log(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">add.doAdd() &#x2F;&#x2F;1</span><br><span class="line">add.doAdd() &#x2F;&#x2F;2</span><br><span class="line">add.doAdd() &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">now 这个变量，并没有随着函数的执行完毕而被回收，</span><br><span class="line">而是继续保存在内存里面。</span><br><span class="line"></span><br><span class="line">由于 add 里面有函数是依赖于 now 这个变量。所以 now 不会被销毁，回收。</span><br><span class="line">由于 now 在外面访问不到</span><br><span class="line"></span><br><span class="line"> var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于方法里有this.name, 这里的this的是window，所以这里是The Window</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that &#x3D; this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line">　　</span><br><span class="line">&#x2F;&#x2F; 这里的that指向object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(typeof Array.isArray&#x3D;&#x3D;&#x3D;&quot;undefined&quot;)&#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg)&#123;</span><br><span class="line">        return Object.prototype.toString.call(arg)&#x3D;&#x3D;&#x3D;&quot;[object Array]&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="找出数组中的最大值"><a href="#找出数组中的最大值" class="headerlink" title="找出数组中的最大值"></a>找出数组中的最大值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;Math.max.apply(null,a);</span><br><span class="line">console.log(max);</span><br><span class="line">&#x2F;&#x2F;第二种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;eval(&#39;Math.max(&#39;+a.toString()+&#39;)&#39;);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">Math.max(...[-1, 5, 11, 3])</span><br><span class="line"> Math.max.apply(Math, [-1, 5, 11, 3])</span><br></pre></td></tr></table></figure>

<h1 id="Javascript的this用法"><a href="#Javascript的this用法" class="headerlink" title="Javascript的this用法"></a>Javascript的this用法</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">链接</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yangbingbinga/article/details/61424363">链接2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this是Javascript语言的一个关键字。</span><br><span class="line"></span><br><span class="line">它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</span><br><span class="line"></span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window</p>
<p>问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢?</p>
<p>用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针!</p>
<p>也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  test: function() &#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(this.a);</span><br><span class="line">    &#125;.bind(this), 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.test();  &#x2F;&#x2F;  2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setTimeout不止两个参数</span><br><span class="line">setTimeout(function(a, b)&#123;</span><br><span class="line">  console.log(a);   &#x2F;&#x2F; 3</span><br><span class="line">  console.log(b);   &#x2F;&#x2F; 4</span><br><span class="line">&#125;,0, 3, 4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">箭头函数比较特殊，没有自己的this，它使用封闭执行上下文(函数或是global)的 this 值。</span><br><span class="line"></span><br><span class="line">var x&#x3D;11;</span><br><span class="line">var obj&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say:()&#x3D;&gt;&#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();&#x2F;&#x2F; 11</span><br><span class="line">obj.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 11</span><br><span class="line">x &#x3D; 14</span><br><span class="line">obj.say() &#x2F;&#x2F; 14</span><br><span class="line">&#x2F;&#x2F;对比一下</span><br><span class="line">var obj2&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say() &#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.say();&#x2F;&#x2F; 22</span><br><span class="line">obj2.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 13</span><br></pre></td></tr></table></figure>

<h3 id="一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global"><a href="#一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global" class="headerlink" title="一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global"></a>一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global</h3><p>在严格模式下，默认绑定会将 this 指向 undefined</p>
<h3 id="二、作为对象方法的调用-this就指这个上级对象"><a href="#二、作为对象方法的调用-this就指这个上级对象" class="headerlink" title="二、作为对象方法的调用    this就指这个上级对象"></a>二、作为对象方法的调用    this就指这个上级对象</h3><h3 id="三-作为构造函数调用"><a href="#三-作为构造函数调用" class="headerlink" title="三 作为构造函数调用"></a>三 作为构造函数调用</h3><p>   所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
<h3 id="四-apply调用"><a href="#四-apply调用" class="headerlink" title="四 apply调用"></a>四 apply调用</h3><p>  this指的就是这第一个参数。<br>  apply()的参数为空时，默认调用全局对象。</p>
<h3 id="五-this指向绑定事件的dom元素"><a href="#五-this指向绑定事件的dom元素" class="headerlink" title="五 this指向绑定事件的dom元素"></a>五 this指向绑定事件的dom元素</h3><p>document.querySelector(“#id”).onclick =function(){<br>    this == document.querySelector(“#id”)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(!(&quot;a&quot; in window))&#123;</span><br><span class="line">    var a &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; window.hasOwnProperty(&quot;a&quot;) &#x3D;&#x3D;&#x3D; true ..</span><br><span class="line">&#x2F;&#x2F;不用多说了. a 还真存在原型链上</span><br><span class="line">&#x2F;&#x2F; 值是 Location 这个 API 的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">console.log(typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; true , 这个不用解释了</span><br><span class="line"></span><br><span class="line">console.log(!!typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及到就是优先级和布尔值的问题</span><br><span class="line">&#x2F;&#x2F; typeof count 就是字符串&quot;number&quot;</span><br><span class="line">&#x2F;&#x2F; !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true</span><br><span class="line">&#x2F;&#x2F; 最后才&#x3D;&#x3D;&#x3D; 比较 , true &#x3D;&#x3D;&#x3D; &quot;number&quot; , return false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var a &#x3D; b &#x3D; 3;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(typeof a &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(&#x3D;号自左向右)</span><br><span class="line">&#x2F;&#x2F; 那个函数可以拆成这样</span><br><span class="line"></span><br><span class="line">(function()</span><br><span class="line">  var a; &#x2F;* 局部变量,外部没法访问*&#x2F;</span><br><span class="line">  b &#x3D; 3; &#x2F;* 全局变量,so . window.b &#x3D;&#x3D;&#x3D; 3 , 外部可以访问到*&#x2F;</span><br><span class="line">  a &#x3D; b;</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 注意a只有在闭包里才能访问(a&#x3D;3)，在外部是undefined  !!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若是改成这样,这道题应该是对的</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D;3</span><br><span class="line">); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">  this.a &#x3D; something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(2)</span><br><span class="line"></span><br><span class="line">console.log(obj1.a) &#x2F;&#x2F; 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2,3); &#x2F;&#x2F; 用 call 强行改变上下文为 obj2内</span><br><span class="line">console.log(obj2.a); &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">var  bar &#x3D; new obj1.foo(4); &#x2F;&#x2F; 这里产生了一个实例</span><br><span class="line">console.log(obj1.a); &#x2F;&#x2F; 2</span><br><span class="line">console.log(bar.a); &#x2F;&#x2F; 4;  new的绑定比隐式和显式绑定优先级更高</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-设计模式你了解多少"><a href="#Q-设计模式你了解多少" class="headerlink" title="Q: 设计模式你了解多少"></a>Q: 设计模式你了解多少</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cnblogs.com&#x2F;tugenhua0707&#x2F;p&#x2F;5198407.html</span><br></pre></td></tr></table></figure>

<h1 id="Q-JS-的基本数据类型有哪些"><a href="#Q-JS-的基本数据类型有哪些" class="headerlink" title="Q: JS 的基本数据类型有哪些"></a>Q: JS 的基本数据类型有哪些</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line">Undefined</span><br><span class="line">Null</span><br><span class="line">Number</span><br><span class="line">Boolean</span><br><span class="line">String</span><br><span class="line">Symbol (ECMAScript 6 新定义)</span><br><span class="line"></span><br><span class="line"> 5 种原始类型即</span><br><span class="line"> Undefined</span><br><span class="line"> Null</span><br><span class="line"> Number</span><br><span class="line"> Boolean</span><br><span class="line"> String</span><br><span class="line"></span><br><span class="line"> 除了Object和Symbol不是，其他都是</span><br></pre></td></tr></table></figure>

<h1 id="Q-null-和-undefined-的差异"><a href="#Q-null-和-undefined-的差异" class="headerlink" title="Q: null 和 undefined 的差异"></a>Q: null 和 undefined 的差异</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">大体说一下,想要知其所以然请引擎搜索</span><br><span class="line"></span><br><span class="line">相同点:</span><br><span class="line"></span><br><span class="line">在 if 判断语句中,值都默认为 false</span><br><span class="line">大体上两者都是代表 无 ,具体看差异</span><br><span class="line">差异:</span><br><span class="line"></span><br><span class="line">null 转为数字类型值为0,而 undefined 转为数字类型为 NaN(Not a Number)</span><br><span class="line">undefined 是代表调用一个值而该值却没有赋值,这时候默认则为 undefined</span><br><span class="line">null 是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)</span><br><span class="line">设置为 null 的变量或者对象会被内存收集器回收</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-清除浮动的方式有哪些-比较好的是哪一种"><a href="#Q-清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="Q: 清除浮动的方式有哪些?比较好的是哪一种"></a>Q: 清除浮动的方式有哪些?比较好的是哪一种</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">常用的一般为三种 .clearfix , clear:both , overflow:hidden ;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  content:&quot;&quot;;&#x2F;&#x2F;设置内容为空</span><br><span class="line">　height:0;&#x2F;&#x2F;高度为0</span><br><span class="line">　line-height:0;&#x2F;&#x2F;行高为0</span><br><span class="line">　display:block;&#x2F;&#x2F;将文本转为块级元素</span><br><span class="line">　visibility:hidden;&#x2F;&#x2F;将元素隐藏</span><br><span class="line">　clear:both&#x2F;&#x2F;清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另一种写法</span><br><span class="line"></span><br><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line"> content:&quot;&quot;;</span><br><span class="line"> display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line"> clear:both;</span><br><span class="line"> overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;&#x2F;&#x2F; 为了兼容IE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">用display:table 是为了避免外边距margin重叠导致的margin塌陷,</span><br><span class="line">内部元素默认会成为 table-cell 单元格的形式</span><br><span class="line">--&gt;</span><br><span class="line">clear:both :若是用在同一个容器内相邻元素上,那是贼好的...有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</span><br><span class="line"></span><br><span class="line">overflow:hidden :这种若是用在同个容器内,可以形成 BFC 避免浮动造成的元素塌陷</span><br></pre></td></tr></table></figure>

<h1 id="Q-跨域问题"><a href="#Q-跨域问题" class="headerlink" title="Q: 跨域问题"></a>Q: 跨域问题</h1><p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/21976">详情</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">我一般用这三种, cors , nginx反向代理 , jsonp</span><br><span class="line"></span><br><span class="line">jsonp : 单纯的 get 一些数据,局限性很大...就是利用script标签的src属性来实现跨域。</span><br><span class="line"></span><br><span class="line">浏览器支持好</span><br><span class="line">调用失败不会返回各种HTTP状态码</span><br><span class="line">给后端传json格式的数据会报415错误，请求格式不正确</span><br><span class="line">callback添加恶意script标签，造成xss漏洞</span><br><span class="line">只能够实现get请求</span><br><span class="line">参数可见</span><br><span class="line"></span><br><span class="line">nginx 反向代理 : 主要就是用了 nginx.conf 内的 proxy_pass http:&#x2F;&#x2F;xxx.xxx.xxx</span><br><span class="line">,会把所有请求代理到那个域名,有利也有弊吧..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cors</span><br><span class="line"></span><br><span class="line">可控性较强,需要前后端都设置,兼容性 IE10+ ,</span><br><span class="line">CORS需要浏览器和服务器同时支持。IE8+：IE8&#x2F;9需要使用XDomainRequest对象来支持CORS。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example &#x2F;&#x2F; 子域乃至整个域名或所有域名是否允许访问</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS &#x2F;&#x2F; 允许那些行为方法</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type &#x2F;&#x2F; 允许的头部字段</span><br><span class="line">Access-Control-Max-Age: 86400 &#x2F;&#x2F; 有效期</span><br><span class="line">cros 的配置不仅仅这些,还有其他一些,具体引擎吧....</span><br><span class="line"></span><br><span class="line">若是我们要用 nginx 或者 express 配置 cors 应该怎么搞起? 来个简易版本的</span><br><span class="line"></span><br><span class="line">nginx</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   # 检查域名后缀</span><br><span class="line">    add_header Access-Control-Allow-Origin xx.xx.com;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;</span><br><span class="line">    add_header Access-Control-Max-Age 86400;</span><br><span class="line">&#125;</span><br><span class="line">express, 当然这货也有一些别人封装好的 cors 中间件,操作性更强...</span><br><span class="line">let express &#x3D; require(&#39;express&#39;);  </span><br><span class="line">let app &#x3D; express();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置所有请求的头部</span><br><span class="line">app.all(&#39;*&#39;, (req, res, next) &#x3D;&gt;  &#123;  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  </span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br><span class="line">有些还会跟你死磕,,除了这些还有其他姿势么...我说了一个HTML5的 postMessage ....</span><br><span class="line"></span><br><span class="line">..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下</span><br><span class="line"></span><br><span class="line">这货用于 iframe 传递消息居多, 大体有这么两步步</span><br><span class="line"></span><br><span class="line">window 打开一个实例,传递一个消息到一个x域名</span><br><span class="line">x 域名下监听 message 事件,获取传递的消息</span><br><span class="line">这货的兼容性没那么好,而且没考虑周全的下容易遭受 CSRF 攻击</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-对于XSS-和-CSRF-如何防范"><a href="#Q-对于XSS-和-CSRF-如何防范" class="headerlink" title="Q: 对于XSS 和 CSRF 如何防范"></a>Q: 对于XSS 和 CSRF 如何防范</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> XSS主要是指跨脚本攻击, 其实就相当于执行js脚本.</span><br><span class="line"></span><br><span class="line">XSS的防范</span><br><span class="line"></span><br><span class="line">1. 验证用户输入的内容, 是否符合规则.</span><br><span class="line">2. 转义 &lt;&gt; 造成代码直接运行的的标签..</span><br><span class="line">    轮询或者正则替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而面试官说这种的效率最低下,找相关资料</span><br><span class="line">若是有用到 cookie ,设置为 http-only ,避免客户端的篡改</span><br><span class="line"></span><br><span class="line">CSP(Content Security Policy)</span><br><span class="line">以白名单的机制对网站加载或执行的资源起作用。</span><br><span class="line">在网页中，这样的策略通过 HTTP 头信息或者 meta</span><br><span class="line">元素定义。CSP虽然提供了强大的安全保护，</span><br><span class="line">但是他也造成了如下问题：Eval及相关函数被禁用、</span><br><span class="line">内嵌的JavaScript代码将不会执行、</span><br><span class="line">只能通过白名单来加载远程脚本。</span><br><span class="line"></span><br><span class="line">CSRF跨域假冒请求</span><br><span class="line"></span><br><span class="line">有3个特性: 跨域, cookie, 请求方式.</span><br><span class="line">CSRF的防范一般这几种</span><br><span class="line"></span><br><span class="line">验证码,用户体验虽然不好,</span><br><span class="line">验证 HTTP Referer 字段,判断请求来源</span><br><span class="line">token加密解密 ,前端和后台双方协定一个token内容</span><br><span class="line"></span><br><span class="line">尽量使用JSON类型传输</span><br><span class="line">    form 传输的格式为:</span><br><span class="line">    Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">    而,JSON的传输类型为:</span><br><span class="line">    Content-Type: application&#x2F;json form</span><br><span class="line">    没有办法去模仿JSON类型进行传输</span><br><span class="line"></span><br><span class="line">DNS劫持, 事实上更偏向于User</span><br><span class="line">    developer实际上对这个也无能为力。</span><br><span class="line"></span><br><span class="line">HTTP(ISP) 劫持</span><br><span class="line">    使用HTTPS 加密方式传输</span><br><span class="line">    替换你的js的提供商，使用HTTPS路径进行加载。</span><br><span class="line"></span><br><span class="line">验证码造成的体验不好,</span><br><span class="line">token 滥用造成的性能问题,轮询替换造成的响应时间等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-谈谈你对-Promise-的理解-和-ajax-有关系么"><a href="#Q-谈谈你对-Promise-的理解-和-ajax-有关系么" class="headerlink" title="Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么"></a>Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么</h1><p><a target="_blank" rel="noopener" href="http://imweb.io/topic/57a0760393d9938132cc8da9">链接</a></p>
<p>promise 是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>异步操作队列化，比传统的异步操作回调函数和事件更合理更强大。</p>
<p>能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p>
<p>==Promise对象三种状态：==</p>
<p>Pending（进行中）<br>Fulfilled（已完成，又称为Resolved）<br>Rejectd（已失败）</p>
<p>一些需要注意的小点,如下</p>
<p>在 Pending 转为另外两种之一的状态时候,状态不可在改变..</p>
<p>Promise 的 then 为异步.而( new Promise() )构造函数内为同步</p>
<p>Promise 的 catch 不能捕获任意情况的错误(比如 then 里面的 setTimout 内手动抛出一个 Error )</p>
<p>Promise 的 resolve 若是传入值而非函数,会发生值穿透的现象</p>
<p>Promise 还有一些自带的方法,比如 race , all ,前者有任一一个解析完毕就返回,后者所有解析完毕返回…</p>
<p>==Promise 方法：==</p>
<p>then： 用链式调用的方式执行回调函数。通过 resolve 方法把 Promise 的状态置为完成态（Resolved），这时 then 方法就能捕捉到变化，并执行“成功”情况的回调。<br>then方法返回的是一个新的Promise实例</p>
<p>reject： 把 Promise 的状态置为已失败（Rejected），这时 then 方法执行“失败”情况的回调</p>
<p>catch：和 then 的第二个参数一样，用来指定 reject 的回调   当执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么也不会报错卡死 js，而是会进到这个 catch 方法中。</p>
<p>all:  提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p>
<ul>
<li><p>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。</p>
</li>
<li><p>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
</li>
</ul>
<p>race:只要有一个异步操作执行完毕，就立刻执行 then 回调。<br>注意：其它没有执行完毕的异步操作仍然会继续执行，而不是停止。</p>
<h3 id="Promise对象两个特点"><a href="#Promise对象两个特点" class="headerlink" title="Promise对象两个特点"></a>Promise对象两个特点</h3><ol>
<li><p>对象状态只由异步操作结果决定。resolve方法会使Promise对象由pendding状态变为fulfilled状态；reject方法或者异常会使得Promise对象由pendding状态变为rejected状态。Promise状态变化只有上图这两条路径。</p>
</li>
<li><p><strong>对象状态一旦改变，任何时候都能得到这个结果。</strong> 即状态一旦进入fulfilled或者rejected，promise便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。</p>
</li>
<li><p>Promise构造方法接受一个方法作为参数，该方法传入两个参数，resolve和reject。</p>
</li>
<li><p>resolve用来将Promise对象的状态置为成功，并将异步操作结果value作为参数传给成功回调函数。</p>
</li>
<li><p>reject用来将Promise对象的状态置为失败，并将异步操作错误error作为参数传给失败回调函数。</p>
</li>
<li><p>then方法绑定两个回调函数，第一个用来处理Promise成功状态，第二个用来处理Promise失败状态。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Promise 和 ajax 没有直接关系. promise 只是为了解决&quot;回调地狱&quot;</span><br><span class="line">Promise 并不能消灭回调地狱，但是它可以使回调变得可控。</span><br><span class="line"></span><br><span class="line">异步回调的问题：</span><br><span class="line"></span><br><span class="line">嵌套层次深，难以维护</span><br><span class="line">无法正常使用return和catch throw</span><br><span class="line">多个回调之间难以建立联系，一个回调函数一旦开启，就无法对其操作</span><br><span class="line">无法正常索引堆栈信息</span><br><span class="line"></span><br><span class="line">从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... some code</span><br><span class="line">    if ( &#x2F;* 异步操作成功 *&#x2F; ) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">模拟回调函数</span><br><span class="line">function runAsync(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行完成&#39;);</span><br><span class="line">        callback(&#39;随便什么数据&#39;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getUserAdmin()</span><br><span class="line">    .then(getProjects)</span><br><span class="line">    .then(getModules)</span><br><span class="line">    .then(getInterfaces)</span><br><span class="line">    .then(procResult)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a>Promise 必知必会（十道题）</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a04066351882517c416715d">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># Generator 函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;cnodejs.org&#x2F;topic&#x2F;542953d42ca9451e1bf3c251)</span><br><span class="line"></span><br><span class="line">Generator 函数是一个普通函数，但是有两个特征。</span><br><span class="line"></span><br><span class="line">一是，function关键字与函数名之间有一个星号；</span><br><span class="line"></span><br><span class="line">二是，函数体内部使用yield语句，定义不同的内部状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br>}<br>var hw = helloWorldGenerator();</p>
<p>const gen = function* () {<br>  const f1 = yield readFile(‘/etc/fstab’);<br>  const f2 = yield readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>写成async函数，就是下面这样。</p>
<p>const asyncReadFile = async function () {<br>  const f1 = await readFile(‘/etc/fstab’);<br>  const f2 = await readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。<br>以后，每次调用遍历器对象的next方法，<br>就会返回一个有着value和done两个属性的对象。<br>value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；<br>done属性是一个布尔值，表示是否遍历结束。</p>
<p>上面已经介绍了说yield是暂停标志，下面对yield进行一些介绍：</p>
<p>（1）、yield后面的表达式只有当调用next时，才会执行yield后面的表达式。</p>
<p>（2）、yield表达式只能写在Generator函数中 ，而不能写在普通的函数中。</p>
<p>（3）、yield表达式如果与其他表达式相结合，必须写在()里面。</p>
<p>yield与return的异同点：</p>
<p>相同点：都可以返回紧跟后面表达式的值</p>
<p>不同点：<br>(a)、在一个函数内部只能存在一个return语句，而可以存在多个yield语句；<br>(b)、return没有记忆功能，在Generator函数中只有当遍历器对象调用next时<br>    才会返回yield后面表达式的值，<br>    当下一次调用时从上一条yield语句后开始执行，<br>    而return后面的表达式只要函数执行就立即返回。<br>(c)、正常函数只有一个返回值，而Generator函数可以有多个返回值。</p>
<p>Generator函数被执行时，返回的是指向函数内部的遍历器对象，<br>只有调用遍历器对象的next方法时，才会返回yield后面函数表达式的值，<br>但是，其实yield表达式的值一直都是undefined。<br>如果在Generator的函数中传递参数且存在多个yield表达式时，<br>那么调用next方法时就要注意传参了：<br>next()中传递的参数就是上一个yield表达式的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 面试题网站</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com)</span><br><span class="line"></span><br><span class="line"># 作用域</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数和变量的可访问范围。<br>作用域分为全局作用域  函数作用域和eval作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 原型</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dee9f8b14771)</span><br><span class="line"></span><br><span class="line">原型其实就是上述所说的继承中的父类。</span><br><span class="line"></span><br><span class="line">原型链 :利用原型串起一个继承链，让一个引用类型继承另一个引用类型的属性和方法，再以此类推下去.</span><br><span class="line">当一个引用类型继承另一个引用类型的属性和方法时候就会产生一个原型连。</span><br><span class="line">当某个函数当成构造函数来调用时，就会产生一个构造函数的实例。这个实例上会拥有一个 __proto__ 属性，这个属性指向该实例的构造函数的原型对象(也可以称为该实例的原型对象)。</span><br><span class="line"></span><br><span class="line">定律：</span><br><span class="line"></span><br><span class="line">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line"></span><br><span class="line">原型链是依赖于__proto__，而不是prototype</span><br><span class="line"></span><br><span class="line">**实例与原型**</span><br><span class="line"></span><br><span class="line">当读取实例的属性时，</span><br><span class="line">如果找不到，就会查找与对象关联的原型中的属性，</span><br><span class="line">如果还查不到，就去找原型的原型，一直找到最顶层为止。</span><br><span class="line"></span><br><span class="line">通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。</span><br><span class="line"></span><br><span class="line">在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。</span><br><span class="line"></span><br><span class="line"> var A &#x3D; new Person();</span><br><span class="line"> Person.prototype &#x3D; A;</span><br><span class="line"></span><br><span class="line">原型对象（Person.prototype）是 构造函数（Person）的一个实例。↓</span><br><span class="line"></span><br><span class="line">#### Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### person1.__proto__ &#x3D;&#x3D; Person.prototype</span><br><span class="line"></span><br><span class="line">实例的构造函数属性（constructor）指向构造函数。↓</span><br><span class="line"></span><br><span class="line">#### person1.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null</span><br><span class="line"></span><br><span class="line">#### person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### obj.__proto__ &#x3D;&#x3D; Object.getPrototypeOf(obj)</span><br><span class="line"></span><br><span class="line"> 原型和原型链是JS实现继承的一种模型。</span><br><span class="line">原型链的形成是真正是靠__proto__ 而非prototype</span><br><span class="line"></span><br><span class="line">## 什么是原型链</span><br><span class="line"></span><br><span class="line"> 由于__proto__是任何对象都有的属性，而js里万物皆对象，</span><br><span class="line"> 所以会形成一条__proto__连起来的链条，递归访问__proto__最终到头，并且值是null</span><br><span class="line"></span><br><span class="line"> 当js引擎查找对象属性时，先查找对象本身是否存在该属性，</span><br><span class="line"> 如果不存在，会在原型链上查找，但不会查找自身的prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>var A = function()&#123;&#125;;
var a = new A();
console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null</code></pre>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>actions<br>assets<br>components<br>reducers<br>store<br>views<br>index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># prototype问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function Foo() {<br>    getName = function () { alert (1); };<br>    return this;<br>}<br>Foo.getName = function () { alert (2);};<br>Foo.prototype.getName = function () { alert (3);};<br>var getName = function () { alert (4);};<br>function getName() { alert (5);}</p>
<p>//请写出以下输出结果：<br>Foo.getName();<br>getName();<br>Foo().getName();<br>getName();<br>new Foo.getName();<br>new Foo().getName();<br>new new Foo().getName();</p>
<p>//答案：<br>Foo.getName();//2<br>getName();//4<br>Foo().getName();//1<br>getName();//1<br>new Foo.getName();//2<br>new Foo().getName();//3<br>new new Foo().getName();//3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># var和函数的提前声明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function fn(a) {<br>  console.log(a);<br>  var a = 2;<br>  function a() {}<br>  console.log(a);<br>}</p>
<p>fn(1);<br>　　输出：function  a() {} 2<br>　　<br>　　<br>我们知道var和function是会提前声明的，<br>而且function是优先于var声明的（如果同时存在的话），<br>所以提前声明后输出的a是个function，<br>然后代码往下执行a进行重新赋值了，故第二次输出是2。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zichi/p/4359786.html">http://www.cnblogs.com/zichi/p/4359786.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># javascript实现将多个有序数组合并为一个有序数组的算法</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010302469)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let ret=arr.reduce((arr1,arr2)=&gt;arr1.concat(arr2)).sort((a,b)=&gt;a-b);<br>ret=Array.from(new Set(ret));<br>console.log(ret);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># new操作符具体干了什么呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1、创建一个新对象<br>2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）<br>3、执行构造函数中的代码（为这个新对象添加属性）<br>4、返回新对象</p>
<p>var obj  = {};<br>obj.<strong>proto</strong> = Base.prototype;<br>Base.call(obj);</p>
<p>创建一个新对象foo；</p>
<p>并将它的<strong>proto__指向其构造函数的prototype，<br>foo.__proto</strong> = Foo.prototype;</p>
<p>动态将this指向新对象，Foo.apply(foo，arguments);</p>
<p>执行函数体中的代码；</p>
<p>放回新对象foo;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 怎么画一条0.5px的边</span><br><span class="line"></span><br><span class="line">[链接：](https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5ab65f40f265da2384408a95)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过直接设置宽高border为0.5px、<br>设置box-shadow的垂直方向的偏移量为0.5px、<br>借助线性渐变linear-gradient、<br>使用transform: scaleY(0.5)的方法，<br>使用SVG的方法。<br>最后发现transfrom scale/svg的方法兼容性和效果都是最好的，<br>svg可以支持复杂的图形，<br>所以在viewport是1的情况下，<br>可以使用transform/SVG画0.5px，<br>而如果viewport的缩放比例不是1的话，那么直接画1px即可。</p>
<p>.hairline-border {<br>  box-shadow: 0 0 0 1px;<br>}<br>@media (min-resolution: 2dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.5px;<br>  }<br>}<br>@media (min-resolution: 3dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.33333333px;<br>  }<br>}<br>@media (min-resolution: 4dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.25px;<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从 arguments 到剩余参数</span><br><span class="line"></span><br><span class="line">如果你想在 ES5 中让函数(或方法)接受任意数量的参数，必须使用特殊变量 arguments：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function logAllArguments() {<br>    for (var i=0; i &lt; arguments.length; i++) {<br>        console.log(arguments[i]);<br>    }<br>}</p>
<p>ES6 中则可以通过 … 运算符定义一个剩余参数(在下面示例中是args)：</p>
<p>function logAllArguments(…args) {<br>    for (const arg of args) {<br>        console.log(arg);<br>    }<br>}</p>
<p>如果有一部分固定参数，剩余参数就更适用了：</p>
<p>function format(pattern, …args) {<br>    ···<br>}</p>
<p>在 ES5 中处理同样的事情有点麻烦：</p>
<p>function format(pattern) {<br>    var args = [].slice.call(arguments, 1);<br>    ···<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</span><br><span class="line"></span><br><span class="line">[连接](https:&#x2F;&#x2F;github.com&#x2F;qiu-deqing&#x2F;FE-interview#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BB%A5http%E4%B8%BA%E4%BE%8B)</span><br><span class="line"></span><br><span class="line">1. 输入url</span><br><span class="line">2. 查看缓存</span><br><span class="line">3. 解析URL</span><br><span class="line">4. 组装HTTP请求报文</span><br><span class="line">5. 获取主机ip</span><br><span class="line">6. 建立tcp连接</span><br><span class="line">7. 发送http请求</span><br><span class="line">8. 服务器检查请求头信息</span><br><span class="line">9. 响应报文通过tcp返回</span><br><span class="line">10. 关闭tcp四次握手</span><br><span class="line">11. 检查状态码</span><br><span class="line">12. 缓存</span><br><span class="line">13. 解码</span><br><span class="line">14. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</span><br><span class="line">15. 显示页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器地址栏输入URL<br>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，<br>足够新鲜直接提供给客户端，否则与服务器进行验证。<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：<br>HTTP1.0提供Expires，<br>值为一个绝对时间表示缓存新鲜日期<br>HTTP1.1增加了Cache-Control: max-age,<br>值为以秒为单位的最大新鲜时间<br>浏览器解析URL获取协议，主机，端口，path<br>浏览器组装一个HTTP（GET）请求报文<br>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存</p>
<p>DNS递归查询（可能存在负载均衡导致每次IP不一样）<br>打开一个socket与目标IP地址，端口建立TCP链接，<br>三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z<br>TCP链接建立后发送HTTP请求</p>
<p>服务器接受请求并解析，将请求转发到服务程序，<br>如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
<p>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，<br>返回304等对应状态码<br>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作<br>服务器将响应报文通过TCP连接发送回浏览器<br>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，<br>关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</p>
<p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，<br>这些情况处理与2XX不同<br>如果资源可缓存，进行缓存<br>对响应进行解码（例如gzip压缩）</p>
<p>根据资源类型决定如何处理（假设资源为HTML文档）</p>
<p>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，<br>执行js脚本，这些操作没有严格的先后顺序，以下分别解释<br>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树<br>解析过程中遇到图片、样式表、js文件，启动下载<br>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</p>
<p>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，<br>不可见节点包括：<br>1）script,meta这样本身不可见的标签。<br>2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式<br>js解析如下：<br>浏览器创建Document对象并解析HTML，<br>将解析到的元素和文本节点添加到文档中，<br>此时document.readystate为loading</p>
<p>HTML解析器遇到没有async和defer的script时，<br>将他们添加到文档中，然后执行行内或外部脚本。<br>这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。<br>这样就可以用document.write()把文本插入到输入流中。<br>同步脚本经常简单定义函数和注册事件处理程序，<br>他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。<br>脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。<br>异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</p>
<p>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，<br>禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，<br>等这些内容完成载入并且所有异步脚本完成载入和执行，<br>document.readState变为complete,window触发load事件<br>显示页面（HTML解析过程中会逐步显示页面）</p>
<h1 id="浏览器渲染主要流程"><a href="#浏览器渲染主要流程" class="headerlink" title="浏览器渲染主要流程"></a>浏览器渲染主要流程</h1><p>HTML解析出DOM Tree<br>CSS解析出Style Rules<br>将二者关联生成Render Tree<br>Layout 根据Render Tree计算每个节点的信息<br>Painting 根据计算好的信息绘制整个页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Q: 网站性能优化</span><br><span class="line"></span><br><span class="line">[原文](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000013963213#articleHeader0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码层面优化：</p>
<p>一、加载和执行</p>
<pre><code>css方面

将样式表放到页面顶部
不使用CSS表达式
使用link不使用@import
不使用IE的Filter

Javascript方面

将脚本放到页面底部,body标签内底部
将javascript和css从外部引入
压缩javascript和css
删除不需要的脚本
减少DOM访问
合理设计事件监听器


图片方面

优化图片：根据实际颜色需要选择色深、压缩
优化css精灵
合并一些小图片( css sprite )压缩图片
图片转dataUrl
不要在HTML中拉伸图片
保证favicon.ico小并且可缓存
图片编码优化</code></pre>
<p>二、 数据存取<br>    - 尽量使用字面量和局部变量<br>        （局部变量在方法运行过后会自行释放，用完手动置为null或undefined也行），<br>        减少使用对象和数组,</p>
<p>三、 DOM编程**（常见的性能瓶颈）<br>    - 最坏的方式就是在循环中操作或者访问DOM，非常消耗性能。<br>    减少DOM数量<br>    - 遍历dom<br>        querySelectorAll()是获取元素最快的API 返回的是一个NodeList<br>        querySelector() 返回的是element,<br>        querySelectorAll()还有一点就是可以同时获取两类元素</p>
<pre><code>- 重绘和重排都是代价昂贵；尽量减少
    重排何时发生：
    1.添加或删除可见DOM元素
    2.元素位置改变
    3.元素尺寸改变（内外边距、边框厚宽高等）
    4.内容改变 （内容导致尺寸变化的时候）
    5.页面渲染器初始化
    6.浏览器窗口尺寸变化</code></pre>
<p>四、 算法和流程控制<br>    - 循环<br>        (当循环体复杂度为X时，优化方案优先减少循环体的复杂度，<br>        循环体复杂度大于X时，优化方案优先减少迭代次数 )<br>    - 条件语句<br>        当条件较少时 使用if-else更易读，<br>        而当条件较多时if-else性能负担比switch大，易读性也没switch好。<br>        优化if-else的方法是：尽可能的把可能出现的条件放在首位，</p>
<p>五、 字符串和正则表达式<br>    - 字符串<br>        join是比较快的，也是大量字符串拼接的唯一高效方式</p>
<p>六、 快速响应的用户界面<br>    - 浏览器UI线程<br>        浏览器限制JavaScript任务的运行时间，限制两分钟，<br>        可以防止恶意代码不断执行来锁定你的浏览器</p>
<pre><code>    单个JavaScript操作的花费总时间应该小于等于100ms，
    这就意味着在100ms内响应用户的操作，不然就会让用户感受到迟钝感

- 定时器让出时间片断
    使用时间戳计算获得程序运行时间，
    以便快速找到运行时间较长的代码部分进行优化</code></pre>
<p>七、 Ajax<br>    - 数据传输<br>        数据的传输同样影响性能<br>    - 数据格式<br>    - Ajax性能<br>        避免不必要的请求：<br>        使Ajax可缓存：服务端设置HTTP头信息确保响应会被浏览器缓存<br>        客户端讲获取的信息存到本地避免再次请求<br>        （localstorage sessionstorage cookice）<br>        设置HTTP头信息，expiresgaosu告诉浏览器缓存多久<br>        减少HTTP请求，合并css、js、图片资源文件等或使用MXHR<br>        通过次要文件用Ajax获取可缩短页面加载时间</p>
<pre><code>    减小cookie大小
    引入资源的域名不要包含cookie</code></pre>
<p>八、编程实践<br>    - 避免双重求值<br>        eval()、Function慎用，<br>        定时器第一个参数建议函数而不是字符串都能避免字符串双重求值<br>    - 使用对象或者数组直接量<br>    - 避免重复工作<br>        A:延迟加载（懒加载）<br>        B:条件预加载<br>    - 使用JavaScript速度快的部分<br>        A.位操作<br>        B.原生方法，首先原生方法是最快的，而且浏览器会缓存部分原生方法<br>        C.复杂计算时多使用Math对象<br>        D.querySelector和querySelectorAll是查询最快的</p>
<p> 九、 构建并部署高性能JavaScript应用<br>    1.合并多个js文件<br>    2.预处理js文件<br>    3.js压缩<br>    4.js的HTTP压缩<br>    5.缓存js文件<br>    6.处理缓存问题<br>    7.使用内容分发网络（CDN）</p>
<p>移动方面</p>
<pre><code>保证组件小于25k
Pack Components into a Multipart Document

content方面

按需加载资源
非必须组件延迟加载
未来所需组件预加载
    在网站 HTML 中的链接属性上增加
    rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记。

将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
减少iframe数量
不要404

Server方面

使用CDN
减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。
方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
避免重定向：多余的中间访问
用dns-prefetch

&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//mat1.gtimg.com&quot;&gt;

动静分离
使用nginx的反向代理，对静态资源的请求直接nginx处理，或放到CDN
动态请求转发给tomcat处理

添加Expires或者Cache-Control响应头
对组件使用Gzip压缩
    Brotli 是一个比较新的文件压缩算法，目前正变得越来越受欢迎。
配置ETag
Flush Buffer Early
Ajax使用GET进行请求
避免空src的img标签</code></pre>
<p>十、 工具</p>
<pre><code>若是打包的代码尽可能切割成多个 chunk ,减少单一 chunk 过大
HTTP的缓存头使用的合理
减小第三方库的依赖
对于代码应该考虑性能来编写,比如使用 requestAnimationFrame 绘制动画,尽可能减少页面重绘(DOM 改变)
渐进升级,引入 preload 这些预加载资源
看情况用 server worker 来缓存资源(比如移动端打算搞 PWA)
比如从服务端着手:

带宽,域名解析, 多域名解析等
使用负载均衡方案 多节点部署
页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)
渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)
当然,这是这些都是很片面的点到...实际工作中去开展要复杂的多;


使用索引加速数据库查询
页面静态化CMS</code></pre>
<p>多个维度考虑,优化 DOM 绘制时间,资源加载时间,域名解析这些;</p>
<p>要全面的优化一个项目是一个大工程…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 优雅降级和渐进增强</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优雅降级：<br>Web站点在所有新式浏览器中都能正常工作，<br>如果用户使用的是老式浏览器，<br>则代码会检查以确认它们是否能正常工作。<br>针对不同版本的hack为那些无法支持功能的<br>浏览器增加候选方案，<br>使之在旧式浏览器上以某种形式降级体验<br>却不至于完全失效.</p>
<p>渐进增强：<br>从被所有浏览器支持的基本功能开始，<br>逐步地添加那些只有新式浏览器才支持的功能,<br>向页面增加无害于基础浏览器的<br>额外样式和功能的。<br>当浏览器支持时，<br>它们会自动地呈现出来并发挥作用。</p>
<p>保证所有人都能访问页面的基本内容和功能<br>同时为高级浏览器和高带宽用户提供<br>更好的用户体验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># js控制css3动画</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开始事件 AnimationStart<br>结束事件 AnimationEnd<br>重复运动事件 AnimationIteration  每次开始动画迭代都触发animationiteration</p>
<p>W3c标准：animationstart animationiteration animationend<br>Webkit：webkitAnimationStart webkitAnimationIteration webkitAnimationEnd<br>Firefox：animationstart animationiteration animationend<br>Opera：animationstart animationiteration animationend<br>IE10：MSAnimationStart MSAnimationIteration MSAnimationEnd</p>
<p>var e = document.getElementById(“left1”);  </p>
<p>e.addEventListener(“animationend”, function() {<br>    alert(‘css3运动结束！’);<br>});  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Object循环key</span><br><span class="line"></span><br><span class="line">- for...in循环：只遍历对象自身的和继承的可枚举的属性。</span><br><span class="line">    通常用for in来遍历对象的键名</span><br><span class="line">    for in更适合遍历对象，不要使用for in遍历数组。</span><br><span class="line"></span><br><span class="line">for in 循环会把数组其他扩展方法也循环</span><br><span class="line"></span><br><span class="line">- for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</span><br><span class="line"></span><br><span class="line">for-of循环是遍历实现iterator接口的成员</span><br><span class="line"></span><br><span class="line">只要是一个对象部署了Symbol.interator接口，就可以用for...of遍历该对象，同时也可以调用该接口的Symbol.interator方法调用next()方法对对象进行遍历，不同的是for..of是对该对象的值的输出，而next()返回的是对象。</span><br><span class="line"></span><br><span class="line">在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</span><br><span class="line"></span><br><span class="line">- Object.keys()：返回对象自身的所有可枚举的属性的键名。</span><br><span class="line">- JSON.stringify()：只串行化对象自身的可枚举的属性。</span><br><span class="line">- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;for...in循环出的是key，for...of循环出的是value&#x3D;&#x3D;</span><br><span class="line">- &#x3D;&#x3D;for...of不能循环普通的对象，需要通过和Object.keys()搭配使用&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">如果实在想用for...of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组</span><br><span class="line">然后遍历：</span><br><span class="line"></span><br><span class="line">## 结论</span><br><span class="line"></span><br><span class="line">1. 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。</span><br><span class="line"></span><br><span class="line">2. for...in循环出的是key，for...of循环出的是value</span><br><span class="line"></span><br><span class="line">3. 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足</span><br><span class="line"></span><br><span class="line">4. for...of不能循环普通的对象，需要通过和Object.keys()搭配使用</span><br><span class="line"></span><br><span class="line">记忆jueqiao :</span><br><span class="line"></span><br><span class="line">已核对 偶数v</span><br><span class="line"></span><br><span class="line">in h（k）对象  o 数组 value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组<br>然后遍历：</p>
<p>var student={<br>    name:’wujunchuan’,<br>    age:22,<br>    locate:{<br>    country:’china’,<br>    city:’xiamen’,<br>    school:’XMUT’<br>    }<br>}<br>for(var key of Object.keys(student)){<br>    //使用Object.keys()方法获取对象key的数组<br>    console.log(key+”: “+student[key]);<br>}</p>
<p>for in 可以遍历到myObject的原型方法method,<br>如果不想遍历原型方法和属性的话，<br>可以在循环内部判断一下,<br>hasOwnPropery方法可以判断<br>某属性是否是该对象的实例属性</p>
<p>for (var key in myObject) {<br>　　if（myObject.hasOwnProperty(key)){<br>　　　　console.log(key);<br>　　}<br>}</p>
<pre><code></code></pre>

      
    </div>

    
    
    
      


    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">believeZJP</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">662k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:02</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

<script src="/js/local-search.js"></script>






  






</body>
</html>
