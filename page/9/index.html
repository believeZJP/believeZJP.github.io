<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"believezjp.oriht.com","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
<meta property="og:type" content="website">
<meta property="og:title" content="believeZJP">
<meta property="og:url" content="http://believezjp.oriht.com/page/9/index.html">
<meta property="og:site_name" content="believeZJP">
<meta property="og:description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="believeZJP">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://believezjp.oriht.com/page/9/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>believeZJP</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">believeZJP</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长路径</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">believeZJP</p>
  <div class="site-description" itemprop="description">积土成山，风雨兴焉；积水成渊，蛟龙生焉;</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/" class="post-title-link" itemprop="url">ES6新语法积累</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-05 19:48:55" itemprop="dateCreated datePublished" datetime="2018-11-05T19:48:55+08:00">2018-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/es6/" itemprop="url" rel="index"><span itemprop="name">es6</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h1 id="es6强制让一个函数有一个默认值"><a href="#es6强制让一个函数有一个默认值" class="headerlink" title="es6强制让一个函数有一个默认值"></a>es6强制让一个函数有一个默认值</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;cuowu&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p><a target="_blank" rel="noopener" href="http://liubin.org/promises-book/">Promise迷你书</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/" class="post-title-link" itemprop="url">HTTP积累</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-05 19:40:58" itemprop="dateCreated datePublished" datetime="2018-11-05T19:40:58+08:00">2018-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/http/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h2 id="http-方法，每个方法分别什么情况下用"><a href="#http-方法，每个方法分别什么情况下用" class="headerlink" title="http 方法，每个方法分别什么情况下用"></a>http 方法，每个方法分别什么情况下用</h2><p>put和get有什么相同点<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce44e5f4623a">链接</a></p>
<p>trace是用来干嘛的，</p>
<p>options是用来干嘛的</p>
<p>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p>OPTIONS 允许客户端查看服务器的性能。</p>
<p>TRACE 回显服务器收到的请求，主要用于测试或诊断。</p>
<p>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-18 14:38:00" itemprop="dateCreated datePublished" datetime="2018-10-18T14:38:00+08:00">2018-10-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-09-11 16:55:34" itemprop="dateModified" datetime="2020-09-11T16:55:34+08:00">2020-09-11</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome test page.<br>post to github.<br>commit new line.<br>add new line for git test.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/s/" class="post-title-link" itemprop="url">十大经典排序算法总结（JavaScript描述）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-18 14:38:00" itemprop="dateCreated datePublished" datetime="2018-10-18T14:38:00+08:00">2018-10-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-29 19:33:42" itemprop="dateModified" datetime="2020-12-29T19:33:42+08:00">2020-12-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>========================</p>
<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li><p>这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，JavaScript可谓风头无两，已经坐上了头把交椅。</p>
</li>
<li><p>在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（十大排序算法或是和十大排序算法同等难度的），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。</p>
</li>
<li><p>算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。</p>
<p>  <img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="大大"></p>
</li>
</ul>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h3><p><strong>（1）排序的定义：对一序列对象根据某个关键字进行排序；</strong></p>
<p>输入：n个数：a1,a2,a3,…,an 输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。</p>
<p>再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。</p>
<p><strong>（3）对于评述算法优劣术语的说明</strong></p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； <strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p>
<p><strong>内排序</strong>：所有排序操作都在内存中完成； <strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>
<p><strong>时间复杂度</strong>: 一个算法执行所耗费的时间。 <strong>空间复杂度</strong>: 运行完一个程序所需内存的大小。</p>
<p>关于时间空间复杂度的更多了解请戳<a target="_blank" rel="noopener" href="http://blog.csdn.net/booirror/article/details/7707551/">这里</a>，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。</p>
<p><strong>（4）排序算法图片总结(图片来源于网络):</strong></p>
<p>排序对比：</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p><strong>图片名词解释：</strong> n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存</p>
<p>排序分类：</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><blockquote>
<p>好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>&lt;2&gt;.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>&lt;3&gt;.针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>&lt;4&gt;.重复步骤1~3，直到排序完成。</li>
</ul>
<p><strong>JavaScript代码实现：</strong></p>
<pre><code>function bubbleSort(arr) &#123;
    var len = arr.length;
    for (var i = 0; i &lt; len; i++) &#123;
        for (var j = 0; j &lt; len - 1 - i; j++) &#123;
            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<blockquote>
<p>**改进冒泡排序： **设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<p>改进后算法如下:</p>
<pre><code>function bubbleSort2(arr) &#123;
    console.time(&#39;改进后冒泡排序耗时&#39;);
    var i = arr.length-1;  //初始时,最后位置保持不变
    while ( i&gt; 0) &#123;
        var pos= 0; //每趟开始时,无记录交换
        for (var j= 0; j&lt; i; j++)
            if (arr[j]&gt; arr[j+1]) &#123;
                pos= j; //记录交换的位置
                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            &#125;
        i= pos; //为下一趟排序作准备
     &#125;
     console.timeEnd(&#39;改进后冒泡排序耗时&#39;);
     return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<blockquote>
<p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
</blockquote>
<p>改进后的算法实现为:</p>
<pre><code>function bubbleSort3(arr3) &#123;
    var low = 0;
    var high= arr.length-1; //设置变量的初始值
    var tmp,j;
    console.time(&#39;2.改进后冒泡排序耗时&#39;);
    while (low &lt; high) &#123;
        for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者
            if (arr[j]&gt; arr[j+1]) &#123;
                tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            &#125;
        --high;                 //修改high值, 前移一位
        for (j=high; j&gt;low; --j) //反向冒泡,找到最小者
            if (arr[j]&lt;arr[j-1]) &#123;
                tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp;
            &#125;
        ++low;                  //修改low值,后移一位
    &#125;
    console.timeEnd(&#39;2.改进后冒泡排序耗时&#39;);
    return arr3;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<p>三种方法耗时对比：</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<blockquote>
<p>由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~</p>
</blockquote>
<p><strong>冒泡排序动图演示:</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p><strong>(3)算法分析</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
</ul>
<blockquote>
<p>当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….）</p>
</blockquote>
<ul>
<li>最差情况：T(n) = O(n2)</li>
</ul>
<blockquote>
<p>当输入的数据是反序时(卧槽，我直接反序不就完了….)</p>
</blockquote>
<ul>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><blockquote>
<p>表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
</blockquote>
<h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.初始状态：无序区为R[1..n]，有序区为空；</li>
<li>&lt;2&gt;.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>&lt;3&gt;.n-1趟结束，数组有序化了。</li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<pre><code>function selectionSort(arr) &#123;
    var len = arr.length;
    var minIndex, temp;
    console.time(&#39;选择排序耗时&#39;);
    for (var i = 0; i &lt; len - 1; i++) &#123;
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) &#123;
            if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            &#125;
        &#125;
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    &#125;
    console.timeEnd(&#39;选择排序耗时&#39;);
    return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]


复制代码</code></pre>
<p><strong>选择排序动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析"><a href="#3-算法分析" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了…..</p>
</blockquote>
<h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.从第一个元素开始，该元素可以认为已经被排序；</li>
<li>&lt;2&gt;.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>&lt;3&gt;.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>&lt;4&gt;.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>&lt;5&gt;.将新元素插入到该位置后；</li>
<li>&lt;6&gt;.重复步骤2~5。</li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<pre><code>function insertionSort(array) &#123;
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39;) &#123;
        console.time(&#39;插入排序耗时：&#39;);
        for (var i = 1; i &lt; array.length; i++) &#123;
            var key = array[i];
            var j = i - 1;
            while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123;
                array[j + 1] = array[j];
                j--;
            &#125;
            array[j + 1] = key;
        &#125;
        console.timeEnd(&#39;插入排序耗时：&#39;);
        return array;
    &#125; else &#123;
        return &#39;array is not an Array!&#39;;
    &#125;
&#125;

复制代码</code></pre>
<blockquote>
<p><strong>改进插入排序：</strong> 查找插入位置时使用二分查找的方式</p>
</blockquote>
<pre><code>function binaryInsertionSort(array) &#123;
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39;) &#123;
        console.time(&#39;二分插入排序耗时：&#39;);

        for (var i = 1; i &lt; array.length; i++) &#123;
            var key = array[i], left = 0, right = i - 1;
            while (left &lt;= right) &#123;
                var middle = parseInt((left + right) / 2);
                if (key &lt; array[middle]) &#123;
                    right = middle - 1;
                &#125; else &#123;
                    left = middle + 1;
                &#125;
            &#125;
            for (var j = i - 1; j &gt;= left; j--) &#123;
                array[j + 1] = array[j];
            &#125;
            array[left] = key;
        &#125;
        console.timeEnd(&#39;二分插入排序耗时：&#39;);

        return array;
    &#125; else &#123;
        return &#39;array is not an Array!&#39;;
    &#125;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
复制代码</code></pre>
<blockquote>
<p>改进前后对比：</p>
</blockquote>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p><strong>插入排序动图演示:</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-1"><a href="#3-算法分析-1" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h3><blockquote>
<p>1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序</p>
</blockquote>
<h4 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。</p>
</blockquote>
<h4 id="2-算法描述和实现-3"><a href="#2-算法描述和实现-3" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>&lt;1&gt;. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>&lt;2&gt;.按增量序列个数k，对序列进行k 趟排序；</li>
<li>&lt;3&gt;.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>function shellSort(arr) &#123;
    var len = arr.length,
        temp,
        gap = 1;
    console.time(&#39;希尔排序耗时:&#39;);
    while(gap &lt; len/5) &#123;          //动态定义间隔序列
        gap =gap*5+1;
    &#125;
    for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123;
        for (var i = gap; i &lt; len; i++) &#123;
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;
                arr[j+gap] = arr[j];
            &#125;
            arr[j+gap] = temp;
        &#125;
    &#125;
    console.timeEnd(&#39;希尔排序耗时:&#39;);
    return arr;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

复制代码</code></pre>
<p><strong>希尔排序图示（图片来源网络）：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="（3）算法分析"><a href="#（3）算法分析" class="headerlink" title="（3）算法分析"></a>（3）算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<h3 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h4 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p> 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<h4 id="2-算法描述和实现-4"><a href="#2-算法描述和实现-4" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>&lt;2&gt;.对这两个子序列分别采用归并排序；</li>
<li>&lt;3&gt;.将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><strong>Javscript代码实现:</strong></p>
<pre><code>function mergeSort(arr) &#123;  //采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    var result = [];
    console.time(&#39;归并排序耗时&#39;);
    while (left.length &amp;&amp; right.length) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());
    console.timeEnd(&#39;归并排序耗时&#39;);
    return result;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(mergeSort(arr));

复制代码</code></pre>
<p><strong>归并排序动图演示:</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-2"><a href="#3-算法分析-2" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h3><blockquote>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。</p>
</blockquote>
<h4 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h4 id="2-算法描述和实现-5"><a href="#2-算法描述和实现-5" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>&lt;2&gt;.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>&lt;3&gt;.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>/*方法说明：快速排序
@param  array 待排序数组*/
//方法一
function quickSort(array, left, right) &#123;
    console.time(&#39;1.快速排序耗时&#39;);
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39; &amp;&amp; typeof left === &#39;number&#39; &amp;&amp; typeof right === &#39;number&#39;) &#123;
        if (left &lt; right) &#123;
            var x = array[right], i = left - 1, temp;
            for (var j = left; j &lt;= right; j++) &#123;
                if (array[j] &lt;= x) &#123;
                    i++;
                    temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                &#125;
            &#125;
            quickSort(array, left, i - 1);
            quickSort(array, i + 1, right);
        &#125;
        console.timeEnd(&#39;1.快速排序耗时&#39;);
        return array;
    &#125; else &#123;
        return &#39;array is not an Array or left or right is not a number!&#39;;
    &#125;
&#125;

//方法二
var quickSort2 = function(arr) &#123;
    console.time(&#39;2.快速排序耗时&#39;);
&amp;emsp;&amp;emsp;if (arr.length &lt;= 1) &#123; return arr; &#125;
&amp;emsp;&amp;emsp;var pivotIndex = Math.floor(arr.length / 2);
&amp;emsp;&amp;emsp;var pivot = arr.splice(pivotIndex, 1)[0];
&amp;emsp;&amp;emsp;var left = [];
&amp;emsp;&amp;emsp;var right = [];
&amp;emsp;&amp;emsp;for (var i = 0; i &lt; arr.length; i++)&#123;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;if (arr[i] &lt; pivot) &#123;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;left.push(arr[i]);
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&#125; else &#123;
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;right.push(arr[i]);
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&#125;
&amp;emsp;&amp;emsp;&#125;
console.timeEnd(&#39;2.快速排序耗时&#39;);
&amp;emsp;&amp;emsp;return quickSort2(left).concat([pivot], quickSort2(right));
&#125;;

var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]


复制代码</code></pre>
<p><strong>快速排序动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="快速排序"></p>
<h4 id="3-算法分析-3"><a href="#3-算法分析-3" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
</blockquote>
<h4 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<h4 id="2-算法描述和实现-6"><a href="#2-算法描述和实现-6" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>&lt;2&gt;.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>&lt;3&gt;.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>/*方法说明：堆排序
@param  array 待排序数组*/
function heapSort(array) &#123;
    console.time(&#39;堆排序耗时&#39;);
    if (Object.prototype.toString.call(array).slice(8, -1) === &#39;Array&#39;) &#123;
        //建堆
        var heapSize = array.length, temp;
        for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123;
            heapify(array, i, heapSize);
        &#125;

        //堆排序
        for (var j = heapSize - 1; j &gt;= 1; j--) &#123;
            temp = array[0];
            array[0] = array[j];
            array[j] = temp;
            heapify(array, 0, --heapSize);
        &#125;
        console.timeEnd(&#39;堆排序耗时&#39;);
        return array;
    &#125; else &#123;
        return &#39;array is not an Array!&#39;;
    &#125;
&#125;
/*方法说明：维护堆的性质
@param  arr 数组
@param  x   数组下标
@param  len 堆大小*/
function heapify(arr, x, len) &#123;
    if (Object.prototype.toString.call(arr).slice(8, -1) === &#39;Array&#39; &amp;&amp; typeof x === &#39;number&#39;) &#123;
        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;
        if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;
            largest = l;
        &#125;
        if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;
            largest = r;
        &#125;
        if (largest != x) &#123;
            temp = arr[x];
            arr[x] = arr[largest];
            arr[largest] = temp;
            heapify(arr, largest, len);
        &#125;
    &#125; else &#123;
        return &#39;arr is not an Array or x is not a number!&#39;;
    &#125;
&#125;
var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];
console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]

复制代码</code></pre>
<p><strong>堆排序动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-4"><a href="#3-算法分析-4" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<h4 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<h4 id="2-算法描述和实现-7"><a href="#2-算法描述和实现-7" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;. 找出待排序的数组中最大和最小的元素；</li>
<li>&lt;2&gt;. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>&lt;3&gt;. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>&lt;4&gt;. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>function countingSort(array) &#123;
    var len = array.length,
        B = [],
        C = [],
        min = max = array[0];
    console.time(&#39;计数排序耗时&#39;);
    for (var i = 0; i &lt; len; i++) &#123;
        min = min &lt;= array[i] ? min : array[i];
        max = max &gt;= array[i] ? max : array[i];
        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;
    &#125;
    for (var j = min; j &lt; max; j++) &#123;
        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);
    &#125;
    for (var k = len - 1; k &gt;= 0; k--) &#123;
        B[C[array[k]] - 1] = array[k];
        C[array[k]]--;
    &#125;
    console.timeEnd(&#39;计数排序耗时&#39;);
    return B;
&#125;
var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];
console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]

复制代码</code></pre>
<p><strong>JavaScript动图演示：</strong>、</p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-5"><a href="#3-算法分析-5" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n+k)</li>
</ul>
<h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
</blockquote>
<h4 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
</blockquote>
<h4 id="2-算法描述和实现-8"><a href="#2-算法描述和实现-8" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.设置一个定量的数组当作空桶；</li>
<li>&lt;2&gt;.遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>&lt;3&gt;.对每个不是空的桶进行排序；</li>
<li>&lt;4&gt;.从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<p><strong>Javascript代码实现:</strong></p>
<pre><code>/*方法说明：桶排序
@param  array 数组
@param  num   桶的数量*/
function bucketSort(array, num) &#123;
    if (array.length &lt;= 1) &#123;
        return array;
    &#125;
    var len = array.length, buckets = [], result = [], min = max = array[0], regex = &#39;/^[1-9]+[0-9]*$/&#39;, space, n = 0;
    num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10);
    console.time(&#39;桶排序耗时&#39;);
    for (var i = 1; i &lt; len; i++) &#123;
        min = min &lt;= array[i] ? min : array[i];
        max = max &gt;= array[i] ? max : array[i];
    &#125;
    space = (max - min + 1) / num;
    for (var j = 0; j &lt; len; j++) &#123;
        var index = Math.floor((array[j] - min) / space);
        if (buckets[index]) &#123;   //  非空桶，插入排序
            var k = buckets[index].length - 1;
            while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123;
                buckets[index][k + 1] = buckets[index][k];
                k--;
            &#125;
            buckets[index][k + 1] = array[j];
        &#125; else &#123;    //空桶，初始化
            buckets[index] = [];
            buckets[index].push(array[j]);
        &#125;
    &#125;
    while (n &lt; num) &#123;
        result = result.concat(buckets[n]);
        n++;
    &#125;
    console.timeEnd(&#39;桶排序耗时&#39;);
    return result;
&#125;
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

复制代码</code></pre>
<p><strong>桶排序图示（图片来源网络）：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<p>关于桶排序<a target="_blank" rel="noopener" href="http://www.cnblogs.com/lonelyxmas/p/3561938.html">更多</a></p>
<h4 id="3-算法分析-6"><a href="#3-算法分析-6" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><blockquote>
<p> 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<ul>
<li>最佳情况：T(n) = O(n+k)</li>
<li>最差情况：T(n) = O(n+k)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
</blockquote>
<h4 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h4 id="2-算法描述和实现-9"><a href="#2-算法描述和实现-9" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p>
<ul>
<li>&lt;1&gt;.取得数组中的最大数，并取得位数；</li>
<li>&lt;2&gt;.arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>&lt;3&gt;.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<p><strong>Javascript代码实现：</strong></p>
<pre><code>/**
 * 基数排序适用于：
 *  (1)数据范围较小，建议在小于1000
 *  (2)每个数值都要大于等于0
 * @author xiazdong
 * @param  arr 待排序数组
 * @param  maxDigit 最大位数
 */
//LSD Radix Sort

function radixSort(arr, maxDigit) &#123;
    var mod = 10;
    var dev = 1;
    var counter = [];
    console.time(&#39;基数排序耗时&#39;);
    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;
        for(var j = 0; j &lt; arr.length; j++) &#123;
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]== null) &#123;
                counter[bucket] = [];
            &#125;
            counter[bucket].push(arr[j]);
        &#125;
        var pos = 0;
        for(var j = 0; j &lt; counter.length; j++) &#123;
            var value = null;
            if(counter[j]!=null) &#123;
                while ((value = counter[j].shift()) != null) &#123;
                      arr[pos++] = value;
                &#125;
          &#125;
        &#125;
    &#125;
    console.timeEnd(&#39;基数排序耗时&#39;);
    return arr;
&#125;
var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]

复制代码</code></pre>
<p><strong>基数排序LSD动图演示：</strong></p>
<p><img src="https://juejin.cn/post/data:image/svg+xml;utf8" alt="这里写图片描述"></p>
<h4 id="3-算法分析-7"><a href="#3-算法分析-7" class="headerlink" title="(3)算法分析"></a>(3)算法分析</h4><ul>
<li>最佳情况：T(n) = O(n * k)</li>
<li>最差情况：T(n) = O(n * k)</li>
<li>平均情况：T(n) = O(n * k)</li>
</ul>
<p>基数排序有两种方法：</p>
<ul>
<li>MSD 从高位开始进行排序</li>
<li>LSD 从低位开始进行排序</li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<p>![<a target="_blank" rel="noopener" href="https://user-gold-cdn.xitu.io/2020/2/3/1700919fb9a285de?w=450&amp;h=359&amp;f=png&amp;s=66765%5D">https://user-gold-cdn.xitu.io/2020/2/3/1700919fb9a285de?w=450&amp;h=359&amp;f=png&amp;s=66765]</a>(<a target="_blank" rel="noopener" href="https://juejin.cn/post/data:image/svg+xml;utf8">https://juejin.cn/post/data:image/svg+xml;utf8</a><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="450" height="359"></svg>)</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。</p>
</blockquote>
<p>.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/hexo%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/hexo%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">搭建Hexo博客笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-10 18:05:59" itemprop="dateCreated datePublished" datetime="2018-10-10T18:05:59+08:00">2018-10-10</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[toc]</p>
<h2 id="hexo-搭建"><a href="#hexo-搭建" class="headerlink" title="hexo 搭建"></a>hexo 搭建</h2><ol>
<li><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">HEXO 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">文档</a></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>node.js git 已经安装，跳过</li>
<li>hexo 安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<!-- more  -->
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不能在文章中有&#123;&#123;&#125;&#125;,否则hexo无法见解析，会报错</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>访问 localhost:4000 即可看到网页</p>
<p>在 sources/posts 文件夹下新建一个 test.md 文件，再次访问页面，可看到新加的文章。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/hexo%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/linux%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/linux%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Linux学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-08 20:31:07" itemprop="dateCreated datePublished" datetime="2018-10-08T20:31:07+08:00">2018-10-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-03-22 20:31:07" itemprop="dateModified" datetime="2019-03-22T20:31:07+08:00">2019-03-22</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>window远程连接工具：<br>secure CRT<br>配置：<br>选项-会话选项-仿真<br>    终端：x-term  ansi颜色<br>    外观：颜色方案：黄黑<br>        光标 竖线<br>    编码：回话选项-外观-字符编码-UTF-8</p>
<h2 id="git-定时任务crontab"><a href="#git-定时任务crontab" class="headerlink" title="git 定时任务crontab"></a>git 定时任务crontab</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">链接</a></p>
<h2 id="在centos执行git-pull报错"><a href="#在centos执行git-pull报错" class="headerlink" title="在centos执行git pull报错"></a>在centos执行git pull报错</h2><p>Peer reports incompatible or unsupported protocol version.</p>
<p>解决办法：</p>
<p>yum update -y nss curl libcurl</p>
<p>执行后，可以正常运行。</p>
<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="==++文件与目录管理++=="></a>==++文件与目录管理++==</h2><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><p>mkdir</p>
<p>eg:mkdir test</p>
<p>mkdir -p test/123/abc</p>
<p>-p 递归创建目录，即使上级目录不存在。<br>还有一种情况就是如果你想要创建的目录存在的话，会提示报错，然后你加上-p参数后，就不会报错了。</p>
<h3 id="命令详情"><a href="#命令详情" class="headerlink" title="命令详情"></a>命令详情</h3><p> man rm,<br> man ls</p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>cp</p>
<p>eg: cp a b</p>
<p>cp copy的简写，即拷贝。格式为 cp [选项] [ 来源文件 ] [目的文件] ，例如我想把test1 拷贝成test2 ，这样即可 cp test1 test2，</p>
<p>-d 这里涉及到一个“连接”的概念。连接分为软连接和硬连接</p>
<p>如果不加这个-d 则拷贝软连接时会把软连接的目标文件拷贝过去，而加上后，其实只是拷贝了一个连接文件（即快捷方式）。</p>
<ul>
<li><p>-r 如果你要拷贝一个目录，必须要加-r选项，否则你是拷贝不了目录的。 omitting directory ‘d’</p>
</li>
<li><p>-i 如果遇到一个存在的文件，会问是否覆盖。</p>
</li>
<li><p>-u 该选项仅当目标文件存在时才会生效，如果源文件比目标文件新才会拷贝，否则不做任何动作</p>
</li>
</ul>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>mv 移动的意思，是move的简写。格式为 mv [ 选项 ] [源文件] [目标文件]。</p>
<ul>
<li><p>-i 和cp的-i 一样，当目标文件存在时会问用户是否要覆盖。</p>
</li>
<li><p>-u 和上边cp 命令的-u选项一个作用，当目标文件存在时才会生效，如果源文件比目标文件新才会移动，否则不做任何动作。</p>
</li>
</ul>
<p>-</p>
<p>windows下的重命名，在linux下用mv就可以搞定。</p>
<h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p> rm -rf</p>
<p> eg:rm -rf testCLI</p>
<p>rmdir 只能删除目录但不能删除文件，要想删除一个文件，则要用rm命令了。</p>
<p>-f 强制的意思，如果不加这个选项，当删除一个不存在的文件时会报错。</p>
<p>-i 这个选项的作用是，当用户删除一个文件时会提示用户是否真的删除。</p>
<p>-r 当删除目录时，加该选项，如果不加这个选项会报错。rm是可以删除不为空的目录的。</p>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>touch a</p>
<blockquote>
<p>a.txt 可以创建一个文件<br>a也是一个文件<br>vi a</p>
</blockquote>
<p>vi a /vim a 可以查看文件内容</p>
<p>输入i，进入编辑模式</p>
<p>按esc，退出编辑模式</p>
<p>输入:wq退出查看文件</p>
<h2 id="进入linux的主目录"><a href="#进入linux的主目录" class="headerlink" title="进入linux的主目录"></a><strong>进入linux的主目录</strong></h2><p>cd /home</p>
<p>pwd 这个命令打印出当前所在目录<br>./ 指的是当前目录</p>
<p>../ 指的是当前目录的上一级目录。<br>cd wwwroot/<br>ls</p>
<blockquote>
<p>绝对路径：路径的写法一定由根目录”/”写起，例如/usr/local/mysql 这就是绝对路径。</p>
</blockquote>
<p>相对路径：路径的写法不是由根目录”/”写起，例如，首先用户进入到/ 然后再进入到 home ，命令为 cd /home 然后 cd test 此时用户所在的路径为 /home/test 。第一个cd命令后跟 /home 第二个 cd 命令后跟 test ，并没有斜杠，这个test是相对于/home 目录来讲的，所以叫做相对路径。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>echo 变量<br>echo ‘abc’&gt;111 将字符输出到一个文件中<br>大于号”&gt;” 在linux中这叫做重定向，即把前面产生的输出写入到后面的文件中。<br>”&gt;&gt;”是追加的意思，而用”&gt;”，如果文件中有内容则会删除文件中内容，而”&gt;&gt;”则不会。</p>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><ul>
<li><p>cat 比较常用的一个命令，即查看一个文件的内容并显示在屏幕上<br>  -n 查看文件时，把行号也显示到屏幕上。<br>  -A 显示所有东西出来，包括特殊字符</p>
</li>
<li><p>tac 其实是cat的反写，同样的功能也是反向打印文件的内容到屏幕上。</p>
</li>
<li><p>more也是用来查看一个文件的内容。当文件内容太多，一屏幕不能占下，而你用cat肯定是看不前面的内容的，那么使用more就可以解决这个问题了。当看完一屏后按<strong>空格键</strong>继续看下一屏。但看完所有内容后就会退出。如果你想提前退出，只需按q键即可。</p>
</li>
<li><p>less作用跟more一样，但比more好在可以上翻，下翻。空格键同样可以翻页，而<strong>按”j”键可以向下移动</strong>（按一下就向下移动一行）<strong>，按”k”键向上移动</strong>。在使用more和less查看某个文件时，你可以按一下”/” 键，然后输入一个word回车，这样就可以查找这个word了。如果是多个该word可以按”n”键显示下一个。另外你也可以不按”/”而是按”?”后边同样跟word来搜索这个word，唯一不同的是，<strong>”/”是在当前行向下搜索，而”?”是在当前行向上搜索</strong>。</p>
<p>  <strong>按n向上，按N向下显示</strong>–老罗</p>
</li>
<li><p>vim</p>
</li>
<li><p>head head后直接跟文件名，则显示文件的前十行。如果加 –n 选项则显示文件前n行。</p>
</li>
<li><p>tail 和head一样，后面直接跟文件名，则显示文件最后十行。如果加-n 选项则显示文件最后n行。</p>
</li>
<li><p>-f <strong>动态显示文件的最后十行</strong>，如果文件是不断增加的，则用-f 选项。如：tail -f /var/log/messages</p>
</li>
</ul>
<p>-</p>
<h3 id="实时查看文件内容"><a href="#实时查看文件内容" class="headerlink" title="实时查看文件内容"></a>实时查看文件内容</h3><ul>
<li>tail -f catalina.out  ！！！！！！！！</li>
</ul>
<h2 id="文件的所属主以及所属组"><a href="#文件的所属主以及所属组" class="headerlink" title="文件的所属主以及所属组"></a>文件的所属主以及所属组</h2><p>所属组”就派上用场了。即，创建一个群组users，让user0和user1同属于users组，然后建立一个文件test2，且其所属组为users，那么user0和user1都可以访问test2文件。</p>
<h2 id="查看文件列表list"><a href="#查看文件列表list" class="headerlink" title="查看文件列表list"></a>查看文件列表list</h2><p>ls<br>ls -l<br>-a 全部的档案都列出，包括隐藏的。</p>
<p>-l 详细列出文件的属性信息，包括大小、创建日期、所属主所属组等等。ll 这个命令等同于ls –l 。</p>
<p>-d 后边跟目录，如果不加这个选项则列出目录下的文件，加上后只列车目录本身。</p>
<h2 id="linux-文件属性"><a href="#linux-文件属性" class="headerlink" title="linux 文件属性"></a>linux 文件属性</h2><p>用ls –l 查看当前目录下的文件时，共显示了9列内容（用空格划分列），都代表了什么含义呢？</p>
<p>第1列，包含的东西有该文件类型和所属主、所属组以及其他用户对该文件的权限。第一列共10位。其中第一位用来描述该文件的类型。上例中，我们看到的类型有”d”, “-“ ，其实除了这两种外还有”l”, “b”, “c”,”s”等。</p>
<p>d 表示该文件为目录；</p>
<ul>
<li>表示该文件为普通文件；</li>
</ul>
<p>l 表示该文件为连接文件（linux file），上边提到的软连接即为该类型；</p>
<p>b 表示该文件为块设备文件，比如磁盘分区</p>
<p>c 表示该文件为串行端口设备，例如键盘、鼠标。</p>
<p>s 表示该文件为套接字文件（socket），用于进程间通信。</p>
<p>后边的9位，每三个为一组。均为rwx 三个参数的组合。其中r 代表可读，w代表可写，x代表可执行。前三位为所属主（user）的权限，中间三位为所属组（group）的权限，最后三位为其他非本群组（others）的权限。下面拿一个具体的例子来述说一下。</p>
<p>一个文件的属性为-rwxr-xr– ，它代表的意思是，该文件为普通文件，文件拥有者可读可写可执行，文件所属组对其可读不可写可执行，其他用户对其只可读。</p>
<p>对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个目录必须要有x权限才能打开并查看该目录。例如一个目录的属性为 drwxr–r– 其所属主为root，那么除了root外的其他用户是不能打开这个目录的。</p>
<p>第2列，表示为连接占用的节点（inode），若为目录时，通常与该目录地下还有多少目录有关系，关于连接（link）在以后章节详细介绍。</p>
<p>第3列，表示该文件的所属主。</p>
<p>第4列，表示该文件的所属组。</p>
<p>第5列，表示该文件的大小。</p>
<p>第6列、第7列和第8列为该文件的创建日期或者最近的修改日期，分别为月份日期以及时间。</p>
<p>第9列，文件名。如果前面有一个. 则表示该文件为隐藏文件。</p>
<h2 id="更改文件的权限"><a href="#更改文件的权限" class="headerlink" title="更改文件的权限"></a>更改文件的权限</h2><p>==？？？太多了？？？以后再学==</p>
<h2 id="在-linux-下搜索一个文件"><a href="#在-linux-下搜索一个文件" class="headerlink" title="在 linux 下搜索一个文件"></a>在 linux 下搜索一个文件</h2><ul>
<li><p>which 用来查找可执行文件的绝对路径</p>
<p>  which只能用来查找PATH环境变量中出现的路径下的可执行文件。不知道某个命令的绝对路径，which一下就知道了。</p>
</li>
<li><p>whereis 通过预先生成的一个文件列表库去查找跟给出的文件名相关的文件。</p>
<p>  语法： whereis [-bmsu] [文件名称]</p>
<p>  -b：只找binary 文件</p>
<p>  -m：只找在说明文件manual路径下的文件</p>
<p>  -s：只找source来源文件</p>
<p>  -u：没有说明档的文件</p>
</li>
<li><p>locate 类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里。后边直接跟文件名。</p>
</li>
<li><p><strong>find</strong> 用的最多，务必要熟悉。<br>  语法： find [路径] [参数] 下面介绍几个笔者经常用的参数</p>
<p>  -atime +n ：访问或执行时间大于n天的文件</p>
<p>  -ctime +n ：写入、更改inode属性（例如更改所有者、权限或者连接）时间大于n天的文件</p>
<p>  -mtime +n ：写入时间大于n天的文件</p>
<p>  -name filename <strong>直接查找该文件名的文件，这个使用最多了。</strong></p>
<p>  -type type ：通过文件类型查找。type 包含了 f, b, c, d, l, s 等等。后续的内容还会介绍文件类型的。</p>
</li>
</ul>
<p>你对这三个time是不是有些晕了，那笔者就先给你介绍一下这三个time属性。</p>
<p>文件的 Access time，atime 是在读取文件或者执行文件时更改的。文件的 Modified time，mtime 是在写入文件时随文件内容的更改而更改的。<br>文件的 Create time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。<br>因此，更改文件的内容即会更改 mtime 和 ctime，但是文件的 ctime 可能会在 mtime 未发生任何变化时更改，例如，更改了文件的权限，但是文件内容没有变化。 如何获得一个文件的atime mtime 以及ctime ？</p>
<p>ls -l 命令可用来列出文件的 atime、ctime 和 mtime。</p>
<p>ls -lc filename         列出文件的 ctime</p>
<p>ls -lu filename         列出文件的 atime</p>
<p>ls -l filename          列出文件的 mtime</p>
<p>atime不一定在访问文件之后被修改，因为：<br>使用ext3文件系统的时候，如果在mount的时候使用了noatime参数那么就不会更新atime的信息。而这是加了 noatime 取消了, 不代表真实情況。<br>反正, 這三個 time stamp 都放在 inode 中。若 mtime, atime 修改inode 就一定會改, 既然 inode 改了, 那 ctime 也就跟著要改了。</p>
<h2 id="linux-文件类型"><a href="#linux-文件类型" class="headerlink" title="linux 文件类型"></a>linux 文件类型</h2><p>1）正规文件（regular file）：就是一般类型的文件，当用ls –l 查看某个目录时，第一个属性为”-“的文件就是正规文件，或者叫普通文件。正规文件又可分成纯文字文件（ascii）和二进制文件（binary）。纯文本文件是可以通过cat, more, less等工具直接查看内容的，而二进制文件并不能。例如我们用的命令/bin/ls 这就是一个二进制文件。</p>
<p>2）目录（directory）即文件夹,ls –l 查看第一个属性为”d”。</p>
<p>3）连接档（link）：ls –l 查看第一个属性为 “l”，类似windows下的快捷方式。</p>
<p>4）设备档（device）：与系统周边相关的一些档案，通常都集中在 /dev 这个目录之下！通常又分为两种：<br>    区块 (block) 设备档：说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的档案啦！第一个属性为 “ b “；<br>    字符 (character) 设备档：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为 “ c “。</p>
<h3 id="linux-文件后缀名"><a href="#linux-文件后缀名" class="headerlink" title="linux 文件后缀名"></a>linux 文件后缀名</h3><p>1.sh代表它是一个shell script<br>2.tar.gz 代表它是一个压缩包，<br>3.my.cnf 代表它是一个配置文件，<br>4.test.zip 代表它是一个压缩文件。<br>早期Unix系统文件名最多允许14个字符，而新的Unix或者linux系统中，文件名最长可以到达 256 个字符！</p>
<h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩 解压缩"></a>压缩 解压缩</h2><p>tar</p>
<p>  解包：tar zxvf filename.tar</p>
<p>  打包：tar czvf filename.tar dirname</p>
<p>zip命令</p>
<p>解压：unzip filename.zip</p>
<p>压缩：zip filename.zip dirname</p>
<h2 id="ln-建立连接档"><a href="#ln-建立连接档" class="headerlink" title="ln 建立连接档"></a>ln 建立连接档</h2><p>ln 语法： ln [-s] [来源文件] [目的文件]<br>ln 常用的选项就一个-s ，如果不加就是建立硬连接，加上就建立软连接。</p>
<p>Hard Link 的限制太多了，包括无法做目录的 link ，所以在用途上面是比较受限的！反而是 Symbolic Link 的使用方向较广！<br>在建立硬连接前后，空间大小不改变。<br>不能创建目录的硬连接。<br>目录是可以软连接的。<br>删除软连接对源文件没有任何影响。</p>
<h2 id="环境变量-PATH"><a href="#环境变量-PATH" class="headerlink" title="环境变量 PATH"></a>环境变量 PATH</h2><p>有两个方法。</p>
<p>一种方法是直接将 /root 的路径加入 PATH 当中！如何增加？可以使用： 　</p>
<p>PATH=”$PATH”:/root</p>
<p>另一种方式则是使用完整档名，亦即直接使用相对或绝对路径来执行，例如：</p>
<p>/root/ls</p>
<p>./ls</p>
<p>====</p>
<h3 id="vim查看版本"><a href="#vim查看版本" class="headerlink" title="vim查看版本"></a>vim查看版本</h3><p>vim</p>
<h4 id="设置vim编码"><a href="#设置vim编码" class="headerlink" title="设置vim编码"></a>设置vim编码</h4><p>vim ~/.vimrc</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="vim-编辑"><a href="#vim-编辑" class="headerlink" title="vim 编辑"></a>vim 编辑</h3><p> 按i ,进入编辑模式，</p>
<p> 编辑完成后，按esc退出编辑模式</p>
<h4 id="退出保存"><a href="#退出保存" class="headerlink" title="退出保存"></a>退出保存</h4><p> :wq</p>
<h4 id="退出不保存"><a href="#退出不保存" class="headerlink" title="退出不保存"></a>退出不保存</h4><p> :q<br>会提示: No write since last change (add ! to override)<br>再输入一次</p>
<p>:q!<br>即可</p>
<p>将以下复制到其中</p>
<p>syntax on<br>set nu!<br>set encoding=utf-8<br>set fenc=utf-8<br>set fileencodings=ucs-bom,utf-8,cp936,gb2312,gb18030</p>
<h4 id="查看系统的编码"><a href="#查看系统的编码" class="headerlink" title="查看系统的编码"></a>查看系统的编码</h4><p>echo $LANG</p>
<h2 id="乱码解决方案"><a href="#乱码解决方案" class="headerlink" title="乱码解决方案"></a>乱码解决方案</h2><ol>
<li>系统编码</li>
<li>vim的编码</li>
<li>连接服务器的终端。<ol>
<li>SecureCRT设置字条编码<br>Option–Session Option–Appearance<br>设置字符编码</li>
</ol>
</li>
</ol>
<h2 id="命令行远程登录服务器"><a href="#命令行远程登录服务器" class="headerlink" title="命令行远程登录服务器"></a>命令行远程登录服务器</h2><p>ssh <a href="mailto:&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#x31;&#x2e;&#50;&#53;">&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#x31;&#x2e;&#50;&#53;</a><br>    用户名@ip</p>
<h2 id="服务器上安装公钥"><a href="#服务器上安装公钥" class="headerlink" title="服务器上安装公钥"></a>服务器上安装公钥</h2><p>键入以下命令，在服务器上安装公钥：</p>
<p>[root@host ~]$ cd .ssh</p>
<p>[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</p>
<p>将本地的key复制到authorized_keys文件中</p>
<h3 id="从gitbash中获ssh-key"><a href="#从gitbash中获ssh-key" class="headerlink" title="从gitbash中获ssh key"></a>从gitbash中获ssh key</h3><p>  clip &lt; ~/.ssh/id_rsa.pub</p>
<p> ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOmNk1rDPVPv+DTpe/ynM9dLDj/FjG/3xkAvjz8EoxSM/QBXNLj69m0SXA4jI6LOIwuS3Pdn011qWGa14zHPDI0wY9cGzlC+AvcuAZ0s+ndppAVk5PktYM0zCfBhlpLyHCgCVNxDxv1shd1A+gG3Lbi+tJ75oOnvJ5uSWC6x6wJgwJy/zUdQHTA3od4Mfkbz/6hr1sWqnCJE3r4H9Na6XtYMbjyl+O+JnePxH4PDwT/0MVxPpojyEqAv/FE9Gb7WjqmLsT5TWEoRhb4V0pm75moh6QObgqQ+RfJLS6Cz+NIvep980qVrYaRQGQG+7bEwy3fNDZlSGXRUALgELceVP/ HP@HP-PC</p>
<h2 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h2><p> uname -r</p>
<h2 id="查看系统"><a href="#查看系统" class="headerlink" title="查看系统"></a>查看系统</h2><p>uname</p>
<h2 id="查看当前正在进行的进程"><a href="#查看当前正在进行的进程" class="headerlink" title="查看当前正在进行的进程"></a>查看当前正在进行的进程</h2><p> jobs</p>
<h2 id="启一个服务，在后台执行，并将日志输出到log"><a href="#启一个服务，在后台执行，并将日志输出到log" class="headerlink" title="启一个服务，在后台执行，并将日志输出到log"></a>启一个服务，在后台执行，并将日志输出到log</h2><p> node . &gt;log 2&gt;&amp;1 &amp;</p>
<p> tail -f log</p>
<h2 id="查找某个进程-eg-node"><a href="#查找某个进程-eg-node" class="headerlink" title="查找某个进程(eg:node)"></a>查找某个进程(eg:node)</h2><p> ps -ef|grep node</p>
<h2 id="在历史命令中查找某个命令"><a href="#在历史命令中查找某个命令" class="headerlink" title="在历史命令中查找某个命令"></a>在历史命令中查找某个命令</h2><p> history|grep cd</p>
<h2 id="写了脚本以后执行一个脚本"><a href="#写了脚本以后执行一个脚本" class="headerlink" title="写了脚本以后执行一个脚本"></a>写了脚本以后执行一个脚本</h2><p>./control.sh</p>
<h2 id="linux-查找文件"><a href="#linux-查找文件" class="headerlink" title="linux 查找文件"></a>linux 查找文件</h2><p>find / -name nginx.conf</p>
<p>find / -name php.ini</p>
<p>find / -name my.cnf</p>
<p>find / -name httpd.conf</p>
<h2 id="php-相关"><a href="#php-相关" class="headerlink" title="php 相关"></a>php 相关</h2><p> 查看php运行目录命令：<br>which php</p>
<p>which 用来查找一个命令的绝对路径</p>
<p>/usr/bin/php<br>查看php-fpm进程数：</p>
<p>ps aux | grep -c php-fpm</p>
<p>查看运行内存<br>/usr/bin/php  -i|grep mem</p>
<p>关闭PHP</p>
<p>killall php-fpm</p>
<p>php重启</p>
<p>/usr/local/php/sbin/php-fpm &amp;</p>
<h2 id="php-配置"><a href="#php-配置" class="headerlink" title="php 配置"></a>php 配置</h2><ol>
<li>端口 httpd.conf listen 80</li>
</ol>
<p>2.</p>
<h2 id="查看linux-IP"><a href="#查看linux-IP" class="headerlink" title="查看linux IP"></a>查看linux IP</h2><h3 id="公网IP"><a href="#公网IP" class="headerlink" title="公网IP"></a>公网IP</h3><p>curl members.3322.org/dyndns/getip</p>
<p>47.94.93.83</p>
<h3 id="内网IP"><a href="#内网IP" class="headerlink" title="内网IP"></a>内网IP</h3><p>ifconfig</p>
<p>inet addr:192.168.42.128</p>
<h2 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h2><p>启动：/usr/local/nginx/sbin/nginx</p>
<p>service nginx start<br>关闭：/usr/local/nginx/sbin/nginx  -s stop</p>
<p>service nginx stop</p>
<p>重启：/usr/local/nginx/sbin/nginx -s  reload</p>
<p>查看nginx状态<br> service nginx status</p>
<p>查看当前nginx目录<br>ps -ef | grep nginx<br>可以在conf目录下的nginx.conf中找到对应的配置。</p>
<p>查看一个服务是否已经启动：</p>
<p>ps -A | grep nginx</p>
<p>如果返回结果的话，说明有nginx在运行，服务已经启动</p>
<p>nginx -V 查看nginx安装目录</p>
<p>cd /usr/local/etc/nginx 里有nginx.conf</p>
<p>sudo nginx -s reload<br>Sudo nginx -s stop</p>
<p>openresty/nginx/coupon</p>
<p>./sbin/nginx -s reload</p>
<p>Nginx 命令<br>service nginx stop/start/status/reload</p>
<p>2、查看nginx.conf配置文件目录</p>
<p>输入命令</p>
<h3 id="nginx-t"><a href="#nginx-t" class="headerlink" title="nginx -t"></a>nginx -t</h3><p>返回结果包含配置文件目录<br>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</p>
<p>nginx: configuration file /etc/nginx/nginx.conf test is successful</p>
<p>检查下80端口是否被其他进程占用了。<br>lsof -i:80</p>
<h3 id="Nginx-配置实现CORS"><a href="#Nginx-配置实现CORS" class="headerlink" title="Nginx 配置实现CORS"></a>Nginx 配置实现CORS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">location ^~ &#x2F;api&#x2F;v1 &#123;</span><br><span class="line"></span><br><span class="line"> add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, PUT, DELETE, OPTIONS&#39;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type    &#39;;</span><br><span class="line"> add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line"> if ($request_method &#x3D; &#39;OPTIONS&#39;) &#123;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, PUT, DELETE, OPTIONS&#39;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type    &#39;;</span><br><span class="line">  add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">  add_header &#39;Access-Control-Max-Age&#39; 1728000; # 20 天</span><br><span class="line">  add_header &#39;Content-Type&#39; &#39;text&#x2F;html charset&#x3D;UTF-8&#39;;</span><br><span class="line">  add_header &#39;Content-Length&#39; 0;</span><br><span class="line">  return 200;</span><br><span class="line"> &#125;</span><br><span class="line">    # 这下面是要被代理的后端服务器，它们就不需要修改代码来支持跨域了</span><br><span class="line"> proxy_pass http:&#x2F;&#x2F;127.0.0.1:8085;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> proxy_redirect off;</span><br><span class="line"> proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"> proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"> proxy_connect_timeout 60;</span><br><span class="line"> proxy_read_timeout 60;</span><br><span class="line"> proxy_send_timeout 60;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="telnet-80-d端口ping不通"><a href="#telnet-80-d端口ping不通" class="headerlink" title="telnet 80 d端口ping不通"></a>telnet 80 d端口ping不通</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &lt;http://127.0.0.1&gt;</span><br><span class="line">curl http:oriht.com</span><br></pre></td></tr></table></figure>

<p>查看实例安全组规则  端口范围是否有80端口</p>
<p>允许自定义 TCP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">80&#x2F;80 地址段访问</span><br><span class="line">0.0.0.0&#x2F;0</span><br><span class="line">-</span><br><span class="line"></span><br><span class="line">1 2017-09-25 11:03:54</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果新配置nginx一直403 禁止访问的话</p>
<p>修改/etc/selinux/config<br>将SELINUX=enforcing 改为<br>SELINUX=disabled</p>
<h2 id="跟着吴博学linux"><a href="#跟着吴博学linux" class="headerlink" title="跟着吴博学linux"></a>跟着吴博学linux</h2><p>ls -lh</p>
<p>sudo sh updata_<a target="_blank" rel="noopener" href="http://www.sh/">www.sh</a></p>
<p>less update_<a target="_blank" rel="noopener" href="http://www.sh/">www.sh</a></p>
<p>ls -l</p>
<p>sudo su root</p>
<p>git branch -r</p>
<h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="!/bin/bash"></a>!/bin/bash</h2><p>rm www-old<br>mv ./www ./www-old<br>ln -s ./ac-www-releases/ac-www-2016-10-17/ www<br>sh git.pull.sh</p>
<p>exit</p>
<p>sudo sh update_<a target="_blank" rel="noopener" href="http://www.sh/">www.sh</a></p>
<hr>
<h2 id="找不到httpd-conf"><a href="#找不到httpd-conf" class="headerlink" title="找不到httpd.conf"></a>找不到httpd.conf</h2><p>httpd.conf的位置一般位于<br>/etc/httpd/conf/httpd.conf</p>
<p>如果没<br>执行命令<br>yum install httpd<br>重新安装一下，</p>
<h2 id="根据nginx配置，查找文件目录"><a href="#根据nginx配置，查找文件目录" class="headerlink" title="根据nginx配置，查找文件目录"></a>根据nginx配置，查找文件目录</h2><p>原本nginx配置好后，目录应该在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root &#x2F;data&#x2F;www&#x2F;hosts;</span><br></pre></td></tr></table></figure>

<p>但如果有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ^~ &#x2F; &#123;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001&#x2F;;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则应根据3001端口来找具体进程对应的进程</p>
<p>执行 如下命令找到对应进程的pid</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -nplt | grep 3001</span><br></pre></td></tr></table></figure>

<p>根据pid来找到目录，执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep 37098</span><br></pre></td></tr></table></figure>

<p>出现如下结果，则为对应的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">501      37098  0.0  0.2 1209696 42828 ?       Ssl  Aug08   8:37 node /home/nodeProjects/express/dist/index.js</span><br></pre></td></tr></table></figure>

<h2 id="跟着立斌学命令行"><a href="#跟着立斌学命令行" class="headerlink" title="跟着立斌学命令行"></a>跟着立斌学命令行</h2><p>dash<br>zsh<br>/oh-my-zsh<br>oh-my-zsh</p>
<p>sh -c “$(curl -fsSL <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</a><br>需要提前装zsh，<br> yum install zsh</p>
<h2 id="切换到zsh"><a href="#切换到zsh" class="headerlink" title="切换到zsh"></a>切换到zsh</h2><p>chsh -s /usr/local/bin/zsh</p>
<p>修改主题，目录<br>/root/.oh-my-zsh/templates/zshrc.zsh-template</p>
<p>zsh-autosuggestions</p>
<p>安装方法：<br>git clone git://github.com/zsh-users/zsh-autosuggestions <del>/.zsh/zsh-autosuggestions<br>source</del>/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh</p>
<p>看一下自己目前使用的终端是什么：</p>
<p>echo $SHELL</p>
<p>查看当前主题</p>
<p>echo $ZSH_THEME</p>
<p>我用的主题<br>robbyrussell</p>
<p> 主题修改文件路径:sudo vim ~/.zshrc</p>
<h2 id="linux-用命令启动服务不掉线"><a href="#linux-用命令启动服务不掉线" class="headerlink" title="linux 用命令启动服务不掉线"></a>linux 用命令启动服务不掉线</h2><p>创建control.sh<br>  运行./control.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">nohup npm start ./ 1&gt;&gt;<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>cat access.log | cut -d’ ‘ -f7 | sort | uniq -c | sort -nr | head -n30</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-08 18:05:59" itemprop="dateCreated datePublished" datetime="2018-10-08T18:05:59+08:00">2018-10-08</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">网站搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-25 20:31:07" itemprop="dateCreated datePublished" datetime="2018-08-25T20:31:07+08:00">2018-08-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-03-22 20:31:07" itemprop="dateModified" datetime="2019-03-22T20:31:07+08:00">2019-03-22</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="网站创建历程"><a href="#网站创建历程" class="headerlink" title="网站创建历程"></a>网站创建历程</h2><h2 id="1-买域名"><a href="#1-买域名" class="headerlink" title="1. 买域名"></a>1. 买域名</h2><pre><code>https://wanwang.aliyun.com/domain/searchresult/

先要起名字，找到合适的域名。
找好后直接付款支付就ok了。</code></pre>
<h3 id="1-1-实名制"><a href="#1-1-实名制" class="headerlink" title="1.1  实名制"></a>1.1  实名制</h3><pre><code>需要身份证照片。
直接拍照，上传，ok，等2个工作日。</code></pre>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p> <a target="_blank" rel="noopener" href="https://cn.aliyun.com/easybuy?spm=5176.8142029.418687.2.QpC6Vr">购买地址</a></p>
<p>云服务器ECS（包年包月）<br>地域: 华北 1<br>可用区: 华北 1 可用区 B<br>I/O 优化实例: 非 I/O 优化实例<br>实例规格: 1 核 2GB<br>网络类型: 经典网络<br>带宽: 1Mbps（按固定带宽）<br>操作系统: CentOS 7.2 64位<br>系统盘: 40GB 普通云盘<br>密码: 已设置<br>实例名称: oriht</p>
<p>linux学习：<br><a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/linux-command/chap03.html">http://wiki.jikexueyuan.com/project/linux-command/chap03.html</a></p>
<p>登陆的操作：<br>ssh root@ip</p>
<p>三：连接数据库：mysql -uroot -proot //p</p>
<p>还有就是遇到死链接的问题需要</p>
<p>配置路由：‘URL_MODEL’=2;<br>或者配置为0 和3 这里需要仔细查看TP手册部署那里。</p>
<p>直接写路径就可以</p>
<p>3。chkconfig –level 35 vsftpd on4.yum -y install vsftpd;5 cd /home/wwwroot/default/6 chmod 777 /home/wwwroot/default/chmod 777 /home/wwwroot/default/ -R<br>这里要注意的是权限问题：你要把application目录权限-777例如：chmod 777 /home/wwwroot/default/ -Rchmod -R 777 /home/wwwroot/default/</p>
<p><a target="_blank" rel="noopener" href="http://www.centoscn.com/image-text/install/2014/0514/2972.html">在centos上安装git</a></p>
<h2 id="备案流程"><a href="#备案流程" class="headerlink" title="备案流程"></a>备案流程</h2><p> 网站备案信息真实性核验单 [查看样例] 请打印3份，按照样例分别填写并全部邮寄</p>
<p> 申请邮寄幕布 您自行拍照后上传</p>
<h2 id="远程拷贝"><a href="#远程拷贝" class="headerlink" title="远程拷贝"></a>远程拷贝</h2><p>拷贝远程服务器的文件到本地:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r -P 端口号 用户名@IP地址:/usr/<span class="built_in">local</span>/tomcat_airc/webapps/  /tmp/kyj/</span><br></pre></td></tr></table></figure></code></pre>
<p>拷贝本地文件到远程服务器:</p>
<pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /tmp/kyj/sys.war 用户名@IP地址:/usr/<span class="built_in">local</span>/tomcat_airc/webapps/</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="服务器信息"><a href="#服务器信息" class="headerlink" title="服务器信息"></a>服务器信息</h2><p> php的默认端口是8080<br> nginx的默认端口改成80</p>
<h2 id="https配置"><a href="#https配置" class="headerlink" title="https配置"></a>https配置</h2><p> 在阿里云买好证书，</p>
<ol>
<li><p>在nginx安装目录下新建cert目录<br>cd /usr/local/nginx<br>mkdir cert</p>
</li>
<li><p>将证书下载下来，复制到cert目录下<br> scp -r 本地文件目录 root@(ip):/usr/local/nginx/cert/<br> 这里有123.pem 和123.key,两个都要传到远程服务器</p>
</li>
<li><p>配置后不生效</p>
</li>
<li><p>curl -l <a target="_blank" rel="noopener" href="http://oriht.com/">http://oriht.com</a></p>
</li>
<li><p>wget <a target="_blank" rel="noopener" href="http://oriht.com/">http://oriht.com</a></p>
</li>
<li><p>需要进入阿里云服务器的实例里，找到安全组规则，配置443访问权限。才能访问https的端口</p>
</li>
<li><p>nginx no input file specified 查看nginx error.log, 发现是nginx之前的配置找不到路径之类的问题，先将所有的其他配置注释掉，mv **.conf **.conf.bak</p>
</li>
<li><p>又报502 Bad Gateway 说是nginx-fpm的占用内存太多，默认进程数太少</p>
</li>
</ol>
<p>1、查看php fastcgi的进程数（max_children值）</p>
<p><code>netstat -anop | grep php-cgi | wc -l</code><br>1、查看php fastcgi的进程数（max_children值）</p>
<p><code>netstat -anop | grep php-cgi | wc -l</code></p>
<p>3、调整/usr/local/php/etc/php-fpm.conf 的相关设置</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm.max_children &#x3D; 5</span><br><span class="line">request_terminate_timeout &#x3D; 60</span><br></pre></td></tr></table></figure></code></pre>
<p>部分PHP程序的执行时间超过了Nginx的等待时间，可以适当增加nginx.conf配置文件中FastCGI的timeout时间，例如：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">fastcgi_connect_timeout 300;</span><br><span class="line">fastcgi_send_timeout 300;</span><br><span class="line">fastcgi_read_timeout 300;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/" class="post-title-link" itemprop="url">前端经验积累</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-03 21:42:02" itemprop="dateCreated datePublished" datetime="2018-07-03T21:42:02+08:00">2018-07-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-11-29 21:42:02" itemprop="dateModified" datetime="2018-11-29T21:42:02+08:00">2018-11-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="判断一个对象是不是数组"><a href="#判断一个对象是不是数组" class="headerlink" title="判断一个对象是不是数组"></a>判断一个对象是不是数组</h1><ol>
<li>instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;;</span><br><span class="line">var b&#x3D;[];</span><br><span class="line">console.log(a instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">console.log(b instanceof Array);&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">注意！！！！！！</span><br><span class="line">console.log(b instanceof Object);&#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Array.isArray()</p>
</li>
<li><p>使用Object.prototype上的原生toString()方法判断。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(a));&#x2F;&#x2F;[object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(b));&#x2F;&#x2F;[object Array]</span><br><span class="line">同理判断一个对象是否是函数：</span><br><span class="line">console.log(Object.prototype.toString.call(obj)&#x3D;&#x3D;&#x3D;&#39;[object Function]&#39;)    &#x2F;&#x2F;true或false</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>obj.constructor===Array   //true</li>
</ol>
<h1 id="真值-假值（Truthy-Falsy）"><a href="#真值-假值（Truthy-Falsy）" class="headerlink" title="真值 / 假值（Truthy / Falsy）"></a>真值 / 假值（Truthy / Falsy）</h1><p>以下为false</p>
<ul>
<li>false</li>
<li>0</li>
<li>“”（空字符串）</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">!0 &#x2F;&#x2F; true -- 0 is false, 所以返回true</span><br><span class="line">!!0 &#x2F;&#x2F; false -- 0 is falsy so !0 returns true so !(!0) returns false</span><br><span class="line">!!&quot;&quot; &#x2F;&#x2F; false -- empty string is falsy so NOT (NOT false) equals false</span><br><span class="line"></span><br><span class="line">new Boolean(0) &#x2F;&#x2F; false</span><br><span class="line">new Boolean(1) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let a &#x3D; [] &#x3D;&#x3D; true &#x2F;&#x2F; a is false since [].toString() give &quot;&quot; back.</span><br><span class="line">let b &#x3D; [1] &#x3D;&#x3D; true &#x2F;&#x2F; b is true since [1].toString() give &quot;1&quot; back.</span><br><span class="line">let c &#x3D; [2] &#x3D;&#x3D; true &#x2F;&#x2F; c is false since [2].toString() give &quot;2&quot; back.</span><br><span class="line"></span><br><span class="line">在内部，当一个对象与布尔值比较时，</span><br><span class="line">比如[] &#x3D;&#x3D; true，它其实进行的是[].toString() &#x3D;&#x3D; true。</span><br></pre></td></tr></table></figure>

<h1 id="JS语句为什么不能以“function”和大括号开头"><a href="#JS语句为什么不能以“function”和大括号开头" class="headerlink" title="JS语句为什么不能以“function”和大括号开头"></a>JS语句为什么不能以“function”和大括号开头</h1><ul>
<li>以function开头，但必须是一个函数声明语句</li>
<li>以大括号开头，但该大括号不再被当做一个对象处理，而是当做一个语句块处理</li>
<li>综上两条说明，JS语句可以以function，也可以以大括号作为开头，前提是必须符合JS中的语法规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;a: &#39;a&#39;&#125;.a;   &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line">function()&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token (</span><br><span class="line">&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line"></span><br><span class="line">“&#123;&#125;.toString();” 等同于: “; .toString();” 未通过对象主体调用“toString”方法，不符合JS中期待的表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Object-assign-JSON-stringify是深拷贝吗"><a href="#Object-assign-JSON-stringify是深拷贝吗" class="headerlink" title="Object.assign, JSON.stringify是深拷贝吗"></a>Object.assign, JSON.stringify是深拷贝吗</h1><p>不是的话怎么解决</p>
<p>shallowCopy（浅拷贝）或 deepCopy（深拷贝）</p>
<p>深拷贝造成了 CPU 和内存的浪费</p>
<p>深拷贝如果是只有最底层一个元素改变，会造成性能影响，怎么解决? immutable</p>
<p>Object.assign()可以对非嵌套对象进行深拷贝的方法,<br>如果对象中出现嵌套情况,那么其对被嵌套对象的行为就成了普通的浅拷贝.<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。</p>
<p>对象解构运算，也是浅拷贝。</p>
<p>JSON对象中包含两个方法, stringify()和parse(),前者可以将对象JSON化,而后者可以将JSON格式转换为对象.这是一种可以实现深拷贝的方法.<br>但这种方法的缺陷是会破坏原型链,并且无法拷贝属性值为function的属性<br>所以如果只是想单纯复制一个嵌套对象,可以使用此方法</p>
<p>缺点是你创建一个临时的，可能很大的字符串，只是为了把它重新放回解析器。另一个缺点是这种方法不能处理循环对象。而且循环对象经常发生。例如，当您构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const x &#x3D; &#123;&#125;;</span><br><span class="line">const y &#x3D; &#123;x&#125;;</span><br><span class="line">x.y &#x3D; y; &#x2F;&#x2F; Cycle: x.y.x.y.x.y.x.y.x...</span><br><span class="line">const copy &#x3D; JSON.parse(JSON.stringify(x)); &#x2F;&#x2F; throws!</span><br><span class="line"></span><br><span class="line">let bar &#x3D; JSON.parse(JSON.stringify(foo));</span><br><span class="line">Object.assign(&#123;&#125;, foo);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a: 0,</span><br><span class="line">    b: 20,</span><br><span class="line">&#125;</span><br><span class="line">obj &#x3D; &#123;...obj, a: obj.a + 1&#125;</span><br><span class="line"></span><br><span class="line">Structured Clone 结构化克隆算法</span><br><span class="line">MessageChannel</span><br><span class="line">缺点是它是异步的。虽然这并无大碍，</span><br><span class="line">但是有时候你需要使用同步的方式来深度拷贝一个对象</span><br><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;port1, port2&#125; &#x3D; new MessageChannel();</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#x2F;* ... *&#x2F;;</span><br><span class="line">const clone &#x3D; await structuralClone(obj);</span><br></pre></td></tr></table></figure>

<p>es7 … 的方式<br>直接{…obj}赋值属于浅复制，在修改值时{…obj,a:1}就起到了类深复制的效果<br>更新一个 Object</p>
<h3 id="immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"><a href="#immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发" class="headerlink" title="immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"></a>immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发</h3><p> <a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/3">链接</a></p>
<p> Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。</p>
<p>为什么immutable比较两个对象不同会快？原因如下：<br>和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。用法：is(map1,map2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">这是原来的 reducer：</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    newState &#x3D; Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        apples: [</span><br><span class="line">            ...state.apples.slice(0, action.payload),</span><br><span class="line">            Object.assign(&#123;&#125;, state.apples[action.payload], &#123; isEaten: true &#125;),</span><br><span class="line">            ...state.apples.slice(action.payload + 1)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">    return newState;</span><br><span class="line"></span><br><span class="line">这是使用 immutable.js 库的reducer :</span><br><span class="line"></span><br><span class="line">import &#123; fromJS &#125; from &#39;immutable&#39;;</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    return fromJS(state).setIn([&#39;apples&#39;,action.payload,&#39;isEaten&#39;], true).toJS();</span><br><span class="line"></span><br><span class="line">团队约定 state 都用 immutable 内部的数据类型，就可以连 fromJS 和 toJS 的转化都省了，超级方便！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="JSONP-后端返回alert-data-，前端会执行吗"><a href="#JSONP-后端返回alert-data-，前端会执行吗" class="headerlink" title="JSONP 后端返回alert(data)，前端会执行吗"></a>JSONP 后端返回alert(data)，前端会执行吗</h1><p>因为后端把回调方法名转成另一个名字将data包在里边，所以不会执行alert。</p>
<p>为什么是jsonp, img, iframe也可以，为什么？</p>
<p>jsonp全名叫做json with padding<br>函数调用，数据都被包裹传递到参数中了，</p>
<p>将服务端的数据用padding包起来，所谓的padding就相当于一个函数。假设我们原来有数据 {“data”,”something”}，用一个名为callback的padding包起来之后 就成了 callback({“data”:”something”})，这样将script标签加载完毕之后，会立马执行这个函数，并将数据当做参数传了进去。如果我们可以事先在前端事先指定一个函数名，并定义这个函数。然后告诉后端，用这个函数名作为padding包裹数据。那么当前端动态创建script标签之后，script加载完毕了就会执行这个函数，这样我们就成功的跨域获得了数据~</p>
<p>从开发者工具里面可以看到实际发送的请求</p>
<p>Request URL:<a target="_blank" rel="noopener" href="https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924">https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924</a></p>
<p>这里可以看出来jQuery自动生成的padding是jsonp1430727166924返回的数据：;jsonp1430727166924({“rating”:{“max”:10,”numRaters”:336,”average”:”7.0”,”min”:0},”price”:”15.00元”});</p>
<h1 id="js-css执行顺序，并行串行，阻塞"><a href="#js-css执行顺序，并行串行，阻塞" class="headerlink" title="js,css执行顺序，并行串行，阻塞"></a>js,css执行顺序，并行串行，阻塞</h1><p><a target="_blank" rel="noopener" href="http://blog.jobbole.com/12749/">链接</a><br>DOM文档的加载顺序是由上而下的顺序加载；</p>
<p>1、DOM加载到link标签</p>
<p>==css文件的加载是与DOM的加载并行的==，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；</p>
<p>2、DOM加载到script标签</p>
<p>由于==js文件不会与DOM并行加载==，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；</p>
<p>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现；</p>
<p>所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。至到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。</p>
<p>嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。</p>
<p>浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>
<p>3、解决方法</p>
<p>前提，js是外部脚本；</p>
<p>在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；</p>
<p>在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；</p>
<p>同时使用defer和async属性时，defer属性会失效；</p>
<p>可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。</p>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;十进制转其他</span><br><span class="line">var x&#x3D;110;  </span><br><span class="line">alert(x);</span><br><span class="line">alert(x.toString(8));  </span><br><span class="line">alert(x.toString(32));  </span><br><span class="line">alert(x.toString(16));  </span><br><span class="line">&#x2F;&#x2F;其他转十进制</span><br><span class="line">var x&#x3D;&#39;110&#39;;</span><br><span class="line">alert(parseInt(x,2));  </span><br><span class="line">alert(parseInt(x,8));  </span><br><span class="line">alert(parseInt(x,16));  </span><br><span class="line">&#x2F;&#x2F;其他转其他  </span><br><span class="line">&#x2F;&#x2F;先用parseInt转成十进制再用toString转到目标进制  </span><br><span class="line">alert(String.fromCharCode(parseInt(141,8)))  </span><br><span class="line">alert(parseInt(&#39;ff&#39;,16).toString(2));  </span><br></pre></td></tr></table></figure>

<h1 id="两个对象判断"><a href="#两个对象判断" class="headerlink" title="两个对象判断=="></a>两个对象判断==</h1><p>引用下温特大大的总结就是：<br>只要记住 null 只和undefined 相等，<br>有 number 都转 number，<br>有 boolean 也转 number，<br>有 string 都转 string，<br>对象互相不等，<br>NaN 互相不等就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log([] &#x3D;&#x3D; []) &#x2F;&#x2F; false</span><br><span class="line">console.log(![] &#x3D;&#x3D; false) &#x2F;&#x2F; false</span><br><span class="line">console.log([] &#x3D;&#x3D; false) &#x2F;&#x2F; true</span><br><span class="line">console.log(!!&#39;hello&#39;) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;hello&#39; &#x3D;&#x3D; true) &#x2F;&#x2F; &#39;hello&#39;&#x3D;&#x3D;1  false</span><br><span class="line">console.log(typeof(typeof(&#39;hello&#39;)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typeof的运算数未定义,返回的就是 “undefined”.</span><br><span class="line"></span><br><span class="line">运算数为数字 typeof(x) &#x3D; “number”</span><br><span class="line"></span><br><span class="line">字符串 typeof(x) &#x3D; “string”</span><br><span class="line"></span><br><span class="line">布尔值 typeof(x) &#x3D; “boolean”</span><br><span class="line"></span><br><span class="line">对象,数组和null typeof(x) &#x3D; “object”</span><br><span class="line"></span><br><span class="line">函数 typeof(x) &#x3D; “function”</span><br></pre></td></tr></table></figure>

<h1 id="FOUC无样式内容闪烁"><a href="#FOUC无样式内容闪烁" class="headerlink" title="FOUC无样式内容闪烁"></a>FOUC无样式内容闪烁</h1><p>Flash of Uncompiled Content</p>
<p>原因大致为： 1，使用import方法导入样式表。 2，将样式表放在页面底部 3，有几个样式表，放在html结构的不同位置。</p>
<p>解决方法： 使用LINK标签将样式表放在文档HEAD中。</p>
<ol>
<li><p>v-cloak</p>
</li>
<li><p>用v-text</p>
</li>
<li><p>v-if, v-show</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- same as --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// <span class="tag">&lt;<span class="name">div</span>&gt;</span> 不会显示，直到编译结束。</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="js实现jQuery-clone"><a href="#js实现jQuery-clone" class="headerlink" title="js实现jQuery.clone"></a>js实现jQuery.clone</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">逐级递归；</span><br><span class="line"></span><br><span class="line">递归中收集每个元素的全部信息，包括该元素上绑定的所有事件。</span><br><span class="line"></span><br><span class="line">复制时候重现按照获得的事件列表逐个加载回去。</span><br><span class="line"></span><br><span class="line">除此之外主要可能是考虑各种兼容，</span><br><span class="line">包括cloneNode方法的兼容，</span><br><span class="line">获取元素属性时候的某些标签的兼容。</span><br></pre></td></tr></table></figure>

<h1 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h1><p>（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。</p>
<h1 id="ajax参数"><a href="#ajax参数" class="headerlink" title="ajax参数"></a>ajax参数</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huiyuantang/p/5458278.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.url: 发送请求的地址</span><br><span class="line">2.type: 请求方式（post或get</span><br><span class="line">3.timeout: 请求超时时间（毫秒）</span><br><span class="line">4.async: 默认设置为true，异步请求</span><br><span class="line">5.cache: 从浏览器缓存中加载请求信息</span><br><span class="line">6.data: 发送到服务器的数据</span><br><span class="line">7.dataType: xml,html, json,text</span><br><span class="line">8.beforeSend：发送请求前，执行一些操作</span><br><span class="line">9.complete：完成后调用的回调函数</span><br><span class="line">10.success：请求成功后调用的回调函数</span><br><span class="line">11.error:</span><br><span class="line">12.contentType：</span><br><span class="line">13.dataFilter：</span><br><span class="line"></span><br><span class="line">16.ifModified：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;闭包限定命名空间</span><br><span class="line">(function ($) &#123;</span><br><span class="line">    $.fn.extend(&#123;</span><br><span class="line">        &quot;highLight&quot;:function(options)&#123;</span><br><span class="line">            &#x2F;&#x2F;do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(window.jQuery);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">$(&quot;p&quot;).highLight(); &#x2F;&#x2F;调用自定义 高亮插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="exports-module-exports区别"><a href="#exports-module-exports区别" class="headerlink" title="exports, module.exports区别"></a>exports, module.exports区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports</span><br><span class="line"></span><br><span class="line">exports在module.exports 被改变后，失效。</span><br><span class="line"></span><br><span class="line">1. module.exports 初始值为一个空对象 &#123;&#125;</span><br><span class="line">2. exports 是指向的 module.exports 的引用</span><br><span class="line">3. require() 返回的是 module.exports 而不是 exports</span><br></pre></td></tr></table></figure>

<h1 id="上传文件方式"><a href="#上传文件方式" class="headerlink" title="上传文件方式"></a>上传文件方式</h1><ul>
<li><p>form表单上传文件</p>
  <form action="/test/" method="POST" enctype="multipart/form-data">
</li>
<li><p>原生js实现ajax上传文件<br>   var xml=new XMLHttpRequest();</p>
<p>  var data=new FormData; //创建formdata对象</p>
<p>  data.append(“testfile”,document.getElementById(“file_upload”).files[0]);//找到对象之后的file[0]对应的就是文件对象</p>
<p>  xml.open(“POST”,”/test/“,true);</p>
</li>
<li><p>jquery实现ajax上传文件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data&#x3D;new FormData;</span><br><span class="line">data.append(&quot;testfile&quot;,document.getElementById(&quot;file_upload&quot;).files[0]);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;&#x2F;test&#x2F;&quot;,</span><br><span class="line">    type:&quot;POST&quot;,</span><br><span class="line">    dataType:&quot;JSON&quot;,</span><br><span class="line">    data:data,</span><br><span class="line">    contentType: false,</span><br><span class="line">    processData: false,</span><br><span class="line">    success:function(rst)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>form+iframe上传文件</p>
<h1 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h1><p> @mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin通过 @include来调用。</p>
<p> @mixin通过 @include调用后解析出来的样式是以拷贝形式存在的，而继承则是以联合声明的方式存在的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sass style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">@mixin center-block &#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br><span class="line">.demo&#123;</span><br><span class="line">    @include center-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;css style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">.demo&#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1，session 在服务器端，</span><br><span class="line">    cookie 在客户端（浏览器）</span><br><span class="line">2，session 默认被存在在服务器</span><br><span class="line">    的一个文件里（不是内存）</span><br><span class="line">3，session 的运行依赖 session id，</span><br><span class="line">    而 session id 是存在 cookie 中的，</span><br><span class="line">    也就是说，如果浏览器禁用了 cookie ，</span><br><span class="line">    同时 session 也会失效</span><br><span class="line">    （但是可以通过其它方式实现，</span><br><span class="line">    比如在 url 中传递 session_id）</span><br><span class="line">4，session 可以放在 文件、数据库、或内存中都可以。</span><br><span class="line">5，用户验证这种场合一般会用 session</span><br><span class="line">因此，维持一个会话的核心就是</span><br><span class="line">客户端的唯一标识，即 session id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="AMD-CMD-CommonJS"><a href="#AMD-CMD-CommonJS" class="headerlink" title="AMD, CMD, CommonJS"></a>AMD, CMD, CommonJS</h1><p>==记忆方法==</p>
<p>AR<br>AMD– require.js</p>
<p>CS<br>CMD– sea.js</p>
<p>A AMD A在前，提前加载</p>
<p>C CMD C在后，延迟加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">node的module遵循CommonJS规范，</span><br><span class="line">requirejs遵循AMD，seajs遵循CMD，</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------- node -----------</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  a : function() &#123;&#125;,</span><br><span class="line">  b : &#39;xxx&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------- AMD or CMD ----------------</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  module.exports &#x3D; &#123;</span><br><span class="line">    a : function() &#123;&#125;,</span><br><span class="line">    b : &#39;xxx&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。</span><br><span class="line">它采用异步方式加载模块，模块的加载不影响它后面语句的运行。</span><br><span class="line">所有依赖这个模块的语句，都定义在一个回调函数中，</span><br><span class="line">等到加载完成之后，这个回调函数才会运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line"></span><br><span class="line">1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</span><br><span class="line">不过 RequireJS 从 2.0 开始，</span><br><span class="line">也改成可以延迟执行（根据写法不同，处理方式不同）。</span><br><span class="line">CMD 推崇 as lazy as possible.</span><br><span class="line"></span><br><span class="line">2. CMD 推崇依赖就近，AMD 推崇依赖前置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="import引入模块"><a href="#import引入模块" class="headerlink" title="import引入模块"></a>import引入模块</h3><p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>注意:import必须放在文件的最开始.import命令是编译阶段执行的，在代码运行之前,表达式和变量只有在运行时才能得到结果的语法结构。import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）所以import中不能含有表达式或者变量,因此无法实现动态加载.<br>因此，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。<br>这样的设计，有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br></pre></td></tr></table></figure>

<h1 id="position取值"><a href="#position取值" class="headerlink" title="position取值"></a>position取值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ralative是指相对定位</span><br><span class="line">元素仍保持其未定位前的形状，它原本所占的空间仍保留。</span><br><span class="line"></span><br><span class="line">absolute是指绝对定位</span><br><span class="line">    即完全离开文档流, 相关于position属性非static值的比来父级元素进行偏移。</span><br><span class="line">    如果不存在这样的父对象，则依据body对象。而其层叠通过z-index属性定义</span><br><span class="line">fixed: 固定定位</span><br><span class="line">    固定定位：即完全离开文档流，相关于视区进行偏移。</span><br><span class="line">static：元素框正常生成</span><br><span class="line">inherit：继承值，对象将继承其父对象相应的值。</span><br></pre></td></tr></table></figure>

<h1 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="call和apply-bind区别"><a href="#call和apply-bind区别" class="headerlink" title="call和apply, bind区别"></a>call和apply, bind区别</h1><p>这三个参数的返回值区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">作用完全一样，唯一的区别就在参数上</span><br><span class="line"></span><br><span class="line">call 接收的参数不固定，</span><br><span class="line">第一个参数是函数体内 this 的指向，</span><br><span class="line">第二个参数以下是依次传入的参数。</span><br><span class="line"></span><br><span class="line">apply接收两个参数，</span><br><span class="line">第一个参数也是函数体内 this 的指向。</span><br><span class="line">第二个参数是一个集合对象（数组或者类数组）</span><br><span class="line"></span><br><span class="line">记忆方法：</span><br><span class="line"></span><br><span class="line">apply ---- array 要传数组</span><br><span class="line">call  ---- 逗号隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三个的使用区别：</span><br><span class="line">都是用来改变函数的this对象的指向的；</span><br><span class="line">第一个参数都是this要指向的对象；</span><br><span class="line">都可以利用后续参数传参；</span><br><span class="line">bind是返回对应函数，便于稍后调用，apply、call是立即调用；</span><br><span class="line">bind（）--也是改变函数体内this的指向;</span><br><span class="line">bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let obj1&#x3D;&#123;</span><br><span class="line">    a:222</span><br><span class="line">&#125;;</span><br><span class="line">let obj2&#x3D;&#123;</span><br><span class="line">    a:111,</span><br><span class="line">    fn:function()&#123;</span><br><span class="line">        alert(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.fn.call(obj1);&#x2F;&#x2F;222</span><br><span class="line"></span><br><span class="line">call 和 apply 两个主要用途就是</span><br><span class="line"></span><br><span class="line">1.改变 this 的指向（把 this 从 obj2 指向到 obj1 ）</span><br><span class="line"></span><br><span class="line">2.方法借用（ obj1 没有 fn ，只是借用 obj2 方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="箭头函数怎么绑定全局this"><a href="#箭头函数怎么绑定全局this" class="headerlink" title="箭头函数怎么绑定全局this"></a>箭头函数怎么绑定全局this</h1><p>箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () &#x3D;&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  &#x2F;&#x2F; undefined window&#123;...&#125;</span><br><span class="line"></span><br><span class="line">作为方法的箭头函数this指向全局window对象，</span><br><span class="line">而普通函数则指向调用它的对象</span><br></pre></td></tr></table></figure>

<h1 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h1><p><a target="_blank" rel="noopener" href="http://caibaojian.com/es6-features.html">链接</a></p>
<h1 id="foreach-map-reduce-filter区别"><a href="#foreach-map-reduce-filter区别" class="headerlink" title="foreach, map, reduce, filter区别"></a>foreach, map, reduce, filter区别</h1><h1 id="函数声明-amp-函数表达式的区别"><a href="#函数声明-amp-函数表达式的区别" class="headerlink" title="函数声明&amp;函数表达式的区别"></a>函数声明&amp;函数表达式的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">函数声明中函数名是必须的；函数表达式中则是可选的</span><br><span class="line"> &#x2F;&#x2F;函数声明</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(1, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数表达式</span><br><span class="line">&#x2F;* var s &#x3D; function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2)); *&#x2F;</span><br><span class="line"></span><br><span class="line">var s &#x3D; function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2));</span><br><span class="line">&#x2F;&#x2F;以上两种都可以</span><br><span class="line"></span><br><span class="line">二、用函数声明定义的函数,函数可以在函数声明之前调用,而用函数表达式定义的函数只能在声明之后调用。</span><br><span class="line"></span><br><span class="line">【根本原因在于解析器对这两种定义方式读取的顺序不同:解析器会事先读取函数声明，即函数声明放在任意位置都可以被调用；</span><br><span class="line"></span><br><span class="line">对于函数表达式，解析器只有在读到函数表达式所在那行的时候才执行】</span><br><span class="line"></span><br><span class="line">使用var 表达式定义函数， 只有变量声明提前了，变量初始化代码仍然在原来的位置</span><br></pre></td></tr></table></figure>

<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段</p>
<h5 id="addEventListener-evtype-fn-useCapture"><a href="#addEventListener-evtype-fn-useCapture" class="headerlink" title="addEventListener(evtype,fn,useCapture)"></a>addEventListener(evtype,fn,useCapture)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">useCapture是true，则事件处理函数在捕获阶段被执行，否则 在冒泡阶段执行</span><br><span class="line"></span><br><span class="line">因为如果被监听的元素没有子元素，那么哪个监听代码写在前面，就先执行哪个！</span><br><span class="line"></span><br><span class="line">&lt;label&gt;Click me &lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#39;label&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;)</span><br><span class="line">    document.querySelector(&#39;input&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">因为label和input是有绑定的</span><br><span class="line">点击label后，浏览器自动帮你再点击一次label</span><br><span class="line">过程就是先进行一次事件机制，这一次对内部input元素的事件监听是不管不问的，所以先打出1</span><br><span class="line">结束后，再进行一次事件机制，这一次，按照正常事件机制流程走，所以接着打出了2,1</span><br></pre></td></tr></table></figure>

<p>阻止冒泡<br>window.event.cancelBubble = true</p>
<p>e.preventDefault();</p>
<p>return false</p>
<p>都能阻止<br> stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。<br>stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡</p>
<h1 id="git-问题"><a href="#git-问题" class="headerlink" title="git 问题"></a>git 问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git回退到某个commit版本</span><br><span class="line"></span><br><span class="line">git reset --hard commitId</span><br><span class="line">强制提交</span><br><span class="line">git push -f origin master</span><br><span class="line">删除分支</span><br><span class="line">git branch -d branchname  </span><br><span class="line"></span><br><span class="line">git 删除远程分支</span><br><span class="line">git push origin branchname</span><br><span class="line"></span><br><span class="line">rebase 和 merge区别</span><br><span class="line"></span><br><span class="line">rebase，合并的结果好看，一条线，但合并过程中出现冲突的话，比较麻烦（rebase过程中，一个commit出现冲突，下一个commit也极有可能出现冲突，一次rebase可能要解决多次冲突）；merge，合并结果不好看，一堆线交错，但合并有冲突的话，只要解一次就行了；</span><br><span class="line"></span><br><span class="line">commit 粒度把握得好，就直接 merge，把握不好，先 rebase 把粒度调整好了，再 merge。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="let-var-const-区别"><a href="#let-var-const-区别" class="headerlink" title="let var const 区别"></a>let var const 区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let 的「创建」过程被提升了，但是初始化没有提升。</span><br><span class="line"></span><br><span class="line">let在未定义之前使用，会报错</span><br><span class="line"></span><br><span class="line">var 的「创建」和「初始化」都被提升了。</span><br><span class="line"></span><br><span class="line">function 的「创建」「初始化」和「赋值」都被提升了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let 声明的变量的作用域是块级的；</span><br><span class="line">let 不能重复声明已存在的变量；</span><br><span class="line">let 有暂时死区，不会被提升。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域</span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) &#123; 循环体 &#125; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog">js链接</a></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">链接</a></p>
<p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。</p>
<p>在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>最大用处有两个，<br>一是可以读取函数内部的变量，<br>（创建局部变量，保护局部变量不会被访问和修改）。<br>另一个就是让这些变量的值始终保持在内存中。</p>
<p>闭包常见用途：</p>
<p>创建特权方法用于访问控制<br>事件处理程序及回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">let add&#x3D;(function()&#123;</span><br><span class="line">let now&#x3D;0;</span><br><span class="line">return &#123;</span><br><span class="line"> doAdd:function()&#123;</span><br><span class="line">    now++;</span><br><span class="line">    console.log(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">add.doAdd() &#x2F;&#x2F;1</span><br><span class="line">add.doAdd() &#x2F;&#x2F;2</span><br><span class="line">add.doAdd() &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">now 这个变量，并没有随着函数的执行完毕而被回收，</span><br><span class="line">而是继续保存在内存里面。</span><br><span class="line"></span><br><span class="line">由于 add 里面有函数是依赖于 now 这个变量。所以 now 不会被销毁，回收。</span><br><span class="line">由于 now 在外面访问不到</span><br><span class="line"></span><br><span class="line"> var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于方法里有this.name, 这里的this的是window，所以这里是The Window</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that &#x3D; this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line">　　</span><br><span class="line">&#x2F;&#x2F; 这里的that指向object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(typeof Array.isArray&#x3D;&#x3D;&#x3D;&quot;undefined&quot;)&#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg)&#123;</span><br><span class="line">        return Object.prototype.toString.call(arg)&#x3D;&#x3D;&#x3D;&quot;[object Array]&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="找出数组中的最大值"><a href="#找出数组中的最大值" class="headerlink" title="找出数组中的最大值"></a>找出数组中的最大值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;Math.max.apply(null,a);</span><br><span class="line">console.log(max);</span><br><span class="line">&#x2F;&#x2F;第二种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;eval(&#39;Math.max(&#39;+a.toString()+&#39;)&#39;);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">Math.max(...[-1, 5, 11, 3])</span><br><span class="line"> Math.max.apply(Math, [-1, 5, 11, 3])</span><br></pre></td></tr></table></figure>

<h1 id="Javascript的this用法"><a href="#Javascript的this用法" class="headerlink" title="Javascript的this用法"></a>Javascript的this用法</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">链接</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yangbingbinga/article/details/61424363">链接2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this是Javascript语言的一个关键字。</span><br><span class="line"></span><br><span class="line">它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</span><br><span class="line"></span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window</p>
<p>问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢?</p>
<p>用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针!</p>
<p>也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  test: function() &#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(this.a);</span><br><span class="line">    &#125;.bind(this), 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.test();  &#x2F;&#x2F;  2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setTimeout不止两个参数</span><br><span class="line">setTimeout(function(a, b)&#123;</span><br><span class="line">  console.log(a);   &#x2F;&#x2F; 3</span><br><span class="line">  console.log(b);   &#x2F;&#x2F; 4</span><br><span class="line">&#125;,0, 3, 4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">箭头函数比较特殊，没有自己的this，它使用封闭执行上下文(函数或是global)的 this 值。</span><br><span class="line"></span><br><span class="line">var x&#x3D;11;</span><br><span class="line">var obj&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say:()&#x3D;&gt;&#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();&#x2F;&#x2F; 11</span><br><span class="line">obj.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 11</span><br><span class="line">x &#x3D; 14</span><br><span class="line">obj.say() &#x2F;&#x2F; 14</span><br><span class="line">&#x2F;&#x2F;对比一下</span><br><span class="line">var obj2&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say() &#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.say();&#x2F;&#x2F; 22</span><br><span class="line">obj2.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 13</span><br></pre></td></tr></table></figure>

<h3 id="一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global"><a href="#一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global" class="headerlink" title="一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global"></a>一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global</h3><p>在严格模式下，默认绑定会将 this 指向 undefined</p>
<h3 id="二、作为对象方法的调用-this就指这个上级对象"><a href="#二、作为对象方法的调用-this就指这个上级对象" class="headerlink" title="二、作为对象方法的调用    this就指这个上级对象"></a>二、作为对象方法的调用    this就指这个上级对象</h3><h3 id="三-作为构造函数调用"><a href="#三-作为构造函数调用" class="headerlink" title="三 作为构造函数调用"></a>三 作为构造函数调用</h3><p>   所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
<h3 id="四-apply调用"><a href="#四-apply调用" class="headerlink" title="四 apply调用"></a>四 apply调用</h3><p>  this指的就是这第一个参数。<br>  apply()的参数为空时，默认调用全局对象。</p>
<h3 id="五-this指向绑定事件的dom元素"><a href="#五-this指向绑定事件的dom元素" class="headerlink" title="五 this指向绑定事件的dom元素"></a>五 this指向绑定事件的dom元素</h3><p>document.querySelector(“#id”).onclick =function(){<br>    this == document.querySelector(“#id”)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(!(&quot;a&quot; in window))&#123;</span><br><span class="line">    var a &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; window.hasOwnProperty(&quot;a&quot;) &#x3D;&#x3D;&#x3D; true ..</span><br><span class="line">&#x2F;&#x2F;不用多说了. a 还真存在原型链上</span><br><span class="line">&#x2F;&#x2F; 值是 Location 这个 API 的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">console.log(typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; true , 这个不用解释了</span><br><span class="line"></span><br><span class="line">console.log(!!typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及到就是优先级和布尔值的问题</span><br><span class="line">&#x2F;&#x2F; typeof count 就是字符串&quot;number&quot;</span><br><span class="line">&#x2F;&#x2F; !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true</span><br><span class="line">&#x2F;&#x2F; 最后才&#x3D;&#x3D;&#x3D; 比较 , true &#x3D;&#x3D;&#x3D; &quot;number&quot; , return false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var a &#x3D; b &#x3D; 3;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(typeof a &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(&#x3D;号自左向右)</span><br><span class="line">&#x2F;&#x2F; 那个函数可以拆成这样</span><br><span class="line"></span><br><span class="line">(function()</span><br><span class="line">  var a; &#x2F;* 局部变量,外部没法访问*&#x2F;</span><br><span class="line">  b &#x3D; 3; &#x2F;* 全局变量,so . window.b &#x3D;&#x3D;&#x3D; 3 , 外部可以访问到*&#x2F;</span><br><span class="line">  a &#x3D; b;</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 注意a只有在闭包里才能访问(a&#x3D;3)，在外部是undefined  !!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若是改成这样,这道题应该是对的</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D;3</span><br><span class="line">); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">  this.a &#x3D; something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(2)</span><br><span class="line"></span><br><span class="line">console.log(obj1.a) &#x2F;&#x2F; 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2,3); &#x2F;&#x2F; 用 call 强行改变上下文为 obj2内</span><br><span class="line">console.log(obj2.a); &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">var  bar &#x3D; new obj1.foo(4); &#x2F;&#x2F; 这里产生了一个实例</span><br><span class="line">console.log(obj1.a); &#x2F;&#x2F; 2</span><br><span class="line">console.log(bar.a); &#x2F;&#x2F; 4;  new的绑定比隐式和显式绑定优先级更高</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-设计模式你了解多少"><a href="#Q-设计模式你了解多少" class="headerlink" title="Q: 设计模式你了解多少"></a>Q: 设计模式你了解多少</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cnblogs.com&#x2F;tugenhua0707&#x2F;p&#x2F;5198407.html</span><br></pre></td></tr></table></figure>

<h1 id="Q-JS-的基本数据类型有哪些"><a href="#Q-JS-的基本数据类型有哪些" class="headerlink" title="Q: JS 的基本数据类型有哪些"></a>Q: JS 的基本数据类型有哪些</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line">Undefined</span><br><span class="line">Null</span><br><span class="line">Number</span><br><span class="line">Boolean</span><br><span class="line">String</span><br><span class="line">Symbol (ECMAScript 6 新定义)</span><br><span class="line"></span><br><span class="line"> 5 种原始类型即</span><br><span class="line"> Undefined</span><br><span class="line"> Null</span><br><span class="line"> Number</span><br><span class="line"> Boolean</span><br><span class="line"> String</span><br><span class="line"></span><br><span class="line"> 除了Object和Symbol不是，其他都是</span><br></pre></td></tr></table></figure>

<h1 id="Q-null-和-undefined-的差异"><a href="#Q-null-和-undefined-的差异" class="headerlink" title="Q: null 和 undefined 的差异"></a>Q: null 和 undefined 的差异</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">大体说一下,想要知其所以然请引擎搜索</span><br><span class="line"></span><br><span class="line">相同点:</span><br><span class="line"></span><br><span class="line">在 if 判断语句中,值都默认为 false</span><br><span class="line">大体上两者都是代表 无 ,具体看差异</span><br><span class="line">差异:</span><br><span class="line"></span><br><span class="line">null 转为数字类型值为0,而 undefined 转为数字类型为 NaN(Not a Number)</span><br><span class="line">undefined 是代表调用一个值而该值却没有赋值,这时候默认则为 undefined</span><br><span class="line">null 是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)</span><br><span class="line">设置为 null 的变量或者对象会被内存收集器回收</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-清除浮动的方式有哪些-比较好的是哪一种"><a href="#Q-清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="Q: 清除浮动的方式有哪些?比较好的是哪一种"></a>Q: 清除浮动的方式有哪些?比较好的是哪一种</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">常用的一般为三种 .clearfix , clear:both , overflow:hidden ;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  content:&quot;&quot;;&#x2F;&#x2F;设置内容为空</span><br><span class="line">　height:0;&#x2F;&#x2F;高度为0</span><br><span class="line">　line-height:0;&#x2F;&#x2F;行高为0</span><br><span class="line">　display:block;&#x2F;&#x2F;将文本转为块级元素</span><br><span class="line">　visibility:hidden;&#x2F;&#x2F;将元素隐藏</span><br><span class="line">　clear:both&#x2F;&#x2F;清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另一种写法</span><br><span class="line"></span><br><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line"> content:&quot;&quot;;</span><br><span class="line"> display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line"> clear:both;</span><br><span class="line"> overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;&#x2F;&#x2F; 为了兼容IE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">用display:table 是为了避免外边距margin重叠导致的margin塌陷,</span><br><span class="line">内部元素默认会成为 table-cell 单元格的形式</span><br><span class="line">--&gt;</span><br><span class="line">clear:both :若是用在同一个容器内相邻元素上,那是贼好的...有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</span><br><span class="line"></span><br><span class="line">overflow:hidden :这种若是用在同个容器内,可以形成 BFC 避免浮动造成的元素塌陷</span><br></pre></td></tr></table></figure>

<h1 id="Q-跨域问题"><a href="#Q-跨域问题" class="headerlink" title="Q: 跨域问题"></a>Q: 跨域问题</h1><p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/21976">详情</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">我一般用这三种, cors , nginx反向代理 , jsonp</span><br><span class="line"></span><br><span class="line">jsonp : 单纯的 get 一些数据,局限性很大...就是利用script标签的src属性来实现跨域。</span><br><span class="line"></span><br><span class="line">浏览器支持好</span><br><span class="line">调用失败不会返回各种HTTP状态码</span><br><span class="line">给后端传json格式的数据会报415错误，请求格式不正确</span><br><span class="line">callback添加恶意script标签，造成xss漏洞</span><br><span class="line">只能够实现get请求</span><br><span class="line">参数可见</span><br><span class="line"></span><br><span class="line">nginx 反向代理 : 主要就是用了 nginx.conf 内的 proxy_pass http:&#x2F;&#x2F;xxx.xxx.xxx</span><br><span class="line">,会把所有请求代理到那个域名,有利也有弊吧..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cors</span><br><span class="line"></span><br><span class="line">可控性较强,需要前后端都设置,兼容性 IE10+ ,</span><br><span class="line">CORS需要浏览器和服务器同时支持。IE8+：IE8&#x2F;9需要使用XDomainRequest对象来支持CORS。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example &#x2F;&#x2F; 子域乃至整个域名或所有域名是否允许访问</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS &#x2F;&#x2F; 允许那些行为方法</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type &#x2F;&#x2F; 允许的头部字段</span><br><span class="line">Access-Control-Max-Age: 86400 &#x2F;&#x2F; 有效期</span><br><span class="line">cros 的配置不仅仅这些,还有其他一些,具体引擎吧....</span><br><span class="line"></span><br><span class="line">若是我们要用 nginx 或者 express 配置 cors 应该怎么搞起? 来个简易版本的</span><br><span class="line"></span><br><span class="line">nginx</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   # 检查域名后缀</span><br><span class="line">    add_header Access-Control-Allow-Origin xx.xx.com;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;</span><br><span class="line">    add_header Access-Control-Max-Age 86400;</span><br><span class="line">&#125;</span><br><span class="line">express, 当然这货也有一些别人封装好的 cors 中间件,操作性更强...</span><br><span class="line">let express &#x3D; require(&#39;express&#39;);  </span><br><span class="line">let app &#x3D; express();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置所有请求的头部</span><br><span class="line">app.all(&#39;*&#39;, (req, res, next) &#x3D;&gt;  &#123;  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  </span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br><span class="line">有些还会跟你死磕,,除了这些还有其他姿势么...我说了一个HTML5的 postMessage ....</span><br><span class="line"></span><br><span class="line">..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下</span><br><span class="line"></span><br><span class="line">这货用于 iframe 传递消息居多, 大体有这么两步步</span><br><span class="line"></span><br><span class="line">window 打开一个实例,传递一个消息到一个x域名</span><br><span class="line">x 域名下监听 message 事件,获取传递的消息</span><br><span class="line">这货的兼容性没那么好,而且没考虑周全的下容易遭受 CSRF 攻击</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-对于XSS-和-CSRF-如何防范"><a href="#Q-对于XSS-和-CSRF-如何防范" class="headerlink" title="Q: 对于XSS 和 CSRF 如何防范"></a>Q: 对于XSS 和 CSRF 如何防范</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> XSS主要是指跨脚本攻击, 其实就相当于执行js脚本.</span><br><span class="line"></span><br><span class="line">XSS的防范</span><br><span class="line"></span><br><span class="line">1. 验证用户输入的内容, 是否符合规则.</span><br><span class="line">2. 转义 &lt;&gt; 造成代码直接运行的的标签..</span><br><span class="line">    轮询或者正则替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而面试官说这种的效率最低下,找相关资料</span><br><span class="line">若是有用到 cookie ,设置为 http-only ,避免客户端的篡改</span><br><span class="line"></span><br><span class="line">CSP(Content Security Policy)</span><br><span class="line">以白名单的机制对网站加载或执行的资源起作用。</span><br><span class="line">在网页中，这样的策略通过 HTTP 头信息或者 meta</span><br><span class="line">元素定义。CSP虽然提供了强大的安全保护，</span><br><span class="line">但是他也造成了如下问题：Eval及相关函数被禁用、</span><br><span class="line">内嵌的JavaScript代码将不会执行、</span><br><span class="line">只能通过白名单来加载远程脚本。</span><br><span class="line"></span><br><span class="line">CSRF跨域假冒请求</span><br><span class="line"></span><br><span class="line">有3个特性: 跨域, cookie, 请求方式.</span><br><span class="line">CSRF的防范一般这几种</span><br><span class="line"></span><br><span class="line">验证码,用户体验虽然不好,</span><br><span class="line">验证 HTTP Referer 字段,判断请求来源</span><br><span class="line">token加密解密 ,前端和后台双方协定一个token内容</span><br><span class="line"></span><br><span class="line">尽量使用JSON类型传输</span><br><span class="line">    form 传输的格式为:</span><br><span class="line">    Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">    而,JSON的传输类型为:</span><br><span class="line">    Content-Type: application&#x2F;json form</span><br><span class="line">    没有办法去模仿JSON类型进行传输</span><br><span class="line"></span><br><span class="line">DNS劫持, 事实上更偏向于User</span><br><span class="line">    developer实际上对这个也无能为力。</span><br><span class="line"></span><br><span class="line">HTTP(ISP) 劫持</span><br><span class="line">    使用HTTPS 加密方式传输</span><br><span class="line">    替换你的js的提供商，使用HTTPS路径进行加载。</span><br><span class="line"></span><br><span class="line">验证码造成的体验不好,</span><br><span class="line">token 滥用造成的性能问题,轮询替换造成的响应时间等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-谈谈你对-Promise-的理解-和-ajax-有关系么"><a href="#Q-谈谈你对-Promise-的理解-和-ajax-有关系么" class="headerlink" title="Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么"></a>Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么</h1><p><a target="_blank" rel="noopener" href="http://imweb.io/topic/57a0760393d9938132cc8da9">链接</a></p>
<p>promise 是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>异步操作队列化，比传统的异步操作回调函数和事件更合理更强大。</p>
<p>能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p>
<p>==Promise对象三种状态：==</p>
<p>Pending（进行中）<br>Fulfilled（已完成，又称为Resolved）<br>Rejectd（已失败）</p>
<p>一些需要注意的小点,如下</p>
<p>在 Pending 转为另外两种之一的状态时候,状态不可在改变..</p>
<p>Promise 的 then 为异步.而( new Promise() )构造函数内为同步</p>
<p>Promise 的 catch 不能捕获任意情况的错误(比如 then 里面的 setTimout 内手动抛出一个 Error )</p>
<p>Promise 的 resolve 若是传入值而非函数,会发生值穿透的现象</p>
<p>Promise 还有一些自带的方法,比如 race , all ,前者有任一一个解析完毕就返回,后者所有解析完毕返回…</p>
<p>==Promise 方法：==</p>
<p>then： 用链式调用的方式执行回调函数。通过 resolve 方法把 Promise 的状态置为完成态（Resolved），这时 then 方法就能捕捉到变化，并执行“成功”情况的回调。<br>then方法返回的是一个新的Promise实例</p>
<p>reject： 把 Promise 的状态置为已失败（Rejected），这时 then 方法执行“失败”情况的回调</p>
<p>catch：和 then 的第二个参数一样，用来指定 reject 的回调   当执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么也不会报错卡死 js，而是会进到这个 catch 方法中。</p>
<p>all:  提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p>
<ul>
<li><p>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。</p>
</li>
<li><p>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
</li>
</ul>
<p>race:只要有一个异步操作执行完毕，就立刻执行 then 回调。<br>注意：其它没有执行完毕的异步操作仍然会继续执行，而不是停止。</p>
<h3 id="Promise对象两个特点"><a href="#Promise对象两个特点" class="headerlink" title="Promise对象两个特点"></a>Promise对象两个特点</h3><ol>
<li><p>对象状态只由异步操作结果决定。resolve方法会使Promise对象由pendding状态变为fulfilled状态；reject方法或者异常会使得Promise对象由pendding状态变为rejected状态。Promise状态变化只有上图这两条路径。</p>
</li>
<li><p><strong>对象状态一旦改变，任何时候都能得到这个结果。</strong> 即状态一旦进入fulfilled或者rejected，promise便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。</p>
</li>
<li><p>Promise构造方法接受一个方法作为参数，该方法传入两个参数，resolve和reject。</p>
</li>
<li><p>resolve用来将Promise对象的状态置为成功，并将异步操作结果value作为参数传给成功回调函数。</p>
</li>
<li><p>reject用来将Promise对象的状态置为失败，并将异步操作错误error作为参数传给失败回调函数。</p>
</li>
<li><p>then方法绑定两个回调函数，第一个用来处理Promise成功状态，第二个用来处理Promise失败状态。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Promise 和 ajax 没有直接关系. promise 只是为了解决&quot;回调地狱&quot;</span><br><span class="line">Promise 并不能消灭回调地狱，但是它可以使回调变得可控。</span><br><span class="line"></span><br><span class="line">异步回调的问题：</span><br><span class="line"></span><br><span class="line">嵌套层次深，难以维护</span><br><span class="line">无法正常使用return和catch throw</span><br><span class="line">多个回调之间难以建立联系，一个回调函数一旦开启，就无法对其操作</span><br><span class="line">无法正常索引堆栈信息</span><br><span class="line"></span><br><span class="line">从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... some code</span><br><span class="line">    if ( &#x2F;* 异步操作成功 *&#x2F; ) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">模拟回调函数</span><br><span class="line">function runAsync(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行完成&#39;);</span><br><span class="line">        callback(&#39;随便什么数据&#39;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getUserAdmin()</span><br><span class="line">    .then(getProjects)</span><br><span class="line">    .then(getModules)</span><br><span class="line">    .then(getInterfaces)</span><br><span class="line">    .then(procResult)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a>Promise 必知必会（十道题）</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a04066351882517c416715d">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># Generator 函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;cnodejs.org&#x2F;topic&#x2F;542953d42ca9451e1bf3c251)</span><br><span class="line"></span><br><span class="line">Generator 函数是一个普通函数，但是有两个特征。</span><br><span class="line"></span><br><span class="line">一是，function关键字与函数名之间有一个星号；</span><br><span class="line"></span><br><span class="line">二是，函数体内部使用yield语句，定义不同的内部状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br>}<br>var hw = helloWorldGenerator();</p>
<p>const gen = function* () {<br>  const f1 = yield readFile(‘/etc/fstab’);<br>  const f2 = yield readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>写成async函数，就是下面这样。</p>
<p>const asyncReadFile = async function () {<br>  const f1 = await readFile(‘/etc/fstab’);<br>  const f2 = await readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。<br>以后，每次调用遍历器对象的next方法，<br>就会返回一个有着value和done两个属性的对象。<br>value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；<br>done属性是一个布尔值，表示是否遍历结束。</p>
<p>上面已经介绍了说yield是暂停标志，下面对yield进行一些介绍：</p>
<p>（1）、yield后面的表达式只有当调用next时，才会执行yield后面的表达式。</p>
<p>（2）、yield表达式只能写在Generator函数中 ，而不能写在普通的函数中。</p>
<p>（3）、yield表达式如果与其他表达式相结合，必须写在()里面。</p>
<p>yield与return的异同点：</p>
<p>相同点：都可以返回紧跟后面表达式的值</p>
<p>不同点：<br>(a)、在一个函数内部只能存在一个return语句，而可以存在多个yield语句；<br>(b)、return没有记忆功能，在Generator函数中只有当遍历器对象调用next时<br>    才会返回yield后面表达式的值，<br>    当下一次调用时从上一条yield语句后开始执行，<br>    而return后面的表达式只要函数执行就立即返回。<br>(c)、正常函数只有一个返回值，而Generator函数可以有多个返回值。</p>
<p>Generator函数被执行时，返回的是指向函数内部的遍历器对象，<br>只有调用遍历器对象的next方法时，才会返回yield后面函数表达式的值，<br>但是，其实yield表达式的值一直都是undefined。<br>如果在Generator的函数中传递参数且存在多个yield表达式时，<br>那么调用next方法时就要注意传参了：<br>next()中传递的参数就是上一个yield表达式的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 面试题网站</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com)</span><br><span class="line"></span><br><span class="line"># 作用域</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数和变量的可访问范围。<br>作用域分为全局作用域  函数作用域和eval作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 原型</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dee9f8b14771)</span><br><span class="line"></span><br><span class="line">原型其实就是上述所说的继承中的父类。</span><br><span class="line"></span><br><span class="line">原型链 :利用原型串起一个继承链，让一个引用类型继承另一个引用类型的属性和方法，再以此类推下去.</span><br><span class="line">当一个引用类型继承另一个引用类型的属性和方法时候就会产生一个原型连。</span><br><span class="line">当某个函数当成构造函数来调用时，就会产生一个构造函数的实例。这个实例上会拥有一个 __proto__ 属性，这个属性指向该实例的构造函数的原型对象(也可以称为该实例的原型对象)。</span><br><span class="line"></span><br><span class="line">定律：</span><br><span class="line"></span><br><span class="line">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line"></span><br><span class="line">原型链是依赖于__proto__，而不是prototype</span><br><span class="line"></span><br><span class="line">**实例与原型**</span><br><span class="line"></span><br><span class="line">当读取实例的属性时，</span><br><span class="line">如果找不到，就会查找与对象关联的原型中的属性，</span><br><span class="line">如果还查不到，就去找原型的原型，一直找到最顶层为止。</span><br><span class="line"></span><br><span class="line">通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。</span><br><span class="line"></span><br><span class="line">在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。</span><br><span class="line"></span><br><span class="line"> var A &#x3D; new Person();</span><br><span class="line"> Person.prototype &#x3D; A;</span><br><span class="line"></span><br><span class="line">原型对象（Person.prototype）是 构造函数（Person）的一个实例。↓</span><br><span class="line"></span><br><span class="line">#### Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### person1.__proto__ &#x3D;&#x3D; Person.prototype</span><br><span class="line"></span><br><span class="line">实例的构造函数属性（constructor）指向构造函数。↓</span><br><span class="line"></span><br><span class="line">#### person1.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null</span><br><span class="line"></span><br><span class="line">#### person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### obj.__proto__ &#x3D;&#x3D; Object.getPrototypeOf(obj)</span><br><span class="line"></span><br><span class="line"> 原型和原型链是JS实现继承的一种模型。</span><br><span class="line">原型链的形成是真正是靠__proto__ 而非prototype</span><br><span class="line"></span><br><span class="line">## 什么是原型链</span><br><span class="line"></span><br><span class="line"> 由于__proto__是任何对象都有的属性，而js里万物皆对象，</span><br><span class="line"> 所以会形成一条__proto__连起来的链条，递归访问__proto__最终到头，并且值是null</span><br><span class="line"></span><br><span class="line"> 当js引擎查找对象属性时，先查找对象本身是否存在该属性，</span><br><span class="line"> 如果不存在，会在原型链上查找，但不会查找自身的prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>var A = function()&#123;&#125;;
var a = new A();
console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null</code></pre>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>actions<br>assets<br>components<br>reducers<br>store<br>views<br>index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># prototype问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function Foo() {<br>    getName = function () { alert (1); };<br>    return this;<br>}<br>Foo.getName = function () { alert (2);};<br>Foo.prototype.getName = function () { alert (3);};<br>var getName = function () { alert (4);};<br>function getName() { alert (5);}</p>
<p>//请写出以下输出结果：<br>Foo.getName();<br>getName();<br>Foo().getName();<br>getName();<br>new Foo.getName();<br>new Foo().getName();<br>new new Foo().getName();</p>
<p>//答案：<br>Foo.getName();//2<br>getName();//4<br>Foo().getName();//1<br>getName();//1<br>new Foo.getName();//2<br>new Foo().getName();//3<br>new new Foo().getName();//3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># var和函数的提前声明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function fn(a) {<br>  console.log(a);<br>  var a = 2;<br>  function a() {}<br>  console.log(a);<br>}</p>
<p>fn(1);<br>　　输出：function  a() {} 2<br>　　<br>　　<br>我们知道var和function是会提前声明的，<br>而且function是优先于var声明的（如果同时存在的话），<br>所以提前声明后输出的a是个function，<br>然后代码往下执行a进行重新赋值了，故第二次输出是2。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zichi/p/4359786.html">http://www.cnblogs.com/zichi/p/4359786.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># javascript实现将多个有序数组合并为一个有序数组的算法</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010302469)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let ret=arr.reduce((arr1,arr2)=&gt;arr1.concat(arr2)).sort((a,b)=&gt;a-b);<br>ret=Array.from(new Set(ret));<br>console.log(ret);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># new操作符具体干了什么呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1、创建一个新对象<br>2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）<br>3、执行构造函数中的代码（为这个新对象添加属性）<br>4、返回新对象</p>
<p>var obj  = {};<br>obj.<strong>proto</strong> = Base.prototype;<br>Base.call(obj);</p>
<p>创建一个新对象foo；</p>
<p>并将它的<strong>proto__指向其构造函数的prototype，<br>foo.__proto</strong> = Foo.prototype;</p>
<p>动态将this指向新对象，Foo.apply(foo，arguments);</p>
<p>执行函数体中的代码；</p>
<p>放回新对象foo;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 怎么画一条0.5px的边</span><br><span class="line"></span><br><span class="line">[链接：](https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5ab65f40f265da2384408a95)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过直接设置宽高border为0.5px、<br>设置box-shadow的垂直方向的偏移量为0.5px、<br>借助线性渐变linear-gradient、<br>使用transform: scaleY(0.5)的方法，<br>使用SVG的方法。<br>最后发现transfrom scale/svg的方法兼容性和效果都是最好的，<br>svg可以支持复杂的图形，<br>所以在viewport是1的情况下，<br>可以使用transform/SVG画0.5px，<br>而如果viewport的缩放比例不是1的话，那么直接画1px即可。</p>
<p>.hairline-border {<br>  box-shadow: 0 0 0 1px;<br>}<br>@media (min-resolution: 2dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.5px;<br>  }<br>}<br>@media (min-resolution: 3dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.33333333px;<br>  }<br>}<br>@media (min-resolution: 4dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.25px;<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从 arguments 到剩余参数</span><br><span class="line"></span><br><span class="line">如果你想在 ES5 中让函数(或方法)接受任意数量的参数，必须使用特殊变量 arguments：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function logAllArguments() {<br>    for (var i=0; i &lt; arguments.length; i++) {<br>        console.log(arguments[i]);<br>    }<br>}</p>
<p>ES6 中则可以通过 … 运算符定义一个剩余参数(在下面示例中是args)：</p>
<p>function logAllArguments(…args) {<br>    for (const arg of args) {<br>        console.log(arg);<br>    }<br>}</p>
<p>如果有一部分固定参数，剩余参数就更适用了：</p>
<p>function format(pattern, …args) {<br>    ···<br>}</p>
<p>在 ES5 中处理同样的事情有点麻烦：</p>
<p>function format(pattern) {<br>    var args = [].slice.call(arguments, 1);<br>    ···<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</span><br><span class="line"></span><br><span class="line">[连接](https:&#x2F;&#x2F;github.com&#x2F;qiu-deqing&#x2F;FE-interview#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BB%A5http%E4%B8%BA%E4%BE%8B)</span><br><span class="line"></span><br><span class="line">1. 输入url</span><br><span class="line">2. 查看缓存</span><br><span class="line">3. 解析URL</span><br><span class="line">4. 组装HTTP请求报文</span><br><span class="line">5. 获取主机ip</span><br><span class="line">6. 建立tcp连接</span><br><span class="line">7. 发送http请求</span><br><span class="line">8. 服务器检查请求头信息</span><br><span class="line">9. 响应报文通过tcp返回</span><br><span class="line">10. 关闭tcp四次握手</span><br><span class="line">11. 检查状态码</span><br><span class="line">12. 缓存</span><br><span class="line">13. 解码</span><br><span class="line">14. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</span><br><span class="line">15. 显示页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器地址栏输入URL<br>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，<br>足够新鲜直接提供给客户端，否则与服务器进行验证。<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：<br>HTTP1.0提供Expires，<br>值为一个绝对时间表示缓存新鲜日期<br>HTTP1.1增加了Cache-Control: max-age,<br>值为以秒为单位的最大新鲜时间<br>浏览器解析URL获取协议，主机，端口，path<br>浏览器组装一个HTTP（GET）请求报文<br>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存</p>
<p>DNS递归查询（可能存在负载均衡导致每次IP不一样）<br>打开一个socket与目标IP地址，端口建立TCP链接，<br>三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z<br>TCP链接建立后发送HTTP请求</p>
<p>服务器接受请求并解析，将请求转发到服务程序，<br>如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
<p>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，<br>返回304等对应状态码<br>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作<br>服务器将响应报文通过TCP连接发送回浏览器<br>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，<br>关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</p>
<p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，<br>这些情况处理与2XX不同<br>如果资源可缓存，进行缓存<br>对响应进行解码（例如gzip压缩）</p>
<p>根据资源类型决定如何处理（假设资源为HTML文档）</p>
<p>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，<br>执行js脚本，这些操作没有严格的先后顺序，以下分别解释<br>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树<br>解析过程中遇到图片、样式表、js文件，启动下载<br>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</p>
<p>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，<br>不可见节点包括：<br>1）script,meta这样本身不可见的标签。<br>2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式<br>js解析如下：<br>浏览器创建Document对象并解析HTML，<br>将解析到的元素和文本节点添加到文档中，<br>此时document.readystate为loading</p>
<p>HTML解析器遇到没有async和defer的script时，<br>将他们添加到文档中，然后执行行内或外部脚本。<br>这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。<br>这样就可以用document.write()把文本插入到输入流中。<br>同步脚本经常简单定义函数和注册事件处理程序，<br>他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。<br>脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。<br>异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</p>
<p>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，<br>禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，<br>等这些内容完成载入并且所有异步脚本完成载入和执行，<br>document.readState变为complete,window触发load事件<br>显示页面（HTML解析过程中会逐步显示页面）</p>
<h1 id="浏览器渲染主要流程"><a href="#浏览器渲染主要流程" class="headerlink" title="浏览器渲染主要流程"></a>浏览器渲染主要流程</h1><p>HTML解析出DOM Tree<br>CSS解析出Style Rules<br>将二者关联生成Render Tree<br>Layout 根据Render Tree计算每个节点的信息<br>Painting 根据计算好的信息绘制整个页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Q: 网站性能优化</span><br><span class="line"></span><br><span class="line">[原文](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000013963213#articleHeader0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码层面优化：</p>
<p>一、加载和执行</p>
<pre><code>css方面

将样式表放到页面顶部
不使用CSS表达式
使用link不使用@import
不使用IE的Filter

Javascript方面

将脚本放到页面底部,body标签内底部
将javascript和css从外部引入
压缩javascript和css
删除不需要的脚本
减少DOM访问
合理设计事件监听器


图片方面

优化图片：根据实际颜色需要选择色深、压缩
优化css精灵
合并一些小图片( css sprite )压缩图片
图片转dataUrl
不要在HTML中拉伸图片
保证favicon.ico小并且可缓存
图片编码优化</code></pre>
<p>二、 数据存取<br>    - 尽量使用字面量和局部变量<br>        （局部变量在方法运行过后会自行释放，用完手动置为null或undefined也行），<br>        减少使用对象和数组,</p>
<p>三、 DOM编程**（常见的性能瓶颈）<br>    - 最坏的方式就是在循环中操作或者访问DOM，非常消耗性能。<br>    减少DOM数量<br>    - 遍历dom<br>        querySelectorAll()是获取元素最快的API 返回的是一个NodeList<br>        querySelector() 返回的是element,<br>        querySelectorAll()还有一点就是可以同时获取两类元素</p>
<pre><code>- 重绘和重排都是代价昂贵；尽量减少
    重排何时发生：
    1.添加或删除可见DOM元素
    2.元素位置改变
    3.元素尺寸改变（内外边距、边框厚宽高等）
    4.内容改变 （内容导致尺寸变化的时候）
    5.页面渲染器初始化
    6.浏览器窗口尺寸变化</code></pre>
<p>四、 算法和流程控制<br>    - 循环<br>        (当循环体复杂度为X时，优化方案优先减少循环体的复杂度，<br>        循环体复杂度大于X时，优化方案优先减少迭代次数 )<br>    - 条件语句<br>        当条件较少时 使用if-else更易读，<br>        而当条件较多时if-else性能负担比switch大，易读性也没switch好。<br>        优化if-else的方法是：尽可能的把可能出现的条件放在首位，</p>
<p>五、 字符串和正则表达式<br>    - 字符串<br>        join是比较快的，也是大量字符串拼接的唯一高效方式</p>
<p>六、 快速响应的用户界面<br>    - 浏览器UI线程<br>        浏览器限制JavaScript任务的运行时间，限制两分钟，<br>        可以防止恶意代码不断执行来锁定你的浏览器</p>
<pre><code>    单个JavaScript操作的花费总时间应该小于等于100ms，
    这就意味着在100ms内响应用户的操作，不然就会让用户感受到迟钝感

- 定时器让出时间片断
    使用时间戳计算获得程序运行时间，
    以便快速找到运行时间较长的代码部分进行优化</code></pre>
<p>七、 Ajax<br>    - 数据传输<br>        数据的传输同样影响性能<br>    - 数据格式<br>    - Ajax性能<br>        避免不必要的请求：<br>        使Ajax可缓存：服务端设置HTTP头信息确保响应会被浏览器缓存<br>        客户端讲获取的信息存到本地避免再次请求<br>        （localstorage sessionstorage cookice）<br>        设置HTTP头信息，expiresgaosu告诉浏览器缓存多久<br>        减少HTTP请求，合并css、js、图片资源文件等或使用MXHR<br>        通过次要文件用Ajax获取可缩短页面加载时间</p>
<pre><code>    减小cookie大小
    引入资源的域名不要包含cookie</code></pre>
<p>八、编程实践<br>    - 避免双重求值<br>        eval()、Function慎用，<br>        定时器第一个参数建议函数而不是字符串都能避免字符串双重求值<br>    - 使用对象或者数组直接量<br>    - 避免重复工作<br>        A:延迟加载（懒加载）<br>        B:条件预加载<br>    - 使用JavaScript速度快的部分<br>        A.位操作<br>        B.原生方法，首先原生方法是最快的，而且浏览器会缓存部分原生方法<br>        C.复杂计算时多使用Math对象<br>        D.querySelector和querySelectorAll是查询最快的</p>
<p> 九、 构建并部署高性能JavaScript应用<br>    1.合并多个js文件<br>    2.预处理js文件<br>    3.js压缩<br>    4.js的HTTP压缩<br>    5.缓存js文件<br>    6.处理缓存问题<br>    7.使用内容分发网络（CDN）</p>
<p>移动方面</p>
<pre><code>保证组件小于25k
Pack Components into a Multipart Document

content方面

按需加载资源
非必须组件延迟加载
未来所需组件预加载
    在网站 HTML 中的链接属性上增加
    rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记。

将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
减少iframe数量
不要404

Server方面

使用CDN
减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。
方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
避免重定向：多余的中间访问
用dns-prefetch

&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//mat1.gtimg.com&quot;&gt;

动静分离
使用nginx的反向代理，对静态资源的请求直接nginx处理，或放到CDN
动态请求转发给tomcat处理

添加Expires或者Cache-Control响应头
对组件使用Gzip压缩
    Brotli 是一个比较新的文件压缩算法，目前正变得越来越受欢迎。
配置ETag
Flush Buffer Early
Ajax使用GET进行请求
避免空src的img标签</code></pre>
<p>十、 工具</p>
<pre><code>若是打包的代码尽可能切割成多个 chunk ,减少单一 chunk 过大
HTTP的缓存头使用的合理
减小第三方库的依赖
对于代码应该考虑性能来编写,比如使用 requestAnimationFrame 绘制动画,尽可能减少页面重绘(DOM 改变)
渐进升级,引入 preload 这些预加载资源
看情况用 server worker 来缓存资源(比如移动端打算搞 PWA)
比如从服务端着手:

带宽,域名解析, 多域名解析等
使用负载均衡方案 多节点部署
页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)
渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)
当然,这是这些都是很片面的点到...实际工作中去开展要复杂的多;


使用索引加速数据库查询
页面静态化CMS</code></pre>
<p>多个维度考虑,优化 DOM 绘制时间,资源加载时间,域名解析这些;</p>
<p>要全面的优化一个项目是一个大工程…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 优雅降级和渐进增强</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优雅降级：<br>Web站点在所有新式浏览器中都能正常工作，<br>如果用户使用的是老式浏览器，<br>则代码会检查以确认它们是否能正常工作。<br>针对不同版本的hack为那些无法支持功能的<br>浏览器增加候选方案，<br>使之在旧式浏览器上以某种形式降级体验<br>却不至于完全失效.</p>
<p>渐进增强：<br>从被所有浏览器支持的基本功能开始，<br>逐步地添加那些只有新式浏览器才支持的功能,<br>向页面增加无害于基础浏览器的<br>额外样式和功能的。<br>当浏览器支持时，<br>它们会自动地呈现出来并发挥作用。</p>
<p>保证所有人都能访问页面的基本内容和功能<br>同时为高级浏览器和高带宽用户提供<br>更好的用户体验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># js控制css3动画</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开始事件 AnimationStart<br>结束事件 AnimationEnd<br>重复运动事件 AnimationIteration  每次开始动画迭代都触发animationiteration</p>
<p>W3c标准：animationstart animationiteration animationend<br>Webkit：webkitAnimationStart webkitAnimationIteration webkitAnimationEnd<br>Firefox：animationstart animationiteration animationend<br>Opera：animationstart animationiteration animationend<br>IE10：MSAnimationStart MSAnimationIteration MSAnimationEnd</p>
<p>var e = document.getElementById(“left1”);  </p>
<p>e.addEventListener(“animationend”, function() {<br>    alert(‘css3运动结束！’);<br>});  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Object循环key</span><br><span class="line"></span><br><span class="line">- for...in循环：只遍历对象自身的和继承的可枚举的属性。</span><br><span class="line">    通常用for in来遍历对象的键名</span><br><span class="line">    for in更适合遍历对象，不要使用for in遍历数组。</span><br><span class="line"></span><br><span class="line">for in 循环会把数组其他扩展方法也循环</span><br><span class="line"></span><br><span class="line">- for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</span><br><span class="line"></span><br><span class="line">for-of循环是遍历实现iterator接口的成员</span><br><span class="line"></span><br><span class="line">只要是一个对象部署了Symbol.interator接口，就可以用for...of遍历该对象，同时也可以调用该接口的Symbol.interator方法调用next()方法对对象进行遍历，不同的是for..of是对该对象的值的输出，而next()返回的是对象。</span><br><span class="line"></span><br><span class="line">在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</span><br><span class="line"></span><br><span class="line">- Object.keys()：返回对象自身的所有可枚举的属性的键名。</span><br><span class="line">- JSON.stringify()：只串行化对象自身的可枚举的属性。</span><br><span class="line">- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;for...in循环出的是key，for...of循环出的是value&#x3D;&#x3D;</span><br><span class="line">- &#x3D;&#x3D;for...of不能循环普通的对象，需要通过和Object.keys()搭配使用&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">如果实在想用for...of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组</span><br><span class="line">然后遍历：</span><br><span class="line"></span><br><span class="line">## 结论</span><br><span class="line"></span><br><span class="line">1. 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。</span><br><span class="line"></span><br><span class="line">2. for...in循环出的是key，for...of循环出的是value</span><br><span class="line"></span><br><span class="line">3. 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足</span><br><span class="line"></span><br><span class="line">4. for...of不能循环普通的对象，需要通过和Object.keys()搭配使用</span><br><span class="line"></span><br><span class="line">记忆jueqiao :</span><br><span class="line"></span><br><span class="line">已核对 偶数v</span><br><span class="line"></span><br><span class="line">in h（k）对象  o 数组 value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组<br>然后遍历：</p>
<p>var student={<br>    name:’wujunchuan’,<br>    age:22,<br>    locate:{<br>    country:’china’,<br>    city:’xiamen’,<br>    school:’XMUT’<br>    }<br>}<br>for(var key of Object.keys(student)){<br>    //使用Object.keys()方法获取对象key的数组<br>    console.log(key+”: “+student[key]);<br>}</p>
<p>for in 可以遍历到myObject的原型方法method,<br>如果不想遍历原型方法和属性的话，<br>可以在循环内部判断一下,<br>hasOwnPropery方法可以判断<br>某属性是否是该对象的实例属性</p>
<p>for (var key in myObject) {<br>　　if（myObject.hasOwnProperty(key)){<br>　　　　console.log(key);<br>　　}<br>}</p>
<pre><code></code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/React%20%E5%92%8CVue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/React%20%E5%92%8CVue/" class="post-title-link" itemprop="url">React和Vue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-26 21:42:02" itemprop="dateCreated datePublished" datetime="2018-04-26T21:42:02+08:00">2018-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-11-29 21:42:02" itemprop="dateModified" datetime="2018-11-29T21:42:02+08:00">2018-11-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在jsx文件中为什么一定要引用react"><a href="#在jsx文件中为什么一定要引用react" class="headerlink" title="在jsx文件中为什么一定要引用react"></a>在jsx文件中为什么一定要引用react</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JSX 语法就是用React.createElement()来构建 React 元素的。</span><br><span class="line">它接受三个参数，第一个参数可以是一个标签名。</span><br><span class="line">如div、span，或者 React 组件。</span><br><span class="line">第二个参数为传入的属性。</span><br><span class="line">第三个以及之后的参数，皆作为组件的子组件。</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement()</span><br><span class="line"></span><br><span class="line">React.cloneElement()与React.createElement()相似，</span><br><span class="line">不同的是它传入的第一个参数是一个 React</span><br><span class="line">元素，而不是标签名或组件。</span><br><span class="line">新添加的属性会并入原有的属性，</span><br><span class="line">传入到返回的新元素中，而就的子元素奖杯替换。</span><br><span class="line"></span><br><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h1><p>React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。</p>
<h2 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass()"></a>React.createClass()</h2><p>React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Greeting &#x3D; React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h2><p>ES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Greeting extemds React.Component&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="无状态函数"><a href="#无状态函数" class="headerlink" title="无状态函数"></a>无状态函数</h1><p>无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。</p>
<h1 id="元素与组件的区别"><a href="#元素与组件的区别" class="headerlink" title="元素与组件的区别"></a>元素与组件的区别</h1><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="componentWillReceiveProps应用场景"><a href="#componentWillReceiveProps应用场景" class="headerlink" title="componentWillReceiveProps应用场景"></a>componentWillReceiveProps应用场景</h1><p>如果子组件需要的数据是直接由父组件通过props传递过来就不需要在componentwillreceiveprops中setState，但是如果子组件有自己的状态，同时这个状态依赖于父组件的数据，那么就需要子组件单独进行setState操作，否则无法完成子组件的更新。同时有一点，在componentwillreceiveprops中写setState不会再次触发子组件的render。解释一下：父组件setState时会触发子组件的render，此时如果在子组件的componentwillreceiveprops里setState，给人的感觉是会再一次触发子组件的render（加上前面的一次就是两次），实际情况是不会的</p>
<h1 id="vuex和redux使用有什么不同"><a href="#vuex和redux使用有什么不同" class="headerlink" title="vuex和redux使用有什么不同"></a>vuex和redux使用有什么不同</h1><p>Vuex 其实是一个针对 Vue 特化的 Flux，主要是为了配合 Vue 本身的响应式机制。当然吸取了一些 Redux 的特点，比如单状态树和便于测试和热重载的 API，但是也选择性的放弃了一些在 Vue 的场景下并不契合的特性，比如强制的 immutability（在保证了每一次状态变化都能追踪的情况下强制的 immutability 带来的收益就很有限了）、为了同构而设计得较为繁琐的 API、必须依赖第三方库才能相对高效率地获得状态树的局部状态等等（相比之下 Vuex 直接用 Vue 本身的计算属性就可以）所以 Vue + Vuex 会更简洁，也不需要考虑性能问题，代价就是 Vuex 只能和 Vue 配合。Vue + Redux 也不是不可以，但是 Redux 作为一个泛用的实现和 Vue 的契合度肯定不如 Vuex。</p>
<h1 id="nextTick的作用，原理，用api的场景"><a href="#nextTick的作用，原理，用api的场景" class="headerlink" title="nextTick的作用，原理，用api的场景"></a>nextTick的作用，原理，用api的场景</h1><p>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</p>
<p>也许有人会问，我在 Vue 实例方法中修改了数据，然后再在 $nextTick 回调中获取该数据在相应 DOM 元素所绑定的内容（或属性）殊无必要，我为什么需要这样的 API 呢？</p>
<p>考虑这样一种场景，你有一个 jQuery 插件，希望在 DOM 元素中某些属性发生变化之后重新应用该插件，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。</p>
<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</p>
<p>原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。</p>
<p>当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    example: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; modify data</span><br><span class="line">      this.message &#x3D; &#39;changed&#39;</span><br><span class="line">      &#x2F;&#x2F; DOM is not updated yet</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; DOM is now updated</span><br><span class="line">        &#x2F;&#x2F; &#96;this&#96; is bound to the current instance</span><br><span class="line">        this.doSomethingElse()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</p>
<h1 id="vue的props，state-compute区别"><a href="#vue的props，state-compute区别" class="headerlink" title="vue的props，state, compute区别"></a>vue的props，state, compute区别</h1><p>data: Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。</p>
<p>props: 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
<p>两个的区别就是data是响应式的？</p>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p>注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>
<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。</p>
<h1 id="react-native-和原生的怎么通信"><a href="#react-native-和原生的怎么通信" class="headerlink" title="react native 和原生的怎么通信"></a>react native 和原生的怎么通信</h1><h1 id="pure-component"><a href="#pure-component" class="headerlink" title="pure component"></a>pure component</h1><p>React15.3中新加了一个 PureComponent 类， 也就是纯组件，取代其前身 PureRenderMixin , PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，</p>
<p>可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。</p>
<h1 id="React-Native-与-原生交互"><a href="#React-Native-与-原生交互" class="headerlink" title="React Native 与 原生交互"></a>React Native 与 原生交互</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41dd77a83c13">链接</a></p>
<h1 id="vue-js-和vue-runtime-js区别"><a href="#vue-js-和vue-runtime-js区别" class="headerlink" title="vue.js 和vue.runtime.js区别"></a>vue.js 和vue.runtime.js区别</h1><p>vue.js</p>
<p>完整版：同时包含编译器和运行时的版本。</p>
<p>runtime.js</p>
<p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p>
<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p>
<h1 id="高阶组件？？-解决了什么问题"><a href="#高阶组件？？-解决了什么问题" class="headerlink" title="高阶组件？？ 解决了什么问题"></a>高阶组件？？ 解决了什么问题</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010371752">链接</a></p>
<p>适配器模式，</p>
<p>高阶函数的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。</p>
<p>对于高阶组件，它描述的便是接受React组件作为输入，输出一个新的React组件的组件。</p>
<p>高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的React组件，供其他组件调用。</p>
<p>高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用。</p>
<h1 id="setState源码剖析，多次调用解密"><a href="#setState源码剖析，多次调用解密" class="headerlink" title="setState源码剖析，多次调用解密"></a>setState源码剖析，多次调用解密</h1><p>setState流程还是很复杂的，设计也很精巧，<br>避免了重复无谓的刷新组件。它的主要流程如下</p>
<ol>
<li><p>enqueueSetState将state放入队列中，并调用enqueueUpdate处理要更新的Component</p>
</li>
<li><p>如果组件当前正处于update事务中，则先将Component存入dirtyComponent中。否则调用batchedUpdates处理。</p>
</li>
<li><p>batchedUpdates发起一次transaction.perform()事务<br>开始执行事务初始化，运行，结束三个阶段</p>
<p> 1 初始化：事务初始化阶段没有注册方法，故无方法要执行</p>
<p> 2 运行：执行setSate时传入的callback方法，一般不会传callback参数</p>
<p> 3 结束：更新isBatchingUpdates为false，并执行FLUSH_BATCHED_UPDATES这个wrapper中的close方法<br>FLUSH_BATCHED_UPDATES在close阶段，会循环遍历所有的dirtyComponents，调用updateComponent刷新组件，并执行它的pendingCallbacks, 也就是setState中设置的callback。</p>
</li>
</ol>
<p>会调用到batchedUpdates进行批处理更新，<br>React以事务的方式处理组件update，事务处理完后会调用wrapper.close(),</p>
<h1 id="react-diff"><a href="#react-diff" class="headerlink" title="react diff"></a>react diff</h1><p><a target="_blank" rel="noopener" href="https://github.com/purplebamboo/blog/issues/3">链接</a></p>
<p>三大要点</p>
<ul>
<li>tree diff<br>  两棵树只会对同一层次的节点进行比较。</li>
<li>component diff<br>  判断是否是同一类型组件</li>
<li>element diff<br>  同一节点 插入，删除，移动属性</li>
</ul>
<p>在reactjs中我们需要更新时都是调用的setState</p>
<p>setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。</p>
<p>就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新。</p>
<p>会合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了。</p>
<p>本质上还是递归调用receiveComponent的过程。</p>
<p>这里注意两个函数：</p>
<p>inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。</p>
<p>_shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。</p>
<p>==简单回顾下reactjs的差异算法：==</p>
<p>首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。</p>
<p>react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。</p>
<p>每个类型的元素都要处理好自己的更新：</p>
<p>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</p>
<p>text节点的更新很简单，直接更新文案。</p>
<p>浏览器基本元素的更新，分为两块：</p>
<p>先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。</p>
<p>然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。<br>整个reactjs的差异算法就是这个样子。</p>
<p>最核心的两个_shouldUpdateReactComponent以及diff,patch算法。</p>
<p>//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</p>
<p>_patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20346379?refer=purerender">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"></span><br><span class="line">React 通过制定大胆的 diff 策略，将 O(n3)</span><br><span class="line">复杂度的问题转换成 O(n) 复杂度的问题；</span><br><span class="line"></span><br><span class="line">React 通过分层求异的策略，对 tree diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">React 通过相同类生成相似树形结构，</span><br><span class="line">不同类生成不同树形结构的策略，</span><br><span class="line">对 component diff 进行算法优化；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">React 通过设置唯一 key的策略，</span><br><span class="line">对 element diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">建议，在开发组件时，保持稳定的 DOM</span><br><span class="line">结构会有助于性能的提升；</span><br><span class="line"></span><br><span class="line">建议，在开发过程中，尽量减少类似将最后一个节点移</span><br><span class="line">动到列表首部的操作，当节点数量过大或更新操作</span><br><span class="line">过于频繁时，在一定程度上会影响 React 的渲染性能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree diff</span><br><span class="line"></span><br><span class="line">React 对树的算法进行了简洁明了的优化，</span><br><span class="line">即对树进行分层比较，两棵树只会对同一层次的</span><br><span class="line">节点进行比较。</span><br><span class="line"></span><br><span class="line">component diff</span><br><span class="line"></span><br><span class="line">如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</span><br><span class="line"></span><br><span class="line">如果不是，则将该组件判断为 dirty component，</span><br><span class="line">从而替换整个组件下的所有子节点。</span><br><span class="line"></span><br><span class="line">对于同一类型的组件，有可能其 Virtual DOM</span><br><span class="line">没有任何变化，如果能够确切的知道这点那可以</span><br><span class="line">节省大量的 diff 运算时间，因此 React 允许用户通过</span><br><span class="line">shouldComponentUpdate() 来判断该组件是否需要进行 diff。</span><br><span class="line"></span><br><span class="line">element diff</span><br><span class="line"></span><br><span class="line">当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</span><br><span class="line"></span><br><span class="line">INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</span><br><span class="line"></span><br><span class="line">MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild&#x3D;nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</span><br><span class="line"></span><br><span class="line">REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</span><br><span class="line"></span><br><span class="line">React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。</span><br><span class="line"></span><br><span class="line">针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="设计组件"><a href="#设计组件" class="headerlink" title="设计组件"></a>设计组件</h1><p>组件尽量只做渲染，逻辑处理放到reducer中</p>
<h1 id="redux-中的action"><a href="#redux-中的action" class="headerlink" title="redux 中的action"></a>redux 中的action</h1><p>Action Creator 的唯一功能就是返回一个Action供 dispatch 进行调用。</p>
<p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件：</p>
<p>是一个纯文本对象</p>
<p>只具备 type 、payload、error 和 meta 中的一个或者多个属性。</p>
<p>type 字段不可缺省，其它字段可缺省</p>
<p>若 Action 报错，error 字段不可缺省，切必须为 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">在 redux 全家桶中，可以利用 redux-actions 来创建符合 FSA 规范的Action：</span><br><span class="line"></span><br><span class="line">import &#123;creatAction&#125; from &#39;redux-actions&#39;;</span><br><span class="line"></span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO)</span><br><span class="line">&#x2F;&#x2F;same as</span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO,data&#x3D;&gt;data)</span><br><span class="line"></span><br><span class="line">Redux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件：</span><br><span class="line"></span><br><span class="line">redux-thunk</span><br><span class="line">redux-promise</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用connect将组件绑定到redux</span><br><span class="line">export const ButtonContainer &#x3D; connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Buttons);</span><br><span class="line"></span><br><span class="line">容器组件实现 mapStateToProps()（用于将状态映射到数据）</span><br><span class="line">和 mapDispatchToProps()（用于将状态映射到行为）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</span><br><span class="line"></span><br><span class="line">操作发起时的 Action</span><br><span class="line">操作成功时的 Action</span><br><span class="line">操作失败时的 Action</span><br><span class="line"></span><br><span class="line">操作开始时，送出一个 Action，触发 State 更新为&quot;正在操作&quot;状态，View 重新渲染</span><br><span class="line"></span><br><span class="line">用户触发第一个 Action，这个跟同步操作一样，没有问题；</span><br><span class="line">如何才能在操作结束时，系统自动送出第二个 Action 呢？</span><br><span class="line"></span><br><span class="line">Action 是由store.dispatch方法发送的。</span><br><span class="line">而store.dispatch方法正常情况下，参数只能是对象，</span><br><span class="line">不能是函数。</span><br><span class="line"></span><br><span class="line">这时，就要使用中间件redux-thunk。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fetchPosts &#x3D; postTitle &#x3D;&gt; (dispatch, getState) &#x3D;&gt; &#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  return fetch(&#96;&#x2F;some&#x2F;API&#x2F;$&#123;postTitle&#125;.json&#96;)</span><br><span class="line">    .then(response &#x3D;&gt; response.json())</span><br><span class="line">    .then(json &#x3D;&gt; dispatch(receivePosts(postTitle, json)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法一</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;));</span><br><span class="line">&#x2F;&#x2F; 使用方法二</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;)).then(() &#x3D;&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">看这里，返回的是Promise，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>==用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。==</p>
<p>store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。</p>
<p>Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，</p>
<p>Redux的单向数据流是同步操作，驱动Redux流程的是action对象，每一个action对象被派发到Store上之后，同步地被分配给所有的reducer函数，每个reducer都是纯函数，纯函数不产生任何副作用，自然是完成数据操作之后立刻同步返回，reducer返回的结果又被同步地拿去更新Store上的状态数据，更新状态数据的操作会立刻被同步给监听Store状态改变的函数，从而引发作为视图的React组件更新过程。</p>
<p>这个过程从头到尾，Redux马不停蹄地一路同步执行，根本没有执行异步操作的机会，那应该在哪里插入访问服务器的异步操作呢？</p>
<p>Redux创立之初就意识到了这种问题，所以提供了thunk这种解决方法，但是thunk并没有作为Redux的一部分一起发布，而是存在一个独立的redux-thunk发布包中，</p>
<p>redux-thunk只是Redux中异步操作的解决方法之一</p>
<p>在Redux架构下，一个action对象在通过store.dispatch派发，在调用reducer函数之前，会先经过一个中间件的环节，这就是产生异步操作的机会，实际上redux-thunk提供的就是一个Redux中间件，我们需要在创建Store时用上这个中间件。</p>
<h1 id="异步action对象"><a href="#异步action对象" class="headerlink" title="异步action对象"></a>异步action对象</h1><h2 id="非常好的讲解"><a href="#非常好的讲解" class="headerlink" title="非常好的讲解"></a><a target="_blank" rel="noopener" href="http://geek.csdn.net/news/detail/202352">非常好的讲解</a></h2><p>当我们想要让Redux帮忙处理一个异步操作的时候，代码一样也要派发一个action对象，毕竟Redux单向数据流就是由action对象驱动的。但是这个引发异步操作的action对象比较特殊，我们叫它们“异步action对象”。</p>
<p>前面例子中的action构造函数返回的都是一个普通的对象，这个对象包含若干字段，其中必不可少的字段是type，但是“异步action对象”不是一个普通JavaScript对象，而是一个函数。</p>
<p>如果没有redux-thunk中间件的存在，这样一个函数类型的action对象被派发出来会一路发送到各个reducer函数，reducer函数从这些实际上是函数的action对象上是无法获得type字段的，所以也做不了什么实质的处理。</p>
<p>不过，有了redux-thunk中间件之后，这些action对象根本没有机会触及到reducer函数，在中间件一层就被redux-thunk截获。</p>
<p>redux-thunk的工作是检查action对象是不是函数，如果不是函数就放行，完成普通action对象的生命周期，而如果发现action对象是函数，那就执行这个函数，并把Store的dispatch函数和getState函数作为参数传递到函数中去，处理过程到此为止，不会让这个异步action对象继续往前派发到reducer函数。</p>
<p>举一个并不涉及网络API访问的异步操作例子，在Counter组件中存在一个普通的同步增加计数的action构造函数increment，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const increment &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  type: ActionTypes.INCREMENT,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>派发increment执行返回的action对象，Redux会同步更新Store状态和视图，但是我们现在想要创造一个功能，能够发出一个“让Counter组件在1秒之后计数加一”的指令，这就需要定义一个新的异步action构造函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const incrementAsync &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      dispatch(increment());</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">异步action构造函数incrementAsync返回的是一个新的函数，这样一个函数被dispatch函数派发之后，会被redux-thunk中间件执行，于是setTimeout函数就会发生作用，在1秒之后利用参数dispatch函数派发出同步action构造函数increment的结果。</span><br><span class="line"></span><br><span class="line">这就是异步action的工作机理，这个例子虽然简单，但是可以看得出来，异步action最终还是要产生同步action派发才能对Redux系统产生影响。</span><br><span class="line"></span><br><span class="line">redux-thunk要做的工作也就不过如此，但因为引入了一次函数执行，而且这个函数还能够访问到dispatch和getState，就给异步操作带来了可能。</span><br><span class="line"></span><br><span class="line">action对象函数中完全可以通过fetch发起一个对服务器的异步请求，当得到服务器结果之后，通过参数dispatch，把成功或者失败的结果当做action对象再派发出去。这一次派发的是普通的action对象，就不会被redux-thunk截获，而是直接被派发到reducer，最终驱动Store上状态的改变。</span><br><span class="line"></span><br><span class="line">通常我们在组件的componentDidMount函数中做请求服务器的事情，因为当生命周期函数componentDidMount被调用的时候，表明装载过程已经完成，组件需要渲染的内容已经在DOM树上出现，对服务器的请求可能依赖于已经渲染的内容，在componentDidMount函数中发送对服务器请求是一个合适的时机。</span><br><span class="line"></span><br><span class="line">fetch函数执行会立刻返回，返回一个Promise类型的对象，所以后面会跟上一大串then和catch的语句。每个Promise成功的时候，对应的then中的回调函数会被调用；如果失败，对应catch中的回调函数也被调用。</span><br><span class="line"></span><br><span class="line"># vue声明组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一、全局注册<br>// 注册<br>Vue.component(‘my-component’, {<br>  template: ‘<div>A custom component!</div>‘<br>})</p>
<p>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</p>
<p>用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？</p>
<p>// 创建根实例<br>new Vue({<br>  el: ‘#example’<br>})</p>
<p>二、局部注册<br>var Child = {<br>  template: ‘<div>A custom component!</div>‘<br>}</p>
<p>new Vue({<br>  // …<br>  components: {<br>    // <my-component> 将只在父组件模板中可用<br>    ‘my-component’: Child<br>  }<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 检测变化的注意事项</span><br><span class="line"></span><br><span class="line">Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</span><br><span class="line"></span><br><span class="line">Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</span><br><span class="line"></span><br><span class="line">Vue.set(vm.someObject, &#39;b&#39;, 2)</span><br><span class="line"></span><br><span class="line">this.$set(this.someObject,&#39;b&#39;,2)</span><br><span class="line"></span><br><span class="line">想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代替 &#96;Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)&#96;</span><br><span class="line">this.someObject &#x3D; Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># watch 深度监听</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;deep： true&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</span><br><span class="line"></span><br><span class="line">不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue &#x3D;&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    a: function (val, oldVal) {<br>      console.log(‘new: %s, old: %s’, val, oldVal)<br>    },<br>    // 方法名<br>    b: ‘someMethod’,<br>    // 深度 watcher<br>    c: {<br>      handler: function (val, oldVal) { /* … <em>/ },<br>      deep: true<br>    },<br>    // 该回调将会在侦听开始之后被立即调用<br>    d: {<br>      handler: function (val, oldVal) { /</em> … <em>/ },<br>      immediate: true<br>    },<br>    e: [<br>      function handle1 (val, oldVal) { /</em> … <em>/ },<br>      function handle2 (val, oldVal) { /</em> … <em>/ }<br>    ],<br>    // watch vm.e.f’s value: {g: 5}<br>    ‘e.f’: function (val, oldVal) { /</em> … */ }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 异步更新队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>this.$nextTick(function () {<br>    console.log(this.$el.textContent) // =&gt; ‘更新完成’<br>  })</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性 computed</span><br><span class="line"></span><br><span class="line">对于任何复杂逻辑，你都应当使用计算属性。</span><br><span class="line"></span><br><span class="line">当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;方法和计算属性：&#x3D;&#x3D; 两种方式的最终结果确实是完全相同的。</span><br><span class="line"></span><br><span class="line">不同的是计算属性是基于它们的依赖进行缓存的。</span><br><span class="line"></span><br><span class="line">计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage</span><br><span class="line">计算属性会立即返回之前的计算结果，而不必再次执行函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>computed: {<br>    // 计算属性的 getter<br>    reversedMessage: function () {<br>      // <code>this</code> 指向 vm 实例<br>      return this.message.split(‘’).reverse().join(‘’)<br>    }<br>}</p>
<p>  console.log(vm.reversedMessage) // =&gt; ‘olleH’<br>vm.message = ‘Goodbye’<br>console.log(vm.reversedMessage) // =&gt; ‘eybdooG’</p>
<p>// 在组件中<br>methods: {<br>  reversedMessage: function () {<br>    return this.message.split(‘’).reverse().join(‘’)<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性的 setter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// …<br>computed: {<br>  fullName: {<br>    // getter<br>    get: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>    },<br>    // setter<br>    set: function (newValue) {<br>      var names = newValue.split(‘ ‘)<br>      this.firstName = names[0]<br>      this.lastName = names[names.length - 1]<br>    }<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># watch 侦听器</span><br><span class="line"></span><br><span class="line">虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</span><br><span class="line"></span><br><span class="line">使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    // 如果 <code>question</code> 发生改变，这个函数就会运行<br>    question: function (newQuestion, oldQuestion) {<br>      this.answer = ‘Waiting for you to stop typing…’<br>      this.getAnswer()<br>    }<br>},</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># getters作用</span><br><span class="line"></span><br><span class="line">Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</span><br><span class="line"></span><br><span class="line">this.$store.getters.doneTodosCount</span><br><span class="line"></span><br><span class="line"># mapGetters 辅助函数</span><br><span class="line"></span><br><span class="line">mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</span><br><span class="line"></span><br><span class="line"># 提交 mutation 的另一种方式是直接使用包含 type 属性的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>store.commit({<br>  type: ‘increment’,<br>  amount: 10<br>})</p>
<p>store.commit(‘increment’, {<br>  amount: 10<br>})<br>可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，<br>或者使用 mapMutations 辅助函数将组件中的 methods<br>映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 分发 Action</span><br><span class="line"></span><br><span class="line">Action 通过 store.dispatch 方法触发：</span><br><span class="line"></span><br><span class="line">store.dispatch(&#39;increment&#39;)</span><br><span class="line"></span><br><span class="line"># vue组件类型, 怎么定义一个组件</span><br><span class="line"></span><br><span class="line"># vue切换路由</span><br><span class="line"></span><br><span class="line">其他方式 不留痕迹</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">一、router.push(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&lt;router-link :to&#x3D;&quot;...&quot;&gt; router.push(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const userId &#x3D; 123</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">二、 router.replace(location, onComplete?, onAbort?)</span><br><span class="line">跟 router.push 很像，唯一的不同就是，它不会向 history</span><br><span class="line">添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</span><br><span class="line"></span><br><span class="line">三、router.go(n)</span><br><span class="line">在 history 记录中向前或者后退多少步，</span><br><span class="line">类似 window.history.go(n)。</span><br></pre></td></tr></table></figure>

<h1 id="vue-router传参方式"><a href="#vue-router传参方式" class="headerlink" title="vue-router传参方式"></a>vue-router传参方式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">query 和params</span><br><span class="line"> &#123; <span class="attr">path</span>: <span class="string">&#x27;/news/:id&#x27;</span>, <span class="attr">component</span>: NewsDetail &#125;,</span><br><span class="line">      &lt;span&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line"><span class="number">1</span>、用法</span><br><span class="line">    query要用path来引入，params要用name来引入，</span><br><span class="line">    接收参数都是类似的，</span><br><span class="line">    分别是<span class="built_in">this</span>.$route.query.name和<span class="built_in">this</span>.$route.params.name。</span><br><span class="line"></span><br><span class="line">    接收参数时，已经是$route而不是$router了哦！！</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、展示</span><br><span class="line">　　query更加类似于我们ajax中get传参，params则类似于post，</span><br><span class="line">　　说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</span><br><span class="line"></span><br><span class="line">query:</span><br><span class="line">params:</span><br></pre></td></tr></table></figure>

<h1 id="受控组件-非受控组件"><a href="#受控组件-非受控组件" class="headerlink" title="受控组件 非受控组件"></a>受控组件 非受控组件</h1><h1 id="没有任何嵌套关系的组件之间传值"><a href="#没有任何嵌套关系的组件之间传值" class="headerlink" title="没有任何嵌套关系的组件之间传值"></a>没有任何嵌套关系的组件之间传值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(1) Event Emitter&#x2F;Target&#x2F;Dispatcher</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.addEventListener(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.dispatchEvent(‘click’);</span><br><span class="line"></span><br><span class="line">(2) Publish &#x2F; Subscribe</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">globalBroadcaster.subscribe(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">globalBroadcaster.publish(‘click’);</span><br><span class="line"></span><br><span class="line">(3) Signals</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.clicked.add(function() &#123; alert(‘click’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.clicked.dispatch();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="this-setState-参数"><a href="#this-setState-参数" class="headerlink" title="this.setState()参数"></a>this.setState()参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这个函数接受两个参数，</span><br><span class="line">第一个参数表示上一个状态值，</span><br><span class="line">第二参数表示当前的 props，</span><br><span class="line">第二个参数是 state 导致的页面变化完成后的回调，等价于componentDidUpdate。</span><br><span class="line"></span><br><span class="line">this.setState((prevState, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">setState的关键点:</span><br><span class="line"></span><br><span class="line">setState不会立刻改变React组件中state的值；</span><br><span class="line">setState通过引发一次组件的更新过程来引发重新绘制；</span><br><span class="line">多次setState函数调用产生的效果会合并。</span><br><span class="line"></span><br><span class="line">当setState被调用时，能驱动组件的更新过程，引发componentDidUpdate、render等一系列函数的调用。</span><br></pre></td></tr></table></figure>

<h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><p>主要分为三段，mount（挂载）、update（更新）、unmount（卸载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">一、mount，即挂载阶段，</span><br><span class="line">    第一次让组件出现在页面中的过程，React会将render的返回值插入到页面中，</span><br><span class="line">    这个过程会暴露以下几个钩子（hook）：</span><br><span class="line"></span><br><span class="line">    constructor()       &#x2F;&#x2F; 初始化props和state</span><br><span class="line"></span><br><span class="line">    　　初始化getDefaultProps()和getInitialState()</span><br><span class="line"></span><br><span class="line">    　　getDefaultProps: 执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的</span><br><span class="line">这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制</span><br><span class="line"></span><br><span class="line">getInitialState : 控件加载之前执行，返回值会被用于state的初始化值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    　　初始化</span><br><span class="line">    componentWillMount()    &#x2F;&#x2F; 将要被插入</span><br><span class="line"></span><br><span class="line">    执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次</span><br><span class="line"></span><br><span class="line">    render()    &#x2F;&#x2F; 将return的内容插入到页面里</span><br><span class="line">    componentDidMount()   &#x2F;&#x2F; 插入完成后的动作</span><br><span class="line">        在组件被装配后立即调用。</span><br><span class="line">        初始化使得DOM节点应该进行到这里。</span><br><span class="line">        若你需要从远端加载数据，</span><br><span class="line">        这是一个适合实现网络请求的地方。</span><br><span class="line">        在该方法里设置状态将会触发重渲。</span><br><span class="line"></span><br><span class="line">二、update，即更新阶段，如果数据有任何变动就会来这一阶段，这个过程有5个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillReceiveProps( nextprops )   &#x2F;&#x2F; 接受需要更新的props</span><br><span class="line">    　　在装配了的组件接收到新属性前调用。</span><br><span class="line">    　　若你需要更新状态响应属性改变（例如，重置它），</span><br><span class="line">    　　你可能需对比this.props和nextProps</span><br><span class="line">    　　并在该方法中使用this.setState()处理状态改变。</span><br><span class="line"></span><br><span class="line">    注意即使属性未有任何改变，React可能也会调用该方法，因此若你想要处理改变，请确保比较当前和之后的值。这可能会发生在当父组件引起你的组件重渲。</span><br><span class="line"></span><br><span class="line">　　shouldComponentUpdate( nextProps, nextState )   &#x2F;&#x2F; 请问要不要更新组件 true&#x2F;false</span><br><span class="line"></span><br><span class="line">        接收到新属性或状态时，</span><br><span class="line">        shouldComponentUpdate() 在渲染前被调用。默认为true。</span><br><span class="line">        该方法并不会在初始化渲染或当使用forceUpdate()时被调用。</span><br><span class="line">        当他们状态改变时，返回false 并不能阻止子组件重渲。</span><br><span class="line">        若shouldComponentUpdate()返回false，componentWillUpdate()将不会被调用。</span><br><span class="line">　　componentWillUpdate()  &#x2F;&#x2F; 准备更新组件啦</span><br><span class="line"></span><br><span class="line">　　render() &#x2F;&#x2F; 更新</span><br><span class="line"></span><br><span class="line">　　componentDidUpdate()   &#x2F;&#x2F; 更新完成</span><br><span class="line">    该方法并不会在初始化渲染时调用。</span><br><span class="line">三、unmount，即卸载过程，当一个组件要从页面移除时，会进入这个过程，其中有一个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillUnmount()    &#x2F;&#x2F; 要卸载啦</span><br><span class="line">    可以在该方法里处理任何必要的清理工作，</span><br><span class="line">    例如解绑定时器，取消网络请求，</span><br><span class="line">    清理任何在componentDidMount环节创建的DOM元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一般我们只在这几个钩子里setState：</span><br><span class="line"></span><br><span class="line">componentWillMount()</span><br><span class="line"></span><br><span class="line">componentDidMount()</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redux原理"><a href="#Redux原理" class="headerlink" title="Redux原理"></a>Redux原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Redux 和 React 没有直接关系，</span><br><span class="line">它瞄准的目标是应用状态管理。</span><br><span class="line"></span><br><span class="line">核心概念是 Map&#x2F;Reduce 中的 Reduce。</span><br><span class="line">且 Reducer 的执行是同步，</span><br><span class="line">产生的 State 是 Immutable 的。</span><br><span class="line"></span><br><span class="line">改变 State 只能通过向 Reducer dispatch actions 来完成。</span><br><span class="line"></span><br><span class="line">State 的不同字段，可以通过不同的 Reducers 来分别维护。</span><br><span class="line">combineReducers 负责组合这些 Reducers，</span><br><span class="line">前提是每个 Reducer 只能维护自己关心的字段。</span><br><span class="line"></span><br><span class="line">Action 对象只能是 Javascript Plain Object，</span><br><span class="line">但是通过在 store 上装载 middleware，</span><br><span class="line">则可以任意定义 action 对象的形式，</span><br><span class="line">反正会有特定的 middleware 负责</span><br><span class="line">将此 action 对象变为 Javascript Plain Object。</span><br><span class="line"></span><br><span class="line">可以以middleware 链条为集中点实现很多控制逻辑，</span><br><span class="line">例如 Log，Undo, ErrorHandler 等。</span><br><span class="line"></span><br><span class="line">Redux 仅仅专注于应用状态的维护，</span><br><span class="line">reducer、dispatch&#x2F;middleware 是两个常用扩展点、</span><br><span class="line">Higher-order Store 则仅针对需要扩展全部 Store 功能时使用。</span><br><span class="line"></span><br><span class="line">react-redux 是 Redux 针对 React&#x2F;React-Native 的 Binding，</span><br><span class="line">connect&#x2F;selector 是扩展点，</span><br><span class="line">负责将 store 中的状态添加到 React component 的 props 中。</span><br><span class="line"></span><br><span class="line">Redux 借用了很多函数式编程的思想，</span><br><span class="line">了解函数式编程会利于理解其实现原理，</span><br><span class="line">虽然使用它不需要了解很多函数式编程的概念。</span><br><span class="line">和 Flux 相比，Redux 的概念更精简、约定更严格、状态更确定、而是扩展却更灵活。</span><br><span class="line"></span><br><span class="line">通过 https:&#x2F;&#x2F;github.com&#x2F;xgrommx&#x2F;awesome-redux 可以获得大量参考。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;3334467e4b32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redux有三大准则</span><br><span class="line"></span><br><span class="line">单一数据源</span><br><span class="line">整个应用状态，都应该被存储在单一store的对象树中。</span><br><span class="line"></span><br><span class="line">只读状态</span><br><span class="line">唯一可以修改状态的方式，</span><br><span class="line">就是发送（dispatch）一个动作（Action），</span><br><span class="line">通俗来讲，就是说只有getter，没有setter。</span><br><span class="line"></span><br><span class="line">使用纯函数去修改状态</span><br><span class="line">纯函数保障了状态的稳定性，</span><br><span class="line">不会因不同环境导致应用程序出现不同情况，</span><br><span class="line">听说是redux真正的精髓，日后可以深入了解。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="谈谈MVVM模式"><a href="#谈谈MVVM模式" class="headerlink" title="谈谈MVVM模式"></a>谈谈MVVM模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</span><br><span class="line"></span><br><span class="line">DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</span><br><span class="line"></span><br><span class="line">MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</span><br><span class="line"></span><br><span class="line">在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</span><br><span class="line"></span><br><span class="line">ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-mvvm和mvc区别"><a href="#2-mvvm和mvc区别" class="headerlink" title="2:mvvm和mvc区别"></a>2:mvvm和mvc区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvc和mvvm其实区别并不大。都是一种设计思想。</span><br><span class="line">主要就是mvc中Controller演变成mvvm中的viewModel。</span><br><span class="line">mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，</span><br><span class="line">加载速度变慢，影响用户体验。</span><br><span class="line">和当 Model 频繁发生变化，开发者需要主动更新到View 。</span><br></pre></td></tr></table></figure>

<h1 id="让CSS只在当前组件中起作用"><a href="#让CSS只在当前组件中起作用" class="headerlink" title="让CSS只在当前组件中起作用"></a>让CSS只在当前组件中起作用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将当前组件的&lt;style&gt;修改为&lt;style scoped&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Vue中使用插件的步骤"><a href="#Vue中使用插件的步骤" class="headerlink" title="Vue中使用插件的步骤"></a>Vue中使用插件的步骤</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件</span><br><span class="line">使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, &#123; someOption: true &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件的使用和自己创建公用组件"><a href="#组件的使用和自己创建公用组件" class="headerlink" title="组件的使用和自己创建公用组件"></a>组件的使用和自己创建公用组件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步：在components目录新建你的组件文件（indexPage.vue），</span><br><span class="line">    script一定要export default &#123;&#125;</span><br><span class="line">第二步：在需要用的页面（组件）中导入：</span><br><span class="line">    import indexPage from &#39;@&#x2F;components&#x2F;indexPage.vue&#39;</span><br><span class="line">第三步：注入到vue的子组件的components属性上面,components:&#123;indexPage&#125;</span><br><span class="line">第四步：在template视图view中使用，</span><br><span class="line">问题有indexPage命名，使用的时候则index-page。</span><br></pre></td></tr></table></figure>

<h1 id="vue如何实现按需加载配合webpack设置"><a href="#vue如何实现按需加载配合webpack设置" class="headerlink" title="vue如何实现按需加载配合webpack设置"></a>vue如何实现按需加载配合webpack设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。</span><br><span class="line">不进行页面按需加载引入方式：import  home   from &#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;</span><br><span class="line">进行页面按需加载的引入方式：const  home &#x3D; r &#x3D;&gt; require.ensure( [], () &#x3D;&gt; r (require(&#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;)))</span><br></pre></td></tr></table></figure>

<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a><keep-alive></keep-alive>作用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</span><br></pre></td></tr></table></figure>

<h1 id="vue-route模式"><a href="#vue-route模式" class="headerlink" title="vue-route模式"></a>vue-route模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">默认为hash，但是用hash模式的话，页面地址会加#</span><br><span class="line"></span><br><span class="line">所以一般采用 history模式</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># vue阻止事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　.stop 阻止事件冒泡<br>　.prevent 阻止默认事件<br>　.capture　阻止事件捕获<br>　.once 只触发一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># router传参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>routes: [<br>    {<br>        path: ‘/linkParams/:name’,<br>        name:’linkParams’,<br>        component: linkParams<br>    }<br>]</p>
<p>获取name</p>
<p>let name = this.$route.params.name</p>
<p>// 字符串,这里的字符串是路径path匹配噢，不是router配置里的name<br>this.$router.push(‘home’)</p>
<p>// 对象<br>this.$router.push({ path: ‘home’ })</p>
<p>// 命名的路由 这里会变成 /user/123<br>this.$router.push({ name: ‘user’, params: { userId: 123 }})</p>
<p>// 带查询参数，变成 /register?plan=private<br>this.$router.push({ path: ‘register’, query: { plan: ‘private’ }})</p>
<p>router.beforeEach((to, from, next)=&gt;{<br>  //do something<br>  next();<br>});<br>router.afterEach((to, from, next) =&gt; {<br>    console.log(to.path);<br>});</p>
<p>每个钩子方法接收三个参数：</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p>
<p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
<p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
<p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SSR实现原理</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。<br>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。<br>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。<br>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端。</p>
<p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue实例初始化的过程中实现依赖管理的分析</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com&#x2F;a&#x2F;vue&#x2F;2018&#x2F;0301&#x2F;1795.html)</span><br><span class="line"></span><br><span class="line">大致的总结下就是：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initState的过程中，<br>将props,computed,data等属性通过Object.defineProperty<br>来改造其getter/setter属性，<br>并为每一个响应式属性实例化一个observer观察者。<br>这个observer内部dep记录了这个响应式属性的所有依赖。</p>
<p>当响应式属性调用setter函数时，<br>通过dep.notify()方法去遍历所有的依赖，<br>调用watcher.update()去完成数据的动态响应。</p>
<p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，<br>通过Object.defineProperty()来劫持各个属性的setter，getter，<br>在数据变动时发布消息给订阅者，<br>触发相应的监听回调。</p>
<p>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，<br>包括子属性对象的属性，<br>都加上 setter和getter<br>这样的话，<br>给这个对象的某个值赋值，就会触发setter，<br>那么就能监听到了数据变化</p>
<p>第二步：compile解析模板指令，<br>将模板中的变量替换成数据，<br>然后初始化渲染页面视图，<br>并将每个指令对应的节点绑定更新函数，<br>添加监听数据的订阅者，一旦数据有变动，<br>收到通知，更新视图</p>
<p>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，<br>主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，<br>能调用自身的update()方法，<br>并触发Compile中绑定的回调，则功成身退。</p>
<p>第四步：MVVM作为数据绑定的入口，<br>整合Observer、Compile和Watcher三者，<br>通过Observer来监听自己的model数据变化，<br>通过Compile来解析编译模板指令，<br>最终利用Watcher搭起Observer和Compile之间的通信桥梁，<br>达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue声明组件的state是用data方法，那为什么data是通过一个function来返回一个对象，而不是直接写一个对象呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：从语法上说，如果不用function返回就会出现语法错误导致编译不通过。从原理上的话，大概就是组件可以被多次创建，如果不使用function就会使所有调用该组件的页面公用同一个数据域，这样就失去了组件的概念了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># vuex</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> State、 Getter、Mutation 、Action、 Module<br>通过状态（数据源）集中管理驱动组件的变化<br>（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中；<br>改变状态的方式是提交mutations，<br>这是个同步的事物； 异步逻辑应该封装在action中。</p>
<p>一、Action 类似于 mutation，不同在于：<br>二、Action 提交的是 mutation，而不是直接变更状态。<br>三、Action 可以包含任意异步操作</p>
<p>一、getters 可以对State进行计算操作，它就是Store的计算属性<br>二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>三、 如果一个状态只在一个组件内使用，是可以不用getters</p>
<p>二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 说下vue组件之间的通信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：<br>非父子组件间通信，Vue 有提供 Vuex，以状态共享方式来实现通信</p>
<p>prop 向下传递，事件向上传递。<br>还可以通过$emit方法出发一个消息，然后$on接收这个消息</p>
<p>兄弟组件间的数据通讯，它们将会 寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法 。</p>
<p>var Event = new Vue()<br>//父组件<br> Event.$on(“a-msg”, function (a) {<br>    this.a = a;<br>  }.bind(this));</p>
<p>// 子组件<br> Event.$emit(“a-msg”, this.a);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue 生命周期</span><br><span class="line"></span><br><span class="line"># 简单描述每个周期具体适合哪些场景</span><br><span class="line"></span><br><span class="line">Create  Mount  Update  Destroy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>beforeCreate（创建前）,<br>created（创建后）,</p>
<p>beforeMount(载入前),<br>mounted（载入后）,</p>
<p>beforeUpdate（更新前）,<br>updated（更新后）,</p>
<p>beforeDestroy（销毁前）,<br>destroyed（销毁后）</p>
<p>每个钩子函数都在啥时间触发</p>
<p>beforeCreate<br>在实例初始化之后，<br>数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>
<p>created<br>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>beforeMount<br>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p>mounted<br>挂载元素，获取到DOM节点<br>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。<br>如果 root 实例挂载了一个文档内元素，<br>当 mounted 被调用时 vm.$el 也在文档内。</p>
<p>beforeUpdate<br>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p>updated<br>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。<br>然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<p>beforeDestroy<br>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p>destroyed<br>Vue 实例销毁后调用。<br>调用后，Vue 实例指示的所有东西都会解绑定，<br>所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
<p>生命周期钩子的一些常见使用方法：</p>
<p>beforecreate : 可以在这加个loading事件，<br>在加载实例时触发</p>
<p>created : 初始化完成时需要执行的事件写在这里，<br>如在这结束loading事件，异步请求也适宜在这里调用</p>
<p>mounted: 在这发起后端请求，拿回数据，配合路由钩子做一些事情</p>
<p>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框 你确认删除XX吗？<br>nextTick : 更新数据后立即操作dom<br>activated::keep-alive组件激活时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># v-show和v-if指令的共同点和不同点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏<br>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</p>
<p>v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。<br>因此，如果需要频繁切换 v-show 较好，<br>如果在运行时条件不大可能改变 v-if 较好。</p>
<p>1.v-if 指令可以应用于template包装元素上，<br>而v-show不支持template<br>2.将v-show应用在组件上时，因为指令的优先级<br>v-else 会出现问题，<br>解决办法就是用另一个 v-show 替换 v-else</p>
<p>// 错误<br><custom-component v-show="condition"></custom-component></p>
<p v-else>这可能也是一个组件</p>
     // 正确做法
<custom-component v-show="condition"></custom-component>
<p v-show="!condition">这可能也是一个组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># vue 父子组件嵌套时，组件内部的各个生命周期钩子触发先后顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
顺序是 先创建父组件(父组件beforeMount)，然后才创建子组件，当子组件创建完成并且实体dom挂载完成后(子组件先mounted)父组件才挂载完成(父组件mounted)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># h函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
它来自单词 hyperscript，
这个单词通常用在 virtual-dom 的实现中。
Hyperscript 本身是指

<p>生成HTML 结构的 script 脚本，<br>因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言）</p>
<p>个人理解：<br>createElement 函数是用来生成 HTML DOM<br>元素的，也就是上文中的 generate HTML<br>structures，也就是 Hyperscript，<br>这样作者才把 createElement 简写成 h。</p>
<p>大概的翻译下：<br>render: h =&gt; h(App) 是下面内容的缩写：</p>
<p>render: function (createElement) {<br>    return createElement(App);<br>}<br>进一步缩写为(ES6 语法)：</p>
<p>render (createElement) {<br>    return createElement(App);<br>}<br>再进一步缩写为：</p>
<p>render (h){<br>    return h(App);<br>}<br>按照 ES6 箭头函数的写法，就得到了：</p>
<p>render: h =&gt; h(App);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># react-redux中connect函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010188279)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>connect方法做的事情是<br>将state和dispatch绑定到Connect组件的参数上，<br>然后Connect组件将你当前的App组件封装起来，<br>使得App组件可以通过props获取到父<br>组件Connect传递的state和props。</p>
<p>Provider是顶层组件的作用，<br>将store作为上下文提供给全局共享，<br>而Connect组件是局部组件，将某个react组件包装起来，<br>传递指定的state和props给该组件访问。</p>
<p>connect()返回值是Connect组件（请注意大小写的区别）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue和React区别</span><br><span class="line"></span><br><span class="line">### 相同</span><br><span class="line"></span><br><span class="line">- 使用 Virtual DOM</span><br><span class="line">- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</span><br><span class="line">- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</span><br><span class="line"></span><br><span class="line">都是JavaScript的UI框架，专注于创造前端的富应用。</span><br><span class="line">不同于早期的JavaScript框架“功能齐全”，</span><br><span class="line"></span><br><span class="line">### 区别</span><br><span class="line"></span><br><span class="line">- **性能**</span><br><span class="line"></span><br><span class="line">    计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。</span><br><span class="line"></span><br><span class="line">    Vue可以更快地计算出Virtual DOM的差异，</span><br><span class="line">    这是由于它在渲染过程中，</span><br><span class="line">    会跟踪每一个组件的依赖关系，</span><br><span class="line">    不需要重新渲染整个组件树。</span><br><span class="line"></span><br><span class="line">    而对于React而言，每当应用的状态被改变时，</span><br><span class="line">    全部子组件都会重新渲染。</span><br><span class="line">    当然，这可以通过shouldComponentUpdate</span><br><span class="line">    这个生命周期方法来进行控制，</span><br><span class="line">    但Vue将此视为默认的优化。</span><br><span class="line"></span><br><span class="line">- **JSX和Templates**</span><br><span class="line"></span><br><span class="line">    React 中，所有的组件的渲染功能都依靠 JSX</span><br><span class="line">    可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。</span><br><span class="line"></span><br><span class="line">    模板比起 JSX 读写起来更自然。</span><br><span class="line">    基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。</span><br><span class="line">    可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。</span><br><span class="line"></span><br><span class="line">    vue的模板语法去除了往视图&#x2F;组件中添加逻辑的诱惑，保持了关注点分离。</span><br><span class="line"></span><br><span class="line">    与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已。</span><br><span class="line"></span><br><span class="line">- **组件作用域内的 CSS**</span><br><span class="line"></span><br><span class="line">    Vue 设置样式的默认方法是单文件组件里类似 style 的标签。</span><br><span class="line">    可选 scoped 属性会自动添加一个唯一的属性</span><br><span class="line"></span><br><span class="line">    CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的</span><br><span class="line"></span><br><span class="line">- **Props**</span><br><span class="line"></span><br><span class="line">    JSX库中，数据通过props传到子组件中去。</span><br><span class="line"></span><br><span class="line">    在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”</span><br><span class="line"></span><br><span class="line">    在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。</span><br><span class="line"></span><br><span class="line">- **构建工具**</span><br><span class="line"></span><br><span class="line">    React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。</span><br><span class="line"></span><br><span class="line">- **配套框架**</span><br><span class="line"></span><br><span class="line">    Vue的核心团队维护着vue-router和vuex，</span><br><span class="line">    它们由官方维护支持且与核心库同步更新的。</span><br><span class="line">    而React的react-router和react-redux则是由社区成员维护，</span><br><span class="line">    创建了一个更分散的生态系统</span><br><span class="line"></span><br><span class="line">- **向下扩展**</span><br><span class="line"></span><br><span class="line">    React 学习曲线陡峭，学 React 前，你需要知道 JSX 和 ES2015，</span><br><span class="line"></span><br><span class="line">- **原生渲染**</span><br><span class="line"></span><br><span class="line">    Weex 还在积极发展，成熟度也不能和 React Native 相抗衡。</span><br><span class="line"></span><br><span class="line">&lt;https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5a9b8417518825558251ce15&gt;</span><br><span class="line"></span><br><span class="line"># redux原理</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000004236064)</span><br><span class="line"></span><br><span class="line"># redux流程</span><br><span class="line"></span><br><span class="line">[Redux 入门教程](http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;2016&#x2F;09&#x2F;redux_tutorial_part_one_basic_usages.html)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// store<br>// Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>//数据集合，就叫做 State<br>const state = store.getState();</p>
<p>// Action Creator定义一个函数来生成 Action<br>const ADD_TODO = ‘添加 TODO’;</p>
<p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p>
<p>const action = addTodo(‘Learn Redux’);</p>
<p>//store.dispatch()是 View 发出 Action 的唯一方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>store.dispatch({<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>});</p>
<p>store.dispatch(addTodo(‘Learn Redux’));</p>
<p>//Reducer State 的计算过程就叫做 Reducer。<br>接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<p>const reducer = function (state, action) {<br>  // …<br>  return new_state;<br>};</p>
<p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }<br>};</p>
<p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2<br>});</p>
<p>Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p>
<p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p>
<p>reducer最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<p>不得改写参数<br>不能调用系统 I/O 的API<br>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</p>
<p>必须返回一个全新的对象<br>// State 是一个对象<br>function reducer(state, action) {<br>  return Object.assign({}, state, { thingToChange });<br>  // 或者<br>  return { …state, …newState };<br>}</p>
<p>// State 是一个数组<br>function reducer(state, action) {<br>  return […state, newItem];<br>}</p>
<pre><code></code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">believeZJP</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">758k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:29</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
