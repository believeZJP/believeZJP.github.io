<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>一问一答</title>
    <style type="text/css">
    body {
        padding: 5px;
        font-family: "microsoft yahei";
    }
    p,pre {
        margin: 0;
        border: 0;
    }
    .start-up-code {
        padding-left: 15px;
        padding-top: 15px;
        padding-bottom: 15px;
        width: 80%;
        margin: 0 auto;
    }
    .start-up-code > p {
        background-color: #E18728;
        padding-left: 10px;
        font-size: 18px;
        font-weight: bold;
        line-height: 2;
        color: white;
    }
    .start-up-code > pre {
        padding-left: 5px;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        webkit-box-sizing: border-box;
        display: block;
        white-space: pre-wrap;
        white-space: -moz-pre-wrap;
        white-space: -pre-wrap;
        white-space: -o-pre-wrap;
        word-wrap: break-word;
        width: 100%;
        overflow-x: auto;
        background-color: #FFFAE8;
        /*background-color: #1D1F21;*/
        color: #3E4B53;
        line-height: 1.5;
        font-size: 16px;
        font-weight: bold;
        /*letter-spacing: 1px;*/
        font-family: "microsoft yahei", Times, serif;
    }
    </style>
</head>

<body>
    <br />
    <hr width="80%" />
    <div class="start-up-code">
        <P>疑难解惑</P>
        <pre>
			<code>
				
1.caller和callee的区别
	答：<a href="http://blog.csdn.net/laijieyao/article/details/43404953" target="_blank">查看</a>
	caller
	caller返回一个函数的引用，这个函数调用了当前的函数。
	使用这个属性要注意:
	1 这个属性只有当函数在执行时才有用
	2 如果在javascript程序中，函数是由顶层调用的，则返回null
	
	functionName.caller: functionName是当前正在执行的函数。
	
	var a = function() { 
		console.log(a.caller); 
	} 
	var b = function() { 
		a(); 
	} 
	b();	
	
	上面的代码中，b调用了a，那么a.caller返回的是b的引用，可运行查看结果。
	如果直接调用a(即a在任何函数中被调用，也就是顶层调用),返回null:
	
	callee
	callee放回正在执行的函数本身的引用，它是arguments的一个属性
	使用callee时要注意:
	1 这个属性只有在函数执行时才有效
	2 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length
	3 它可以用来递归匿名函数。
	
	var a = function() { 
		console.log(arguments.callee); 
	} 
	var b = function() { 
		a(); 
	} 
	b();
	
	a在b中被调用，但是它返回了a本身的引用，可运行查看结果。
	
	<hr />
2.为什么有的轮巡技术会使用setTimeOut,而不是用setInterval
	答：
	   http://www.tuicool.com/articles/BV7viq
	       轮询请求如果不需要等待结果返回，那么完全可以使用setInterval来发起定时请求。
	       但很显然长轮询是需要等待结果返回，然后再次发起请求的。
	       轮询本质就是递归，递归和循环可是两码事。
		
		function test() {
		    var date = new Date();
		    console.log("test:" + date.getMinutes() + ':' + date.getSeconds() + ':' + date.getMilliseconds());
		}
		var num = 0;
		var i = setTimeout(function() {
		    num++;
		    test();
		    //var date = new Date();
		    //console.log("间隔：" + date.getMinutes() + ':' + date.getSeconds() + ':' + date.getMilliseconds());
		    if (num <= 10) {
		        i = setTimeout(arguments.callee, 1000);//关键
		    }
		    
		}, 1000);
		
		//这样数出来是每隔2s输出一次，
		//1000都改成500是每隔1s都输出一次
3.javascript是多线程吗?
	答：javascript只有单线程，不存在同时执行！！！！	
		JS采用一种队列(event loop)的机制来处理各个事件.
		比如用户的点击，ajax异步请求,所有的事件都被放入一个队列中，然后先进先出，逐个执行。
		
		另一方面，浏览器还有一个GUI渲染线程，当需要重绘页面时渲染页面。
		但问题是GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，
		GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

		所以,在脚本中执行对界面进行更新操作,如添加结点,删除结点或改变结点的外观等更新并不会立即体现出来,
		这些操作将保存在一个队列中,待JavaScript引擎空闲时才有机会渲染出来.
		
4.live,bind,click ,delegate区别		
		答：bind( )方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。
  			  live( )方法将一个事件处理程序附加到与当前选择器匹配的所有元素
  			  	（包含现有的或将来添加的）的指定事件上并返回jQuery对象。
			  one()方法将事件处理程序附加到匹配元素的指定事件并返回jQuery对象。
				所附加的事件处理程序最多只能执行一次。
			  delegate()方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素
			  （现有的或将来的）的一个或多个事件上。
			
			区别：
				bind方法只能给当前存在的元素绑定事件，对于事后采用JS等方式新生成的元素无效，
				而live方法则正好弥补了bind方法的这个缺陷，它可以对后生成的元素也可以绑定相应的事件。
				原理实现？---→<a href="http://www.jb51.net/article/40838.htm" target="_blank">点我</a>
				
			delegate比live好用的优点：
				速度、灵活性和链能力、　live仅支持CSS选择器
				<a href="http://justcoding.iteye.com/blog/1457883" target="_blank">详细内容，点我</a>
			
6、写出程序运行的结果？
	alert(typeof(null))      object
	alert(typeof(undefined))    undefined
	alert(typeof(NaN))				number
	alert(NaN == undefined)				false
	
	var str = "123abc"
	alert(typeof(str++))			number	//此时输出str++为NaN
	alert(str)							NaN
	
	-----------------------
	var x =1,y=z=0;
	function add(n){
		return n = n + 1;
	}
	y = add(x);		//2
	z = add(x);		//2
	--------------------
	var myObject = {
		num:2,
		add:function(){
			this.num = 3;
			(function(){
				alert(this.num);			//undefined
				this.num = 4;
			})();
			alert(this.num);				//3
		}
	}
	myObject.add();//先 是undefined，然后是3
	-------------------------
	
	var i =0;
	for(i =0;i++<3;){
		setTimeout(function(){
			return function(){console.log(i);}
		}(),0);
	}
	//输出23，3个4，继续执行输出26，3个4；

    typeof 会返回几种类型
	    typeof(1): number
		typeof(NaN): number
		typeof(Number.MIN_VALUE): number
		typeof(Infinity): number
		typeof("123"): string
		typeof("abc")	//string
		typeof(undefined): undefined
		typeof(abc) 		//undefined
		typeof(true): boolean
		typeof(null)					//object

		typeof(window): object
		typeof(document): object
		typeof(eval): function
		typeof(Date): function
		typeof(function(){})		//function
		typeof([1,2,3])				//object
		typeof(new Number(8))	//object

8、写出一个给数组排重的函数
		function unique(arr) {
		  var ret = []
		  var hash = {}
		
		  for (var i = 0; i < arr.length; i++) {
		    var item = arr[i]
		    var key = typeof(item) + item
		    if (hash[key] !== 1) {
		      ret.push(item)
		      hash[key] = 1
		    }
		  }
		
		  return ret;
		}

			
			
			
			
			
			</code>
		</pre>
    </div>
</body>

</html>
