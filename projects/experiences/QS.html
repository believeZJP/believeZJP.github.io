<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>一问一答</title>
    <!--
    	作者：421790588@qq.com
    	时间：2016-05-13
    	描述：
    	页面架构设计：
    		1.问题 	h2
    		2.答案---｛
						2-1.文字	.desc
						2-2.代码	.codeArea
    -->
    <style type="text/css">
    body {
        padding: 5px;
        font-family: "microsoft yahei";
        font-size:14px;
    }
    p,pre {
        margin: 0;
        border: 0;
    }
    code{
    	display: block;
    }
    h2{
	    border: 2px solid #2BCC18;
   		padding: 1em;
    	margin: 0;
    }
    .con {
        padding-left: 1.5em;
        padding-top: 1.5em;
        padding-bottom: 1.5em;
        width:98%;
        margin: 0 auto;
    }
    .con > p {
        background-color: #E18728;
        padding-left: 1em;
        font-size: 1.8em;
        font-weight: bold;
        line-height: 2;
        color: #FFF;
    }
    .desc {
        display: block;
        white-space: pre-wrap;
        word-wrap: break-word;
        width: 100%;
        overflow-x: auto;
        background-color: #FFFAE8;
        color: #3E4B53;
        line-height: 1.5em;
        font-size: 1.5em;
        font-weight: bold;
        font-family: "microsoft yahei", Times, serif;
    }
    .codeArea{
    	background-color: #1D1F21;
    	color: #FFF;
        line-height: 1.4em;
        padding-left: 0.5em;
    }
    
@media only screen and (min-width : 320px) {
	.desc,.code{
		font-size: 1.1em;
	}   
}	
@media(min-width:480px){
	.desc,.code{
		font-size: 1.1em;
	}   	
}
@media screen and (min-width: 768px) {
	.desc,.code{
		font-size: 1.3em;
	}
}	
@media(min-width:1366px){
	.desc,.code{
		font-size: 1.3em;
	}	
}	

    </style>
</head>

<body>
    <br />
    <hr width="80%" />
    <div class="con">
        <P>疑难解惑</P>
        <code class="desc">
				
	<h2>1.caller和callee的区别</h2>
	答：<a href="http://blog.csdn.net/laijieyao/article/details/43404953" target="_blank">查看</a>
	caller
	caller返回一个函数的引用，这个函数调用了当前的函数。
	使用这个属性要注意:
	1 这个属性只有当函数在执行时才有用
	2 如果在javascript程序中，函数是由顶层调用的，则返回null
	
	functionName.caller: functionName是当前正在执行的函数。
<code class="codeArea">
var a = function() { 
	console.log(a.caller); 
} 
var b = function() { 
	a(); 
} 
b();	
</code>
	上面的代码中，b调用了a，那么a.caller返回的是b的引用，可运行查看结果。
	如果直接调用a(即a在任何函数中被调用，也就是顶层调用),返回null:
	
	callee
	callee放回正在执行的函数本身的引用，它是arguments的一个属性
	使用callee时要注意:
	1 这个属性只有在函数执行时才有效
	2 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length
	3 它可以用来递归匿名函数。
<code class="codeArea">
var a = function() { 
	console.log(arguments.callee); 
} 
var b = function() { 
	a(); 
} 
b();
</code>	
	a在b中被调用，但是它返回了a本身的引用，可运行查看结果。
	<hr />
<h2>2.为什么有的轮巡技术会使用setTimeOut,而不是用setInterval</h2>
	答：http://www.tuicool.com/articles/BV7viq
       轮询请求如果不需要等待结果返回，那么完全可以使用setInterval来发起定时请求。
       但很显然长轮询是需要等待结果返回，然后再次发起请求的。
       轮询本质就是递归，递归和循环可是两码事。
		<code class="codeArea">
function test() {
    var date = new Date();
    console.log("test:" + date.getMinutes() + ':' + date.getSeconds() + ':' + date.getMilliseconds());
}
var num = 0;
var i = setTimeout(function() {
    num++;
    test();
    //var date = new Date();
    //console.log("间隔：" + date.getMinutes() + ':' + date.getSeconds() + ':' + date.getMilliseconds());
    if (num <= 10) {
        i = setTimeout(arguments.callee, 1000);//关键
    }
    
}, 1000);
		</code>
		//这样数出来是每隔2s输出一次，
		//1000都改成500是每隔1s都输出一次
		<hr />
<h2>3.javascript是多线程吗?</h2>
	答：javascript只有单线程，不存在同时执行！！！！	
		JS采用一种队列(event loop)的机制来处理各个事件.
		比如用户的点击，ajax异步请求,所有的事件都被放入一个队列中，然后先进先出，逐个执行。
		
		另一方面，浏览器还有一个GUI渲染线程，当需要重绘页面时渲染页面。
		但问题是GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，
		GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

		所以,在脚本中执行对界面进行更新操作,如添加结点,删除结点或改变结点的外观等更新并不会立即体现出来,
		这些操作将保存在一个队列中,待JavaScript引擎空闲时才有机会渲染出来.
		
<h2>4.live,bind,click ,delegate区别</h2>	
		答：bind( )方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。
  			  live( )方法将一个事件处理程序附加到与当前选择器匹配的所有元素
  			  	（包含现有的或将来添加的）的指定事件上并返回jQuery对象。
			  one()方法将事件处理程序附加到匹配元素的指定事件并返回jQuery对象。
				所附加的事件处理程序最多只能执行一次。
			  delegate()方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素
			  （现有的或将来的）的一个或多个事件上。
			
			区别：
				bind方法只能给当前存在的元素绑定事件，对于事后采用JS等方式新生成的元素无效，
				而live方法则正好弥补了bind方法的这个缺陷，它可以对后生成的元素也可以绑定相应的事件。
				原理实现？---→<a href="http://www.jb51.net/article/40838.htm" target="_blank">点我</a>
				
			delegate比live好用的优点：
				速度、灵活性和链能力、　live仅支持CSS选择器
				<a href="http://justcoding.iteye.com/blog/1457883" target="_blank">详细内容，点我</a>
			
<h2>6、写出程序运行的结果？</h2>
	typeof 会返回几种类型:
	<code class="codeArea">
	typeof(null) 					//object
	typeof(undefined) 		//undefined
	typeof(NaN)					//number
	NaN == undefined		//false
	                                
	var str = "123abc"              
	alert(typeof(str++))				//number	//此时输出str++为NaN
	alert(str)								//NaN
                                    
    typeof(1) 								//number
	typeof(NaN) 							//number
	typeof(Number.MIN_VALUE) //number 
	typeof(Infinity) 						//number
	typeof("123") 						//string
	typeof("abc")						//string
	typeof(undefined) 				//undefined
	typeof(abc) 							//undefined
	typeof(true) 							//boolean
	typeof(null)							//object

	typeof(window) 					//object
	typeof(document) 				//object
	typeof(eval) 							//function
	typeof(Date) 						//function
	typeof(function(){})				//function
	typeof([1,2,3])						//object
	typeof(new Number(8))			//object

	-----------------------
	var x =1,y=z=0;
	function add(n){
		return n = n + 1;
	}
	y = add(x);		//2
	z = add(x);		//2
	--------------------
	var myObject = {
		num:2,
		add:function(){
			this.num = 3;
			(function(){
				alert(this.num);			//undefined
				this.num = 4;
			})();
			alert(this.num);				//3
		}
	}
	myObject.add();//先 是undefined，然后是3
	-------------------------
	
	var i =0;
	for(i =0;i++<3;){
		setTimeout(function(){
			return function(){console.log(i);}
		}(),0);
	}
	//输出23，3个4，继续执行输出26，3个4；
	</code>
<h2>8、写出一个给数组排重的函数</h2>
第一种是比较常规的方法
思路：
1.构建一个新的数组存放结果
2.for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比
3.若结果数组中没有该元素，则存到结果数组中

第二种方法比上面的方法效率要高
思路：
1.先将原数组进行排序
2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，
因为已经排序，所以重复元素会在相邻位置
3.如果不相同，则将该元素存入结果数组中
第二种方法也会有一定的局限性，因为在去重前进行了排序，所以最后返回的去重结果也是排序后的。
如果要求不改变数组的顺序去重，那这种方法便不可取了。

第三种方法（推荐使用）
思路：
1.创建一个新的数组存放结果
2.创建一个空对象
3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，
同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。
说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，
如果能访问到值，则说明重复。

<code class="codeArea">
//第一种
function unique1(){
var res = [this[0]];
for(var i = 1; i < this.length; i++){
	var repeat = false;
	for(var j = 0; j < res.length; j++){
		if(this[i] == res[j]){
    	repeat = true;
    	break;
    }
}
	if(!repeat){
	res.push(this[i]);
	}
}
 return res;
}
var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]
alert(arr.unique1());	
//第二种
function unique2(){
 this.sort(); //先排序
 var res = [this[0]];
 for(var i = 1; i < this.length; i++){
  if(this[i] !== res[res.length - 1]){
   res.push(this[i]);
  }
 }
 return res;
}
var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0];
alert(arr.unique2());	
	
function unique3(){
	var res = [];
	var json = {};
 	for(var i = 0; i < this.length; i++){
  	if(!json[this[i]]){
   		res.push(this[i]);
   		json[this[i]] = 1;
  	}
 }
 return res;
}
var arr = [112,112,34,'你好',112,112,34,'你好','str','str1'];
alert(arr.unique3());
</code>
		</code>
    </div>
</body>

</html>
