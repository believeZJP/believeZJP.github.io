<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>一问一答</title>
    <!--
    	作者：421790588@qq.com
    	时间：2016-05-13
    	描述：
    	页面架构设计：
    		1.问题 	h2
    		2.答案---｛
						2-1.文字	.desc
						2-2.代码	.codeArea
    -->
    <style type="text/css">
    body {
        padding: 5px;
        font-family: "microsoft yahei";
        font-size:14px;
    }
    p,pre {
        margin: 0;
        border: 0;
    }
    code{
    	display: block;
    }
    h2{
	    border: 2px solid #2BCC18;
   		padding: 1em;
    	margin: 0;
    }
    .con {
        padding-left: 1.5em;
        padding-top: 1.5em;
        padding-bottom: 1.5em;
        width:98%;
        margin: 0 auto;
    }
    .con > p {
        background-color: #E18728;
        padding-left: 1em;
        font-size: 1.8em;
        font-weight: bold;
        line-height: 2;
        color: #FFF;
    }
    .desc {
        display: block;
        white-space: pre-wrap;
        word-wrap: break-word;
        width: 100%;
        overflow-x: auto;
        background-color: #FFFAE8;
        color: #3E4B53;
        line-height: 1.5em;
        font-size: 1.5em;
        font-weight: bold;
        font-family: "microsoft yahei", Times, serif;
    }
    .codeArea{
    	background-color: #1D1F21;
    	color: #FFF;
        line-height: 1.4em;
        padding-left: 0.5em;
    }
    
@media only screen and (min-width : 320px) {
	.desc,.code{
		font-size: 1.1em;
	}   
}	
@media(min-width:480px){
	.desc,.code{
		font-size: 1.1em;
	}   	
}
@media screen and (min-width: 768px) {
	.desc,.code{
		font-size: 1.3em;
	}
}	
@media(min-width:1366px){
	.desc,.code{
		font-size: 1.3em;
	}	
}	

    </style>
</head>

<body>
    <br />
    <hr width="80%" />
    <div class="con">
        <p>疑难解惑</p>
        <code class="desc">
				
	<h2>1.caller和callee的区别</h2>
	<div class="h2Area">
	答：<a href="http://blog.csdn.net/laijieyao/article/details/43404953" target="_blank">查看</a>
	caller
	caller返回一个函数的引用，这个函数调用了当前的函数。
	使用这个属性要注意:
	1 这个属性只有当函数在执行时才有用
	2 如果在javascript程序中，函数是由顶层调用的，则返回null
	
	functionName.caller: functionName是当前正在执行的函数。
<code class="codeArea">
var a = function() { 
	console.log(a.caller); 
} 
var b = function() { 
	a(); 
} 
b();	
</code>
	上面的代码中，b调用了a，那么a.caller返回的是b的引用，可运行查看结果。
	如果直接调用a(即a在任何函数中被调用，也就是顶层调用),返回null:
	
	callee
	callee放回正在执行的函数本身的引用，它是arguments的一个属性
	使用callee时要注意:
	1 这个属性只有在函数执行时才有效
	2 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length
	3 它可以用来递归匿名函数。
<code class="codeArea">
var a = function() { 
	console.log(arguments.callee); 
} 
var b = function() { 
	a(); 
} 
b();
</code>	
	a在b中被调用，但是它返回了a本身的引用，可运行查看结果。
		
	</div>
	<hr />
<h2>2.为什么有的轮巡技术会使用setTimeOut,而不是用setInterval</h2>
<div class="h2Area">
	答：http://www.tuicool.com/articles/BV7viq
	http://www.jb51.net/article/35535.htm
       轮询请求如果不需要等待结果返回，那么完全可以使用setInterval来发起定时请求。
       但很显然长轮询是需要等待结果返回，然后再次发起请求的。
       轮询本质就是递归，递归和循环可是两码事。
		<code class="codeArea">
function test() {
    var date = new Date();
    console.log("test:" + date.getMinutes() + ':' + date.getSeconds() + ':' + date.getMilliseconds());
}
var num = 0;
var i = setTimeout(function() {
    num++;
    test();
    //var date = new Date();
    //console.log("间隔：" + date.getMinutes() + ':' + date.getSeconds() + ':' + date.getMilliseconds());
    if (num <= 10) {
        i = setTimeout(arguments.callee, 1000);//关键
    }
    
}, 1000);
		</code>
		//这样数出来是每隔2s输出一次，
		//1000都改成500是每隔1s都输出一次
</div>
		<hr />
<h2>3.javascript是多线程吗?</h2>
<div class="h2Area">
	答：javascript只有单线程，不存在同时执行！！！！	
		JS采用一种队列(event loop)的机制来处理各个事件.
		比如用户的点击，ajax异步请求,所有的事件都被放入一个队列中，然后先进先出，逐个执行。
		
		另一方面，浏览器还有一个GUI渲染线程，当需要重绘页面时渲染页面。
		但问题是GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，
		GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

		所以,在脚本中执行对界面进行更新操作,如添加结点,删除结点或改变结点的外观等更新并不会立即体现出来,
		这些操作将保存在一个队列中,待JavaScript引擎空闲时才有机会渲染出来.
	
</div>
<hr />

<h2>4.live,bind,click ,delegate区别</h2>	
<div class="h2Area">
		答：bind()向匹配元素添加一个或多个事件处理器
  			  live() 向当前或未来的匹配元素添加一个或多个事件处理器；
  			  	（包含现有的或将来添加的）的指定事件上并返回jQuery对象。
			  one()方法将事件处理程序附加到匹配元素的指定事件并返回jQuery对象。
				所附加的事件处理程序最多只能执行一次。
			  delegate()方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素
			  （现有的或将来的）的一个或多个事件上。
			  on() 为指定的元素,添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。
		  		使用 on() 方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）。
			
			相同点：
			1.都支持单元素多事件的绑定；空格相隔方式或者大括号替代方式;
			2.均是通过事件冒泡方式，将事件传递到document进行事件的响应；
			比较和联系:
			1.bind()函数只能针对已经存在的元素进行事件的设置；
				但是live(),on(),delegate()均支持未来新添加元素的事件设置；
			2.bind()函数在jquery1.7版本以前比较受推崇，1.7版本出来之后，替代函数为on(),这也是1.7版本新添加的函数，同样，可以用来代替live()函数，live()函数在1.9版本已经删除；
			3.live()函数和delegate()函数两者类似，但是live()函数在执行速度，灵活性和CSS选择器支持方面较delegate()差些，想了解具体情况，请参考这篇《jQuery中的.bind()、.live()和.delegate()之间区别分析》
			4.bind()支持Jquery所有版本；live()支持jquery1.8-；delegate()支持jquery1.4.2+；on()支持jquery1.7+；


			live()方法会把click事件绑定到$(document)对象
			（但这一点从代码中体现不出来，这也是.live()方法饱受诟病的一个重要原因，稍后再详细讨论）
			，而且只需要给$(document)绑定一次（不是50次，更不是5000次），
			然后就能够处理后续动态加载的照片单元格的单击事件。
			在接收到任何事件时，$(document)对象都会检查事件类型和事件目标，
			如果是click事件且事件目标是td，那么就执行委托给它的处理程序。

			它有如下几个主要缺点：
			$()函数会找到当前页面中的所有td元素并创建jQuery对象，但在确认事件目标时却不用这个td元素集合，而是使用选择符表达式与event.target或其祖先元素进行比较，因而生成这个jQuery对象会造成不必要的开销；
			默认把事件绑定到$(document)元素，如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失；
			只能放在直接选择的元素后面，不能在连缀的DOM遍历方法后面使用，即$("#info_table td").live...可以，但$("#info_table").find("td").live...不行；
			收集td元素并创建jQuery对象，但实际操作的却是$(document)对象，令人费解。
			
			
			使用.delegate()有如下优点（或者说解决了.live()方法的如下问题）：
			直接将目标元素选择符（"td"）、事件（"click"）及处理程序与“受拖方”$("#info_table")绑定，不额外收集元素、事件传播路径缩短、语义明确；
			支持在连缀的DOM遍历方法后面调用，即支持$("table").find("#info").delegate...，支持精确控制；
			可见，.delegate()方法是一个相对完美的解决方案。但在DOM结构简单的情况下，也可以使用.live()。
			提示：使用事件委托时，如果注册到目标元素上的其他事件处理程序使用.stopPropagation()阻止了事件传播，那么事件委托就会失效。

			原理实现？---→<a href="http://www.jb51.net/article/40838.htm" target="_blank">点我</a>
			
				
			delegate比live好用的优点：
				速度、灵活性和链能力、　live仅支持CSS选择器
				<a href="http://justcoding.iteye.com/blog/1457883" target="_blank">详细内容，点我</a>
	
</div>
<hr />			
<h2>6、写出程序运行的结果？</h2>
<div class="h2Area">
	typeof 会返回几种类型:
	<code class="codeArea">
	typeof(null) 					//object
	typeof(undefined) 		//undefined
	typeof(NaN)					//number
	NaN == undefined		//false
	                                
	var str = "123abc"              
	alert(typeof(str++))				//number	//此时输出str++为NaN
	alert(str)								//NaN
                                    
    typeof(1) 								//number
	typeof(NaN) 							//number
	typeof(Number.MIN_VALUE) //number 
	typeof(Infinity) 						//number
	typeof("123") 						//string
	typeof("abc")						//string
	typeof(undefined) 				//undefined
	typeof(abc) 							//undefined
	typeof(true) 							//boolean
	typeof(null)							//object

	typeof(window) 					//object
	typeof(document) 				//object
	typeof(eval) 							//function
	typeof(Date) 						//function
	typeof(function(){})				//function
	typeof([1,2,3])						//object
	typeof(new Number(8))			//object

	-----------------------
	var x =1,y=z=0;
	function add(n){
		return n = n + 1;
	}
	y = add(x);		//2
	z = add(x);		//2
	--------------------
	var myObject = {
		num:2,
		add:function(){
			this.num = 3;
			(function(){
				alert(this.num);			//undefined
				this.num = 4;
			})();
			alert(this.num);				//3
		}
	}
	myObject.add();//先 是undefined，然后是3
	-------------------------
	
	var i =0;
	for(i =0;i++<3;){
		setTimeout(function(){
			return function(){console.log(i);}
		}(),0);
	}
	//输出23，3个4，继续执行输出26，3个4；
	</code>
	
</div>
<hr />
<h2>8、写出一个给数组排重的函数</h2>
<div class="h2Area">
第一种是比较常规的方法
思路：
1.构建一个新的数组存放结果
2.for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比
3.若结果数组中没有该元素，则存到结果数组中

第二种方法比上面的方法效率要高
思路：
1.先将原数组进行排序    ----数组默认的sort是从小到大排的！！！！
2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，
因为已经排序，所以重复元素会在相邻位置
3.如果不相同，则将该元素存入结果数组中
第二种方法也会有一定的局限性，因为在去重前进行了排序，所以最后返回的去重结果也是排序后的。
如果要求不改变数组的顺序去重，那这种方法便不可取了。

第三种方法（推荐使用）
思路：
1.创建一个新的数组存放结果
2.创建一个空对象
3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，
同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。
说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，
如果能访问到值，则说明重复。

<code class="codeArea">
//第一种
function unique1(){
var res = [this[0]];
for(var i = 1; i < this.length; i++){
	var repeat = false;
	for(var j = 0; j < res.length; j++){
		if(this[i] == res[j]){
    	repeat = true;
    	break;
    }
}
	if(!repeat){
	res.push(this[i]);
	}
}
 return res;
}
var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]
alert(arr.unique1());	
//第二种
function unique2(){
 this.sort(); //先排序
 var res = [this[0]];
 for(var i = 1; i < this.length; i++){
  if(this[i] !== res[res.length - 1]){
   res.push(this[i]);
  }
 }
 return res;
}
var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0];
alert(arr.unique2());	
	
function unique3(){
	var res = [];
	var json = {};
 	for(var i = 0; i < this.length; i++){
  	if(!json[this[i]]){
   		res.push(this[i]);
   		json[this[i]] = 1;
  	}
 }
 return res;
}
var arr = [112,112,34,'你好',112,112,34,'你好','str','str1'];
alert(arr.unique3());
</code>
	
</div>
<hr />
<h2>事件委托</h2>
<div class="h2Area">
	事件委托，就是事件目标自身不处理事件，而是把处理任务委托给其父元素或者祖先元素，甚至根元素。
事件委托主要是利用事件冒泡现象来实现的，对于事件委托的精准的掌握，可以有利于提高代码的执行效率。
遍历单元格和为每一个单元格绑定事件处理函数将会大大降低代码的性能，如果让单元格的父元素监听事件，只要判断最初触发事件的DOM元素是否是td即可。


http://www.jb51.net/Special/205.htm
http://www.jb51.net/article/28770.htm
	
</div>
<hr />

<h2>浏览器默认是事件冒泡</h2>
<div class="h2Area">
浏览器默认的为冒泡型事件触发机制,
http://www.cnblogs.com/Ren_Lei/archive/2010/09/26/1836130.html

addEventListener中的第三个参数是useCapture, 一个bool类型。
当为false时为冒泡(由里向外)，true为捕获(由外向里)。

先捕获，后冒泡

http://zhangyaochun.iteye.com/blog/1270659

综上，一个事件的传递过程包含三个阶段，分别称为：

捕获阶段，目标阶段，冒泡阶段

目标指的就是包裹得最深的那个元素。
	
</div>
<hr />
<h2>js获取当前元素的文本</h2>
<div class="h2Area">
	目前在<a>a的文本<span>span的文本</span></a>
	获取文本时，用innerText,jQuery的text(),textContent()时，都会把span中的也获取到。
	解决方案：
	 	var aDom = document.getElementsByTagName("a")[0];
	 	var text = aDom.firstChild.nodeValue;
	
</div>
<hr />

<h2>css单独一行添加省略号</h2>
<div class="h2Area">
	white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
	
</div>
<hr />























遇到的问题，
由于加了overflow后导致li中的input错位
<li>
	<label for=""></label>
	<input type="text" />
</li>



<h2>插件编写</h2>
(function($){
	$.fn.changeStyle = function(option){
		//接受参数。
		var defaultSetting = {//默认参数缺省值
			colorStr: 'green',
			fontSize:12
		};
		var setting = $.extend(defaultSetting,option);
		this.css('color',setting.colorStr).css('fontSize',setting.fontSize+'px');
		return this;//满足链式调用的jQuery插件
		
	}
})(jQuery);//防止$符号污染的jQuery插件

(function($){
	$.fn.extend({
		changeStyle : function(option){
			var defaultSetting = {
				colorStr: 'green',
				fontSize:12
			};
			var setting = $.extend(defaultSetting,option);
			this.css('color',setting.colorStr).css('fontSize',setting.fontSize+'px');
			return this;
		}
	});
})(jQuery);

PS:
	$.extend 和$.fn.extend都可以扩展jQuery功能。
	$.extend 是在jQuery全局对象上扩展方法
	$.fn.extend是在$选择符选择的jQuery对象上扩展方法。
	扩展jQuery的公共方法一般用$.extend方法，
	定义插件一般用$.fn.extend方法。

		</code>
    </div>
<script type="text/javascript">
		var h2s = document.getElementsByTagName("h2");
		for (var i = 0; i < h2s.length; i++) {
			(function(i){  
				var temp = h2s[i];
				temp.onclick = function(i){
					var dis =  temp.nextElementSibling.style.display ;
					if(dis === "none"){
						temp.nextElementSibling.style.display = 'block';
					}else{
						temp.nextElementSibling.style.display = 'none';
					}
				};
			})(i);  
		}
	</script>
</body>

</html>
