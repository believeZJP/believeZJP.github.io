<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"believezjp.oriht.com","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
<meta property="og:type" content="website">
<meta property="og:title" content="believeZJP">
<meta property="og:url" content="http://believezjp.oriht.com/index.html">
<meta property="og:site_name" content="believeZJP">
<meta property="og:description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="believeZJP">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://believezjp.oriht.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>believeZJP</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">believeZJP</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长路径</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">believeZJP</p>
  <div class="site-description" itemprop="description">积土成山，风雨兴焉；积水成渊，蛟龙生焉;</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/Alfred/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/Alfred/" class="post-title-link" itemprop="url">Alfred</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-30 10:59:15" itemprop="dateCreated datePublished" datetime="2020-12-30T10:59:15+08:00">2020-12-30</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<h2 id="Alfred是什么"><a href="#Alfred是什么" class="headerlink" title="Alfred是什么"></a>Alfred是什么</h2><ol>
<li>可以当做app快速启动(关闭)工具来使用</li>
<li>自定义搜索</li>
<li>workflow</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/72fe06566fce">下载</a></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>唤起  <code>option+空格</code><br>设置  <code>command+,</code></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/Alfred/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">思维导图列表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-29 19:36:01" itemprop="dateCreated datePublished" datetime="2020-12-29T19:36:01+08:00">2020-12-29</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a href="../img/xmind/%E6%89%A7%E8%A1%8C%E6%9C%89%E9%81%93%E5%9B%9B%E6%AD%A5%E6%B3%95.xmind">执行有道四步法</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E7%BE%BD%E6%AF%9B%E7%90%83%E9%80%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E7%BE%BD%E6%AF%9B%E7%90%83%E9%80%9F%E6%88%90/" class="post-title-link" itemprop="url">羽毛球速成</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-27 15:25:36" itemprop="dateCreated datePublished" datetime="2020-11-27T15:25:36+08:00">2020-11-27</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>握球拍的手势</p>
<p>时刻保持主动出击状态， 不要打完一个球后，就定住不动站着看，等球再过来就没有时间启动身体反应了</p>
<p>网前挑球时对手是轻打过来的，要使劲打到后场</p>
<p>如果对手轻挑过来，你再轻挑，球的弹力不够很难过网</p>
<p>后场球挥拍扣杀姿势要好好练</p>
<p>练好扣球才能得分赢球</p>
<p>打球姿势要录视频看是否正确，可能自己觉得正确，实际是错的。</p>
<p><strong>握拍手势和挥拍姿势是基础！！！</strong></p>
<p>要有刚有柔, 才能对球控制自如。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/React%E4%B8%ADAPI%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/React%E4%B8%ADAPI%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" class="post-title-link" itemprop="url">React中API使用的正确姿势</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 16:18:50" itemprop="dateCreated datePublished" datetime="2020-08-20T16:18:50+08:00">2020-08-20</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="惰性初始化state"><a href="#惰性初始化state" class="headerlink" title="惰性初始化state"></a>惰性初始化state</h2><p>defaultValue 参数只会在组件的初始渲染中起作⽤，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获<br>得，则可以传⼊⼀个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调⽤：</p>
<p><strong>这种写法可以避免定义多个state时，每次渲染都要执行初始化操作，而用惰性初始化state，可以解决重复初始化的问题。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 每次setInputValue引起的重新渲染进⼊函数组件内defaultValue都会被忽略。</span></span><br><span class="line"><span class="keyword">const</span> TestInput= <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultValue = props.value || <span class="string">&#x27;请输⼊&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> [inputValue,setInputValue] = useState(defaultValue)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input value=&#123;inputValue&#125; onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span>setInputValue(e.target.value)&#125; /&gt; &#123;<span class="keyword">in</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestInput</span><br><span class="line"></span><br><span class="line"><span class="comment">//使⽤函数来解决每次渲染 state 需要通过复杂计算获得的问题</span></span><br><span class="line"><span class="keyword">const</span> TestInput= <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [inputValue,setInputValue] = useState(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> props.value || <span class="string">&#x27;请输⼊&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input value=&#123;inputValue&#125; onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span>setInputValue(e.target.value)&#125; /&gt; &#123;<span class="keyword">in</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestInput</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8standard%E8%A7%84%E8%8C%83%E5%B9%B6%E7%94%A8eslint%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8standard%E8%A7%84%E8%8C%83%E5%B9%B6%E7%94%A8eslint%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">项目使用standard规范并用eslint自动格式化代码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-24 00:06:49" itemprop="dateCreated datePublished" datetime="2020-07-24T00:06:49+08:00">2020-07-24</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在vscode插件中安装<code>standard</code>插件</p>
<p>先禁用，再在工作区启用，即可只在当前工作区生效</p>
<p>在项目中安装<code>standard</code>和<code>eslint</code><br><code>npm i eslint standard -D</code></p>
<p>在命令行执行<code>eslint --init</code>初始化生成<code>.eslintrc.js</code>文件</p>
<p>生成过程中根据自己需求选择即可</p>
<p>在vsCode配置中(setting.json)增加如下配置, 即可自动格式化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;standard.run&quot;: &quot;onSave&quot;,</span><br><span class="line">&quot;standard.autoFixOnSave&quot;: true,</span><br><span class="line">&quot;javascript.validate.enable&quot;: false</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/node-cli%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/node-cli%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">node cli开发调试经验总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-07 09:02:45" itemprop="dateCreated datePublished" datetime="2020-07-07T09:02:45+08:00">2020-07-07</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="node命令行工具开发调试"><a href="#node命令行工具开发调试" class="headerlink" title="node命令行工具开发调试"></a>node命令行工具开发调试</h2><p>npm link命令通过链接目录和可执行文件，实现npm包命令的全局可执行。</p>
<p>简要地讲，这个命令主要做了两件事：</p>
<ol>
<li>为npm包目录创建软链接，将其链到{prefix}/lib/node_modules/package(包名)</li>
<li>为可执行文件(bin)创建软链接，将其链到{prefix}/bin/{name}</li>
</ol>
<p>在<code>package.json</code>中配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;ltsnode&quot;: &quot;bin/ltsnode.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ltsnode.js中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定运行环境为node</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;运行ltsnode命令&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="在VsCode里debug模式里调试"><a href="#在VsCode里debug模式里调试" class="headerlink" title="在VsCode里debug模式里调试"></a>在VsCode里debug模式里调试</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;启动程序&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;skipFiles&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;&lt;node_internals&gt;/**&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// 这里是命令行需要传入的参数</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;10&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// 这里是命令行入口文件的位置，一般放在bin文件夹下</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/bin/ltsnode.js&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后，点击启动程序，即可开始调试。上一步下一步在VsCode正中间顶部。<br>可以使用<code>console.log</code>输出结果到调试控制台</p>
<h2 id="在命令行里里调试"><a href="#在命令行里里调试" class="headerlink" title="在命令行里里调试"></a>在命令行里里调试</h2><p><code>npm link</code></p>
<p>再运行<code>npm link</code>即可</p>
<p>然后再命令行里执行命令<code>ltsnode</code>看效果</p>
<p>进入<code>/usr/local/lib/node_modules</code>会发现一个软链，指向自己项目目录<br><code>ltsnode -&gt; /Users/zhaojianpeng/Desktop/workspaces/ltsnode</code></p>
<h2 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h2><ol>
<li>执行<code>npm link</code>报错</li>
</ol>
<p>开发过程遇到的报错</p>
<ul>
<li><p><code>ENOENT: no such file or directory, chmod &#39;/usr/local/lib/node_modules/videocount/bin/videocount&#39;</code><br>  解决办法：在<code>package.json</code>中</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;videocount&quot;: &quot;bin/videocount.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>  这里一定要加后缀名js</p>
</li>
<li><p><code>npm ERR! Refusing to delete /usr/local/bin/ltsnode: ../../../Users/zhaojianpeng/.config/yarn/link/ltsnode/bin/ltsnode symlink target is not controlled by npm /usr/local/bin</code></p>
</li>
<li><p><code>npm ERR! EEXIST: file already exists, symlink &#39;../lib/node_modules/ltsnode/bin/ltsnode.js&#39; -&gt; &#39;/usr/local/bin/ltsnode&#39;</code></p>
</li>
</ul>
<p>解决办法：<br>尝试了各种办法，删缓存，升级npm版本。执行<code>npm link</code>总是报错。<br><strong>执行<code>rm /usr/local/bin/ltsnode</code>删除软链</strong>搞定~~~</p>
<p>在<code>/usr/local/bin/node_modules</code>里删除软链不好使</p>
<p>期间用到知识</p>
<p>一、使用淘宝镜像<br>1.临时使用<br>npm –registry <a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> install express</p>
<p>2.持久使用<br>npm config set registry <a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>3.通过cnpm<br>npm install -g cnpm –registry=<a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p>二、使用官方镜像<br>npm config set registry <a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p>
<p>三、查看npm源地址<br>npm config get registry</p>
<p>删除软链<br><code>rm -rf ltsnode</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/Promise%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/Promise%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Promise深度解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-19 14:48:30" itemprop="dateCreated datePublished" datetime="2020-06-19T14:48:30+08:00">2020-06-19</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这一章节就是整理了<code>45</code>道<code>Promise</code>的笔试题让大家爽一爽 😁。</p>
<p>这篇文章是一篇比较纯的<code>Promise</code>笔试文章，是我自己在做题的时候，根据题目想要的考点来反敲知识点，然后再由这个知识点编写从浅到深的的题目。</p>
<p>本文的题目没有到特别深入，不过应该覆盖了大部分的考点，另外为了不把大家绕混，答案也没有考虑在<code>Node</code>的执行结果，执行结果全为浏览器环境下。</p>
<p>OK👌， 来看看通过阅读本篇文章你可以学到：</p>
<ul>
<li>Promise的几道基础题</li>
<li>Promise结合setTimeout</li>
<li>Promise中的then、catch、finally</li>
<li>Promise中的all和race</li>
<li>async/await的几道题</li>
<li>async处理错误</li>
<li>综合题</li>
<li>几道大厂的面试题</li>
</ul>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在做下面👇的题目之前，我希望你能清楚几个知识点。</p>
<p>(如果你感觉一上来不想看这些列举的知识点的话，直接看后面的例子再来理解它们也可以)</p>
<p><strong><code>event loop</code>它的执行顺序：</strong></p>
<ul>
<li>一开始整个脚本作为一个宏任务执行</li>
<li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li>
<li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完</li>
<li>执行浏览器UI线程的渲染工作</li>
<li>检查是否有<code>Web Worker</code>任务，有则执行</li>
<li>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</li>
</ul>
<p><strong>微任务包括：</strong><code>MutationObserver</code>、<code>Promise.then()或catch()</code>、<code>Promise为基础开发的其它技术，比如fetch API</code>、<code>V8</code>的垃圾回收过程、<code>Node独有的process.nextTick</code>。</p>
<p><strong>宏任务包括</strong>：<code>script</code> 、<code>setTimeout</code>、<code>setInterval</code> 、<code>setImmediate</code> 、<code>I/O</code> 、<code>UI rendering</code>。</p>
<p><strong>注意</strong>⚠️：在所有任务开始的时候，由于宏任务中包括了<code>script</code>，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如<code>setTimeout</code>)将被放到下一轮宏任务中来执行。</p>
<h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><h4 id="1-1-题目一"><a href="#1-1-题目一" class="headerlink" title="1.1 题目一"></a>1.1 题目一</h4><pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  console.log(&#39;promise1&#39;)
&#125;)
console.log(&#39;1&#39;, promise1);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code></li>
<li>然后执行同步代码<code>1</code>，此时<code>promise1</code>没有被<code>resolve</code>或者<code>reject</code>，因此状态还是<code>pending</code></li>
</ul>
<p>结果：</p>
<pre><code>&#39;promise1&#39;
&#39;1&#39; Promise&#123;&lt;pending&gt;&#125;
复制代码</code></pre>
<h4 id="1-2-题目二"><a href="#1-2-题目二" class="headerlink" title="1.2 题目二"></a>1.2 题目二</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  resolve(&#39;success&#39;)
  console.log(2);
&#125;);
promise.then(() =&gt; &#123;
  console.log(3);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行其中的同步代码<code>1</code></li>
<li>再遇到<code>resolve(&#39;success&#39;)</code>， 将<code>promise</code>的状态改为了<code>resolved</code>并且将值保存下来</li>
<li>继续执行同步代码<code>2</code></li>
<li>跳出<code>promise</code>，往下执行，碰到<code>promise.then</code>这个微任务，将其加入微任务队列</li>
<li>执行同步代码<code>4</code></li>
<li>本轮宏任务全部执行完毕，检查微任务队列，发现<code>promise.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>
</ul>
<p>结果：</p>
<pre><code>1 2 4 3
复制代码</code></pre>
<h4 id="1-3-题目三"><a href="#1-3-题目三" class="headerlink" title="1.3 题目三"></a>1.3 题目三</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  console.log(2);
&#125;);
promise.then(() =&gt; &#123;
  console.log(3);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析</p>
<ul>
<li>和题目二相似，只不过在<code>promise</code>中并没有<code>resolve</code>或者<code>reject</code></li>
<li>因此<code>promise.then</code>并不会执行，它只有在被改变了状态之后才会执行。</li>
</ul>
<p>结果：</p>
<pre><code>1 2 4
复制代码</code></pre>
<h4 id="1-4-题目四"><a href="#1-4-题目四" class="headerlink" title="1.4 题目四"></a>1.4 题目四</h4><pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  console.log(&#39;promise1&#39;)
  resolve(&#39;resolve1&#39;)
&#125;)
const promise2 = promise1.then(res =&gt; &#123;
  console.log(res)
&#125;)
console.log(&#39;1&#39;, promise1);
console.log(&#39;2&#39;, promise2);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>promise1</code></li>
<li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来</li>
<li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列</li>
<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code></li>
<li>执行同步代码<code>1</code>， 同时打印出<code>promise1</code>的状态是<code>resolved</code></li>
<li>执行同步代码<code>2</code>，同时打印出<code>promise2</code>的状态是<code>pending</code></li>
<li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>
</ul>
<p>结果：</p>
<pre><code>&#39;promise1&#39;
&#39;1&#39; Promise&#123;&lt;resolved&gt;: &#39;resolve1&#39;&#125;
&#39;2&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;resolve1&#39;
复制代码</code></pre>
<h4 id="1-5-题目五"><a href="#1-5-题目五" class="headerlink" title="1.5 题目五"></a>1.5 题目五</h4><p>接下来看看这道题：</p>
<pre><code>const fn = () =&gt; (new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  resolve(&#39;success&#39;)
&#125;))
fn().then(res =&gt; &#123;
  console.log(res)
&#125;)
console.log(&#39;start&#39;)
复制代码</code></pre>
<p>这道题里最先执行的是<code>&#39;start&#39;</code>吗 🤔️ ？</p>
<p>请仔细看看哦，<code>fn</code>函数它是直接返回了一个<code>new Promise</code>的，而且<code>fn</code>函数的调用是在<code>start</code>之前，所以它里面的内容应该会先执行。</p>
<p>结果：</p>
<pre><code>1
&#39;start&#39;
&#39;success&#39;
复制代码</code></pre>
<h4 id="1-6-题目六"><a href="#1-6-题目六" class="headerlink" title="1.6 题目六"></a>1.6 题目六</h4><p>如果把<code>fn</code>的调用放到<code>start</code>之后呢？</p>
<pre><code>const fn = () =&gt;
  new Promise((resolve, reject) =&gt; &#123;
    console.log(1);
    resolve(&quot;success&quot;);
  &#125;);
console.log(&quot;start&quot;);
fn().then(res =&gt; &#123;
  console.log(res);
&#125;);
复制代码</code></pre>
<p>是的，现在<code>start</code>就在<code>1</code>之前打印出来了，因为<code>fn</code>函数是之后执行的。</p>
<p><strong>注意⚠️</strong>：之前我们很容易就以为看到new Promise()就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。</p>
<p>答案：</p>
<pre><code>&quot;start&quot;
1
&quot;success&quot;
复制代码</code></pre>
<p>好嘞，学完了这几道基础题，让我们来用个表情包压压惊。</p>
<h3 id="2-Promise结合setTimeout"><a href="#2-Promise结合setTimeout" class="headerlink" title="2. Promise结合setTimeout"></a>2. Promise结合setTimeout</h3><h4 id="2-1-题目一"><a href="#2-1-题目一" class="headerlink" title="2.1 题目一"></a>2.1 题目一</h4><pre><code>console.log(&#39;start&#39;)
setTimeout(() =&gt; &#123;
  console.log(&#39;time&#39;)
&#125;)
Promise.resolve().then(() =&gt; &#123;
  console.log(&#39;resolve&#39;)
&#125;)
console.log(&#39;end&#39;)
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出<code>start</code>和<code>end</code>。</li>
<li><code>setTimout</code>作为一个宏任务被放入宏任务队列(下一个)</li>
<li><code>Promise.then</code>作为一个微任务被放入微任务队列</li>
<li>本次宏任务执行完，检查微任务，发现<code>Promise.then</code>，执行它</li>
<li>接下来进入下一个宏任务，发现<code>setTimeout</code>，执行。</li>
</ul>
<p>结果：</p>
<pre><code>&#39;start&#39;
&#39;end&#39;
&#39;resolve&#39;
&#39;time&#39;
复制代码</code></pre>
<h4 id="2-2-题目二"><a href="#2-2-题目二" class="headerlink" title="2.2 题目二"></a>2.2 题目二</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  console.log(1);
  setTimeout(() =&gt; &#123;
    console.log(&quot;timerStart&quot;);
    resolve(&quot;success&quot;);
    console.log(&quot;timerEnd&quot;);
  &#125;, 0);
  console.log(2);
&#125;);
promise.then((res) =&gt; &#123;
  console.log(res);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析：</p>
<p>和题目<code>1.2</code>很像，不过在<code>resolve</code>的外层加了一层<code>setTimeout</code>定时器。</p>
<ul>
<li>从上至下，先遇到<code>new Promise</code>，执行该构造函数中的代码<code>1</code></li>
<li>然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行</li>
<li>执行同步代码<code>2</code></li>
<li>跳出<code>promise</code>函数，遇到<code>promise.then</code>，但其状态还是为<code>pending</code>，这里理解为先不执行</li>
<li>执行同步代码<code>4</code></li>
<li>一轮循环过后，进入第二次宏任务，发现延迟队列中有<code>setTimeout</code>定时器，执行它</li>
<li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列</li>
<li>继续执行同步代码<code>timerEnd</code></li>
<li>宏任务全部执行完毕，查找微任务队列，发现<code>promise.then</code>这个微任务，执行它。</li>
</ul>
<p>因此执行结果为：</p>
<pre><code>1
2
4
&quot;timerStart&quot;
&quot;timerEnd&quot;
&quot;success&quot;
复制代码</code></pre>
<h4 id="2-3-题目三"><a href="#2-3-题目三" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><p>题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么：</p>
<p><strong>(1)</strong>:</p>
<pre><code>setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;);
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer3&#39;)
  &#125;, 0)
&#125;, 0)
setTimeout(() =&gt; &#123;
  console.log(&#39;timer2&#39;)
&#125;, 0)
console.log(&#39;start&#39;)
复制代码</code></pre>
<p><strong>(2)</strong>:</p>
<pre><code>setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;);
  Promise.resolve().then(() =&gt; &#123;
    console.log(&#39;promise&#39;)
  &#125;)
&#125;, 0)
setTimeout(() =&gt; &#123;
  console.log(&#39;timer2&#39;)
&#125;, 0)
console.log(&#39;start&#39;)
复制代码</code></pre>
<p><strong>执行结果：</strong></p>
<pre><code>&#39;start&#39;
&#39;timer1&#39;
&#39;timer2&#39;
&#39;timer3&#39;
复制代码

&#39;start&#39;
&#39;timer1&#39;
&#39;promise&#39;
&#39;timer2&#39;
复制代码</code></pre>
<p>这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。</p>
<p>一个是为定时器<code>timer3</code>，一个是为<code>Promise.then</code></p>
<p>但是如果是定时器<code>timer3</code>的话，它会在<code>timer2</code>后执行，而<code>Promise.then</code>却是在<code>timer2</code>之前执行。</p>
<p>你可以这样理解，<code>Promise.then</code>是微任务，它会被加入到本轮中的微任务列表，而定时器<code>timer3</code>是宏任务，它会被加入到下一轮的宏任务中。</p>
<p>理解完这两个案例，可以来看看下面一道比较难的题目了。</p>
<h4 id="2-3-题目三-1"><a href="#2-3-题目三-1" class="headerlink" title="2.3 题目三"></a>2.3 题目三</h4><pre><code>Promise.resolve().then(() =&gt; &#123;
  console.log(&#39;promise1&#39;);
  const timer2 = setTimeout(() =&gt; &#123;
    console.log(&#39;timer2&#39;)
  &#125;, 0)
&#125;);
const timer1 = setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;)
  Promise.resolve().then(() =&gt; &#123;
    console.log(&#39;promise2&#39;)
  &#125;)
&#125;, 0)
console.log(&#39;start&#39;);
复制代码</code></pre>
<p>这道题稍微的难一些，在<code>promise</code>中执行定时器，又在定时器中执行<code>promise</code>；</p>
<p>并且要注意的是，这里的<code>Promise</code>是直接<code>resolve</code>的，而之前的<code>new Promise</code>不一样。</p>
<p>(偷偷告诉你，这道题往下一点有流程图)</p>
<p>因此过程分析为：</p>
<ul>
<li>刚开始整个脚本作为第一次宏任务来执行，我们将它标记为<strong>宏1</strong>，从上至下执行</li>
<li>遇到<code>Promise.resolve().then</code>这个微任务，将<code>then</code>中的内容加入第一次的微任务队列标记为<strong>微1</strong></li>
<li>遇到定时器<code>timer1</code>，将它加入下一次宏任务的延迟列表，标记为<strong>宏2</strong>，等待执行(先不管里面是什么内容)</li>
<li>执行<strong>宏1</strong>中的同步代码<code>start</code></li>
<li>第一次宏任务(<strong>宏1</strong>)执行完毕，检查第一次的微任务队列(<strong>微1</strong>)，发现有一个<code>promise.then</code>这个微任务需要执行</li>
<li>执行打印出<strong>微1</strong>中同步代码<code>promise1</code>，然后发现定时器<code>timer2</code>，将它加入<strong>宏2</strong>的后面，标记为<strong>宏3</strong></li>
<li>第一次微任务队列(<strong>微1</strong>)执行完毕，执行第二次宏任务(<strong>宏2</strong>)，首先执行同步代码<code>timer1</code></li>
<li>然后遇到了<code>promise2</code>这个微任务，将它加入此次循环的微任务队列，标记为<strong>微2</strong></li>
<li><strong>宏2</strong>中没有同步代码可执行了，查找本次循环的微任务队列(<strong>微2</strong>)，发现了<code>promise2</code>，执行它</li>
<li>第二轮执行完毕，执行<strong>宏3</strong>，打印出<code>timer2</code></li>
</ul>
<p>所以结果为：</p>
<pre><code>&#39;start&#39;
&#39;promise1&#39;
&#39;timer1&#39;
&#39;promise2&#39;
&#39;timer2&#39;
复制代码</code></pre>
<p>如果感觉有点绕的话，可以看下面这张图，就一目了然了。</p>
<p>![](<a target="_blank" rel="noopener" href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="664"></svg>)</p>
<h4 id="2-4-题目四"><a href="#2-4-题目四" class="headerlink" title="2.4 题目四"></a>2.4 题目四</h4><pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)
const promise2 = promise1.then(() =&gt; &#123;
  throw new Error(&#39;error!!!&#39;)
&#125;)
console.log(&#39;promise1&#39;, promise1)
console.log(&#39;promise2&#39;, promise2)
setTimeout(() =&gt; &#123;
  console.log(&#39;promise1&#39;, promise1)
  console.log(&#39;promise2&#39;, promise2)
&#125;, 2000)
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>从上至下，先执行第一个<code>new Promise</code>中的函数，碰到<code>setTimeout</code>将它加入下一个宏任务列表</li>
<li>跳出<code>new Promise</code>，碰到<code>promise1.then</code>这个微任务，但其状态还是为<code>pending</code>，这里理解为先不执行</li>
<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code></li>
<li>执行同步代码<code>console.log(&#39;promise1&#39;)</code>，且打印出的<code>promise1</code>的状态为<code>pending</code></li>
<li>执行同步代码<code>console.log(&#39;promise2&#39;)</code>，且打印出的<code>promise2</code>的状态为<code>pending</code></li>
<li>碰到第二个定时器，将其放入下一个宏任务列表</li>
<li>第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务</li>
<li>先执行第一个定时器里的内容，将<code>promise1</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise1.then</code>推入微任务队列</li>
<li>该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是<code>promise1.then</code>，它抛出了一个错误，且将<code>promise2</code>的状态设置为了<code>rejected</code></li>
<li>第一个定时器执行完毕，开始执行第二个定时器中的内容</li>
<li>打印出<code>&#39;promise1&#39;</code>，且此时<code>promise1</code>的状态为<code>resolved</code></li>
<li>打印出<code>&#39;promise2&#39;</code>，且此时<code>promise2</code>的状态为<code>rejected</code></li>
</ul>
<p>完整的结果为：</p>
<pre><code>&#39;promise1&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;promise2&#39; Promise&#123;&lt;pending&gt;&#125;
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
&#39;promise1&#39; Promise&#123;&lt;resolved&gt;: &quot;success&quot;&#125;
&#39;promise2&#39; Promise&#123;&lt;rejected&gt;: Error: error!!!&#125;
复制代码</code></pre>
<h4 id="2-5-题目五"><a href="#2-5-题目五" class="headerlink" title="2.5 题目五"></a>2.5 题目五</h4><p>如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案：</p>
<pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&quot;success&quot;);
    console.log(&quot;timer1&quot;);
  &#125;, 1000);
  console.log(&quot;promise1里的内容&quot;);
&#125;);
const promise2 = promise1.then(() =&gt; &#123;
  throw new Error(&quot;error!!!&quot;);
&#125;);
console.log(&quot;promise1&quot;, promise1);
console.log(&quot;promise2&quot;, promise2);
setTimeout(() =&gt; &#123;
  console.log(&quot;timer2&quot;);
  console.log(&quot;promise1&quot;, promise1);
  console.log(&quot;promise2&quot;, promise2);
&#125;, 2000);
复制代码</code></pre>
<p>结果：</p>
<pre><code>&#39;promise1里的内容&#39;
&#39;promise1&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;promise2&#39; Promise&#123;&lt;pending&gt;&#125;
&#39;timer1&#39;
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
&#39;timer2&#39;
&#39;promise1&#39; Promise&#123;&lt;resolved&gt;: &quot;success&quot;&#125;
&#39;promise2&#39; Promise&#123;&lt;rejected&gt;: Error: error!!!&#125;
复制代码</code></pre>
<h3 id="3-Promise中的then、catch、finally"><a href="#3-Promise中的then、catch、finally" class="headerlink" title="3. Promise中的then、catch、finally"></a>3. Promise中的then、catch、finally</h3><p>额，可能你看到下面👇这么多的<code>1，2，3</code>脾气就上来了，不是说好了本篇文章没什么屁话嘛，怎么还是这么多一二三四。</p>
<p>😂，你要理解我的用心良苦啊，我这是帮你把知识点都列举出来，做个总结而已。当然，你也可以先不看，先去做后面的题，然后再回过头来看这些，你就觉得这些点都好好懂啊，甚至都不需要记。</p>
<p><strong>总结：</strong></p>
<ol>
<li><code>Promise</code>的状态一经改变就不能再改变。(见3.1)</li>
<li><code>.then</code>和<code>.catch</code>都会返回一个新的<code>Promise</code>。(上面的👆1.4证明了)</li>
<li><code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。(见3.2)</li>
<li>在<code>Promise</code>中，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，例如<code>return 2</code>会被包装为<code>return Promise.resolve(2)</code>。</li>
<li><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次, 但如果<code>Promise</code>内部的状态一经改变，并且有了一个值，那么后续每次调用<code>.then</code>或者<code>.catch</code>的时候都会直接拿到该值。(见3.5)</li>
<li><code>.then</code> 或者 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获。(见3.6)</li>
<li><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。(见3.7)</li>
<li><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。(见3.8)</li>
<li><code>.then</code>方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为<code>catch</code>是<code>.then</code>第二个参数的简便写法。(见3.9)</li>
<li><code>.finally</code>方法也是返回一个<code>Promise</code>，他在<code>Promise</code>结束的时候，无论结果为<code>resolved</code>还是<code>rejected</code>，都会执行里面的回调函数。</li>
</ol>
<h4 id="3-1-题目一"><a href="#3-1-题目一" class="headerlink" title="3.1 题目一"></a>3.1 题目一</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  resolve(&quot;success1&quot;);
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
&#125;);
promise
.then(res =&gt; &#123;
    console.log(&quot;then: &quot;, res);
  &#125;).catch(err =&gt; &#123;
    console.log(&quot;catch: &quot;, err);
  &#125;)
复制代码</code></pre>
<p>结果：</p>
<pre><code>&quot;then: success1&quot;
复制代码</code></pre>
<p>构造函数中的 <code>resolve</code> 或 <code>reject</code> 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，<code>Promise</code>的状态一经改变就不能再改变。</p>
<h4 id="3-2-题目二"><a href="#3-2-题目二" class="headerlink" title="3.2 题目二"></a>3.2 题目二</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  reject(&quot;error&quot;);
  resolve(&quot;success2&quot;);
&#125;);
promise
.then(res =&gt; &#123;
    console.log(&quot;then1: &quot;, res);
  &#125;).then(res =&gt; &#123;
    console.log(&quot;then2: &quot;, res);
  &#125;).catch(err =&gt; &#123;
    console.log(&quot;catch: &quot;, err);
  &#125;).then(res =&gt; &#123;
    console.log(&quot;then3: &quot;, res);
  &#125;)
复制代码</code></pre>
<p>结果：</p>
<pre><code>&quot;catch: &quot; &quot;error&quot;
&quot;then3: &quot; undefined
复制代码</code></pre>
<p>验证了第三个结论，<code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。</p>
<p>至于<code>then3</code>也会被执行，那是因为<code>catch()</code>也会返回一个<code>Promise</code>，且由于这个<code>Promise</code>没有返回值，所以打印出来的是<code>undefined</code>。</p>
<h4 id="3-3-题目三"><a href="#3-3-题目三" class="headerlink" title="3.3 题目三"></a>3.3 题目三</h4><pre><code>Promise.resolve(1)
  .then(res =&gt; &#123;
    console.log(res);
    return 2;
  &#125;)
  .catch(err =&gt; &#123;
    return 3;
  &#125;)
  .then(res =&gt; &#123;
    console.log(res);
  &#125;);
复制代码</code></pre>
<p>结果：</p>
<pre><code>1
2
复制代码</code></pre>
<p><code>Promise</code>可以链式调用，不过<code>promise</code> 每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 <code>promise</code>，从而实现了链式调用, 它并不像一般我们任务的链式调用一样<code>return this</code>。</p>
<p>上面的输出结果之所以依次打印出<code>1</code>和<code>2</code>，那是因为<code>resolve(1)</code>之后走的是第一个<code>then</code>方法，并没有走<code>catch</code>里，所以第二个<code>then</code>中的<code>res</code>得到的实际上是第一个<code>then</code>的返回值。</p>
<p>且<code>return 2</code>会被包装成<code>resolve(2)</code>。</p>
<h4 id="3-4-题目四"><a href="#3-4-题目四" class="headerlink" title="3.4 题目四"></a>3.4 题目四</h4><p>如果把<code>3.3</code>中的<code>Promise.resolve(1)</code>改为<code>Promise.reject(1)</code>又会怎么样呢？</p>
<pre><code>Promise.reject(1)
  .then(res =&gt; &#123;
    console.log(res);
    return 2;
  &#125;)
  .catch(err =&gt; &#123;
    console.log(err);
    return 3
  &#125;)
  .then(res =&gt; &#123;
    console.log(res);
  &#125;);
复制代码</code></pre>
<p>结果：</p>
<pre><code>1
3
复制代码</code></pre>
<p>结果打印的当然是 <code>1 和 3</code>啦，因为<code>reject(1)</code>此时走的就是<code>catch</code>，且第二个<code>then</code>中的<code>res</code>得到的就是<code>catch</code>中的返回值。</p>
<h4 id="3-5-题目五"><a href="#3-5-题目五" class="headerlink" title="3.5 题目五"></a>3.5 题目五</h4><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer&#39;)
    resolve(&#39;success&#39;)
  &#125;, 1000)
&#125;)
const start = Date.now();
promise.then(res =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)
promise.then(res =&gt; &#123;
  console.log(res, Date.now() - start)
&#125;)
复制代码</code></pre>
<p>执行结果：</p>
<pre><code>&#39;timer&#39;
&#39;success&#39; 1001
&#39;success&#39; 1002
复制代码</code></pre>
<p>当然，如果你足够快的话，也可能两个都是<code>1001</code>。</p>
<p><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次，但这里 <code>Promise</code> 构造函数只执行一次。或者说 <code>promise</code> 内部状态一经改变，并且有了一个值，那么后续每次调用 <code>.then</code> 或者 <code>.catch</code> 都会直接拿到该值。</p>
<h4 id="3-6-题目六"><a href="#3-6-题目六" class="headerlink" title="3.6 题目六"></a>3.6 题目六</h4><pre><code>Promise.resolve().then(() =&gt; &#123;
  return new Error(&#39;error!!!&#39;)
&#125;).then(res =&gt; &#123;
  console.log(&quot;then: &quot;, res)
&#125;).catch(err =&gt; &#123;
  console.log(&quot;catch: &quot;, err)
&#125;)
复制代码</code></pre>
<p>猜猜这里的结果输出的是什么 🤔️ ？</p>
<p>你可能想到的是进入<code>.catch</code>然后被捕获了错误。</p>
<p>结果并不是这样的，它走的是<code>.then</code>里面：</p>
<pre><code>&quot;then: &quot; &quot;Error: error!!!&quot;
复制代码</code></pre>
<p>这也验证了第4点和第6点，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>。</p>
<p>当然如果你抛出一个错误的话，可以用下面👇两的任意一种：</p>
<pre><code>return Promise.reject(new Error(&#39;error!!!&#39;));
// or
throw new Error(&#39;error!!!&#39;)
复制代码</code></pre>
<h4 id="3-7-题目七"><a href="#3-7-题目七" class="headerlink" title="3.7 题目七"></a>3.7 题目七</h4><pre><code>const promise = Promise.resolve().then(() =&gt; &#123;
  return promise;
&#125;)
promise.catch(console.err)
复制代码</code></pre>
<p><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>
<p>因此结果会报错：</p>
<pre><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
复制代码</code></pre>
<h4 id="3-8-题目八"><a href="#3-8-题目八" class="headerlink" title="3.8 题目八"></a>3.8 题目八</h4><pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
复制代码</code></pre>
<p>这道题看着好像很简单，又感觉很复杂的样子，怎么这么多个<code>.then</code>啊… 😅</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/28/1708baaf2b1e9075?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>其实你只要记住<strong>原则8</strong>：<code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。</p>
<p>第一个<code>then</code>和第二个<code>then</code>中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个<code>then</code>里。</p>
<p>所以输出结果为：</p>
<pre><code>1
复制代码</code></pre>
<h4 id="3-9-题目九"><a href="#3-9-题目九" class="headerlink" title="3.9 题目九"></a>3.9 题目九</h4><p>下面来介绍一下<code>.then</code>函数中的两个参数。</p>
<p>第一个参数是用来处理<code>Promise</code>成功的函数，第二个则是处理失败的函数。</p>
<p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p>
<p>让我们来看看这个例子🌰：</p>
<pre><code>Promise.reject(&#39;err!!!&#39;)
  .then((res) =&gt; &#123;
    console.log(&#39;success&#39;, res)
  &#125;, (err) =&gt; &#123;
    console.log(&#39;error&#39;, err)
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;catch&#39;, err)
  &#125;)
复制代码</code></pre>
<p>这里的执行结果是：</p>
<pre><code>&#39;error&#39; &#39;error!!!&#39;
复制代码</code></pre>
<p>它进入的是<code>then()</code>中的第二个参数里面，而如果把第二个参数去掉，就进入了<code>catch()</code>中：</p>
<pre><code>Promise.reject(&#39;err!!!&#39;)
  .then((res) =&gt; &#123;
    console.log(&#39;success&#39;, res)
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;catch&#39;, err)
  &#125;)
复制代码</code></pre>
<p>执行结果：</p>
<pre><code>&#39;catch&#39; &#39;error!!!&#39;
复制代码</code></pre>
<p>但是有一个问题，如果是这个案例呢？</p>
<pre><code>Promise.resolve()
  .then(function success (res) &#123;
    throw new Error(&#39;error!!!&#39;)
  &#125;, function fail1 (err) &#123;
    console.log(&#39;fail1&#39;, err)
  &#125;).catch(function fail2 (err) &#123;
    console.log(&#39;fail2&#39;, err)
  &#125;)
复制代码</code></pre>
<p>由于<code>Promise</code>调用的是<code>resolve()</code>，因此<code>.then()</code>执行的应该是<code>success()</code>函数，可是<code>success()</code>函数抛出的是一个错误，它会被后面的<code>catch()</code>给捕获到，而不是被<code>fail1</code>函数捕获。</p>
<p>因此执行结果为：</p>
<pre><code>fail2 Error: error!!!
   at success
复制代码</code></pre>
<h4 id="3-10-题目十"><a href="#3-10-题目十" class="headerlink" title="3.10 题目十"></a>3.10 题目十</h4><p>接着来看看<code>.finally()</code>，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。</p>
<p>其实你只要记住它三个很重要的知识点就可以了：</p>
<ol>
<li><code>.finally()</code>方法不管<code>Promise</code>对象最后的状态如何都会执行</li>
<li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是没法知道<code>Promise</code>最终的状态是<code>resolved</code>还是<code>rejected</code>的</li>
<li>它最终返回的默认会是一个<strong>上一次的Promise对象值</strong>，不过如果抛出的是一个异常则返回异常的<code>Promise</code>对象。</li>
</ol>
<p>来看看这个简单的例子🌰：</p>
<pre><code>Promise.resolve(&#39;1&#39;)
  .then(res =&gt; &#123;
    console.log(res)
  &#125;)
  .finally(() =&gt; &#123;
    console.log(&#39;finally&#39;)
  &#125;)
Promise.resolve(&#39;2&#39;)
  .finally(() =&gt; &#123;
    console.log(&#39;finally2&#39;)
   return &#39;我是finally2返回的值&#39;
  &#125;)
  .then(res =&gt; &#123;
    console.log(&#39;finally2后面的then函数&#39;, res)
  &#125;)
复制代码</code></pre>
<p>这两个<code>Promise</code>的<code>.finally</code>都会执行，且就算<code>finally2</code>返回了新的值，它后面的<code>then()</code>函数接收到的结果却还是<code>&#39;2&#39;</code>，因此打印结果为：</p>
<pre><code>&#39;1&#39;
&#39;finally2&#39;
&#39;finally&#39;
&#39;finally2后面的then函数&#39; &#39;2&#39;
复制代码</code></pre>
<p>至于为什么<code>finally2</code>的打印要在<code>finally</code>前面，请看下一个例子中的解析。</p>
<p>不过在此之前让我们再来确认一下，<code>finally</code>中要是抛出的是一个异常是怎样的：</p>
<pre><code>Promise.resolve(&#39;1&#39;)
  .finally(() =&gt; &#123;
    console.log(&#39;finally1&#39;)
    throw new Error(&#39;我是finally中抛出的异常&#39;)
  &#125;)
  .then(res =&gt; &#123;
    console.log(&#39;finally后面的then函数&#39;, res)
  &#125;)
  .catch(err =&gt; &#123;
    console.log(&#39;捕获错误&#39;, err)
  &#125;)
复制代码</code></pre>
<p>执行结果为：</p>
<pre><code>&#39;finally1&#39;
&#39;捕获错误&#39; Error: 我是finally中抛出的异常
复制代码</code></pre>
<p>但是如果改为<code>return new Error(&#39;我是finally中抛出的异常&#39;)</code>，打印出来的就是<code>&#39;finally后面的then函数 1&#39;</code></p>
<p>OK，👌，让我们来看一个比较难的例子🌰：</p>
<pre><code>function promise1 () &#123;
  let p = new Promise((resolve) =&gt; &#123;
    console.log(&#39;promise1&#39;);
    resolve(&#39;1&#39;)
  &#125;)
  return p;
&#125;
function promise2 () &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    reject(&#39;error&#39;)
  &#125;)
&#125;
promise1()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .finally(() =&gt; console.log(&#39;finally1&#39;))

promise2()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .finally(() =&gt; console.log(&#39;finally2&#39;))
复制代码</code></pre>
<p>执行过程：</p>
<ul>
<li>首先定义了两个函数<code>promise1</code>和<code>promise2</code>，先不管接着往下看。</li>
<li><code>promise1</code>函数先被调用了，然后执行里面<code>new Promise</code>的同步代码打印出<code>promise1</code></li>
<li>之后遇到了<code>resolve(1)</code>，将<code>p</code>的状态改为了<code>resolved</code>并将结果保存下来。</li>
<li>此时<code>promise1</code>内的函数内容已经执行完了，跳出该函数</li>
<li>碰到了<code>promise1().then()</code>，由于<code>promise1</code>的状态已经发生了改变且为<code>resolved</code>因此将<code>promise1().then()</code>这条微任务加入本轮的微任务列表(<strong>这是第一个微任务</strong>)</li>
<li>这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将<code>.finally</code>加入微任务列表，那是因为<code>.then</code>本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管<code>.finally()</code></li>
<li>再往下走碰到了<code>promise2()</code>函数，其中返回的<code>new Promise</code>中并没有同步代码需要执行，所以执行<code>reject(&#39;error&#39;)</code>的时候将<code>promise2</code>函数中的<code>Promise</code>的状态变为了<code>rejected</code></li>
<li>跳出<code>promise2</code>函数，遇到了<code>promise2().catch()</code>，将其加入当前的微任务队列(<strong>这是第二个微任务</strong>)，且链式调用后面的内容得等该任务执行完后才执行，和<code>.then()</code>一样。</li>
<li>OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在<code>promise1().then()</code>，执行它，打印出<code>1</code>，然后遇到了<code>.finally()</code>这个微任务将它加入微任务列表(<strong>这是第三个微任务</strong>)等待执行</li>
<li>再执行<code>promise2().catch()</code>打印出<code>error</code>，执行完后将<code>finally2</code>加入微任务加入微任务列表(<strong>这是第四个微任务</strong>)</li>
<li>OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行<code>finally1</code>和<code>finally2</code>。</li>
</ul>
<p>结果：</p>
<pre><code>&#39;promise1&#39;
&#39;1&#39;
&#39;error&#39;
&#39;finally1&#39;
&#39;finally2&#39;
复制代码</code></pre>
<p>在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为<strong>链式调用</strong>后面的内容需要等前一个调用执行完才会执行。</p>
<p>就像是这里的<code>finally()</code>会等<code>promise1().then()</code>执行完才会将<code>finally()</code>加入微任务队列，其实如果这道题中你把<code>finally()</code>换成是<code>then()</code>也是这样的:</p>
<pre><code>function promise1 () &#123;
  let p = new Promise((resolve) =&gt; &#123;
    console.log(&#39;promise1&#39;);
    resolve(&#39;1&#39;)
  &#125;)
  return p;
&#125;
function promise2 () &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    reject(&#39;error&#39;)
  &#125;)
&#125;
promise1()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .then(() =&gt; console.log(&#39;finally1&#39;))

promise2()
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
  .then(() =&gt; console.log(&#39;finally2&#39;))
复制代码</code></pre>
<h3 id="4-Promise中的all和race"><a href="#4-Promise中的all和race" class="headerlink" title="4. Promise中的all和race"></a>4. Promise中的all和race</h3><p>在做下面👇的题目之前，让我们先来了解一下<code>Promise.all()</code>和<code>Promise.race()</code>的用法。</p>
<p>通俗来说，<code>.all()</code>的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。</p>
<p><code>.race()</code>的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</p>
<p>来看看题目一。</p>
<h4 id="4-1-题目一"><a href="#4-1-题目一" class="headerlink" title="4.1 题目一"></a>4.1 题目一</h4><p>我们知道如果直接在脚本文件中定义一个<code>Promise</code>，它构造函数的第一个参数是会立即执行的，就像这样：</p>
<pre><code>const p1 = new Promise(r =&gt; console.log(&#39;立即打印&#39;))
复制代码</code></pre>
<p>控制台中会立即打印出 “立即打印”。</p>
<p>因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了：</p>
<pre><code>function runP1 () &#123;
    const p1 = new Promise(r =&gt; console.log(&#39;立即打印&#39;))
    return p1
&#125;

runP1() // 调用此函数时才执行
复制代码</code></pre>
<p>OK 👌， 让我们回归正题。</p>
<p>现在来构建这么一个函数：</p>
<pre><code>function runAsync (x) &#123;
    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
    return p
&#125;
复制代码</code></pre>
<p>该函数传入一个值<code>x</code>，然后间隔一秒后打印出这个<code>x</code>。</p>
<p>如果我用<code>.all()</code>来执行它会怎样呢？</p>
<pre><code>function runAsync (x) &#123;
    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
    return p
&#125;
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt; console.log(res))
复制代码</code></pre>
<p>先来想想此段代码在浏览器中会如何执行？</p>
<p>没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出<code>1, 2, 3</code>，还有一个数组<code>[1, 2, 3]</code>。</p>
<pre><code>1
2
3
[1, 2, 3]
复制代码</code></pre>
<p>所以你现在能理解这句话的意思了吗：<strong>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。</strong></p>
<p><code>.all()</code>后面的<code>.then()</code>里的回调函数接收的就是所有异步操作的结果。</p>
<p>而且这个结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致！！！</p>
<blockquote>
<p>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p>
</blockquote>
<h4 id="4-2-题目二"><a href="#4-2-题目二" class="headerlink" title="4.2 题目二"></a>4.2 题目二</h4><p>我新增了一个<code>runReject</code>函数，它用来在<code>1000 * x</code>秒后<code>reject</code>一个错误。</p>
<p>同时<code>.catch()</code>函数能够捕获到<code>.all()</code>里最先的那个异常，并且只执行一次。</p>
<p>想想这道题会怎样执行呢 🤔️？</p>
<pre><code>function runAsync (x) &#123;
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
&#125;
function runReject (x) &#123;
  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x))
  return p
&#125;
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt; console.log(res))
  .catch(err =&gt; console.log(err))
复制代码</code></pre>
<p>不卖关子了 😁，让我来公布答案：</p>
<pre><code>// 1s后输出
1
3
// 2s后输出
2
Error: 2
// 4s后输出
4
复制代码</code></pre>
<p>没错，就像我之前说的，<code>.catch</code>是会捕获最先的那个异常，在这道题目中最先的异常就是<code>runReject(2)</code>的结果。</p>
<p>另外，如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。</p>
<p>注意，为什么不说是不进入<code>.then()</code>中呢 🤔️？</p>
<p>哈哈，大家别忘了<code>.then()</code>方法的第二个参数也是可以捕获错误的：</p>
<pre><code>Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res =&gt; console.log(res), 
  err =&gt; console.log(err))
复制代码</code></pre>
<h4 id="4-3-题目三"><a href="#4-3-题目三" class="headerlink" title="4.3 题目三"></a>4.3 题目三</h4><p>接下来让我们看看另一个有趣的方法<code>.race</code>。</p>
<p>让我看看你们的英语水平如何？</p>
<p>快！一秒钟告诉我<code>race</code>是什么意思？</p>
<p>![](<a target="_blank" rel="noopener" href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="294" height="221"></svg>)</p>
<p>好吧…你们果然很强…</p>
<p><code>race</code>，比赛，赛跑的意思。</p>
<p>所以使用<code>.race()</code>方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过<code>race</code>已经不管那些任务的结果了。</p>
<p>来，改造一下<code>4.1</code>这道题：</p>
<pre><code>function runAsync (x) &#123;
  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))
  return p
&#125;
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt; console.log(&#39;result: &#39;, res))
  .catch(err =&gt; console.log(err))
复制代码</code></pre>
<p>执行结果为：</p>
<pre><code>1
&#39;result: &#39; 1
2
3
复制代码</code></pre>
<blockquote>
<p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p>
</blockquote>
<h4 id="4-4-题目四"><a href="#4-4-题目四" class="headerlink" title="4.4 题目四"></a>4.4 题目四</h4><p>改造一下题目<code>4.2</code>：</p>
<pre><code>function runAsync(x) &#123;
  const p = new Promise(r =&gt;
    setTimeout(() =&gt; r(x, console.log(x)), 1000)
  );
  return p;
&#125;
function runReject(x) &#123;
  const p = new Promise((res, rej) =&gt;
    setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)
  );
  return p;
&#125;
Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])
  .then(res =&gt; console.log(&quot;result: &quot;, res))
  .catch(err =&gt; console.log(err));
复制代码</code></pre>
<p>遇到错误的话，也是一样的，在这道题中，<code>runReject(0)</code>最先执行完，所以进入了<code>catch()</code>中：</p>
<pre><code>0
&#39;Error: 0&#39;
1
2
3
复制代码</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>好的，让我们来总结一下<code>.then()</code>和<code>.race()</code>吧，😄</p>
<ul>
<li><code>Promise.all()</code>的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。</li>
<li><code>.race()</code>的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</li>
<li><code>Promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致。</li>
<li><code>all和race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被<code>then</code>的第二个参数或者后面的<code>catch</code>捕获；但并不会影响数组中其它的异步任务的执行。</li>
</ul>
<h3 id="5-async-await的几道题"><a href="#5-async-await的几道题" class="headerlink" title="5. async/await的几道题"></a>5. async/await的几道题</h3><p>既然谈到了<code>Promise</code>，那就肯定得再说说<code>async/await</code>，在很多时候<code>async</code>和<code>Promise</code>的解法差不多，又有些不一样。不信你来看看题目一。</p>
<h4 id="5-1-题目一"><a href="#5-1-题目一" class="headerlink" title="5.1 题目一"></a>5.1 题目一</h4><pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;
async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;
async1();
console.log(&#39;start&#39;)
复制代码</code></pre>
<p>这道基础题输出的是啥？</p>
<p>答案：</p>
<pre><code>&#39;async1 start&#39;
&#39;async2&#39;
&#39;start&#39;
&#39;async1 end&#39;
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置</li>
<li>发现<code>async1</code>函数被调用了，然后去看看调用的内容</li>
<li>执行函数中的同步代码<code>async1 start</code>，之后碰到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code></li>
<li>跳出<code>async1</code>函数后，执行同步代码<code>start</code></li>
<li>在一轮宏任务全部执行完之后，再来执行刚刚<code>await</code>后面的内容<code>async1 end</code>。</li>
</ul>
<p>在这里，你可以理解为「紧跟着await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中」。</p>
<p>让我们来看看将<code>await</code>转换为<code>Promise.then</code>的伪代码：</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  // 原来代码
  // await async2();
  // console.log(&quot;async1 end&quot;);

  // 转换后代码
  new Promise(resolve =&gt; &#123;
    console.log(&quot;async2&quot;)
    resolve()
  &#125;).then(res =&gt; console.log(&quot;async1 end&quot;))
&#125;
async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;
async1();
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>转换后的伪代码和前面的执行结果是一样的。(感谢评论区<a target="_blank" rel="noopener" href="https://juejin.im/user/57e0f2738ac2470061745306">Wing93</a>和<a target="_blank" rel="noopener" href="https://juejin.im/user/5602aa7360b2521f381a3873">Jexxie</a>小伙伴的指出)</p>
<p>另外关于<code>await</code>和<code>Promise</code>的区别，如果我们把<code>await async2()</code>换成一个<code>new Promise</code>呢？</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  new Promise(resolve =&gt; &#123;
    console.log(&#39;promise&#39;)
  &#125;)
  console.log(&quot;async1 end&quot;);
&#125;
async1();
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>此时的执行结果为：</p>
<pre><code>&#39;async start&#39;
&#39;promise&#39;
&#39;async1 end&#39;
&#39;start&#39;
复制代码</code></pre>
<p>可以看到<code>new Promise()</code>并不会阻塞后面的同步代码<code>async1 end</code>的执行。</p>
<h4 id="5-2-题目二"><a href="#5-2-题目二" class="headerlink" title="5.2 题目二"></a>5.2 题目二</h4><p>现在将<code>async</code>结合定时器看看。</p>
<p>给题目一中的 <code>async2</code>函数中加上一个定时器：</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;
async function async2() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer&#39;)
  &#125;, 0)
  console.log(&quot;async2&quot;);
&#125;
async1();
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。</p>
<p>答案：</p>
<pre><code>&#39;async1 start&#39;
&#39;async2&#39;
&#39;start&#39;
&#39;async1 end&#39;
&#39;timer&#39;
复制代码</code></pre>
<h4 id="5-3-题目三"><a href="#5-3-题目三" class="headerlink" title="5.3 题目三"></a>5.3 题目三</h4><p>来吧，小伙伴们，让我们多加几个定时器看看。😁</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer1&#39;)
  &#125;, 0)
&#125;
async function async2() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer2&#39;)
  &#125;, 0)
  console.log(&quot;async2&quot;);
&#125;
async1();
setTimeout(() =&gt; &#123;
  console.log(&#39;timer3&#39;)
&#125;, 0)
console.log(&quot;start&quot;)
复制代码</code></pre>
<p>思考一下🤔，执行结果会是什么？</p>
<p>其实如果你能做到这里了，说明你前面的那些知识点也都掌握了，我就不需要太过详细的步骤分析了。</p>
<p>直接公布答案吧：</p>
<pre><code>&#39;async1 start&#39;
&#39;async2&#39;
&#39;start&#39;
&#39;async1 end&#39;
&#39;timer2&#39;
&#39;timer3&#39;
&#39;timer1&#39;
复制代码</code></pre>
<p>定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是<code>0</code>，所以只要关注谁先被调用的。。</p>
<h4 id="5-4-题目四"><a href="#5-4-题目四" class="headerlink" title="5.4 题目四"></a>5.4 题目四</h4><p>正常情况下，<code>async</code>中的<code>await</code>命令是一个<code>Promise</code>对象，返回该对象的结果。</p>
<p>但如果不是<code>Promise</code>对象的话，就会直接返回对应的值，相当于<code>Promise.resolve()</code></p>
<pre><code>async function fn () &#123;
  // return await 1234
  // 等同于
  return 123
&#125;
fn().then(res =&gt; console.log(res))
复制代码</code></pre>
<p>结果：</p>
<pre><code>123
复制代码</code></pre>
<h4 id="5-5-题目五"><a href="#5-5-题目五" class="headerlink" title="5.5 题目五"></a>5.5 题目五</h4><pre><code>async function async1 () &#123;
  console.log(&#39;async1 start&#39;);
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
  &#125;)
  console.log(&#39;async1 success&#39;);
  return &#39;async1 end&#39;
&#125;
console.log(&#39;srcipt start&#39;)
async1().then(res =&gt; console.log(res))
console.log(&#39;srcipt end&#39;)
复制代码</code></pre>
<p>这道题目比较有意思，大家要注意了。</p>
<p>在<code>async1</code>中<code>await</code>后面的<code>Promise</code>是没有返回值的，也就是它的状态始终是<code>pending</code>状态，因此相当于一直在<code>await</code>，<code>await</code>，<code>await</code>却始终没有响应…</p>
<p>![](<a target="_blank" rel="noopener" href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="255" height="255"></svg>)</p>
<p>所以在<code>await</code>之后的内容是不会执行的，也包括<code>async1</code>后面的 <code>.then</code>。</p>
<p>答案为：</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;promise1&#39;
&#39;script end&#39;
复制代码</code></pre>
<h4 id="5-6-题目六"><a href="#5-6-题目六" class="headerlink" title="5.6 题目六"></a>5.6 题目六</h4><p>让我们给<code>5.5</code>中的<code>Promise</code>加上<code>resolve</code>：</p>
<pre><code>async function async1 () &#123;
  console.log(&#39;async1 start&#39;);
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
    resolve(&#39;promise1 resolve&#39;)
  &#125;).then(res =&gt; console.log(res))
  console.log(&#39;async1 success&#39;);
  return &#39;async1 end&#39;
&#125;
console.log(&#39;srcipt start&#39;)
async1().then(res =&gt; console.log(res))
console.log(&#39;srcipt end&#39;)
复制代码</code></pre>
<p>现在<code>Promise</code>有了返回值了，因此<code>await</code>后面的内容将会被执行：</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;promise1&#39;
&#39;script end&#39;
&#39;promise1 resolve&#39;
&#39;async1 success&#39;
&#39;async1 end&#39;
复制代码</code></pre>
<h4 id="5-7-题目七"><a href="#5-7-题目七" class="headerlink" title="5.7 题目七"></a>5.7 题目七</h4><pre><code>async function async1 () &#123;
  console.log(&#39;async1 start&#39;);
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
    resolve(&#39;promise resolve&#39;)
  &#125;)
  console.log(&#39;async1 success&#39;);
  return &#39;async1 end&#39;
&#125;
console.log(&#39;srcipt start&#39;)
async1().then(res =&gt; &#123;
  console.log(res)
&#125;)
new Promise(resolve =&gt; &#123;
  console.log(&#39;promise2&#39;)
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer&#39;)
  &#125;)
&#125;)
复制代码</code></pre>
<p>这道题应该也不难，不过有一点需要注意的，在<code>async1</code>中的<code>new Promise</code>它的<code>resovle</code>的值和<code>async1().then()</code>里的值是没有关系的，很多小伙伴可能看到<code>resovle(&#39;promise resolve&#39;)</code>就会误以为是<code>async1().then()</code>中的返回值。</p>
<p>因此这里的执行结果为：</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;promise1&#39;
&#39;promise2&#39;
&#39;async1 success&#39;
&#39;async1 end&#39;
&#39;timer&#39;
复制代码</code></pre>
<h4 id="5-8-题目八"><a href="#5-8-题目八" class="headerlink" title="5.8 题目八"></a>5.8 题目八</h4><p>我们再来看一道头条曾经的面试题：</p>
<pre><code>async function async1() &#123;
  console.log(&quot;async1 start&quot;);
  await async2();
  console.log(&quot;async1 end&quot;);
&#125;

async function async2() &#123;
  console.log(&quot;async2&quot;);
&#125;

console.log(&quot;script start&quot;);

setTimeout(function() &#123;
  console.log(&quot;setTimeout&quot;);
&#125;, 0);

async1();

new Promise(function(resolve) &#123;
  console.log(&quot;promise1&quot;);
  resolve();
&#125;).then(function() &#123;
  console.log(&quot;promise2&quot;);
&#125;);
console.log(&#39;script end&#39;)
复制代码</code></pre>
<p>有了上面👆几题做基础，相信你很快也能答上来了。</p>
<p>![](<a target="_blank" rel="noopener" href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="300" height="300"></svg>)</p>
<p>自信的写下你们的答案吧。</p>
<pre><code>&#39;script start&#39;
&#39;async1 start&#39;
&#39;async2&#39;
&#39;promise1&#39;
&#39;script end&#39;
&#39;async1 end&#39;
&#39;promise2&#39;
&#39;setTimeout&#39;
复制代码</code></pre>
<p>(这道题最后<code>async1 end</code>和<code>promise2</code>的顺序其实在网上饱受争议，我这里使用浏览器<code>Chrome V80</code>，<code>Node v12.16.1</code>的执行结果都是上面这个答案)</p>
<h4 id="5-9-题目九"><a href="#5-9-题目九" class="headerlink" title="5.9 题目九"></a>5.9 题目九</h4><p>好的👌，<code>async/await</code>大法已练成，咱们继续：</p>
<pre><code>async function testSometing() &#123;
  console.log(&quot;执行testSometing&quot;);
  return &quot;testSometing&quot;;
&#125;

async function testAsync() &#123;
  console.log(&quot;执行testAsync&quot;);
  return Promise.resolve(&quot;hello async&quot;);
&#125;

async function test() &#123;
  console.log(&quot;test start...&quot;);
  const v1 = await testSometing();
  console.log(v1);
  const v2 = await testAsync();
  console.log(v2);
  console.log(v1, v2);
&#125;

test();

var promise = new Promise(resolve =&gt; &#123;
  console.log(&quot;promise start...&quot;);
  resolve(&quot;promise&quot;);
&#125;);
promise.then(val =&gt; console.log(val));

console.log(&quot;test end...&quot;);
复制代码</code></pre>
<p>答案：</p>
<pre><code>&#39;test start...&#39;
&#39;执行testSometing&#39;
&#39;promise start...&#39;
&#39;test end...&#39;
&#39;testSometing&#39;
&#39;执行testAsync&#39;
&#39;promise&#39;
&#39;hello async&#39;
&#39;testSometing&#39; &#39;hello async&#39;
复制代码</code></pre>
<h3 id="6-async处理错误"><a href="#6-async处理错误" class="headerlink" title="6. async处理错误"></a>6. async处理错误</h3><h4 id="6-1-题目一"><a href="#6-1-题目一" class="headerlink" title="6.1 题目一"></a>6.1 题目一</h4><p>在<code>async</code>中，如果 <code>await</code>后面的内容是一个异常或者错误的话，会怎样呢？</p>
<pre><code>async function async1 () &#123;
  await async2();
  console.log(&#39;async1&#39;);
  return &#39;async1 success&#39;
&#125;
async function async2 () &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    console.log(&#39;async2&#39;)
    reject(&#39;error&#39;)
  &#125;)
&#125;
async1().then(res =&gt; console.log(res))
复制代码</code></pre>
<p>例如这道题中，<code>await</code>后面跟着的是一个状态为<code>rejected</code>的<code>promise</code>。</p>
<p><strong>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p>
<p>所以答案为：</p>
<pre><code>&#39;async2&#39;
Uncaught (in promise) error
复制代码</code></pre>
<p>如果改为<code>throw new Error</code>也是一样的：</p>
<pre><code>async function async1 () &#123;
  console.log(&#39;async1&#39;);
  throw new Error(&#39;error!!!&#39;)
  return &#39;async1 success&#39;
&#125;
async1().then(res =&gt; console.log(res))
复制代码</code></pre>
<p>结果为：</p>
<pre><code>&#39;async1&#39;
Uncaught (in promise) Error: error!!!
复制代码</code></pre>
<h4 id="6-2-题目二"><a href="#6-2-题目二" class="headerlink" title="6.2 题目二"></a>6.2 题目二</h4><p>如果想要使得错误的地方不影响<code>async</code>函数后续的执行的话，可以使用<code>try catch</code></p>
<pre><code>async function async1 () &#123;
  try &#123;
    await Promise.reject(&#39;error!!!&#39;)
  &#125; catch(e) &#123;
    console.log(e)
  &#125;
  console.log(&#39;async1&#39;);
  return Promise.resolve(&#39;async1 success&#39;)
&#125;
async1().then(res =&gt; console.log(res))
console.log(&#39;script start&#39;)
复制代码</code></pre>
<p>这里的结果为：</p>
<pre><code>&#39;script start&#39;
&#39;error!!!&#39;
&#39;async1&#39;
&#39;async1 success&#39;
复制代码</code></pre>
<p>或者你可以直接在<code>Promise.reject</code>后面跟着一个<code>catch()</code>方法：</p>
<pre><code>async function async1 () &#123;
  // try &#123;
  //   await Promise.reject(&#39;error!!!&#39;)
  // &#125; catch(e) &#123;
  //   console.log(e)
  // &#125;
  await Promise.reject(&#39;error!!!&#39;)
    .catch(e =&gt; console.log(e))
  console.log(&#39;async1&#39;);
  return Promise.resolve(&#39;async1 success&#39;)
&#125;
async1().then(res =&gt; console.log(res))
console.log(&#39;script start&#39;)
复制代码</code></pre>
<p>运行结果是一样的。</p>
<h3 id="7-综合题"><a href="#7-综合题" class="headerlink" title="7. 综合题"></a>7. 综合题</h3><p>上面👆的题目都是被我拆分着说一些功能点，现在让我们来做一些比较难的综合题吧。</p>
<h4 id="7-1-题目一"><a href="#7-1-题目一" class="headerlink" title="7.1 题目一"></a>7.1 题目一</h4><pre><code>const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;
    console.log(3);
    let p = new Promise((resolve, reject) =&gt; &#123;
        console.log(7);
        setTimeout(() =&gt; &#123;
            console.log(5);
            resolve(6);
            console.log(p)
        &#125;, 0)
        resolve(1);
    &#125;);
    resolve(2);
    p.then((arg) =&gt; &#123;
        console.log(arg);
    &#125;);
&#125;));
first().then((arg) =&gt; &#123;
    console.log(arg);
&#125;);
console.log(4);
复制代码</code></pre>
<p>过程分析：</p>
<ul>
<li>第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在<code>4</code>之前，所以可以来看看<code>first</code>函数里面的内容了。(这一步有点类似于题目<code>1.5</code>)</li>
<li>函数<code>first</code>返回的是一个<code>new Promise()</code>，因此先执行里面的同步代码<code>3</code></li>
<li>接着又遇到了一个<code>new Promise()</code>，直接执行里面的同步代码<code>7</code></li>
<li>执行完<code>7</code>之后，在<code>p</code>中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走</li>
<li>碰到了<code>resolve(1)</code>，这里就把<code>p</code>的状态改为了<code>resolved</code>，且返回值为<code>1</code>，不过这里也先不执行</li>
<li>跳出<code>p</code>，碰到了<code>resolve(2)</code>，这里的<code>resolve(2)</code>，表示的是把<code>first</code>函数返回的那个<code>Promise</code>的状态改了，也先不管它。</li>
<li>然后碰到了<code>p.then</code>，将它加入本次循环的微任务列表，等待执行</li>
<li>跳出<code>first</code>函数，遇到了<code>first().then()</code>，将它加入本次循环的微任务列表(<code>p.then</code>的后面执行)</li>
<li>然后执行同步代码<code>4</code></li>
<li>本轮的同步代码全部执行完毕，查找微任务列表，发现<code>p.then</code>和<code>first().then()</code>，依次执行，打印出<code>1和2</code></li>
<li>本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码<code>5</code></li>
<li>然后又遇到了一个<code>resolve(6)</code>，它是放在<code>p</code>里的，但是<code>p</code>的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说<code>resolve(6)</code>相当于没任何用处，因此打印出来的<code>p</code>为<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>。(这一步类似于题目<code>3.1</code>)</li>
</ul>
<p>结果：</p>
<pre><code>3
7
4
1
2
5
Promise&#123;&lt;resolved&gt;: 1&#125;
复制代码</code></pre>
<p>做对了的小伙伴奖励自己一朵小<code>(大)</code>红<code>(嘴)</code>花<code>(巴)</code>吧，😄</p>
<p>![](<a target="_blank" rel="noopener" href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="360" height="360"></svg>)</p>
<h4 id="7-2-题目二"><a href="#7-2-题目二" class="headerlink" title="7.2 题目二"></a>7.2 题目二</h4><pre><code>const async1 = async () =&gt; &#123;
  console.log(&#39;async1&#39;);
  setTimeout(() =&gt; &#123;
    console.log(&#39;timer1&#39;)
  &#125;, 2000)
  await new Promise(resolve =&gt; &#123;
    console.log(&#39;promise1&#39;)
  &#125;)
  console.log(&#39;async1 end&#39;)
  return &#39;async1 success&#39;
&#125; 
console.log(&#39;script start&#39;);
async1().then(res =&gt; console.log(res));
console.log(&#39;script end&#39;);
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res =&gt; console.log(res))
setTimeout(() =&gt; &#123;
  console.log(&#39;timer2&#39;)
&#125;, 1000)
复制代码</code></pre>
<p>注意的知识点：</p>
<ul>
<li><code>async</code>函数中<code>await</code>的<code>new Promise</code>要是没有返回值的话则不执行后面的内容(类似题<code>5.5</code>)</li>
<li><code>.then</code>函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题<code>3.8</code> )</li>
<li>注意定时器的延迟时间</li>
</ul>
<p>因此本题答案为：</p>
<pre><code>&#39;script start&#39;
&#39;async1&#39;
&#39;promise1&#39;
&#39;script end&#39;
1
&#39;timer2&#39;
&#39;timer1&#39;
复制代码</code></pre>
<h4 id="7-3-题目三"><a href="#7-3-题目三" class="headerlink" title="7.3 题目三"></a>7.3 题目三</h4><pre><code>const p1 = new Promise((resolve) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;resolve3&#39;);
    console.log(&#39;timer1&#39;)
  &#125;, 0)
  resolve(&#39;resovle1&#39;);
  resolve(&#39;resolve2&#39;);
&#125;).then(res =&gt; &#123;
  console.log(res)
  setTimeout(() =&gt; &#123;
    console.log(p1)
  &#125;, 1000)
&#125;).finally(res =&gt; &#123;
  console.log(&#39;finally&#39;, res)
&#125;)
复制代码</code></pre>
<p>注意的知识点：</p>
<ul>
<li><code>Promise</code>的状态一旦改变就无法改变(类似题目<code>3.5</code>)</li>
<li><code>finally</code>不管<code>Promise</code>的状态是<code>resolved</code>还是<code>rejected</code>都会执行，且它的回调函数是接收不到<code>Promise</code>的结果的，所以<code>finally()</code>中的<code>res</code>是一个迷惑项(类似<code>3.10</code>)。</li>
<li>最后一个定时器打印出的<code>p1</code>其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个<code>Promise</code>的返回值(<code>3.10</code>中也有提到), 而这道题中<code>.finally</code>上一个<code>Promise</code>是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以<code>p1</code>打印出来的<code>Promise</code>的值会是<code>undefined</code>，如果你在定时器的<strong>下面</strong>加上一个<code>return 1</code>，则值就会变成<code>1</code>(感谢掘友<a target="_blank" rel="noopener" href="https://juejin.im/user/5b1487eee51d4506e1748613">JS丛中过</a>的指出)。</li>
</ul>
<p>答案：</p>
<pre><code>&#39;resolve1&#39;
&#39;finally&#39; undefined
&#39;timer1&#39;
Promise&#123;&lt;resolved&gt;: undefined&#125;
复制代码</code></pre>
<h3 id="8-几道大厂的面试题"><a href="#8-几道大厂的面试题" class="headerlink" title="8. 几道大厂的面试题"></a>8. 几道大厂的面试题</h3><h4 id="8-1-使用Promise实现每隔1秒输出1-2-3"><a href="#8-1-使用Promise实现每隔1秒输出1-2-3" class="headerlink" title="8.1 使用Promise实现每隔1秒输出1,2,3"></a>8.1 使用Promise实现每隔1秒输出1,2,3</h4><p>这道题比较简单的一种做法是可以用<code>Promise</code>配合着<code>reduce</code>不停的在<code>promise</code>后面叠加<code>.then</code>，请看下面的代码：</p>
<pre><code>const arr = [1, 2, 3]
arr.reduce((p, x) =&gt; &#123;
  return p.then(() =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; r(console.log(x)), 1000)
    &#125;)
  &#125;)
&#125;, Promise.resolve())
复制代码</code></pre>
<p>或者你可以更简单一点写：</p>
<pre><code>const arr = [1, 2, 3]
arr.reduce((p, x) =&gt; p.then(() =&gt; new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve())
复制代码</code></pre>
<p>参考链接：<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000010748967">如何让异步操作顺序执行</a></p>
<p><strong>拓展题</strong></p>
<p>这道拓展题来自于“万物皆可爱的<a target="_blank" rel="noopener" href="https://juejin.im/user/5cd2341ce51d456e5c5baba3">LINGLONG</a> ”小姐姐，炒鸡棒 😁👍。</p>
<p>题目是这样的，她把我上面👆写的箭头函数版本改造了一下：</p>
<pre><code>const arr = [1, 2, 3];
const result = arr.reduce((p, x) =&gt; p.then(new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve());
复制代码</code></pre>
<p>眼尖的小伙伴看出区别了吗？😁</p>
<p><code>p.then</code>里的代码由<code>() =&gt; new Promise(...)</code>变成了<code>new Promise(...)</code>。</p>
<p>现在执行结果就大不相同了。</p>
<p><strong>在一秒后按顺序同时打印出<code>1、2、3</code>:</strong></p>
<pre><code>1
2
3
复制代码</code></pre>
<p>咦 🤔️？为什么会这样呢 🤔️？</p>
<p>只是一个小小的改变却有大大的区别。</p>
<p>其实刚开始看到的时候霖呆呆我也愣了那么几秒😂。不过等我们一步一步拆分并对想不通的地方写了几个案例来看就理解了。</p>
<p>评论区和小姐姐扯了一大堆，结果把她越弄越糊😂。后来我改变了一种思路来描述，觉得应该直接上伪代码：</p>
<pre><code>const arr = [1, 2, 3]
arr.reduce((p, x) =&gt; p.then(() =&gt; new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve())
复制代码</code></pre>
<p>转换为伪代码就是这样：</p>
<p>(相当于是用<code>reduce</code>不停的往后面叠加<code>.then</code>)</p>
<pre><code>Promise.resolve()
  .then(() =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; &#123;
        r(console.log(1))
      &#125;, 1000)
    &#125;)
  &#125;)
  .then(r =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; &#123;
        r(console.log(2))
      &#125;, 1000)
    &#125;)
  &#125;)
  .then(r =&gt; &#123;
    return new Promise(r =&gt; &#123;
      setTimeout(() =&gt; &#123;
        r(console.log(3))
      &#125;, 1000)
    &#125;)
  &#125;)
复制代码</code></pre>
<p>可以看到，每一个<code>.then</code>都是依赖于上一个<code>new Promise</code>何时被<code>resolve</code>了才会执行的，例如第二个<code>.then()</code>，它要等<code>r(console.log(1)</code>这段代码执行了，才会执行。</p>
<p>那么<code>r(console.log(1))</code>什么时候执行呢？就是在第一个定时器(也就是一秒后)触发的时候才执行。这样就保证了后面接着的<code>.then()</code>要等前一个定时器执行完才能执行，也就是隔一秒输出。</p>
<p>而如果是这样写的话：</p>
<pre><code>const arr = [1, 2, 3];
const result = arr.reduce((p, x) =&gt; p.then(new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve());
复制代码</code></pre>
<p>它的伪代码就是这样：</p>
<p>(每个<code>then</code>里面的第一个参数不是一个函数)</p>
<pre><code>Promise.resolve()
  .then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(1))
    &#125;, 1000)
  &#125;))
  .then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(2))
    &#125;, 1000)
  &#125;))
  .then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(3))
    &#125;, 1000)
  &#125;))
复制代码</code></pre>
<p><code>p.then()</code>里面的参数如果不是函数的话，会发生透传，这个在<code>3.8</code>中已经提过了。但是发生透传，<code>.then()</code>里的代码就不执行了吗？</p>
<p>并不是的，我们来看这个例子：</p>
<pre><code>const p = Promise.resolve(1).then(console.log(&#39;我不关心结果&#39;))
console.log(p)
p.then((res) =&gt; console.log(res))
复制代码</code></pre>
<p>很明显这里也发生了透传，但是<code>&#39;我不关心结果&#39;</code>也还是被打印出来了，并且由于透传，<code>p.then()</code>里获取到的<code>res</code>就是<code>1</code>，因此会打印出：</p>
<pre><code>&#39;我不关心结果&#39;
Promise&#123;
[[PromiseStatus]]: &quot;resolved&quot;
[[PromiseValue]]: 1
&#125;
1
复制代码</code></pre>
<p>(第二行打印出<code>Promise&#123;&lt;pending&gt;&#125;</code>的小伙伴请把这个对象展开来看)</p>
<p>这个例子表明，就算发生了透传，<code>p.then()</code>中的代码依旧也是会执行的。</p>
<p>所以回到</p>
<pre><code>.then(new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(1))
    &#125;, 1000)
  &#125;))
复制代码</code></pre>
<p>中，现在<code>.then()</code>中就相当于是执行一段同步代码：</p>
<pre><code>new Promise(r =&gt; &#123;
    setTimeout(() =&gt; &#123;
      r(console.log(1))
    &#125;, 1000)
  &#125;)
复制代码</code></pre>
<p>而这段代码的作用是向延迟队列中<code>push</code>一个一秒后执行的定时器任务。</p>
<p>并且在<code>push</code>完定时器之后，代码就马上进入了下一个<code>.then</code>(因为既然第一个<code>.then</code>已经是透传的了就没有必要等它的执行结果了)</p>
<p>下一个<code>.then</code>竟然也是一个透传，OK，那我继续<code>push</code>这个定时器，然后再执行第三个<code>.then</code>。</p>
<p>三个<code>.then</code>已经执行完成了，现在我们的延迟队列中已经有了三个定时器等待执行，**并且三个定时器的延迟时间都是1000ms!!!**。</p>
<p>所以等到了时间之后，就会同时打印出来了<code>1、2、3</code>。（其实准确来说，不是同时打印的，不过中间相差的时间非常非常短，大可忽略它）</p>
<p>现在你是否理解了其中的区别呢 😝。</p>
<h4 id="8-2-使用Promise实现红绿灯交替重复亮"><a href="#8-2-使用Promise实现红绿灯交替重复亮" class="headerlink" title="8.2 使用Promise实现红绿灯交替重复亮"></a>8.2 使用Promise实现红绿灯交替重复亮</h4><p>红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在：</p>
<pre><code>function red() &#123;
    console.log(&#39;red&#39;);
&#125;
function green() &#123;
    console.log(&#39;green&#39;);
&#125;
function yellow() &#123;
    console.log(&#39;yellow&#39;);
&#125;
复制代码</code></pre>
<p>答案：</p>
<pre><code>function red() &#123;
  console.log(&quot;red&quot;);
&#125;
function green() &#123;
  console.log(&quot;green&quot;);
&#125;
function yellow() &#123;
  console.log(&quot;yellow&quot;);
&#125;
const light = function (timer, cb) &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(() =&gt; &#123;
      cb()
      resolve()
    &#125;, timer)
  &#125;)
&#125;
const step = function () &#123;
  Promise.resolve().then(() =&gt; &#123;
    return light(3000, red)
  &#125;).then(() =&gt; &#123;
    return light(2000, green)
  &#125;).then(() =&gt; &#123;
    return light(1000, yellow)
  &#125;).then(() =&gt; &#123;
    return step()
  &#125;)
&#125;

step();
复制代码</code></pre>
<h4 id="8-3-实现mergePromise函数"><a href="#8-3-实现mergePromise函数" class="headerlink" title="8.3 实现mergePromise函数"></a>8.3 实现mergePromise函数</h4><p>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。</p>
<pre><code>const time = (timer) =&gt; &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(() =&gt; &#123;
      resolve()
    &#125;, timer)
  &#125;)
&#125;
const ajax1 = () =&gt; time(2000).then(() =&gt; &#123;
  console.log(1);
  return 1
&#125;)
const ajax2 = () =&gt; time(1000).then(() =&gt; &#123;
  console.log(2);
  return 2
&#125;)
const ajax3 = () =&gt; time(1000).then(() =&gt; &#123;
  console.log(3);
  return 3
&#125;)

function mergePromise () &#123;
  // 在这里写代码
&#125;

mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; &#123;
  console.log(&quot;done&quot;);
  console.log(data); // data 为 [1, 2, 3]
&#125;);

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]
复制代码</code></pre>
<p>这道题有点类似于<code>Promise.all()</code>，不过<code>.all()</code>不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。</p>
<p>解题思路：</p>
<ul>
<li>定义一个数组<code>data</code>用于保存所有异步操作的结果</li>
<li>初始化一个<code>const promise = Promise.resolve()</code>，然后循环遍历数组，在<code>promise</code>后面添加执行<code>ajax</code>任务，同时要将添加的结果重新赋值到<code>promise</code>上。</li>
</ul>
<p>答案：</p>
<pre><code>function mergePromise (ajaxArray) &#123;
  // 存放每个ajax的结果
  const data = [];
  let promise = Promise.resolve();
  ajaxArray.forEach(ajax =&gt; &#123;
   // 第一次的then为了用来调用ajax
   // 第二次的then是为了获取ajax的结果
    promise = promise.then(ajax).then(res =&gt; &#123;
      data.push(res);
      return data; // 把每次的结果返回
    &#125;)
  &#125;)
  // 最后得到的promise它的值就是data
  return promise;
&#125;
复制代码</code></pre>
<h4 id="8-4-根据promiseA-实现一个自己的promise"><a href="#8-4-根据promiseA-实现一个自己的promise" class="headerlink" title="8.4 根据promiseA+实现一个自己的promise"></a>8.4 根据promiseA+实现一个自己的promise</h4><p>说真的，这道题被问到的概率还是挺高的，而且要说的内容也很多…</p>
<p>霖呆呆这里偷个懒，不想细说了…</p>
<p>不过哈，我保证，下下题我一定仔细说 😼.</p>
<p>![](<a target="_blank" rel="noopener" href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="440" height="440"></svg>)</p>
<p>来吧，给你们一些好的宝典：</p>
<ul>
<li>[《Promise不会？？看这里！！！史上最通俗易懂的Promise！！！》](<a target="_blank" rel="noopener" href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b">https://juejin.im/post/5afe6d3bf265da0b9e654c4b</a> rel=)</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23312442">《写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise》</a></li>
</ul>
<h4 id="8-5-封装一个异步加载图片的方法"><a href="#8-5-封装一个异步加载图片的方法" class="headerlink" title="8.5 封装一个异步加载图片的方法"></a>8.5 封装一个异步加载图片的方法</h4><p>这个相对简单一些，只需要在图片的<code>onload</code>函数中，使用<code>resolve</code>返回一下就可以了。</p>
<p>来看看具体代码：</p>
<pre><code>function loadImg(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    const img = new Image();
    img.onload = function() &#123;
      console.log(&quot;一张图片加载完成&quot;);
      resolve(img);
    &#125;;
    img.onerror = function() &#123;
     reject(new Error(&#39;Could not load image at&#39; + url));
    &#125;;
    img.src = url;
  &#125;);
复制代码</code></pre>
<h4 id="8-6-限制异步操作的并发个数并尽可能快的完成全部"><a href="#8-6-限制异步操作的并发个数并尽可能快的完成全部" class="headerlink" title="8.6 限制异步操作的并发个数并尽可能快的完成全部"></a>8.6 限制异步操作的并发个数并尽可能快的完成全部</h4><p>有8个图片资源的url，已经存储在数组<code>urls</code>中。</p>
<p><code>urls</code>类似于<code>[&#39;https://image1.png&#39;, &#39;https://image2.png&#39;, ....]</code></p>
<p>而且已经有一个函数<code>function loadImg</code>，输入一个<code>url</code>链接，返回一个<code>Promise</code>，该<code>Promise</code>在图片下载完成的时候<code>resolve</code>，下载失败则<code>reject</code>。</p>
<p>但有一个要求，任何时刻同时下载的链接<strong>数量不可以超过3个</strong>。</p>
<p>请写一段代码实现这个需求，要求<strong>尽可能快速</strong>地将所有图片下载完成。</p>
<pre><code>var urls = [
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;,
  &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;,
];
function loadImg(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    const img = new Image();
    img.onload = function() &#123;
      console.log(&quot;一张图片加载完成&quot;);
      resolve(img);
    &#125;;
    img.onerror = function() &#123;
     reject(new Error(&#39;Could not load image at&#39; + url));
    &#125;;
    img.src = url;
  &#125;);
复制代码</code></pre>
<p>看到这道题时，我最开始的想法是：</p>
<ul>
<li>拿到<code>urls</code>，然后将这个数组每3个<code>url</code>一组创建成一个二维数组</li>
<li>然后用<code>Promise.all()</code>每次加载一组<code>url</code>（也就是并发3个），这一组加载完再加载下一组。</li>
</ul>
<p>这个想法从技术上说并不难实现，有点类似于第三题。不过缺点也明显，那就是每次都要等到上一组全部加载完之后，才加载下一组，那如果上一组有<code>2</code>个已经加载完了，还有<code>1</code>个特别慢，还在加载，要等这个慢的也加载完才能进入下一组。这明显会照常卡顿，影响加载效率。</p>
<p>但是开始没有考虑这么多，因此有了第一个版本。</p>
<p><strong>如果你有兴趣可以看看想法一的代码，虽然对你没什么帮助，想直接知道比较好的做法的小伙伴请跳到想法二</strong></p>
<p>![](<a target="_blank" rel="noopener" href="https://juejin.im/post/data:image/svg+xml;utf8,">https://juejin.im/post/data:image/svg+xml;utf8,</a><?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="320" height="259"></svg>)</p>
<p><strong>想法一</strong>💡：</p>
<pre><code>function limitLoad (urls, handler, limit) &#123;
  const data = []; // 存储所有的加载结果
  let p = Promise.resolve();
  const handleUrls = (urls) =&gt; &#123; // 这个函数是为了生成3个url为一组的二维数组
    const doubleDim = [];
    const len = Math.ceil(urls.length / limit); // Math.ceil(8 / 3) = 3
    console.log(len) // 3, 表示二维数组的长度为3
    for (let i = 0; i &lt; len; i++) &#123;
      doubleDim.push(urls.slice(i * limit, (i + 1) * limit))
    &#125;
    return doubleDim;
  &#125;
  const ajaxImage = (urlCollect) =&gt; &#123; // 将一组字符串url 转换为一个加载图片的数组
    console.log(urlCollect)
    return urlCollect.map(url =&gt; handler(url))
  &#125;
  const doubleDim = handleUrls(urls); // 得到3个url为一组的二维数组
  doubleDim.forEach(urlCollect =&gt; &#123;
    p = p.then(() =&gt; Promise.all(ajaxImage(urlCollect))).then(res =&gt; &#123;
      data.push(...res); // 将每次的结果展开，并存储到data中 (res为：[img, img, img])
      return data;
    &#125;)
  &#125;)
  return p;
&#125;
limitLoad(urls, loadImg, 3).then(res =&gt; &#123;
  console.log(res); // 最终得到的是长度为8的img数组: [img, img, img, ...]
  res.forEach(img =&gt; &#123;
    document.body.appendChild(img);
  &#125;)
&#125;);
复制代码</code></pre>
<p><strong>想法二</strong>💡：</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4bb1521343ba">LHH大翰仔仔-Promise面试题</a></p>
<p>既然题目的要求是保证每次并发请求的数量为3，那么我们可以先请求<code>urls</code>中的前面三个(下标为<code>0,1,2</code>)，并且请求的时候使用<code>Promise.race()</code>来同时请求，三个中有一个先完成了(例如下标为<code>1</code>的图片)，我们就把这个当前数组中已经完成的那一项(第<code>1</code>项)换成还没有请求的那一项(<code>urls</code>中下标为<code>3</code>)。</p>
<p>直到<code>urls</code>已经遍历完了，然后将最后三个没有完成的请求(也就是状态没有改变的<code>Promise</code>)用<code>Promise.all()</code>来加载它们。</p>
<p>不多说，流程图都给你画好了，你可以结合流程图再来看代码。</p>
<p>为了方便你查看，我截了个图，不过代码在后面也有</p>
<p>(说真的，要我看这一大长串代码我也不愿意…)</p>
<p>代码：</p>
<pre><code>function limitLoad(urls, handler, limit) &#123;
  let sequence = [].concat(urls); // 复制urls
  // 这一步是为了初始化 promises 这个&quot;容器&quot;
  let promises = sequence.splice(0, limit).map((url, index) =&gt; &#123;
    return handler(url).then(() =&gt; &#123;
      // 返回下标是为了知道数组中是哪一项最先完成
      return index;
    &#125;);
  &#125;);
  // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用
  return sequence
    .reduce((pCollect, url) =&gt; &#123;
      return pCollect
        .then(() =&gt; &#123;
          return Promise.race(promises); // 返回已经完成的下标
        &#125;)
        .then(fastestIndex =&gt; &#123; // 获取到已经完成的下标
         // 将&quot;容器&quot;内已经完成的那一项替换
          promises[fastestIndex] = handler(url).then(
            () =&gt; &#123;
              return fastestIndex; // 要继续将这个下标返回，以便下一次变量
            &#125;
          );
        &#125;)
        .catch(err =&gt; &#123;
          console.error(err);
        &#125;);
    &#125;, Promise.resolve()) // 初始化传入
    .then(() =&gt; &#123; // 最后三个用.all来调用
      return Promise.all(promises);
    &#125;);
&#125;
limitLoad(urls, loadImg, 3)
  .then(res =&gt; &#123;
    console.log(&quot;图片全部加载完毕&quot;);
    console.log(res);
  &#125;)
  .catch(err =&gt; &#123;
    console.error(err);
  &#125;);
复制代码</code></pre>
<h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37719279/article/details/80950713">《ES6之Promise常见面试题》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000010748967">《如何让异步操作顺序执行》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html">《大白话讲解Promise（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4bb1521343ba">《LHH大翰仔仔-Promise面试题》</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/guolinengineer/article/details/85067924">《今日头条async/await面试题执行顺序》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5dd8b3a851882572f56b578f">《(2.4w字,建议收藏)😇原生JS灵魂之问(下), 冲刺🚀进阶最后一公里(附个人成长经验分享)》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E4%BF%97%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E4%BF%97%E8%AF%AD/" class="post-title-link" itemprop="url">俗语</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-18 17:24:28" itemprop="dateCreated datePublished" datetime="2020-06-18T17:24:28+08:00">2020-06-18</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="宁可荤口念佛，不可素口骂人"><a href="#宁可荤口念佛，不可素口骂人" class="headerlink" title="宁可荤口念佛，不可素口骂人"></a>宁可荤口念佛，不可素口骂人</h2><p>字面上的意思是说，我们宁可吃肉喝酒，口中念佛，但是不能吃素却骂人。</p>
<p>这里所说的“荤口”，是指的我们普通人，因为这些人酒肉穿肠过，没有什么吃喝忌讳。虽然不刻意去戒口，但是每时每刻心中友善，口中念佛。这句话是老祖宗嘱咐他们的子孙后代，不必拘泥于形式主义，只要我们心中有佛，口中有德，不吃斋吃素也可以。因为人必定是杂食动物，只要做到不浪费，就难能可贵了，做到口出善言就很好了，所以就有了农村俗语“宁可荤口念佛”这句话。</p>
<p>“不可素口骂人”，它引申的意义就是，一个每天吃斋吃素的人，却张口就骂人，这是万万不可的。这就说明他吃斋念佛只是表象，而内心是丑恶的，从他口吐脏言就能说明一切，他所做的修行也是假的。 在古代有个封建思想，说这样的人会遭到报应，因为这些人是“伪善者”。老祖宗告诫后人，千万不要每天吃斋吃素，以为就成了修行人，如果不修口德也是做无用功。就像有些人“居庙堂之上”，却不理民生疾苦，是一个道理，要知道“法网恢恢，疏而不漏”。念佛其实就是为了让人无欲无求，心存善心，骂人显然就是违背了这样的理念。而吃荤不会伤害到别人，但是骂人却可以影响着其它人，也会伤害到其它人，这样看来就宁可荤口念佛，不可素口骂人了。</p>
<p>所以“宁可荤口念佛，不可素口骂人”，就是老祖宗告诫后人，我们宁可做一个“酒肉穿肠过”的善良人，也不要做一个“假仁假义”的伪君子。因为有一些人打着“修行人”的旗号，却做着下流人的事情，或者利用信仰到处去骗钱，这就是对信仰的欺骗，迷信的说法就是会“遭天谴”。</p>
<p>其实吃荤是犯了戒律，但是就算是吃荤了，只要心中有佛，那还是可以念佛的，心存善念，就可成佛。而就算是不吃荤天天念着佛经，但是却口上不留德，天天就知道骂人，这显然违背了做人道德，一边骂着人一边念着佛，那可是非常虚伪的行为。</p>
<p>总之，这句话说的就是骂人可比吃荤更加严重，就算吃荤也可以成佛，但是嘴上无德的话，是始终都得不到别人的尊重，也会影响自身修行的。</p>
<p>过去农村老人都会教育自己的子女，一定不要随便骂人，否则宁愿去吃荤念佛，也不能表里不一，对人不尊。现实生活当中不乏这样的人，表面上吃斋念佛，一副虔诚，实质上举止乖张，动不动就爆粗口，根本没有一点儒雅的样子。这样的人是最令人讨厌的，也是最不受欢迎的人。</p>
<p>如果我们往深层次剖析，这个农村俗语的意义就非常深刻了。不仅显示出了现实生活中，一些人的本性，也告诉我们通过人的表象，要看看他的本质属性，也就能够分清善恶，把好坏人进行区分了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0EventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0EventBus/" class="post-title-link" itemprop="url">自己实现EventBus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-15 16:38:26" itemprop="dateCreated datePublished" datetime="2020-06-15T16:38:26+08:00">2020-06-15</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-12 16:30:26" itemprop="dateCreated datePublished" datetime="2020-06-12T16:30:26+08:00">2020-06-12</time>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表节点定义-Node</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.el = el;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表-LinkedList</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="function"><span class="title">insert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从链表的头节点开始遍历</span></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>(currentNode &amp;&amp; currentNode.el !== item) &#123;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">el, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el);</span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(item);</span><br><span class="line">    <span class="comment">// 将当前节点的next给了新节点的next</span></span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除节点</p>
<p>删除当前节点要找到当前节点的上一个节点。<br>将上一个节点的next指向下一个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPre</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span>(node.next !== <span class="literal">null</span> &amp;&amp; node.next.el !== item) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> preNode = <span class="built_in">this</span>.findPre(item);</span><br><span class="line">    <span class="keyword">if</span> (preNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指向下一个元素，这行代码很关键</span></span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义单个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.el = el;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于查找</span></span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (node !== <span class="literal">null</span> &amp;&amp; node.el !== item) &#123;</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">findPrev</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (node.next !== <span class="literal">null</span> &amp;&amp; node.next.el !== item) &#123;</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入节点</span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">el, item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el);</span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(item);</span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prevNode = <span class="built_in">this</span>.findPrev(item);</span><br><span class="line">    <span class="keyword">if</span> (prevNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 指向下一个元素，这行代码很关键</span></span><br><span class="line">      prevNode.next = prevNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>定义节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>() </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.el = el;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找同单向链表</p>
<p>插入节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">el, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(el);</span><br><span class="line">    <span class="keyword">const</span> currentNode = <span class="built_in">this</span>.find(item);</span><br><span class="line">    <span class="comment">// 先将新节点的指针指向对应位置</span></span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    newNode.prev = currentNode;</span><br><span class="line">    <span class="comment">// 将当前节点的next指针指向新节点</span></span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">    <span class="comment">// 当前节点的next节点的prev指针指向新节点</span></span><br><span class="line">    currentNode.next.prev = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="built_in">this</span>.find(item);</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">    node.prev = <span class="literal">null</span>;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">believeZJP</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">758k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:29</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
