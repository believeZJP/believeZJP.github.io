!(function() {
    // 通用设置
    const w = window.innerWidth,
        _ = window.innerHeight;

    var k,
        S = 0,
        P = 0,
        T = (PIXI.autoDetectRenderer, PIXI.loader),
        E = (PIXI.Rectangle, PIXI.Graphics),
        A = (PIXI.loader.resources,
        PIXI.utils.TextureCache,
        PIXI.Texture,
        PIXI.Text,
        new PIXI.ticker.Ticker(),
        PIXI.Sprite),
        // PIXI里的容器
        Container = PIXI.Container,
        // 屏幕当前旋转角度
        degree = 0,
        // 手势消失的timeout
        imgPre = 'images/';
    // a();
    // 从这开始
    // container 是PIXI容器的实例
    container = new Container();
    (container.width = w), (container.height = _);

    //Create the renderer 创建canvas渲染器
    var W = new PIXI.CanvasRenderer(w, _);

    // 添加canvas到html
    $('.china_tolerance_content')[0].appendChild(W.view);
    //防止屏幕移动
    $(document).bind('touchmove', function(e) {
        e.preventDefault();
    });
    window.onorientationchange = s;

    //   提前加载所有图片
    T.add(imgPre + '01.png')
        .add(imgPre + '02.png')
        .add(imgPre + '01bgdash.png')
        .add(imgPre + '01bg.png')
        .on('progress', onProgress)
        .load(endLoad);

    // 处理加载图片进度，用于页面显示百分比
    function onProgress(e, i) {
        var n = parseInt(e.progress);
        console.log('当前进度' + n);
    }
    function getTexture(name) {
        return new A(T.resources[imgPre + name + '.png'].texture);
    }

    // 图片加载完回调
    function endLoad() {
        // 显示100%
        // loading移除
        setTimeout(function() {
            $('#loading').fadeOut(300);
        }, 300),
            // 初始值设置
            a();

        // 加载各个元素
        var bgColor = new E();
        bgColor.beginFill(4158644);
        bgColor.drawRect(0, 0, 13000, 13000);
        bgColor.endFill();

        // 每屏宽度
        pw = w / k;
        // pw为横屏整屏宽度， 如果宽度小于高度，为竖屏，设置
        w < _ ? (pw = _ / k) : (pw = w / k);
        // 将pw直接定死
        pw = 667 * 2;
        console.log(pw, 'pw页宽', 'w:', w);
        // 开始添加背景图片

        // 设置位置
        container.position.set(w, 0);
        // 总的容器添加子容器
        containerChild = new Container();
        // 添加顺序不能反，最外层的在最后
        containerChild.addChild(bgColor);

        container.addChild(containerChild);
        console.log(container, 'ocn');
        // 因为音箱的层级最高，对话框都要在音箱后面，所以要将音箱层级提高。
        // 注意层级不能超过所有元素的最大值
        // containerChild.setChildIndex(speaker03, 15);
        // container.setChildIndex(handHeld, 8);
        // container.setChildIndex(firstCon, 3);
        // container.setChildIndex(d, 3);
        // (degree = Math.PI / 2), (container.rotation = degree);

        k = _ / 750;
        container.scale.set(k, k);
        container.position.set(w, 0);
        // 一定要设置这个才能触发鼠标事件
        container.interactive = !0;
        container.buttonMode = !0;

        // 对containerI容器绑定触摸事件
        container.on('touchstart', touchStart).on('touchmove', touchMove).on('touchend', touchEnd);

        //   旋转屏幕处理
        s();
        Ne.setDimensions(w, _, w, 13230 + _);
        // 首次渲染
        W.render(container);
        // 更新canvas
        update();
    }

    // 根据硬件频率，刷新canvas
    function update() {
        TWEEN.update(), requestAnimationFrame(update), W.render(container);
    }

    function a() {
        // 宽度小于高度，竖屏，设置loading样式
        $('#loading').css({
            width: w,
            height: _
        });
        w < _
            ? ((k = w / 750), (B = _ / k))
            : //   宽度大于高度，设置loading样式
              ((k = _ / 750), (B = w / k));
    }
    // 确定屏幕旋转角度，根据不同的角度显示不同内容
    function s() {
        console.log(window.orientation, '方向');
        switch (window.orientation) {
            case 0:
                setTimeout(function() {
                    // 计算图片比例
                    a(), (degree = Math.PI / 2), (container.rotation = degree);
                    console.log(k, '屏幕比例');
                    container.scale.set(k, k), W.resize(w, _), container.position.set(w, 0), (S = Ne.__scrollTop);
                    setTimeout(function() {
                        console.log(container.width, '容器宽度');
                        Ne.setDimensions(w, _, w, container.width + 30), Ne.scrollTo(0, S, !1), (B = _ / k);
                    }, 200);
                }, 300);
                break;
            case -90:
                break;
            case 90:
                setTimeout(function() {
                    // 计算图片比例
                    a(), (degree = 0), (container.rotation = degree);
                    console.log(k, '屏幕比例');
                    container.scale.set(k, k), W.resize(w, _), container.position.set(0, 0), (S = Ne.__scrollTop);
                    console.log(S, 's');
                    setTimeout(function() {
                        console.log(container.width, '容器宽度');
                        // Ne.setDimensions(w, _, 13230 + w, _), Ne.scrollTo(S, 0, !1), (B = w / k);
                        Ne.setDimensions(w, _, container.width + 30, _), Ne.scrollTo(S, 0, !1), (B = w / k);
                        // v();
                    }, 200);
                }, 300);
                break;
            case 180:
        }
        B = w < _ ? _ / k : w / k;
    }

    ///////////////////////////
    // Canvas renderer 滑动渐变动作
    var render = function(left, top, zoom) {
        var x, y;
        console.log(degree, 'jiaodu');

        // 0为竖屏，π/2为横屏
        degree > 0 ? ((x = top), (y = left)) : ((x = left), (y = top));
        console.log(`坐标：${x},${y}`);
        // 必须是这样写，才能实现竖屏滚动正常，直接在最外层加位置会导致竖屏无法正常滚动，大bug啊。
        // (container.position.x = -x), (container.position.y = -y);
        (containerChild.position.x = -x), (containerChild.position.y = -y);
    };

    // 初始化滚动插件
    const Ne = new Scroller(render, {
        zooming: !1,
        animating: !0,
        bouncing: !1,
        animationDuration: 1e3
    });
    Ne.__enableScrollY = !0;

    // 开始滑动事件监听
    function touchStart(e) {
        var i = e.data.originalEvent;
        touching = true;
        Ne.doTouchStart(i.touches, i.timeStamp);
    }
    // 滑动过程事件监听
    function touchMove(e) {
        // if (touching) {
        var i = e.data.originalEvent;
        Ne.doTouchMove(i.touches, i.timeStamp, i.scale);
        // }
    }
    // 滑动结束事件监听
    function touchEnd(e) {
        var i = e.data.originalEvent;
        touching = false;
        Ne.doTouchEnd(i.timeStamp);
    }
})();
