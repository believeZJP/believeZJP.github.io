# 公司研发流程

- 规范(工程能力标准化   )
需求-开发-代码准入-测试-发布验证-上线
- 落地
选择工具插件即做优秀工程实践
使用研发平台提升总体工程能力
- 可见
收集分析研发环节所有数据 绘制展现完整工程能力地图


建立工程规范 打通研发壁垒
看见工程能力 追求技术卓越


# 敏捷实践应用
了解如何制定迭代计划、如何使用用户故事管理用户需求、如何做敏捷估算等内容，以达到快速熟悉和掌握敏捷开发模式的目的。了解敏捷开发场景下项目管理平台的使用，如何结合工具平台进行敏捷项目管理。


## 什么是Scrum
Scrum是迭代式增量软件开发过程，即敏捷开发。包括一系列时间和预定义角色的过程骨架。

## Scrum角色
- Product Owner
    需求池
- Team
    所有参与者决定需求顺序
- ScrumMaster
    日会。。。


空间配置-产品规划-迭代计划-迭代执行-showcase-回顾

# 研发工具链

-研发流程
提炼用户价值定义用户交互(PM UE) - 同步目标和计划(PM,RD,QA) - 贡献代码(RD) - 代码检查同行评审(RD) - 自动化测试实时展示进度(RD,QA) - 一键部署产出管理(OP) - 用户反馈持续迭代(PM) - 回到第一步


## icafe

元素：
    空间，计划，卡片，帖子

空间配置

feature
    story
        task
bug



## icode

与需求管理，持续集成和交付打通，形成git工具链
严格的代码准入机制，质量管理前置
代码与产品关联，用数据说话。



git原理
每次提交做快照后，保存一个指向这次快照的索引

git status, log , checkout

git branch 

git branch -r 远程分支


git checkout -b testing origin/testing 从远程分支切分出来的testing分支


git commit -m "info"

### merge

在master合并其他分支
先切回master分支
git merge testing(分支名)

git log --oneline --graph


### rebase

git checkout topic 
git reabase master

###　代码冲突及解决思路
１.　再本地仓库更新并合并代码
    git fetch origin
    git reabase origin/master
2. 依照提示分别打开冲突的文件，逐一修改冲突代码
3. 所有冲突修改完毕后，提交
    git add -u
    git rebase --continue
4. 更新patch
    git push origin HEAD:refs/for/master

### 发起评审    
代码commit后
git push origin HEAD:refs/for/master
或
git push origin dev:refs/for/dev
git push origin HEAD:refs/for/dev


查看最近两次提交的不同
git diff HEAD-1 HEAD


# 行间评论

可以评论，修改，别人可以看到
点击右上角打分/评论  -1 - 2分, 2分才能合入

## 代码开发环节的优秀实践

1. 远程仓库 git clone fetch pull
2. 本地工作区 git add
3. 暂存区 git commit -m ''
    git commit --amend '' 上次提交有错误代码， 这次提交修改错误代码更新使用
    git commit --amend -m [message]
    使用一次新的commit，替代上一次提交
    如果代码没有任何新变化，则用来改写上一次commit的提交信息
    git commit --amend -m [message]

    重做上一次commit，并包括指定文件的新变化
    git commit --amend [file1] [file2] ...

4. 本地仓库git push origin HEAD:refs/for/master
5. 评审区(临时分支)  合入远端仓库

提交规范 分支规范
- 善用git本地分支并行开发多个feature 每个feature创建一个分支
- 95%commit不超过400行
- 主干历史一次只提交一个commit(--amend)， reabase if nessary fast fowward only
- 提交日志中填写有效iCafe卡片id. icode-666
    git commit -m 'icode-5481 modify info'


关联需求，关联产品

每个项目下都有一个third-party,大比例的代码是重复的

重复引入第三方代码问题
    共建各主流语言的内部依赖源即依赖规范

    github mirror解决第三方代码引用问题
善用搜索功能找到所求
    加速学习和开发
    站在巨人的肩膀上
    智能化


代码准入环节的优秀实践

可维护性检查
Unit Test
P0级自动化回归测试
云端编译
增量静态代码扫描
CodeReview
代码规范
增量源码安全扫描
 

- 通过设置提交规则，达到控制入库代码质量的目的

遇到的问题：
代码没法复用
看不懂代码还要修bug
踩坑填坑
重构

解决办法：Code Review


Code Review 过程中能发现问题：
- 代码是否实现了需求定义的功能
- 设计问题： 是否满足SOLID原则，有更加优化的实现方式，方式是否满足单一职责原则
- 是否有重复代码，代码是否可被重用
- 是否存在冗余代码
- 代码可维护问题：是否有循环依赖问题，代码是否过于复杂
- 业务逻辑是否有问题
- 文档和注释是否完善
- 是否有一些不舒服的味道：注释，命名，函数等。
- Test Case是否充分？
---

Code Review中应用的态度
- 对所有review代码逻辑应可以完全看懂(掌握情况就像自己写的一样)
- 好代码的标准不仅仅是可以运行通过(正确性，可读性，可重用性，可运维性)
- Code Review和写代码一样重要： 也有产出,更高质量的代码，理解和找出问题
- 以提升代码质量为最终目标

Code Review注意事项
- 在必要时，Review双方做面对面沟通
    背景，关键点的说明，便于Reviewer理解，必要时提供设计文档
- 对关键模块，建立owner制度
    所有提交代码必须由owner做最终确认
- 对review中发现的问题一追到底
    问题没有完全改正前，不能通过
- 一行代码都不放过



推荐
- 多写行间评论
- 善于给出-2分(打回率)

### 多人协同开发工作流
主干保有完整代码 , 分支上的修改3个月内需合入主干
推荐两种分支协同模式：主干开发，分支开发

#### 主干开发
    前提：充分的本地验证，频繁提交主干，可靠的准入检查
    优势：快速集成，冲突早发现
#### 分支开发
    前提：持续集成无特殊要求，并行开发的分支会有很多
    优势：保证多人多任务多版本并行开发



# agile 持续交付平台
核心：交付流水线的配置和执行
优势：交付过程可视化，自动化，能力快速移植
目标：提升研发质量、缩短交付周期


### 流水线管理

### 资源管理

### 权限管理

### agile 支撑工程能力落地


# 编写可读代码艺术


## 引言
什么是好代码？

编码规范：
    基本要求
    风格一致
    符合业界惯例

可维护性
    自解释性好
    易于理解
    结构清晰

表象→本质
1. 基本要求
2. "自解释"技巧
3. 关键能力：设计&思考
4. "两顶帽子"等基本工作方法

## 写出自解释代码

自解释？：：
    Don't make me think
    内在逻辑清晰明了
    像与源码作者面对面交流
    有品位有格调愉悦感

- 命名 带上有效信息
    避免'泛华'词
    - 所有数据都可以叫data, personalInfo? ImageContent?
    增加信息量
    - 带上单位
        delay-- delayMS -- size  -- sizeMB
    - 包含必要的解释
        days -- daysSincelastUpdate
    
    具体到何种程度合适？？


- 用的词要有效
    多余的词
        convertToString -- toString
    有歧义的词
        results = filtere(objects, 'year <= 2016')
        究竟是保留(select)还是排除(exclude)?

    多琢磨，力求精准

- 命名符合惯例
    - 约定俗称
        循环变量：i,j,k
        表示范围：[begin, end), [first, last]
    - 符合语感
        类名、变量名:名词或动名词
        MemoryCache, shoppingCart
        函数、方法名：动宾结构
        memoryCache：fillCache()
        shoppingCart: removeItem()
    No Surprise!
        getXXX, setXXX：只表达简单操作、无副作用
        成对API,参数含义一致
        insert(arr [], int n)
        remove(arr [], int n)
    - 测试用例
        all in doc string 
        测试对象、场景描述、预期结果
        test_<Function>_<Expect>_<Situation>
        看测试报告，直接看名字就可以知道问题所在

- 注释： 不是万金油！
    好代码> 坏代码 + 注释

    什么是好注释？
    - Don't repeat the codes
    - 没有价值的注释
    - 为常量加注释
        不是对变量名简单的翻译
        为什么取这个值
            // 不少于一个人每天可阅读的RSS文章即可
            const int MAX_RSS_SUBSCRIPTIONS = 1000

            // 只要大于(2* NUM_PROCESSORS)即可
            NUM_THREADS = 8

        解释hack
        提供可能陷阱
        Annotation更好
        好注释
        what:功能是什么  how： 怎么实现的
        why:为什么这样做，背景 Useless:无有效的信息 坏注释

- 逻辑：表达式书写
    左边？右边？
    书写原则
        变量与常量：变量在做，常量再右
        变量与变量：小于号原则，和数轴方向一致
        临时变量+好的命名
        循环表达式 for

- 结构：减少嵌套
    嵌套太深

    善用空格

小结：
    易于阅读
        - 命名：可维护代码的基础
        - 注释： 注释的时机与内容
    易于理解
        - 逻辑： 符合人的思维习惯
        - 结构： 清晰明了


## 编码背后

为什么会有烂代码？
    烂代码只是表象， 代码是逐步腐化的
设计&思考缺失
    思路不明
    层次、职责划分不明确
    与显示需求不符
工作方法
    反复强调、反复发作

- 设计原则
    - 关注点分离(Separation of Concerns)
        不同的知识点放置在不同的部分迭代
    - 单一职责(Single Responsibility Principle)
        能用简单的一句话表明职责
        更有利于命名
        良好设计的基础
    - DRY 
        Do not Repeat Yourself

- 思考缺失
    反复梳理业务逻辑
- 遗留代码
    复杂度
        - 软件的生命周期
        - 设计的本质： 控制复杂度
        - 内在复杂度 vs 实现复杂性

    重构技术
        - 不改变程序外观行为的变更
        - 可回归，易于自动化测试
        重构时机
            - 事不过三：多次在源代码上修改，无法忍受，
            - 小步快走：持续集成
            - 两顶帽子
                两顶帽子
                    重构
                        目标：扫除新功能实现障碍
                        如需要，补充测试
                    新功能
                        重构后，新功能非常好写
                        纯粹新功能开发、新测试用例积累
                    重构
                        提升可读性、可维护性
                        命名、风格、API微调
                    
小结
    能力上
        编码能力、设计能力
        对问题理解程度
        技术掌握：重构&持续集成
    观念上
        腐化代码是结果不是成因
        关键在平时
    
    知识+技能+素养 = 写好代码


## 百度的要求
    编码规范
    http://styleguide.baidu.com/

    统一风格、编码建议
    规范落地
        自动检查：本地、后台度量
        Code Review、GoodCoder考试
        自我追求
    代码准入
        基本：满足规范、通过CR
        自我验收checklist
            是否能用 测试用例表达
            测试用例可回归&自动化
            满足编码规范&可维护性要求
            重点审视API设计--特别拉出来Review命名结构业务流程

## 总结

- 编码技巧
    - 命名注释逻辑结构
    - 自解释： Don't make me think
    - 一些常见的方法、技巧
- 工作习惯
    - 设计水平
    - 对问题的思考深度
    - 重构&两顶帽子
- 公司要求
    - 编码规范
    - 代码准入checklist

- 推荐阅读
    - 编写可读代码的艺术
    - Code Complete
    - 设计模式
    - 重构-改善既有代码的设计
    - 经典开源项目


# 持续集成


## 入门

集成时才发现根本无法运行
在不同的分支合并代码
加班加点改bug
重复进行的手工部署，调试，测试，发布

CI谜题
- 如何降低风险
- 如何尽早的发现问题
- 如何减少重复劳动、降低回归成本
- 如何在修改代码时不再担惊受怕

Continuous Integration

简称CI,是一种敏捷开发模式，意指对软件项目进行持续的自动化构建，通过实时和定时的对代码进行编译与测试执行，来检查代码质量情况


持续集成的目的是保证一个随时可以正常工作的系统
通过小的改动，逐步的构建系统
质量反馈远快于RD的提交代码速度
及时处理构建失败
至少每天集成
使用自动化测试             

 CI =  全面有效的测试 + 高效的构建系统 + 合理的流程规范


## 质量保证意识


## 持续保证开展




# 高可用设计

## 概述

可用性影响

    - 对用户极大伤害
    - 对公司极大伤害
        直接损失
            - pv、流水损失
            - 商业赔付
        长远伤害
            - 给竞品机会
            - 信任下降


可用性是指一个产品可以被特定的用户在特定情况中有效高效并且满意的达成特定目标的程度
在要求的外部资源的到保证的前提下，产品在规定的条件下和规定的时刻或时间去见内处于可执行规定功能的能力。

## 影响因素
 程序、数据变更
 线上操作
 基础设施故障


## 预防

    开发阶段
        代码规范

        容错调度
            重试，防雪崩
            调度
            健康检测
        功能隔离解耦
        
        防攻击
    测试阶段
        代码合法性
        模块级测试
        系统级测试
        格式化测试报告
        免测标准及流程
        0级case构建
            
    上线部署阶段

    线上运行阶段

## 提升服务

发现
止损
灾难恢复
故障复盘(case study)
主动制造故障


# 百度平台化

## 为什么要平台化

## 好平台的特点

- 服务可用性承诺(SLA, SLI, SLO)
服务主体
服务质量指标，目标
度量方式
补偿措施
公告方式

从用户体验受损角度

- 具备故障预防、监控、快速定位、止损和恢复能力


- 安全性



# 机器学习

定义：

在未经明确命令下可以具备自我学习的能力。

对于某类任务T和性能度量P,如果一个计算机程序在T上以P衡量的性能随着经验E而自我完善，那么我们称这个计算机程序在从经验E学习。


分类：
监督学习(Supervised Learning)

特点：数据都有答案，或者叫标签(Label)
用法： 通过学习许多有标签的数据，对新的数据进行预测

非监督学习

特点：数据没有标签
用法： 找出数据间的内在联系

强化学习
特点： 根据当前环境反馈计算并决定下一步该做什么





























