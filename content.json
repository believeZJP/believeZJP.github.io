{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"自我介绍","text":"哇哈哈这里是个人信息主页写一些个人信息啊啊写什么啊啊啊啊啊啊写了些没用的啊啊啊哈哈哈哈哈哈哈哈哈之所以把好多网上可以找到的资源费力气搬到自己博客里，很大一个原因很多东西看过以后很快就忘掉，从此杳无音信，与自己失去联系。有时候费心思找到链接，可能由于种种原因无法访问。 索性，把觉得有价值的东西都挪到自己博客里，方便查找，也可以见证一路走来学过些什么。 另一方面学习工作过程中会遇到各种各样的问题。一些小问题会花不少时间去解决，\b搜索，看好几篇文章才能找到正确答案\b。将它们记录下来，一来加深印象，\u001c二来打开博客，可以直接找到答案。👏👏👏\b","link":"/about/index.html"},{"title":"","text":"/** * @file: file * @author: yueyueniao */ class EventEmeitter { constructor() { // 选择了Map作为储存事件的解构，因为作为键值对的储存方式Map比一般对象更加适合，操作更加简洁 // 储存事件回调键值对 this._events = this._events || new Map(); // 设置监听上限 this._maxListeners = this._maxListeners || 10; } } // 触发名为type的事件 EventEmeitter.prototype.emit = function(type, ...args) { let handler; handler = htis._events.get(type); if(Array.isArray(handler)) { // 如果是一个数组说明有多个监听者，需要依次触发里面的函数 for(let i=0; i 0) { handler[i].apply(this.args); } else { handler[i].call(this); } } } else { // 单个函数情况直接触发 if (args.length > 0) { handler.apply(this, args); } else { handler.call(this); } } return true; } // 监听名为type的事件 EventEmeitter.prototype.addListener = function(type, fn) { // 获取对应事件名称的函数清单 const handler = this._events.get(type); if (!handler) { this._events.seet(type, fn); } else if (handler && typeof handler === 'function') { // 如果handler是函数，说明是一个监听者 // 多个监听者需要用数组存储 this._events.set(type, [handler, fn]); } else { // 已经有多个监听者，直接将函数push到数组 handler.push(fn); } } // 移除名为type的事件 EventEmeitter.prototype.removeListener = function(type, fn) { // 获取对应事件名称的函数清单 const handler = this._events.get(type); if (handler && typeof handler === 'function') { // 如果是函数，说明只被监听了一次 this._events.delete(type, fn); } else { let position; // 如果handler是数组，要找到对应的函数 for(let i=0; i","link":"/jscode/EventEmeitter.js"},{"title":"","text":"/** * @file: file * @author: zhaojianpeng */ /** * @description: * @param {type} * @return: * 代码简单清晰 * 同步读取，容易内存溢出 * */ function copyOld(src, target) { fs.writeFileSync(target, fs.createWriteStream(src)) } function copy(src, dst) { fs.createReadStream(src).pipe(fs.createWriteStream(dst)) } /** * @description: * @param {type} * @return: * 代码简洁 * 没有内存溢出风险 */ const fs = require('fs') const path = require('path') // 复制目录 main('source/tags', 'source/tags2') function main(src, dst) { // const rootSrc = path.resolve(path.resolve(), src) const rootSrc = path.resolve(process.cwd(), src) fs.stat(rootSrc, (err, stats) =>{ if (err) { console.log(err, '错误了') } if (stats.isFile()) { copy(rootSrc, dst) } else if(stats.isDirectory()) { // 如果目标地址也是文件夹的话，生成目标文件夹 // 如果文件不存在，则创建 if(!fs.existsSync(dst)) { fs.mkdirSync(dst) } copyDir(rootSrc, dst) } }) } // 读取文件夹下的文件并复制 function copyDir(src, dst) { fs.readdir(src, (err, paths) => { if (err) { throw err } paths.forEach(tmpPath=>{ const currPath = path.resolve(src, tmpPath) fs.stat(currPath, (err, st)=> { if(st.isFile()) { copy(currPath, path.resolve(dst, tmpPath)) }else if(st.isDirectory()) { // 递归调用复制文件夹内容 const currDst = path.resolve(dst, tmpPath) if(!fs.existsSync(currDst)) { fs.mkdirSync(currDst) } copyDir(currPath, currDst) } }) }) }) }","link":"/jscode/fscopy.js"},{"title":"","text":"js 通过匿名空间隔开公有私有 123456789101112131415161718192021222324252627282930(function() { var abc = 5; function TabView(cfg) { this.a = cfg.a; this.b = cfg.b; } TabView.prototype = { c: function() { abc++;}, d: function() { abc--;} } window.TabView = TabView;})();(function() { var abc = 100; function TreeView(cfg) { this.a = cfg.a; this.b = cfg.b; } TreeView.prototype = { c: function() { abc *= 2;}, d: function() { abc /= 2;} } window.TreeView = TreeView;}); 基于 require.js 重写代码1234567891011121314151617181920212223242526272829// animate.jsdefine(function() { function Animate() {} return { Animate: Animate };});// treeview.jsdefine(function() { function TreeView() {} return { TreeView: TreeView };});// tabview.jsdefine([&quot;animate&quot;], function(a) { function TabView() { this.animate = new a.Animate(); } return { TabView: TabView };});// main.jsrequire([&quot;tabview&quot;, &quot;treeview&quot;], function(tab, tree) { var tabView = new tab.TabView(), treeView = new tree.TreeView();});","link":"/jscode/js.html"},{"title":"","text":"js 通过匿名空间隔开公有私有 123456789101112131415161718192021222324252627282930(function() { var abc = 5; function TabView(cfg) { this.a = cfg.a; this.b = cfg.b; } TabView.prototype = { c: function() { abc++;}, d: function() { abc--;} } window.TabView = TabView;})();(function() { var abc = 100; function TreeView(cfg) { this.a = cfg.a; this.b = cfg.b; } TreeView.prototype = { c: function() { abc *= 2;}, d: function() { abc /= 2;} } window.TreeView = TreeView;}); 基于 require.js 重写代码1234567891011121314151617181920212223242526272829// animate.jsdefine(function() { function Animate() {} return { Animate: Animate };});// treeview.jsdefine(function() { function TreeView() {} return { TreeView: TreeView };});// tabview.jsdefine([&quot;animate&quot;], function(a) { function TabView() { this.animate = new a.Animate(); } return { TabView: TabView };});// main.jsrequire([&quot;tabview&quot;, &quot;treeview&quot;], function(tab, tree) { var tabView = new tab.TabView(), treeView = new tree.TreeView();});","link":"/jscode/js2.html"},{"title":"","text":"/** * @file: file * @author: zhaojianpeng */ class Race { constructor(props = {}) { // super(props) ;[ ['rabbit', '兔子'], ['turtle', '乌龟'], ['turtleStep', 0], ['rabbitStep', 0], ['start', '|'], ['end', '》'], ['pad', '.'], ['speed', 1], ['steps', 50], ['stopAt', 42] ].forEach(elem => { const [key, value] = elem if (!key in props) { this[key] = value } }) } getRaceTrack() { const { start, pad, turtle, turtleStep, rabbit, rabbitStep, steps, end } = this if (!turtleStep && !rabbitStep) { return `${turtle}${rabbit}${start}${pad.repeat(steps)}${end}` } const [ [minStr, min], [maxStr, max] ] = [ [turtle, turtleStep], [rabbit, rabbitStep] ].sort((a, b) => a[1] - b[1]) const prefix = `${pad.repeat((min || 1) - 1)}` const middle = `${pad.repeat(max - min)}` const suffix = `${pad.repeat(steps - max)}` const _start = `${start}${prefix}${minStr}` const _end = suffix ? `${maxStr}${suffix}${end}` : `${end}${maxStr}` return `${_start}${middle}${_end}` } updateRaceTrack(state, racing) { racing.replace(state) } updateSteps() { if (this.turtleStep >= this.steps) return if (this.rabbitStep { if (t","link":"/jscode/rabbit-class.js"},{"title":"","text":"/** * @file: file * @author: zhaojianpeng */ const rabbit = '兔子'; const turtle = '乌龟'; const start = '|'; const end = '》' // 赛道上的每一米用.表示 const pad = '.' // 速度 1米/150ms const speed = 1 // 一共有50米 const steps = 50 // 约定在42米 const stopAt = 42 // 兔子是否停下 let stoped = false // 从0开始轮询 let t = 0 let timer let initState = `${rabbit}${turtle}${start}${pad.repeat(steps)}${end}` function turtleBeyondStart() { return speed * t } function rabbitBeyoondStart() { if (speed * 3 * t >= stopAt) { stoped = true return stopAt } return speed * 3 * t } function race() { const turtleRange = turtleBeyondStart() const rabbitRange = rabbitBeyoondStart() if(turtleRange === 50) { clearInterval(timer) initState = `${start}${pad.repeat(stopAt)}${rabbit}${pad.repeat(steps - stopAt)}${end}${turtle}` } else if (t > 0 && !stoped) { initState = `${start}${pad.repeat(turtleRange)}${turtle}${pad.repeat(rabbitRange - turtleRange)}${rabbit}${pad.repeat(steps - rabbitRange)}${end}` // 这个可以合并到上面这个条件里 // } else if(turtleRange < rabbitRange && stoped) { // // 兔子停止了,兔子在乌龟前面 // initState = `${start}${pad.repeat(turtleRange)}${turtle}${pad.repeat(rabbitRange - turtleRange)}${rabbit}${pad.repeat(steps-stopAt)}${end}` } else if(turtleRange >= rabbitRange && stoped) { // 兔子在乌龟后面 initState = `${start}${pad.repeat(stopAt)}${rabbit}${pad.repeat(turtleRange - stopAt)}${turtle}${pad.repeat(steps-turtleRange)}${end}` } t++; console.log(initState) } timer = setInterval(() => { race() }, 150); const wait = sec => new Promise(resolve => setTimeout(() => resolve(), sec)) // 等待 2 秒再开始启动比赛 wait(2000).then(() => { race() })","link":"/jscode/rabbit.js"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"","text":"// http://news.163.com/special/fdh5_funnyfriend/ function (e) { function n(e) { var n = document.getElementById(e), i = function () { document.removeEventListener(\"WeixinJSBridgeReady\", i), document.removeEventListener(\"YixinJSBridgeReady\", i), n.play() }; document.addEventListener(\"WeixinJSBridgeReady\", i, !1), document.addEventListener(\"YixinJSBridgeReady\", i, !1) } function i(e, n) { return Math.floor(Math.random() * (n - e + 1) + e) } function a(e) { for (var n = e.slice(), a = 0; a < n.length; a++) { var t = i(0, a), r = n[a]; n[a] = n[t], n[t] = r } return n } function t(n) { if (5 == n) return void r(); 3 == n ? (J.visible = !1, whitePage.visible = !0, e(\".music\").addClass(\"white\")) : (J.visible = !0, whitePage.visible = !1, e(\".music\").removeClass(\"white\")); for (var i = 0; i < 5; i++) N[\"num\" + i].visible = !1; N[\"num\" + n].visible = !0, main.children[n].visible = !0, main.children[n].alpha = 0, new TWEEN.Tween({ alpha: 0 }).to({ alpha: 1 }, 300).onUpdate(function () { main.children[n].alpha = this.alpha, main.children[n - 1].alpha = 1 - this.alpha }).start() } function r() { W.resize(750, 1206), b - 1206 > 50 && e(\"canvas,.create_bg,.show_img,.save_img\").css({ \"margin-top\": (b - 1206) / 2 + \"px\" }), e(\".first\").hide(), e(\".music\").hide(), e(\".create_end\").fadeIn(), setTimeout(function () { e(\".create_box\").addClass(\"active\") }, 10), setTimeout(function () { e(\".create_end\").fadeOut(300) }, 2500), new TWEEN.Tween({ width: 0 }).to({ width: 291 }, 2500).onUpdate(function () { e(\".create_rect\").width(this.width) }).easing(TWEEN.Easing.Quadratic.InOut).start(), setTimeout(function () { var n = new z(k.resources[m + \"end/bg\" + H + \".jpg\"].texture); O.addChild(n); var i = new z(k.resources[m + \"end/end_shidian_logo.png\"].texture); i.position.set(297, 1086), O.addChild(i); var a = d(F), t = 10; a > 8 && (t = 5); var r = new j(F, { fontSize: \"60px\", fill: \"#000000\", letterSpacing: t }), o = new j(\"的损友圈\", { fontSize: \"60px\", fill: \"#000000\", letterSpacing: t }); a","link":"/testfile/zhexue.js"}],"posts":[{"title":"7天入门数据结构和算法","text":"数据结构和算法总览线上课程 预习-基础知识自己预习和查看课堂互动-一起思考回答问题课后作业-按照切题方法完成 期待效果 职业顶尖级别 - 对算法数据结构的理解一线互联网公司面试LeetCode 300+的积累 《Outliers》 《异类:不一样的成功启示录》–马尔科姆·格拉德维尔 精通一个领域三步走 Chunk it up 切碎知识点 Deliberate Practicing 刻意练习 Feedback 反馈 Chunk it up 庖丁解牛 脉络相连 数据结构数据结构脑图 一维 基础: 数组 array(string), 链表 linked list 高级: 栈 stack, 队列 queue, 双端队列 deque, 集合 set, 映射 map(hash or map), etc 二维 基础: 树 tree, 图 graph 高级: 二叉搜索树 binary search tree (red-black tree, AVL), 堆 heap, 并查集 disjoint set, 字典树Trie, etc 特殊 位运算 Bitwise, 布隆过滤器 BloomFilter LRU Cache 算法八点算法脑图 基石-三点 if-else, switch —&gt; 跳转 branch for, while loop —&gt; 循环 iteration 递归 Recursion(Divide &amp; Conquer, Backtrace) 所有复杂算法，最后其实就是找它的重复单元是什么 其余五点 搜索Search: 深度优先算法 Depth first search, 广度优先算法 Breadth first search, A*, etc 动态规划 Dynamic Programming 二分查找 Binary Search 贪心 Greedy 数学 Math, 几何 Geometry 刻意练习职业化运动 基本功是区别业余和职业选手的根本 基础动作的分解训练和反复练习 –&gt; 最大的误区(只做一遍) 乒乓球，台球，滑雪 解决办法 刻意训练 – 过遍数(五毒神掌) 练习缺陷、弱点地方 不舒服、不爽、枯燥 生活中的乒乓球，台球等 反馈即使反馈 主动型反馈(自己去找) 高手代码(GitHub, LeetCode, etc.) 第一视角直播 被动型反馈(高手给你指点) code review 教练看你打，给你反馈 刷题技巧切题四件套–四步系统化思考方式 Clarification 明确题目要求 阐明 Possible solutions 想所有可能的解法，比较不同的方法的时间空间复杂度，找出最优解法 compare (time/space) optimal (加强) Coding(多写) Test cases(列举几个，测自己的程序，有始有终) 五毒神掌–五遍刷题法第一遍 花5分钟时间读题思考(最多10分钟，没有思路走第二步) 直接看解法(不要纠结) 注意多解法比较优劣， 背诵和默写好的解法 算法是理解和运用，不是创造算法 第二遍马上自己写–LeetCode提交，直到通过多种解法比较、体会–&gt; 优化！ 第三遍过24小时后，再重复做题不同解法的熟练程度—&gt;专项训练 第四遍过了一周： 反复回来练习相同题目 第五遍面试前一周恢复性训练(看自己时间安排) 小结 职业训练: 拆分知识点、刻意练习、反馈 五步刷题法(五毒神掌) 做算法题最大误区: 只做一遍 LeetCode插件VS Code Plugin里搜LeetCode 把Most Votes 最高票的前三个都看一遍 CodeStyle 遵守代码规范指法和小操作home, end (行头、行尾)Word单词、选单词、选正行IDE自动补全Top tips for IDE-name 自行搜索ide相关使用技巧 自顶向下编程关键方法，关键内容放在上边 最开始思考大层次的逻辑","link":"/posts/7%E5%A4%A9%E5%85%A5%E9%97%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"title":"Alfred","text":"[TOC] Alfred是什么 可以当做app快速启动(关闭)工具来使用 自定义搜索 workflow 安装下载 快捷键唤起 option+空格设置 command+, 配置百度搜索在配置页找到Web Search 点击右下角Edit custom Search. 在弹出框里配置 123Search URL: https://www.baidu.com/s?wd={query}Title: 百度(随便写)keyWord: b 点save 唤醒后再输入框输入b (任意字符) 会自动打开百度搜索 完成上述步骤后， 再点击”Features”-&gt;Default Results-&gt;”Setup fallback results”-&gt;点击弹出的窗口右下角”+”号-&gt;选择Custom Rearch 下的百度(上一步设置的Title)，操作步骤如下图。 配置自定义终端终端使用iTerm2, 可以如下设置在设置页面，左下角Terminal/Shell, 选择Custom 根据iTerm2的版本, 打开自定义脚本配置复制到输入框,即可。 唤醒后， 输入&gt; [shell命令]即可自动打开iTerm2，执行[shell命令] eg: &gt; cd / 使用示例百度搜索option+空格 唤醒, 随便输入内容，下拉列表显示百度搜索，直接回车。 打开指定应用option+空格 唤醒, 输入设置, chrome等应用名字，会直接显示app，回车打开。 w 可显示网易云音乐 iterm 打开终端 计算器唤醒直接在输入框输入算式，即可显示结果 翻译在Web Search中添加https://translate.google.cn/?text={query}，设置快捷键tr 唤醒后输入tr 翻译内容 回车，可自动打开谷歌翻译 默认字典翻译define 翻译内容只能翻译词, 没有谷歌智能,可以及时显示翻译内容，不用打开网页 可以在features-&gt;Dictionary-&gt;Defined a word修改denife为de 退出某个应用quit 加空格 alfred 每次开机运行后都提示是否允许访问通讯录在终端输入如下命令解决 sudo codesign -f -d -s - /Applications/Alfred\\ 3.app/Contents/Frameworks/Alfred\\ Framework.framework/Versions/A/Alfred\\ Framework 常用open用来打开文件，find用来显示文件所在位置 screensaver显示屏保 lock锁屏—(不生效) sleep睡眠 trash废纸篓，emptytrash清空废纸篓 shutdown关机，restart重启，logout注销 workflow 查询本机IP下载地址 双击导入， 输入ip，即可查询本机ip，按cmd+c可以复制 好的链接推荐5分钟上手Mac效率神器Alfred以及Alfred常用操作Alfred Workflow教程与实例Workflow列表","link":"/posts/Alfred/"},{"title":"Bundler源码编写","text":"安装依赖-相关文档 npm install @babel/parser @babel/traverse @babel/core @babel/preset-env --save index.js 12import message from './message.js';console.log(message); message.js 123import { word } from './word.js';const message = `say ${word}`;export default message; word.js 1export const word = 'hello'; bundler.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const fs = require('fs');const path = require('path');const parser = require('@babel/parser');const babel = require('@babel/core');const traverse = require('@babel/traverse').default;// 分析入口文件和依赖const moduleAnalyser = (filename) =&gt; { // 读取文件内容 const content = fs.readFileSync(filename, 'utf-8'); // 使用babel解析文件成抽象语法树 const ast = parser.parse(content, { sourceType: 'module' }); const dependencies = {}; traverse(ast, { // 声明 ImportDeclaration({ node }) { // 获取绝对路径的文件 const dirname = path.dirname(filename); const newFile = './' + path.join(dirname, node.source.value); dependencies[node.source.value] = newFile; } }); // babel转化es6代码到es5 const { code } = babel.transformFromAst(ast, null, { presets:: ['@babel/preset-env'] }); // 返回入口文件和依赖文件 return { filename, dependencies, code }}// 测试入口文件解析是否正常// moduleAnalyser('./src/index.js');// 依赖图谱，分析入口文件及入口文件中引入文件的依赖const makeDependenciesGraph = (entry) =&gt; { const entryModule = moduleAnalyser(entry); const graphArr = [entryModule]; for(let i = 0; i &lt; graphArr.length; i++) { const item = graphArr[i]; const { dependencies } = item; if (dependencies) { for(let j in dependencies) { graphArr.push(moduleAnalyser(dependencies[j])); } } } const graph = {}; graphArr.forEach(item =&gt; { graph[item.filename] = { dependencies: item.dependencies, code: item.code }; }); return graph;};// 生成最终的代码const generageCode = (entry) =&gt; { const graph = JSON.stringify(makeDependenciesGraph(entry)); // 拿到entry, 执行entry对应的代码 return ` (function(graph) { function require(module) { function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]); } var exports = {}; (function(require, exports, code){ eval(code) })(localRequire, exports, graph[module].code) return exports; }; require('${entry}'); })(${graph}); `;}// const graphInfo = makeDependenciesGraph('./src/index.js');const code = generageCode('./src/index.js');","link":"/posts/Bundler%E6%BA%90%E7%A0%81%E7%BC%96%E5%86%99/"},{"title":"CSS 代码示例","text":"设置元素readonly和disabled样式123456#endDate:read-only{ cursor:pointer;}#endDate:disabled{ cursor:not-allowed;} placeholder样式修改123456789.input::-webkit-input-placeholder { color: red;}.input:-moz-placeholder { color: red;}.input:-ms-input-placeholder { color: red;} 选择被用户选取的元素部分123::selection { background:lightblue;} css选择器，选择除了最后一个以外的元素场景：每个li都加右边框，除了最后一个需要写个demo试一下，如果li里嵌套其他元素是否生效 123.ab-character-con .l3:not(:last-child){ border-right:1px solid red;} css两端对齐效果： 123姓 名手 机 号电 话 号 码 1234567891011121314151617181920// html&lt;div&gt;姓名&lt;/div&gt;&lt;div&gt;手机号码&lt;/div&gt;&lt;div&gt;账号&lt;/div&gt;&lt;div&gt;密码&lt;/div&gt;// cssdiv { margin: 10px 0; width: 100px; border: 1px solid red; text-align: justify; text-align-last:justify}div:after{ content: ''; display: inline-block; width: 100%;}","link":"/posts/CSS-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"},{"title":"Chrome插件","text":"Chrome 有丰富的插件, 可以扩展出很多功能, 提高我们的工作效率. 沙拉查词hrome 中最好的一款翻译插件, chrome 应用商店该插件下的好评如潮.在设置里关闭—默认用本扩展浏览 PDF Full Page Screen Capture (全网页截屏)该插件可以将整个网页截成一张长图, 并且支持编辑, 有时我们不方便分享网页时, 比如一些内网站点外网访问不了, 通过全网页截屏就是一个很好的办法. Infinity 新标签页替换 chrome 原有首页的一个选择, 功能完善, 可以方便的管理和查找书签, 每天更换一个壁纸, 点击下边的小风车, 可以随机切换壁纸 Momentum是另一款替换 chrome 原有首页的插件, 简介大气, 左上角可以搜索, 右上角展示天气, 中间展示时间, 下方默认有个 todo 的功能, 左下角可以对标签页进行设置. Octotree让浏览 github 代码变得像本地编辑器一样轻松, 可以搜索文件, 点击代码目录跳转等, 方便地在文件之间切换 Access-Control-Allow-Credentials: true允许跨域访问 Allow-Control-Allow-Origin: *同上 Axure RP Extension for ChromeAxure查看插件 EditThisCookieCookie修改工具 EverSync - Sync bookmarks, backup favorites保存书签工具 React Developer ToolsRedux DevToolsVue.js devtoolsGoogle 翻译谷歌翻译 PageSpeed Insights (with PNaCl)网站加载速度优化工具 掘金掘金tab页默认工具为程序员、设计师、产品经理每日发现优质内容。 潮汐 - 极简番茄钟与白噪音潮汐，屡获殊荣的白噪音专注计时器，帮你保持专注，提升工作效率。 PP谷歌访问助手-永久免费-不限时帮助访问被封锁的谷歌和旗下网站。代理服务器稳定，VPN原理，HTTPS级别加密，确保通信安全。 如何安装下载的CRX插件(1) 从设置-&gt;更多工具-&gt;扩展程序 打开扩展程序页面，或者地址栏输入 Chrome://extensions/ 按下回车打开扩展程序页(2) 打开扩展程序页面的“开发者模式”(右上角)(3) 将crx文件拖拽到扩展程序页面，完成安装 Tampermonkey安装后可以查找在网站找想要的脚本安装 安装方法 chrome应用商店 不翻墙可用 [Tampermonkey下载地址]https://www.crx4chrome.com/crx/755/ 破解VIP会员视频集合 Proxy SwitchyOmega代理切换工具 GoogleHelper安装可以访问Google","link":"/posts/Chrome%E6%8F%92%E4%BB%B6/"},{"title":"EventLoop事件循环执行顺序--promise,nextTick,setTimeout","text":"面试题写出下题输出结果: 1234567891011121314151617181920212223242526async function async1(){ console.log('async1 start') await async2() console.log('async1 end') }async function async2(){ console.log('async2')}console.log('script start')setTimeout(function(){ console.log('setTimeout0')},0) setTimeout(function(){ console.log('setTimeout3')},3) setImmediate(() =&gt; console.log('setImmediate'));process.nextTick(() =&gt; console.log('nextTick'));async1();new Promise(function(resolve){ console.log('promise1') resolve(); console.log('promise2')}).then(function(){ console.log('promise3')})console.log('script end') 面试题正确的输出结果 123456789101112script startasync1 startasync2promise1promise2script endnextTickasync1 endpromise3setTimeout0setImmediatesetTimeout3 提出问题node.js的开发者一定都知道它是单线程的，异步不阻塞且高并发的一门语言 node.js中的异步内部原理:（微任务与事件循环） Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，异步任务最后基于事件循环机制还是要回到主线程，一个个排队执行。 详细讲解1.本轮循环与次轮循环异步任务可以分成两种。 追加在本轮循环的异步任务 追加在次轮循环的异步任务 所谓”循环”，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式. 本轮循环一定早于次轮循环执行。 Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。 2.process.nextTick()1）process.nextTick不要因为有next就被好多小伙伴当作次轮循环。 2）Node 执行完所有同步任务，接下来就会执行process.nextTick的任务队列。 3）开发过程中如果想让异步任务尽可能快地执行，可以使用process.nextTick来完成。 3.微任务（microtack）根据语言规格，Promise对象的回调函数，会进入异步任务里面的”微任务”（microtask）队列。 微任务队列追加在process.nextTick队列的后面，也属于本轮循环。 根据语言规格，Promise对象的回调函数，会进入异步任务里面的”微任务”（microtask）队列。 微任务队列追加在process.nextTick队列的后面，也属于本轮循环。所以，下面的代码总是先输出3，再输出4。 12process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4)); // 输出结果3，4 1234process.nextTick(() =&gt; console.log(1));Promise.resolve().then(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4)); // 输出结果 1，3，2，4 注意，只有前一个队列全部清空以后，才会执行下一个队列。两个队列的概念 nextTickQueue 和微队列microTaskQueue，也就是说开启异步任务也分为几种，像promise对象这种，开启之后直接进入微队列中，微队列内的就是那个任务快就那个先执行完，但是针对于队列与队列之间不同的任务，还是会有先后顺序，这个先后顺序是由队列决定的。 4.事件循环的阶段（idle, prepare忽略了这个阶段）事件循环最阶段最详细的讲解（官网：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout） timers阶段 次阶段包括setTimeout()和setInterval() IO callbacks 大部分的回调事件，普通的caollback poll阶段 网络连接，数据获取，读取文件等操作 check阶段 setImmediate()在这里调用回调 close阶段 一些关闭回调，例如socket.on(‘close’, …) 事件循环注意点 1）Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。 同步任务发出异步请求规划定时器生效的时间执行process.nextTick()等等 最后，上面这些事情都干完了，事件循环就正式开始了。 2）事件循环同样运行在单线程环境下，高并发也是依靠事件循环，每产生一个事件，就会加入到该阶段对应的队列中，此时事件循环将该队列中的事件取出，准备执行之后的callback。 3）假设事件循环现在进入了某个阶段，即使这期间有其他队列中的事件就绪，也会先将当前队列的全部回调方法执行完毕后，再进入到下一个阶段。 5.事件循环中的setTimeOut与setImmediate由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。 12setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2)); 上面代码应该先输出1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。 这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。 实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。 但是，下面的代码一定是先输出2，再输出1。 12345const fs = require('fs');fs.readFile('test.js', () =&gt; { setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));}); 上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。 6.同步任务中async以及promise的一些误解 问题1: 在那道面试题中，在同步任务的过程中，不知道大家有没有疑问，为什么不是执行完async2输出后执行async1 end输出，而是接着执行promise1？ 解答:引用阮一峰老师书中一句话：“ async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。”简单的说，先去执行后面的同步任务代码，执行完成后，也就是表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果。（其实还是本轮循环promise的问题，最后的resolve属于异步，位于本轮循环的末尾。） 问题2: console.log(‘promise2’)为什么也是在resolve之前执行？ 解答：注：此内容来源与阮一峰老师的ES6书籍，调用resolve或者reject并不会终结promise的参数函数的执行。因为立即resolved的Promise是本轮循环的末尾执行，同时总是晚于本轮循环的同步任务。正规的写法调用resolve或者reject以后，Promise的使命就完成了，后继操作应该放在then方法后面。所以最好在它的前面加上return语句，这样就不会出现意外 12345new Promise((resolve,reject) =&gt; { return resolve(1); //后面的语句不会执行 console.log(2);} 问题3: promise3和script end的执行顺序是否有疑问？ 解答：因为立即resolved的Promise是本轮循环的末尾执行，同时总是晚于本轮循环的同步任务。 Promise 是一个立即执行函数，但是他的成功（或失败：reject）的回调函数 resolve 却是一个异步执行的回调。当执行到 resolve() 时，这个任务会被放入到回调队列中，等待调用栈有空闲时事件循环再来取走它。本轮循环中最后执行的。 整体结论 顺序的整体总结就是: 同步任务-&gt; 本轮循环 -&gt;次轮循环 正常语句 -&gt; nextTick -&gt; Promise对象的回调函数 -&gt; 事件循环中的setTimeOut与setImmediate 附件:参考资料node.js官网： [事件循环]：(https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout) Timers eventLoop解析","link":"/posts/EventLoop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F--promise,nextTick,setTimeout/"},{"title":"Express学习积累","text":"express 官网pexpress 应用生成器想用node来做一个后台服务时，看到了express，可以直接生成一个简单的应用骨架。在此记录一下学习过程。 1. 安装1npm install express-generator -g express -h 查看可用的命令行选项 1234567891011121314express -h Usage: express [options] [dir] Options: -h, --help output usage information -V, --version output the version number -e, --ejs add ejs engine support (defaults to jade) --hbs add handlebars engine support -H, --hogan add hogan.js engine support -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory 2. 创建应用1express node-server 会自动创建好多文件各文件含义 12345678910111213141516├── app.js├── bin│ └── www // 启动服务，并监听端口├── package.json // 包管理文件├── public //直接访问端口会访问到的文件│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes // 路由设置，设置不同请求路径不同响应，user.js就是自定义的│ ├── index.js│ └── users.js└── views //渲染视图 ├── error.jade ├── index.jade └── layout.jade 3. 安装依赖先进入项目路径 1cd node-server 安装所有依赖包 1npm install 启动应用12DEBUG=node-server npm start 官网提示windows需要用下面的命令，实际测试，用上面的就可以。 1set DEBUG=node-server &amp; npm start 在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了express 热部署，修改不需要重新启动安装node-dev 1npm install -g node-dev 修改package.json的scripts，增加dev命令 1234&quot;scripts&quot;: { &quot;start&quot;: &quot;node ./bin/www&quot;, &quot;dev&quot;: &quot;node-dev ./bin/www&quot;}, 现在启动服务用 npm run dev 即可修改代码会发现已经更改。 express 设置get和post用同一个方法之前是 router.get(‘/‘) 或 router.post(‘/‘), 直接用router.all(‘/‘)即可 node读写文件api 12345678910111213readFile()writeFile()readFileAsync()writeFileAsync()createReadStream()createWriteStream()writestream的区别和例子没看到 vscode 调试node搞不定啊，~~~~~~~~~用express生成token 供权限校验","link":"/posts/Express%E5%AD%A6%E4%B9%A0%E7%A7%AF%E7%B4%AF/"},{"title":"JavaScript - async&#x2F;await","text":"参考链接 async/await 提供了使用同步样式代码编写异步代码的方式，而不会阻塞主线程。 async 作用是什么根据MDN: async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 如果 async 函数没有返回值， 它会返回 Promise.resolve(undefined)。 语法： 1234567async function name([param[, param[, ... param]]]) { // statements}async function A(){}let A=async function(){}let A=async ()=&gt;{} await 作用是什么(MDN) 语法 [return_value] = await expression; await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，await 可以等任意表达式的结果）。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async函数中，如果有多个await关键字时，如果有一个await的状态变成了rejected，那么后面的操作都不会继续执行，promise也是同理await的返回结果就是后面promise执行的结果，可能是resolves或者rejected的值使用场景循环遍历方便了代码需要同步的操作（文件读取，数据库操作等） async/await 的优点async/await 带给我们的最重要的好处是同步编程风格。 代码演示: 12345678910111213// async/awaitasync getBooksByAuthorWithAwait(id) { const books = await bookModel.fetchAll(); // 这里的books就是异步执行返回的结果 return books.filter(b =&gt; b.authorId === id);}// PromisegetBooksByAuthorWithPromise(id) { return bookModel.fetchAll().then(books =&gt; { return books.filter(b =&gt; b.authorId === id)); }} 这里调用this.getBooksByAuthorWithAwait(id)返回的是Promise对象， 需要执行.then才能获取到异步返回的结果 很明显async/await版本比Promise版本更容易理解，如果忽略await关键字，代码看起来像其他任何同步代码。目前所有主流浏览器都完全支持异步功能。 浏览器支持意味着不必转换代码。便于调试。 async关键字的好处。async声明getBooksByAuthorWithAwait函数返回值是一个Promise。 调用者可以安全的使用getBooksByAuthorWithAwait.then(...)或await getBooksByAuthorWithAwait(). Promise在异常情况下不能调用.then。有了async声明，这种情况就不会出现 如下： 1234567getBooksByAuthorWithPromise(id) { if(!authorId) { return null; } return bookModel.fetchAll() .then(books =&gt; books.filter(b =&gt; b.authorId === id));} 这里如果调用getBooksByAuthorWithPromise可能返回Promise(正常情况)或null(异常情况id为空), 在这种情况下，调用者不能调用.then() async/await 可能会产生误导有人将async/await与Promise进行比较，并声称它是JavaScript下一代异步编程风格。async/await是一种改进，但它只不过是一种语法糖，不会完全改变编码风格。 本质上，async 函数仍然是Promise。 正确使用async函数之前，必须先了解Promise. 更糟糕的是大多数时，需要在使用Promise时同时使用async函数。 这意味着，getBooksByAuthorWithAwait将返回一个Promise，所以也可以使用.then(…)方式来调用它。 async/await常见错误使用async/await时，常见错误： 太过串行化尽管await可以使代码看起来像是同步的，但实际上他们仍然是异步的，必须避免太过串行化。 12345678async getBooksByAuthor(id) { const books = await bookModel.fetchAll(); const author = await authorModel.fetch(id); return { author, books: books.filter(book =&gt; book.authorId === id) };} 以上代码看似正确，然而这是错误的。 await bookModel.fetchAll() 会等待fetchAll()直到fetchAll返回结果 然后await authorModel.fetch(id) 被调用 第二个fetch不依赖于第一个fetch的结果，实际上可以并行调用。然而这里用了await，两个调用变成串行，总的执行时间比并行版本要长的多。 正确写法： 12345678910async getBooksByAuthor(id) { const bookPromise = bookModel.fetchAll(); const authorPromise = authorModel.fetch(id); const book = await bookPromise; const author = await authorPromise; return { author, books: books.filter(book =&gt; book.authorId === id) };} 如果数组中每个item都要请求异步数据，必须依赖Promise 12345678910async getAuthor(id) { // 会引起串行调用，增加运行时间 // const authors = _.map( // authorIds, // id =&gt; await authorModel.fetch(id) // ); // 正确方式 const promises = _.map(authorIds, id =&gt; authorModel.fetch(id)); const authors = await Promise.all(promises);} 总之，仍需将流程视为异步的，然后用await写出同步的代码，在复杂的流程中，直接使用Promise可能更方便。 错误处理在Promise中，异步函数有两个返回值： resolved 和 rejected。可以用.then()处理正常情况，用.catch()处理异常情况。然而用async/await方式处理错误比较棘手。 try…catch推荐用try…catch语法捕获异常。所以最好把await命令放到try…catch代码块中。 1234567891011121314151617class bookModel { fetchAll() { return new Promise((resolve, reject) =&gt; { window.setTimeout(() =&gt; { reject({error: 400}) }, 1000); }); }}// async/awaitasync getBooksByAuthorWithAwait(id) { try { const books = await bookModel.fetchAll(); } catch (error) { console.log(error); // {error: 400} }} 捕捉到异常处理方法： 返回一个正常值。(不在catch块中使用任何return语句，相当于return undefined) 想让调用者处理它，可以直接抛出普通的错误对象。如throw error。允许在Promise.catch中处理错误。 使用try…catch好处： 简单，易于理解 如果不需要每部执行错误处理，可以在一个try…catch块中包装多个await调用来处理一个地方的错误。 这种方法有个缺陷，由于try…catch会捕获代码块中的异常，所以通常不会被Promise捕获的异常也会被捕获到。 123456789101112class BookModel { fetchAll() { cb();// cb未定义，导致异常 return fetch('/books'); }}try { bookModel.fetchAll();} catch(err) { console.log(err); // 打印 cb is not undefined} 代码会打印cb is not undefined，这个错误是由console.log打印出来，而不是JavaScript本身。有时，这是致命的，如果BookModel被包含在一些列函数调用中，其中一个调用者吞噬了错误，那么很难找到这样一个未定义错误。 让函数返回两个值[err, user] = await to(UserModel.findById(1)); 使用.catchawait的功能：它将等待Promise完成它的工作。Promise.catch()也会返回一个Promise。 所以我们可以这样处理错误： 123// books === undefined if error happens,// since nothing returned in the catch statementlet books = await bookModel.fetchAll().catch(err =&gt; {console.log(err);}); 这个方法有两个小问题： 它是Promise和async函数的混合体。仍需要理解Promise是如何工作的。 错误理解先于正常路径，这是不直观的。 结论async/await 关键字无疑是对J avaScript异步编程的改进。它可以使代码更容易阅读和调试。然而，为了正确地使用它们，必须完全理解 Promise，因为 async/await 只不过是 Promise 的语法糖，本质上仍然是 Promise。","link":"/posts/JavaScript-async-await/"},{"title":"JavaScript:for-of到generator","text":"for of在JavaScript中, 循环数组可以通过map, filter, for of 等来遍历一个数组. 为什么for of 可以遍历数组或类数组对象(String, Maps, Sets, arguments)？为什么不能用来遍历一个对象？ 循环数组时，需要两个信息： 对应下标的值 是否遍历结束的标志 在控制台打印一个数组看一下结构 12const arr = [1, 2, 3];console.dir(arr); 在__proto__中可以看到Symbol(Symbol.iterator)数组或类数组对象的原型中都实现了一个方法Symbol.iterator 可以用以下方法查看 123456const map = new Map();console.dir(map);const str = new String();console.dir(str);const set = new Set();console.dir(set); iterator(迭代器)迭代协议 mdn文档 The iterator protocol(可迭代协议允许) JavaScript 对象去定义或定制它们的迭代行为.所以上面出现的Symbol.iterator就是数组对于这个协议的实现。 数组怎么实现了一个iterator呢？MDN 文档 一个迭代器对象 ，知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在 JavaScript 中 迭代器是一个对象，它提供了一个next() 方法，用来返回序列中的下一项。这个方法返回包含两个属性：done和 value。 这里获取上面数组的Symbol.iterator, 打印出来看看 123const arr = [1, 2, 3];let iterator = arr[Symbol.iterator]();console.dir(iterator); 在iterator的原型中有next方法，执行next方法 1234iterator.next(); // 输出 {value: 1, done: false}iterator.next(); // 输出 {value: 2, done: false}iterator.next(); // 输出 {value: 3, done: false}iterator.next(); // 输出 {value: undefined, done: true} 当下标超出时，value:undefinediterator每次都返回一个对象，这个对象包含两个信息，当前下标的值value, 遍历是否结束的标志done 为什么for of 不能遍历一个对象呢？JavaScript 的对象中没有实现一个这样的 iterator 可以打印看一下console.log({}) 为什么在Object中没有内置迭代器？先了解一下基本概念 遍历对象只会在两种层级上对一个JavaScript对象进行遍历： 程序的层级。对一个对象进行迭代，是在迭代展示其结构的对象属性。举个栗子：Array.prototype.length这个属性与对象的结构相关，但却不是它的数据。 数据的层级。迭代数据结构并提取它的数据。举个栗子：迭代数组，对它的每个数据进行迭代，如果arr=[a，b，c]，迭代器访问的是1,2,3 JavaScript虽然不支持用for of遍历对象，但提供了for in 方法来遍历所有非Symbol类型并且是可枚举的属性。 标准不支持，自己实现一个for-of来遍历对象： 12345678910Object.prototype[Symbol.iterator] = function*() { for (const [key, value] of Object.entries(this)) { yield { key, value }; }}for (const { key, value } of { a: 1, b: 2, c: 3 }) { console.log(key, value);} 在实现iterator代码中，用到了Generator 结构：function*() {} Generators语法： 12345678function* gen() { yield 1; yield 2; yield 3;}let g = gen(); // &quot;Generator { }&quot; 这里打印一下gen， console.dir(gen)可以看到next方法。执行看结果 12345let s = gen();s.next(); // {value: 1, done: false}s.next(); // {value: 2, done: false}s.next(); // {value: 3, done: false}s.next(); // {value: undefined, done: true} generator可以实例化出一个iterator，yield语句就是用来中断代码的执行的。配合next() 方法，每次只会执行一个yield语句。 generator特性 yield后面可以跟上另一个Generator, 并且他们会按照次序执行 12345678910111213141516171819function* gen() { yield 1; yield* gen2(); yield 2; return;}function* gen2() { yield 4; yield 5;}let iterator = gen();console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());// 1,4,5,2 return 会终结整个Generator。卸载return后的yield不会执行。 Generator有什么用？能够中断执行代码，帮助我们控制异步代码的执行顺序。 例如有两个异步的函数 A 和 B, 并且 B 的参数是 A 的返回值，也就是说，如果 A 没有执行结束，我们不能执行 B 123456789function* effect() { const { param } = yield A(); const { result } = yield B(param); console.table(result);}const iterator = effect();iterator.next();iterator.next(); 执行两次 next() 得到结果，看起来很繁琐。假设每次执行 A() / B() 的请求结束之后，都会自动执行 next() 即可解决。 参考co源码 Generator原理async 和await 只是Generator的语法糖。dva中有Effect概念，它就是使用Generator来解决异步请求的问题。 Generator和Promise如何异步编程一些基本概念： Generator作为 ES6 中使用协程的解决方案来处理异步编程的具体实现，它的特点是: Generator 中可以使用 yield 关键字配合实例 gen 调用 next() 方法，来将其内部的语句分割执行。 简言之 : next() 被调用一次，则 yield 语句被执行一句，随着 next() 调用， yield 语句被依次执行。 Promise表示一个异步操作的最终状态（完成或失败），以及其返回的值。参考Promise-MDN 异步编程使用Generator和Promise实现的原理： 因为 Generator 本身 yield 语句是分离执行的，所以我们利用这一点，在 yield 语句中返回一个 Promise 对象 首次调用 Generator 中的 next() 后, 假设返回值叫 result ,那么此时 result.value 就是我们定义在 yield 语句中的 Promise 对象 注意：在这一步，我们已经把原来的执行流程暂停，转而执行 Promise 的内容,已经实现了控制异步代码的执行，因为此时我们如果不继续执行 next() 则 generator 中位于当前被执行的 yield 后面的内容，将不会继续执行,这已经达到了我们需要的效果3. 接下来我们就是在执行完当前 Promise 之后，让代码继续往下执行，直到遇到下一个 yield 语句:这一步是最关键的 所以我们怎么做呢: 步骤1： 在当前的 Promise 的 then() 方法中，继续执行 gen.next() 步骤2： 当 gen.next() 返回的结果 result.done === true 时,我们拿到 result.value【也就是一个新的 Promise 对象】再次执行并且在它的then() 方法中继续上面的步骤1，直至 result.done === false 的时候。这时候调用 resolve() 使 promise 状态改变，因为所有的 yield 语句已经被执行完。 步骤1 保证了我们可以走到下一个 yield 语句步骤2 保证了下一个 yield 语句执行完不会中断，直至 Generator 中的最后一个 yield 语句被执行完。 具体实现 从co库中的一个demo开始，了解我们的整个异步请求封装实现 12345co(function*() { yield me.loginAction(me.form); ...}); 引入co库，并且用co来包裹了一个generator（生成器）对象。接下来我们看下co对于包裹起来的generator做了什么处理 1234567891011121314151617181920function co(gen) { // 1.获取当前co函数的执行上下文环境,获取到参数列表 var ctx = this; var args = slice.call(arguments, 1); // 2.返回一个Promise对象 return new Promise(function(resolve, reject) { // 判断并且使用ctx:context(上下文环境)和arg:arguments(参数列表)初始化generator并且复制给gen // 注意: // gen = gen.apply(ctx, args)之后 // 我们调用 gen.next() 时，返回的是一个指针，实际的值是一个对象 // 对象的形式：{done:[false | true], value: ''} if (typeof gen === 'function') gen = gen.apply(ctx, args); // 当返回值不为gen时或者gen.next的类型不为function【实际是判断是否为generator】时 // 当前promise状态被设置为resolve而结束 if (!gen || typeof gen.next !== 'function') return resolve(gen); // 否则执行onFulfilled() onFulfilled(); });} 这里发生了什么 返回一个 promise promise 中将被包裹的 generator 实例化为一个指针，指向 generator 中第一个 yield 语句 判断 generator 实例化出来的指针是否存在：如果没有 yield 语句则指针不存在, 判断指针 gen.next() 方法是否为 function ：如果不为 function 证明无法执行 gen.next()条件有一项不满足就将 promise 的状态置为 resolve否则执行 onFulfilled() 看下 onFulfilled() 的实现 1234567891011121314function onFulfilled(res) { // 在执行onFulfilled时，定义了一个ret来储存gen.next(res)执行后的指针对象 var ret; try { ret = gen.next(res); // 在这里，yield语句抛出的值就是{value:me.loginAction(me.form), done:false} } catch (e) { return reject(e); }// 将ret对象传入到我们定义在promise中的next方法中 next(ret); return null;} onFulfilled 最主要的工作就是 执行 gen.next() 使代码执行到 yield 语句 将执行后返回的结果传入我们自定义的 next() 方法中 next() 方法 123456789101112131415function next(ret) {// 进入next中首先判断我们传入的ret的done状态:// 情况1:ret.done = true 代表我们这个generator中所有yield语句都已经执行完。// 那么将ret.value传入到resolve()中，promise的状态变成解决，整个过程结束。 if (ret.done) return resolve(ret.value);// 情况2:当前ret.done = false 代表generator还未将所有的yield语句执行完，那么这时候// 我们把当前上下文和ret.value传入toPromise中，将其转换为对应的Promise对象`value` var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);// 当value确实是一个promise对象的时候，return value.then(onFulfilled,onRejected)// 我们重新进入到了generator中，执行下一条yield语句 return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: &quot;' + String(ret.value) + '&quot;'));} next 主要工作 判断上一次 yield 语句的执行结果 将 yield 的 result 的 value 值【其实就是我们要异步执行的 Promise 】 执行 value 的 then 方法，重新进入到 onFulfilled 方法中，而在 onFulfilled 中，我们又将进入到当前方法，如此循环的调用，实现了 generator 和 Promise 的执行切换，从而实现了 Promise 的内容按照我们所定义的顺序执行。 至此实现异步操作的控制。 参考链接 前端怪谈_2从 Dva 的 Effect 到 Generator + Promise 实现异步编程","link":"/posts/JavaScript-for-of%E5%88%B0generator/"},{"title":"JavaScript算法之复杂度分析","text":"JavaScript 算法之复杂度分析 想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念—–复杂度分析。 ==是数据结构和算法学习的精髓。== 是什么：数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。数据结构是为算法服务的，算法是要作用再特定的数据结构上的。 学什么： 效率和资源消耗的度量衡–复杂度分析。 最常用、最基础的20个数据结构与算法，学习他们的：“来历”、“特点”、“适合解决什么问题”和“实际的应用场景”。 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire树 算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法 怎么学: 边学边练，每周花 1~2 小时集中攻关三节课涉及的数据结构和算法，全部写出来。 主动提问、多思考、多互动。在留言区增加自己的留言。 自我激励，每次学习完做一篇学习笔记。 沉下心不要浮躁，先把这些基础的数据结构和算法，还有学习方法熟练掌握后，再追求更高层次。 为什么需要复杂度分析执行代码进行复杂度分析弊端 测试结果非常依赖测试环境 测试结果受数据规模的影响很大 大O复杂度表示法不需要具体的测试数据来测试，就可以粗略估计算法执行效率的方法 一、什么是复杂度分析？ 数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。 二、为什么要进行复杂度分析？ 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。 三、如何进行复杂度分析？ 大O表示法 1）来源 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。 2）特点 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。 复杂度分析法则 1）单段代码看高频：比如循环。2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3）嵌套代码求乘积：比如递归、多重循环等4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 四、常用的复杂度级别？ 多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶） 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶） 五、如何掌握好复杂度分析方法？复杂度分析关键在于多练，所谓孰能生巧。 06 | 链表（上）：如何实现LRU缓存淘汰算法五、应用1.如何分别用链表和数组实现LRU缓冲淘汰策略？1）什么是缓存？缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。2）为什么使用缓存？即缓存的特点缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。3）什么是缓存淘汰策略？指的是当缓存被用满时清理数据的优先顺序。4）有哪些缓存淘汰策略？常见的3种包括先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）。5）链表实现LRU缓存淘汰策略当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。6）数组实现LRU缓存淘汰策略方式一：首位置保存最新访问数据，末尾位置优先清理当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。方式二：首位置优先清理，末尾位置保存最新访问数据当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）2.如何通过单链表实现“判断某个字符串是否为水仙花字符串”？（比如 上海自来水来自海上）1）前提：字符串以单个字符的形式存储在单链表中。2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。3）将链表中的字符倒序存储一份在另一个链表中。4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。六、设计思想时空替换思想：“用空间换时间” 与 “用时间换空间”当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。 递归一、什么是递归？ 递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示，比如 123f(n) = f(n-1) + 1;f(n) = f(n-1) + f(n-2);f(n)=n*f(n-1); 二、为什么使用递归？递归的优缺点？ 优点：代码的表达力很强，写起来简洁。 缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。 三、什么样的问题可以用递归解决呢？ 一个问题只要同时满足以下3个条件，就可以用递归来解决： 问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。 问题与子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 四、如何实现递归？ 递归代码编写 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。 递归代码理解 对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 五、递归常见问题及解决方案 警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。 警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。 六、如何将递归改写为非递归代码？ 笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。","link":"/posts/JavaScript%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"},{"title":"Linux","text":"终端上传下载文件 在终端往linux上传文件rz -b 中文的无法上传，需要先将文件名改为英文的，上传上去后，再改为中文。 下载sz -b 参考:链接 一、命令基本格式http://www.cnblogs.com/ShaYeBlog/p/5576601.html git 打tag 命令 [选项][参数] 注意： 1. 个别命令不遵循此格式 2. 有多个选项，可以写在一起 3. 简写：-a == -all, ll == ls -l 1.1 ls ls -a 显示所有文件，包括隐藏文件 ls -l 显示详细信息 ls -d 查看目录属性 ls -h 人性化显示文件大小 ，K/M ls -i 显示inode 1.2 文件权限(10位) 第一位是文件类型，后面每3位一组 -rw-r-r– -文件类型(-文件 d目录 l软链接) rw- u所有者 r– g所属组 r– o其他人 r 读 w 写 x 执行 二、文件处理命令linux中一切皆文件。目录为目录文件。普通文件用来保存数据，目录文件用来保存目录。 2.1 常用目录介绍及作用 / 根目录 /sbin ，/bin 命令保存目录 根目录下的bin和sbin，usr下的bin 和sbin都是用来保存系统命令。bin目录下的命令任何用户都可以执行，sbin下只有root才可以执行。Linux通过此方式区分用户权限 /boot 启动目录，启动相关文件 /dev 设备文件保存目录 /etc 配置文件保存目录 /home 普通用户的家目录 /lib 系统库保存目录 /mnt 系统挂载u盘、移动硬盘目录 /media 挂载光盘目录 /misc 外接磁带机挂载目录 /root 超级用户的家目录 /tmp 临时目录 可存放临时数据 /proc 直接写入内存的 /sys 同 /proc不能直接操作 /usr 系统软件资源目录 /usr/bin/ 系统命令 (普通用户) /usr/sbin/ 系统命令 (超级用户) 2.2 目录处理文件命令 mkdir -p [目录名] -p 递归创建 make directories mkdir src mkdir bin cd 切换所在目录 change directory 简化操作 cd ~ 进入当前用户的家目录 cd - 进入上次目录 cd .. 进入上一级目录 cd . 进入当前目录 pwd 查看当前所在目录位置 print working directory 2.3 文件处理命令 rmdir [目录名] 删除空目录 remove empty directory rm -rf [文件或目录] 删除文件或目录 选项： -r 删除目录 -f 强制 rm [文件名] :提示是否删除 rm -r [目录]: 删除目录需加-r，目录中含有子文件，将继续询问是否删除 rm -rf [目录]: 删除目录，直接删除 **自杀指令** rm -rf / cp [选项] [原文件或目录] [目标目录] 复制 copy -r 复制目录 -p 连带文件属性复制 -d 若源文件是链接文件，则复制链接属性 -a 相当于-pdr 目标文件和源文件属性相同 被复制文件的时间为执行复制命令的时间，若要使被复制的文件与原文件属性完全一致，需加 -a eg: cp abc /tmp/ 若目标目录不加文件名，则原名复制 cp abc /tmp/ana 目标文件加入文件名，改名复制 cp -r ja/ /tmp/ 复制目录 cp -a ja/ /tmp/ 完全复制，包含所有属性 mv [原文件或目录] [目标目录] move eg: mv ja /tmp/ 剪切 mv abc longls 原文件与目标目录在同一个目录，则为重命名 date 查看当前系统时间 2.4 链接命令 格式化硬盘?? ln -s [源文件] [目标文件] link 选项 -s 创建软链接 硬链接特征 拥有相同i节点和存储block块，可以看做是同一个文件。 硬链接与源文件拥有相同的i节点。 删除原文件或硬链接文件的任何一文件，不影响文件索引操作？？？原文件删除了吗？ 1）可以通过i节点识别 2）不能跨分区建立 3）ln ./source/abc ./target/bcd.hard 创建后，引用计数+1 1) ls -i ./souce/abc ./target/bcd.hard 可使用ls -i 来查看文件i节点 不建议创建硬链接文件： 文件过于隐蔽，除了i节点很难区分它是不是硬链接 硬链接限制较多，不能跨分区，不能针对目录，使用中容易出现错误使用方法 软链接特征 类似于Windows的快捷方式 软链接拥有自己的i节点和block块，只保存原文件的文件名和节点号，并没有实际的文件数据。 软链接的权限都为777，但实际权限要看原文件权限。 修改任意文件，另一个都会改变。 删除原文件，软链接不能用 创建软链接，原文件一定要写绝对路径，否则软链接会到它所在的同一个目录去找原文件 硬链接与软链接图 三、文件搜索命令3.1 locate 文件名速度快，但只能按照文件名搜索，不能进行更复杂的搜索 3.2 whereis用于搜索命令所在的路径已经帮助文档所在的位置 -b: 只查找可执行文件 -m: 只查找帮助文件 3.3 which能看到命令的路径，如果有别名，还能看到别名的说明 只能看到外部安装的命令，如pwd. 3.4 $PATH类似于Windows的环境变量，执行命令时，从path定义的目录中寻找 echo $PATH 3.5 whoami显示当前用户 3.6 whatis查询一个命令执行什么功能，并将结果打印到终端上 3.7 find [搜索范围] [搜索条件] 默认完全匹配 避免大范围搜索，非常浪费资源，建议不在直接’/‘目录下搜索 find /root -iname test 不区分要搜索的test大小写格式 find /root -user root 搜索root目录下所有属于root用户的文件 find /root -nouser 没有所属者的文件。 linux中每个文件都有所属者，如果没有，一般都是垃圾文件。 但还是有特殊的，内核产生的文件，就没有所属者，一般在proc和sys目录下； 还有外来文件，u盘拷入的文件也会忽略所有者 模糊查询通配符有3种 1. * 匹配任何字符 find /home -name &quot;*test*&quot;,显示所有名字带test的文件 find /home -name &quot;*&quot;, home目录下所有文件，包括隐藏文件 2. ? 匹配任意一个字符 3. [] 匹配任意一个中括号内的字符， find /home -name &quot;test[12]&quot; 显示test1 test2文件 find /home -name &quot;[12]*&quot; 显示1或2开头的文件 find /home -name &quot;*[12]&quot; 显示所有1或2结尾的文件 find 按文件时间搜索1. find /home -mtime +10 在home目录下，查找10天前修改的文件 2. find /home -mtime 10 10天前当天的文件 3. find /home -mtime -10 10天内修改的文件 atime 文件访问时间 ctime 改变文件属性 mtime 修改文件内容 find 目录 -size 大小小写k和大写M find /etc -size +20k -a -size -50k 查找/etc/目录下大于20k并且小于50k的文件 -a and 与，两个条件都满足 -o or 或，两个条件满足一个即可 find /etc -size +20k -a -size -50k -exec ls -lh {} \\; 查找/etc 目录下，大于20k且小于50k的文件，并显示详细信息 -exec/ -ok 命令 {} \\; 对搜索结果执行操作 固定格式：-exec {} \\\\ ，表示直接对前面的搜索结果进行后面的命令处理。？？？ grep [选项] 字符串 文件名-i 忽略大小写 -v 排除指定字符串 find与grep的区别 find: 在系统中搜索符合条件的文件名，如果需要匹配，使用通配符，为完全匹配 grep: 在文件中搜索符合条件的字符串，如果需要匹配，使用正则表达式，为包含匹配 四、帮助命令4.1 man 命令名称 manual进入man命令操作，q退出；输入: / -d 搜索’-d’字符串；按n往下搜，shfit+n 网上搜 4.2 其他帮助命令 命令 –help info 命令 ls –help -回车 进入带*号的命令 -u 进入上层页面 -n 进入下一个帮助小节 -p 进入上一个帮助小节 -q 退出 五、压缩与解压缩命令 .zip .gz .bz2 .tar.gz .tar.bz2 5.1 zip1234zip 压缩文件名 源文件 # 压缩文件zip -r 压缩目录名 源目录 # 压缩目录unzip 压缩文件 # 解压缩文件 5.2 gz123456gzip 源文件 # 压缩为.gz格式的压缩文件，源文件会消失gzip -c 源文件&gt;压缩文件 # 压缩为.gz格式，源文件会保留gzip -r 目录 # 压缩目录下所有的文件夹，但不能压缩目录gzip -d 压缩文件 # 解压缩文件gunzip 压缩文件 # 解压缩文件 5.3 bzip格式bzip 不能压缩目录 12345bzip2 源文件 # 压缩文件 源文件会消失bzip2 -k 源文件 # 压缩后 保留源文件bzip -d 压缩文件 # 解压bzip2文件bunbzip 压缩文件 # 解压文件 5.4 tar.gz tar.bz212345678910111213tar -cvf 打包文件名 源文件 # 压缩为tar格式tar -zvcf 压缩包名.tar.gz 源文件 # 压缩为.tar.gz格式tar -jvcf 压缩包名.tar.bz2 源文件 # 压缩为.tar.bz2格式# -c 打包# -v 显示过程# -f 指定打包后的文件名tar -xvf 打包文件名 # 解压tar格式tar -zxvf 压缩包名.tar.gz # 解压.tar.gz格式tar -jxvf 压缩包名.tar.bz2 # 解压.tar.bz2格式# -x 解压包# -z 压缩为tar.gz格式# -j 压缩为.tar.bz2格式 其他用法 1. 指定解压位置 tar -jxvf打包文件名 -C 绝对路径 2. 同时压缩多个文件到指定路径 tar -zcvf 绝对路径 （/tmp/） 打包文件名 源文件 源文件 3. 查看压缩包内文件，不解压 tar -ztvf 压缩包文件名 123456tar –cvf jpg.tar *.jpg # 将目录里所有jpg文件打包成tar.jpgtar –czf jpg.tar.gz *.jpg # 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –cjf jpg.tar.bz2 *.jpg # 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –cZf jpg.tar.Z *.jpg # 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg # rar格式的压缩，需要先下载rar for linuxzip jpg.zip *.jpg # zip格式的压缩，需要先下载zip for linux 解压 1234567tar –xvf file.tar # 解压 tar包tar -xzvf file.tar.gz # 解压tar.gztar -xjvf file.tar.bz2 # 解压 tar.bz2tar –xZvf file.tar.Z # 解压tar.Zunrar e file.rar # 解压rarunzip file.zip # 解压zip 六、关机和重启命令6.1 关机和重启 shutdown [选项] 时间 时间后面加&quot;&amp;&quot;,表示将当前计划任务放置后台运行！若不放置，当前界面直到关机/重启都无法进行操作。 这时，如果当前用户按下ctrl+c ，可以取消本次关机或重启的操作； 而其他用户按下ctrl+c，不会取消关机或重启，但可以中断退出，继续其他操作。 选项-h 关机 -r 重启 -c 取消上一个关机命令 时间 now //现在 时: 分 // 后面的时间可以使用[+m]格式，表示多少分钟后执行。 也可以用[hh:mm]格式，表示指定的时间执行，该时间是24小时制的 举例shutdown -h 05:30 设定凌晨05:30关机 shutdown -h now 立即关机 shutdown -r 05:30 设定凌晨05:30重启 shutdown -r now 立即重启 shutdown -c 取消前一个关机或重启命令 6.2 系统运行级别runlevel 查看运行级别 前级别 当前级别 logout 注销 0 //关机 1 //单用户(类似windows安全模式） 2 //不完全多用户，不含NFS服务（字符界面，不包含文件共享服务） 3 //完全多用户（字符界面） 4 //未分配 5 //图形界面 6 //重启 七、挂载与卸载命令7.1 挂载(可理解为分配盘符)(1)查询与自动挂载 mount 查询系统中已挂载的设备mount -a 依据配置文件/etc/fstab的内容，自动挂载 光盘 U盘 数据不建议写入自动挂载 (2) 挂载命令的格式 mount [-t 文件系统] [-o 特殊选项][设备文件名][挂载点] mount选项-t 文件系统：加入文件系统类型来指定挂载的类型，ext3,ext4,光盘：iso9660等文件系统-o 特殊选项：可以指定挂载的额外选项 7.2 挂载/卸载光盘 没用了吧7.3 挂载U盘先看U盘的设备名，然后再挂载 fdisk -l //查看系统中已经识别的硬盘 mount -t vfat /dev/sdb1 /mnt/usb/ 注: vfat 指的是fat32文件系统，单个文件不超过4G Linux默认不支持NTFS文件系统，可以下载ntfs-3g软件安装 八、用户登录查看命令8.1 w查看系统当前信息(负载和开机时间等信息) 当前已经登录的用户及用什么终端进入。 load average: X.XX X.XX X.XX 表示系统在1分钟内 5分钟内 15分钟内 的平均负载(CPU内存)USER: 用户TTY:登录终端 pts/0 第一个远程终端LOGIN@: 登录时间IDLE: 用户闲置时间JCPU: 指的是和该终端连接的所有进程占用的时间。PCPU: 指当前进程所占用的时间WHAT: 当前正在运行的命令 8.2 who 与w类似，但信息有所简化会显示登录来源IP地址 8.3 last查看当前登录和过去登录的用户信息 可以看到reboot时间，实际是查看/var/log/wtmp但必须用last命令才能看 8.4 lastlog查看所有用户最后一次登录时间 /var/log/lastlog 不能直接看，也是用lastlog看 编辑器 :w 报错 :q 退出 :! 强制保存 :ls 列出所有文件 :n 下一个 :N 上一个 :15跳转到指定行 /xxx 从光标位置开始向后搜索 xxx 字符串 ?xxx 从光标位置开始向前搜索","link":"/posts/Linux/"},{"title":"mac 经验","text":"[TOC] mac日常经验积累记录日常经验 在 Mac OS X 的 Terminal 上如何修改行首的显示1sudo scutil --set HostName 新的主机名 执行命令后，再输入 exit 结束当前终端进程。重新打开终端，就会发现主机名已经修改为新的主机名了。 然后重启terminal keyboard键盘设置按command+空格或用Alfred搜keyboard, 打开键盘设置窗口把按键重复和重复前延迟调到最快，可提升打字效率 窗口平铺工具Magnet 在xclient.info可以下载到 mac创建文件夹需要密码从终端进到目标文件夹或目标文件夹上级 执行sudo chmod -R 777 xxx, xxx是你需要添加写权限的文件夹名称 mac录屏自带软件即可录制QuickTime Player mac 安装 tomcat 按照百度经验，安装Java jdk，配置环境变量 检查Java版本 java -version echo $JAVA_HOME 下载tomcat，官网版 修改授权 进入tomcat的bin目录,修改授权 123➜ bin pwd/Users/yp/Documents/workspace/apache-tomcat-7.0.68/bin➜ bin sudo chmod 755 *.sh sudo为系统超级管理员权限. chmod 改变一个或多个文件的存取模式 755代表用户对该文件拥有读、写、执行的权限，同组的其他人员拥有执行和读的权限，没有写的权限，其它用户的权限和同组人员一样. 777代表，user,group ,others ,都有读写和可执行权限. chmod -R 777 folername,获取文件夹权限. 启动二、启动执行启动命令 sudo sh ./startup.sh访问http://localhost:8080/ 关闭 sudo sh ./shutdown.sh 或直接./shutdown.sh 安装 nginx 先安装 homebrew brew install nginx mac 下 vim 快捷键 不在编辑状态下按 dd 删除行链接 查看mac内存和cpu占用系统自带APP–活动监视器, 可以查看 mac 添加任何来源允许权限在命令行执行 1 sudo spctl --master-disable 输入密码,再回到隐私里，就能看到任何来源. 如何卸载 paragon NTFS for mac123找到 /Library/Application Support/Paragon Software 目录sudo ./com.paragon-software.ntfs.uninstall mac本地绑定hosts1234sudo vim /etc/hosts 添加以下内容10.180.112.208 www.baidu.com www.jd.com 可以添加多个域名, 也可以一个 mac手势快捷键1.三指拖动✨✨✨✨✨ 设置-&gt;辅助功能-&gt;鼠标与触控板-&gt;触控板选项-&gt;启动拖移-&gt;三指拖移 可以在触控板在任何软件标题栏拖动该窗口2.docker程序坞缩放✨✨✨✨✨ 放大选中, 最大 鼠标放到docker上可以看到该程序图标放大3.点按✨✨✨✨✨ 设置-&gt;触控板-&gt;轻点来点按 单机只需轻点触控板, 不用用力按4.显示器排列✨✨✨✨✨ 设置-&gt;显示器-&gt;排列 mac如果外接显示器,可以拖动显示器位置来排列位置,方便鼠标移动到另一个显示器5.全屏下切换窗口✨✨✨ 四指滑动 mac安装homebrewHomebrew的安装非常简单，打开终端复制、粘贴以下命令，回车，搞定(请放心使用，原汁原味的官方安装方法搬运）ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 新建管理员用户怎么弄点击“系统偏好设置”-“用户与群组”,点解锁，输入密码，然后点击左下角的“+”新建一个管理员用户，然后回到电脑主屏幕，点击右上角菜单的当前用户，然后选择新建的用户切换进入使用。 触发角在「桌面与屏幕保护程序」-「屏幕保护程序」可以设置鼠标在每个角落的时候相应的操作。 可用于锁屏，显示桌面 MAC 快捷键Mac中主要有四个修饰键，分别是Command，Control，Option和Shift。 Command是Mac里最重要的修饰键，在大多数情况下相当于Windows下的Ctrl。所以以下最基本操作很好理解：Command-Z 撤销Command-X 剪切 Command-C 拷贝（Copy） Command-V 粘贴 Command-A 全选（All） Command-S 保存（Save) Command-F 查找（Find） 截图：Command-Shift-4 截取所选屏幕区域到一个文件 Command-Shift-3 截取全部屏幕到文件 Command-Shift-Control-3 截取全部屏幕到剪贴板 Command-Shift-4 截取所选屏幕区域到一个文件，或按空格键仅捕捉一个窗口 Command-Shift-Control-4 截取所选屏幕区域到剪贴板，或按空格键仅捕捉一个窗现在直接用微信的快捷键了 在应用程序中：Command-Option-esc 打开强制退出窗口 Command-H 隐藏（Hide）当前正在运行的应用程序窗口 Command-Option-H 隐藏（Hide）其他应用程序窗口 Command-Q 退出（Quit）最前面的应用程序 Command-Shift-Z 重做，也就是撤销的逆向操作 Command-Tab 在打开的应用程序列表中转到下一个最近使用的应用程序，相当于Windows中（Alt+Tab） Command-Option-esc 打开“强制退出”窗口，如果有应用程序无响应，可在窗口列表中选择强制退出 文本处理：Command-右箭头 将光标移至当前行的行尾 Command-B 切换所选文字粗体（Bold）显示 fn-Delete 相当于PC全尺寸键盘上的Delete，也就是向后删除 fn-上箭头 向上滚动一页（Page Up） fn-下箭头 向下滚动一页（Page Down） fn-左箭头 滚动至文稿开头（Home） fn-右箭头 滚动至文稿末尾（End） Command-右箭头 将光标移至当前行的行尾 Command-左箭头 将光标移至当前行的行首 Command-下箭头 将光标移至文稿末尾 Command-上箭头 将光标移至文稿开头 Option-右箭头 将光标移至下一个单词的末尾 Option-左箭头 将光标移至上一个单词的开头 Control-A 移至行或段落的开头 在Finder中：Command-Option-V 剪切文件 Command-Shift-N 新建文件夹（New） Command-Shift-. 显示或隐藏系统文件 Command-Shift-G 调出窗口，可输入绝对路径直达文件夹（Go） return 这个其实不算快捷键，点击文件，按下可重命名文件 Command-O 打开所选项。在Mac里打开文件不像Windows里直接按Enter Command-Option-V 作用相当于Windows里的文件剪切。在其它位置上对文件复制（Command-C），在目的位置按下这个快捷键，文件将被剪切到此位置 Command-上箭头 打开包含当前文件夹的文件夹，相当于Windows里的“向上” Command-Delete 将文件移至废纸篓 Command-Shift-Delete 清倒废纸篓 空格键 快速查看选中的文件，也就是预览功能 在浏览器中：Control-Tab 转向下一个标签页 Command-L 光标直接跳至地址栏 Control-Tab 转向下一个标签页 Control-Shift-Tab 转向上一个标签页 Command-加号或等号 放大页面 Command-减号 缩小页面 切换同个软件的不同窗口 command+` 锁屏ctrl+command+q 触摸板触摸板可以设置成触摸板轻敲替代按下的… 如何重置 Mac 上的 NVRAMhttps://support.apple.com/zh-cn/HT204063 重置 Mac 上的系统管理控制器 (SMC)https://support.apple.com/zh-cn/HT201295 UI 切图工具 sketch绘图工具下载破解版 PxCook生成前端代码利器 Flavorsketch导出为PxCook插件Flavor Xmind安装下载地址下载主程序和破解补丁。 先安装主程序，按照破解补丁里的步骤安装即可。 mac关闭指定端口1234sudo lsof -i:8090udo kill -9 [pid]# egudo kill -9 59296 Windows虚拟机http://soft.macx.cn/6205.htm TODO解锁Alfred, Workflow iPhone 8强制重启先按音量+，再按音量-，再长按电源键10s左右会显示开机画面。 homebrew 软件下载安装利器[下载安装]https://brew.sh/index_zh-cn)所有软件列表安装 1brew install wget 在finder左侧边栏建立新文件夹打开finder在设备找到电脑磁盘Macintosh HD或在桌面找到Macintosh HD， 进入用户，选择自己的用户名，新建文件夹，然后拖动到左边边栏即可。想要删除直接右击，选中，从边栏移除. 详见百度经验链接 mac浏览器全屏地址栏被隐藏左上角视图–&gt; 在全屏模式下始终显示工具栏gstgst mac常用软件下载地址mac-torrent-download xclient.info👍👍👍👍👍 参考链接 程序员如何优雅地使用 macOS？","link":"/posts/Mac%20%E7%BB%8F%E9%AA%8C/"},{"title":"Mac快速搭建开发环境","text":"因为笔记本电池坏了，要送机维修，用了半天时间快速换电脑从0搭建得心应手的开发环境。特记录留念。 Mac键盘设置系统设置-&gt; 键盘-&gt; 调到最快 Git 初始化先创建目录 mkdir /Users/zjp(此处为电脑用户名)/.ssh 将原来电脑里的 known_hosts，id_rsa.pub， id_rsa放到这个目录下即可 用git命令 Git 命令快捷方式bdgp 在 ~/.oh-my-zsh/plugins/git的 git.plugin.zsh文件末尾添加 12345678bdgp() { if [[ &quot;$#&quot; != 0 ]] &amp;&amp; [[ &quot;$#&quot; != 1 ]]; then git push origin head:refs/for/&quot;${*}&quot; else [[ &quot;$#&quot; == 0 ]] &amp;&amp; local b=&quot;$(git_current_branch)&quot; git push origin head:refs/for/&quot;${b:=$1}&quot; fi} homebrew 安装地址因为HomeBrew官网提供的安装办法会报错，所以改用以下方法，简介好用，强烈推荐！！！知乎链接然后就可以正常安装插件 各个插件的安装要根据每个插件的安装指南对应安装 iTerm2下载因为网速原因下载最新版会特别慢低版本下载链接 经验不用从官网下载，直接将原电脑应用程序里的文件压缩通过隔空传送发送到新电脑即可。 插件安装详见我的博客believezjp.oriht.com链接Oh-my-zsh的安装都要用库对应的方法安装 安装常用软件搜狗输入法（外观-简约黑2，候选9个字） Vscode 微信开发者工具 百度开发者工具 GitKraken(只能安装6.5.1版本以下的) PdfGuru vscode插件安装直接安装Settings Sync同步即可 Node环境安装直接官网下安装包 文件备份打开Finder里的各个目录查看文件，压缩传送新电脑即可 然后就可以下代码开始搬砖了~~","link":"/posts/Mac%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"MongoDB","text":"安装下载链接 下载完直接安装 管理工具： Robomongo 和 Mongochef","link":"/posts/MongoDB/"},{"title":"Node-常用工具","text":"supervisor 监听Node改动supervisor 官网是一个进程控制系统 平时，我们 node app.js 后，当我们修改了 app.js 的内容，就需要关闭 node 命令行再执行 node app.js。而我们使用 supervisor 后，我们修改了 app.js 中的内容，只要点击保存，即可生效保存后的代码，实现实时监听 node 代码的变动。 基本用法 安装插件：npm i supervisor -g 运行命令：supervisor app.js 查看运行：localhost:3000 执行命令必须在项目的根目录启动。不管服务启动文件在什么位置。 例如：Express4.0中，启动文件位于./bin/www，启动时，必须在./下执行supervisor bin/www 没有任何参数启动服务，默认监控所有文件, 文件夹的变化，一旦有变化，服务就会重启。 这样会出现很多问题：将日志存入某些文件夹，或上传附件等，都会导致服务器文件的变化，必然引起node服务器的重启。 不想监控某些文件夹，可以使用-i参数。如：忽略根目录下的private, 可以这样启动：supervisor -i ./private myapp忽略多个文件夹，则用,隔开supervisor -i ./private,./otherdir myapp 详细介绍运行：supervisor PM2 - Node进程管理PM2- NPM官网PM2 是 Node 进程管理工具，可以利用它来简化很多 Node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。下面就对 PM2 进行入门性的介绍，基本涵盖了 PM2 的常用的功能和配置： 用法 全局安装 PM2：npm i pm2 -g 监听应用：pm2 start index.js 查看所有进程：pm2 list 查看某个进程：pm2 describe App name/id 停止某个进程：pm2 stop App name/id 停止所有进程：pm2 stop all 重启某个进程：pm2 restart App name/id 删除某个进程：pm2 delete App name/id 查看所有的进程状态：pm2 status supervisor 是监听单个进程的话，那么 PM2 就是监听多个进程。 参数说明 --watch：监听应用目录源码的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目，可以弥补node.js缺陷 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如–ignore-watch=”test node_modules “some scripts” -n –name：应用的名称。查看应用信息的时候可以用到 -o --output &lt;path&gt;：标准输出日志文件的路径，有默认路径 -e --error &lt;path&gt;：错误输出日志文件的路径，有默认路径 --interpreter &lt;interpreter&gt;：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用 通过yaml管理多个应用process.yml 12345678910apps: - script : app.js instances: 4 exec_mode: cluster - script : worker.js watch : true env : NODE_ENV: development env_production: NODE_ENV: production 启动: pm2 start process.yml 环境切换开发中会有多个环境(开发，测试，生产等), 根据不同环境切换各种情景 pm2通过在配置文件中的env_xx来声明不同环境的配置，然后在启动时通过--env参数指定运行环境 环境变量如下定义 123456789101112&quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;production&quot;, &quot;REMOTE_ADDR&quot;: &quot;http://www.example.com/&quot;},&quot;env_dev&quot;: { &quot;NODE_ENV&quot;: &quot;development&quot;, &quot;REMOTE_ADDR&quot;: &quot;http://wdev.example.com/&quot;},&quot;env_test&quot;: { &quot;NODE_ENV&quot;: &quot;test&quot;, &quot;REMOTE_ADDR&quot;: &quot;http://wtest.example.com/&quot;} 在应用中通过process.env.REMOTE_ADDR等来读取配置中声明的变量 启动指定的环境：pm2 start app.js --env development 负载均衡12pm2 start app.js -i 3 # 开启三个进程pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程 查看日志pm2 logs 查看监控pm2 monit 开机自动启动 运行 pm2 startup，即在/etc/init.d/ 目录下生成 pm2-root 的启动脚本，且自动将 pm2-root 设为服务； 通过pm2 save保存当前进程状态。 详细介绍pm212pm2 -h # helppm2 # 语法介绍 node版本升级先清缓存安装n模块升级到指定版本/最新版本 12345npm cache clean -fnpm install -g nn stable 安装完成后，查看Node的版本node -v","link":"/posts/Node-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"title":"NodeJS 进阶","text":"参考资料 1. 安装Node.js官网下载直接安装 安装成功后，输入npm -v 和node -v 测试。 Linux安装 123456curl -O https://nodejs.org/dist/v6.9.1/node-v6.9.1.tar.gztar -xzvf node-v6.9.1.tar.gzcd node-v6.9.1./configuremakemake install 版本管理使用nvm 或 n npm 源管理工具nrm 用来切换官方npm源和国内npm源，也可以用来切换官方npm源和公司私有npm源 全局安装 nrm : 1npm i nrm -g 查看nrm内置的npm源地址 1nrm ls 切换源 1npm use cnpm 非常棒的博客：http://blog.fens.me http://blog.fens.me/series-nodejs/ Node 教程https://github.com/nswbmw/N-blog/ Node文档地址：https://nodejs.org/api/fs.html#fs_event_open中文文档http://nodejs.cn/api/fs.html关于文件读取，写入 File System 读取文件 https://segmentfault.com/a/1190000004957223 expresshttp://www.expressjs.com.cn/starter/generator.htmlnode+mongodb搭建博客https://segmentfault.com/a/1190000011794598 Node 自学完全总结http://www.jianshu.com/p/22f62a08559f Node.js教程七天学会NodeJShttp://nqdeng.github.io/7-days-nodejs/#1.1 http://www.open-open.com/lib/view/1392611872538#_label2 https://github.com/alsotang/node-lessons 我来对创业公司中使用 Nodejs，做一个小总结，我们在妥善处理了 运维、集群管理、性能调优等等这些传统语言已经做的非常棒非常成熟的领域，在大部分的创业公司，都可以由前端团队推动，来使用 Nodejs 去接管数据访问层与渲染层的事情，等到公司规模上来以后，就可以依靠更资深的工程师以及原来团队的沉淀，来做 比如日志、监控系统、分布式服务接入这些事情，Nodejs 的落地需要前端工程师，需要 Nodejs 工程师，更需要强大的运维之锤，了解除了 JS 以外的更多技能，比如数据库，比如系统的设计，比如接口服务，比如团队规范协作流程等等等等，在大公司可以扎根一个方向挖下去，在小公司则需要放眼天下，筹备未来。","link":"/posts/NodeJS-%E8%BF%9B%E9%98%B6/"},{"title":"NodeJS中的内存泄漏","text":"内存泄漏(Memory Leak): 由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。严重的情况下导致内存达到某个极限会使得应用程序崩溃。 传统的 C/C++ 中存在指针，对象用完后未释放等情况导致的内存泄漏。而在使用虚拟机执行的语言中如 Java、JavaScript 由于使用了 GC （Garbage Collection，垃圾回收）机制自动释放内存，使得程序员的精力得到的极大的解放，不用再像传统语言那样时刻对于内存的释放而战战兢兢。 即便有了 GC 机制可以自动释放，但这并不意味这内存泄漏的问题不存在了。内存泄漏依旧是开发者们不能绕过的一个问题，今天让我们来了解如何分析 Node.js 中的内存泄漏。 GC in Node.jsNode.js 使用 V8 作为 JavaScript 的执行引擎，所以讨论 Node.js 的 GC 情况就等于在讨论 V8 的 GC。 在 V8 中一个对象的内存是否被释放，是看程序中是否还有地方持有改对象的引用。 在 V8 中，每次 GC 时，是根据 root 对象 (浏览器环境下的 window，Node.js 环境下的 global ) 依次梳理对象的引用，如果能从 root 的引用链到达访问，V8 就会将其标记为可到达对象，反之为不可到达对象。被标记为不可到达对象（即无引用的对象）后就会被 V8 回收。 更多细节，可以参见 解读 V8 GC。 在 Node.js 中内存泄露的原因就是本该被清除的对象，被可到达对象引用以后，未被正确的清除而常驻内存。 内存泄漏的几种情况全局变量使用全局变量或未定义的变量，不会被清除掉 12a = 10;global.b = 1; 闭包闭包的就是内部函数可以访问定义在外部函数中的变量。 123456functionout(){ const bigData =newBuffer(100); inner =function(){ void bigData; }} 由于inner挂载在root上，导致bigData不会被释放 事件监听Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除 node Agent keepAlive 为 true 时，可能造成的内存泄漏。 当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听，而产生内存泄漏。 所以要了解添加事件的对象的生命周期。自己添加的事件监听，必须自己移除。 node Agent keepAlive 内存泄漏 其他原因还有一些其他的情况可能会导致内存泄漏，比如缓存。 在使用缓存的时候，得清楚缓存的对象的多少，如果缓存对象非常多，得做限制最大缓存数量处理。还有就是非常占用 CPU 的代码也会导致内存泄漏，服务器在运行的时候，如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高。 如何避免内存泄漏ESLint 检测代码检查非期望的全局变量。 使用闭包的时候，得知道闭包了什么对象，还有引用闭包的对象何时清除闭包。避免写出复杂的闭包 绑定事件的时候，一定得在恰当的时候清除事件。在编写一个类的时候，推荐使用 init 函数对类的事件监听进行绑定和资源申请，然后 destroy 函数对事件和占用资源进行释放。 定位内存泄漏正常使用就可以重现的内存泄漏，只要在测试环境模拟就可以排查 对于偶然的内存泄漏，一般会与特殊的输入有关系。想稳定重现这种输入是很耗时的过程。如果不能通过代码的日志定位到这个特殊的输入，那么推荐去生产环境打印内存快照了。需要注意的是，打印内存快照是很耗 CPU 的操作，可能会对线上业务造成影响。 快照工具推荐使用 heapdump 用来保存内存快照，使用 devtool 来查看内存快照。使用 heapdump 保存内存快照时，只会有 Node.js 环境中的对象，不会受到干扰（如果使用 node-inspector 的话，快照中会有前端的变量干扰）。 PS：安装 heapdump 在某些 Node.js 版本上可能出错，建议使用 npm install heapdump -target=Node.js 版本来安装。 打印内存快照将 heapdump 引入代码中，使用 heapdump.writeSnapshot 就可以打印内存快照了了。为了减少正常变量的干扰，可以在打印内存快照之前会调用主动释放内存的 gc() 函数（启动时加上 —expose-gc 参数即可开启）。 12345const heapdump =require('heapdump');const save =function(){ gc(); heapdump.writeSnapshot('./'+Date.now()+'.heapsnapshot');} 在打印线上的代码的时候，建议按照内存增长情况来打印快照。heapdump 可以使用 kill 向程序发送信号来打印内存快照（只在 *nix 系统上提供）。 kill -USR2 &lt;pid&gt; 推荐打印 3 个内存快照，一个是内存泄漏之前的内存快照，一个是少量测试以后的内存快照，还有一个是多次测试以后的内存快照。第一个内存快照作为对比，来查看在测试后有哪些对象增长。在内存泄漏不明显的情况下，可以与大量测试以后的内存快照对比，这样能更容易定位。 对比内存快照找出泄漏位置通过内存快照找到数量不断增加的对象，找到增加对象是被谁给引用，找到问题代码，改正之后就行，具体问题具体分析 1234567891011121314151617const{EventEmitter}=require('events');const heapdump =require('heapdump');global.test =newEventEmitter();heapdump.writeSnapshot('./'+Date.now()+'.heapsnapshot');function run3(){ const innerData =newBuffer(100); onst outClosure3 =function(){ void innerData; }; test.on('error',()=&gt;{ console.log('error'); }); outClosure3();}for(let i =0; i &lt;10; i++){ run3();}gc();heapdump.writeSnapshot('./'+Date.now()+'.heapsnapshot'); 这里是对错误代码的最小重现代码。 首先使用 node —expose-gc index.js 运行代码，将会得到两个内存快照，之后打开 devtool，点击 profile，载入内存快照。打开对比，Delta 会显示对象的变化情况，如果对象 Delta 一直增长，就很有可能是内存泄漏了。 其实这三处对象增长都是一个问题导致的。test 对象中的 error 监听事件中闭包引用了 innerData 对象，导致 buffer 没有被清除，从而导致内存泄漏。其实这里的 error 监听事件中没有引用 innerData 为什么会闭包引用了 innerData 对象，这个问题很是疑惑，后来弄清是 V8 的优化问题，在文末会额外讲解一下。对于对比快照找到问题，得看你对代码的熟悉程度，还有眼力了。","link":"/posts/NodeJS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"title":"React中API使用的正确姿势","text":"惰性初始化statedefaultValue 参数只会在组件的初始渲染中起作⽤，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传⼊⼀个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调⽤： 这种写法可以避免定义多个state时，每次渲染都要执行初始化操作，而用惰性初始化state，可以解决重复初始化的问题。 12345678910111213141516171819202122232425// 每次setInputValue引起的重新渲染进⼊函数组件内defaultValue都会被忽略。const TestInput= (props) =&gt; { const defaultValue = props.value || '请输⼊' const [inputValue,setInputValue] = useState(defaultValue) return ( &lt;div&gt; &lt;input value={inputValue} onChange={(e)=&gt;setInputValue(e.target.value)} /&gt; {in &lt;/div&gt; )}export default TestInput//使⽤函数来解决每次渲染 state 需要通过复杂计算获得的问题const TestInput= (props) =&gt; { const [inputValue,setInputValue] = useState(()=&gt;{ return props.value || '请输⼊' }) return ( &lt;div&gt; &lt;input value={inputValue} onChange={(e)=&gt;setInputValue(e.target.value)} /&gt; {in &lt;/div&gt; )}export default TestInput","link":"/posts/React%E4%B8%ADAPI%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"},{"title":"React条件渲染","text":"参考链接模板条件渲染在开发中常用，什么时候用什么方式？怎么写较好？ 先罗列常见方式: IF/ELSE12345678function render() { if (flag) { return &lt;Component1 /&gt;; } else { return &lt;div /&gt;; }} return null不需要返回可以返回null, 代替空div, 提升效率 12345678function render() { if (flag) { return &lt;Component1 /&gt;; } else { return null; }} 组件变量将组件赋值给变量，可以在return前任意修改 12345678910function render() { let component = null; if (flag) { component = &lt;Component1 /&gt;; } return component;} 三元操作符逻辑不复杂可以避免if else 123function render() { return flag ? &lt;Component1 /&gt; : null;} &amp;&amp;最方便!!! 1234function render() { return flag &amp;&amp; &lt;Component1 /&gt;;} IIFE立即执行函数 12345678910111213141516171819(function myFunction(/* arguments */) { // ...})(/* arguments */);&lt;!-- ？？？什么情况用？？？ --&gt;function render() { return ( &lt;div&gt; {(() =&gt; { if (flag) { return &lt;Component1 /&gt;; } else { return &lt;div /&gt;; } })()} &lt;/div&gt; );} 子组件将一大块的逻辑拆分成子组件 12345678910111213141516function render() { return ( &lt;div&gt; &lt;SubRender /&gt; &lt;/div&gt; );}function SubRender() { if (flag) { return &lt;Component1 /&gt;; } else { return &lt;div /&gt;; }} IF 组件–什么时候用做一个条件渲染组件 IF 代替 js 函数的 if： 1234&lt;If condition={true}&gt; &lt;span&gt;Hi!&lt;/span&gt;&lt;/If&gt; 这个组件实现也很简单 12345678const If = props =&gt; { const condition = props.condition || false; const positive = props.then || null; const negative = props.else || null; return condition ? positive : negative;}; 高阶组件返回一个新组件的函数，并且接收一个组件作为参数在高阶组件里写条件语句，返回不同的组件即可： 12345678910function higherOrderComponent(Component) { return function EnhancedComponent(props) { if (flag) { return &lt;AnotherComponent {...props} /&gt;; } return &lt;Component {...props} /&gt;; };} 理解要不要封装，怎么封装，取决于应用复杂度。 对于任何代码封装，都会增加这段代码连接逻辑的复杂度。 假定无论如何代码的复杂度都是恒定不变的，下面这段代码，连接复杂度为0，而对于render函数而言，逻辑复杂度是100. 1234567function render() { if (flag) { return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;; } else { return &lt;div /&gt;; }} 拆分成两个函数，逻辑复杂度对render, SubComponent来说都是50，但连接复杂度是50: 1234567891011function render() { if (flag) { return &lt;SubComponent/&gt;; } else { return &lt;div/&gt;; }}function SubComponent() { return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;} 可以看到，通过函数拆分，降低了每个函数的逻辑复杂度，却提高了连接复杂度。 假设一个程序员可以一次性轻松记忆10个函数。如果再多，函数之间的调用关系会让人头大。 应用较小时应用较小时，假设共有10个函数，如果做了逻辑抽象，拆分出了10个子函数，那么总逻辑复杂度不变，函数变成20个。 此时，要修改项目，需要找到关键代码的位置。 如果没有做逻辑抽象， 小明可以一下记住10个函数，很快完成需求。 做了逻辑抽象，需要理解的逻辑复杂度是不变的。但要读20个函数，小明需要在线索中不断跳转，还是只找了10个关键函数，但一共就20个函数，逻辑并不复杂，这值得吗？ 这时，会觉得，简单的逻辑，却花了较长的时间找代码。 应用较大时应用较大时，假设有500个函数，不考虑抽象后带来的复用好处，假设都无法复用，那么做逻辑抽象后，总逻辑复杂度不变，函数变成了1000个。 小明接到需求开始维护项目。从一开始没能理解项目的全貌，所以开始一步步探索。 现在有两种选择：一是在未做逻辑抽象时的探索，一是在做过逻辑抽象后的探索。 假设没有做逻辑抽象，小明需面对500个这种函数： 1234567function render() { if (renderComponent) { return isOk ? &lt;Component1 /&gt; : &lt;Component2 /&gt;; } else { return isReady ? &lt;Component3 /&gt; : &lt;Component4 /&gt;; }} 如果做了逻辑抽象，需面对1000个这种函数 1234567function render() { if (renderComponent) { return &lt;Component1And2 /&gt;; } else { return &lt;Component3And4 /&gt;; }} 项目庞大后，总函数数量并不会影响对线索的查找，而总线索深度也几乎总是固定的，一般在5层左右。 小明理解5个或10个函数成本差不多，但没有做逻辑抽象时，这5个函数各自掺杂了其他逻辑，这5个函数各自掺杂了其他逻辑，反而影响对函数的理解。 这时做逻辑抽象是合适的。 总结总的来说，推荐使用子函数，子组件，IF组件，高阶组件做条件渲染，因为这四种方式都能提高程序的抽象能力。 往往抽象后的代码会更具有复用性，单个函数逻辑更清晰，在切面编程时更利于理解。 当项目很简单时，整个项目的理解成本都很低，抽象带来的复杂度反而让项目变成了需要切面编程时就得不偿失了。 总结： 当项目很简单，或条件渲染的逻辑确认无法复用时，推荐在代码中用 &amp;&amp; 或三元运算符、IIFE等直接实现条件渲染。 当项目复杂时，尽量使用子函数，子组件，IF组件，高阶组件等方式做更有抽象度的条件渲染。 在做逻辑抽象时，考虑下项目的复杂度, 避免因为抽象带来的成本增加，让本可以整体理解的项目变得支离破碎。","link":"/posts/React%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"title":"Redis实战读书笔记","text":"相关文档 redis官网 redis中文下载安装 redis中文文档 当你需要以接近实时的速度访问快速变动的数据流时，Redis这样的键值数据库就是你的最佳选择。 安装下载、解压、编译Redis 1234wget http://download.redis.io/releases/redis-5.0.2.tar.gztar xzf redis-5.0.2.tar.gzcd redis-5.0.2make 提示错误 1xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决, 输入以下命令: 1xcode-select --install 回车后，系统弹出下载xcode，点击确认，下载完成后即可。（实际上不是下载xcode，可能下载xcode有关插件，下载时长约1分钟） 在这里发生个有趣的现象，直接拷贝到终端里执行会报错无法识别参数，手动敲了一遍可以执行😶😳😳 启动在redis安装目录下，进入src，执行./redis-server可以看到启动画面 另开一个终端，在同样目录下，执行./redis-cli, 连接成功。 客户端常用命令 命令 版本 set key value 设置 key 的值 get key 获取 key 的值 exists key 查看此 key 是否存在 del key 删除存储在给定键中的值 keys * 查看所有的 key flushall 消除所有的 key Redis与其他软件的相同与不同 Redis是一个远程内存数据库，具有复制特性及未解决问题而升高的独一无二的数据模型。 Redis提供了5种不同类型的数据结构，各种问题都可映射到这些数据结构。 redis简介redis是什么Redis 是一个速度非常快的非关系数据库(non-relational database), 可以存储键(key)与5种不同类型的值之间的映射(mapping), 可以将存储在内存的键值对数据持久化到硬盘，还可以通过复制，持久化和客户端分片等特性，可以将redis扩展成一个能够包含数百GB数据、每秒处理上百万请求的系统。 redis能做什么redis数据结构5种结构|结构类型|存储的值|读写能力||——-|——-|——||string(字符串)|可以是字符串、整数或浮点数|对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或自减操作||list(列表) |一个链表，每个节点都包含一个字符串|从链表两端推入或弹出元素；根据偏移量对链表进行trim;读取单个或多个元素；根据值查找或移除元素||set(集合) |包含字符串的无序收集器(unordered collection), 并且被包含的每个字符串都是独一无二、各不相同的|添加、获取、移除单个元素；检查一个元素是否存在；计算交集，并集，差集；从集合里随机获取元素||hash(散列) |包含键值对的无序散列表|添加、获取移除单个键值对；获取所有键值对||zset(有序集合)|字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列书序有分值大小决定|添加、获取、移除单个元素；根据分值范围(range)或成员来获取元素| string形如: hello: world set, get, del 使用示例 1234set hello worldget hellodel helloget hello 命令返回1表示成功执行， 0表示执行失败 list 列表一个列表结构可以有序的存储多个字符串，列表可以包含相同的元素形如: list-key: [item, item2, item] 列表命令|命令|行为||—|—-||lpush |将元素推入列表左端(left end)||rpush | …右端(right end)||lpop |从列表左端弹出元素||rpop |从右端弹出元素 ||lrange key start stop |获取列表给定范围所有值, 支持负索引, -1表示最右边第一个元素||llen key| 获取列表中元素的个数,时间复杂度为O(1)||lrem key count value| 删除列表中前count个值为value的元素,返回值是实际删除的个数||lindex |获取列表在给定位置的单个元素||lset key index value| 将索引为index的元素赋值为value||ltrim key start end| 删除指定索引范围之外的所有元素||linsert key BEFORE|AFTER pivot value| 从左往右查找值为pivot的元素，根据第二个参数是before还是after来决定将value插入到该元素前面还是后面||rpoplpush source destination| 将元素从一个列表转到另一个列表| 说明: count &gt; 0, lrem从列表左边开始删除前count个值为value的元素count &lt; 0, lrem从列表右边开始删除前count个值为value的元素count = 0, lrem删除所有值为value的元素ltrim和lpush一起使用来限制列表中元素的数量，比如记录日志只保留最近100条，每次加入元素时调用一次ltrim 12lpush logs $newLogsltrim logs 0 99 12345678910111213141516171819lpush numbers 1# 支持同时增加多个元素lpush numbers 2 3# 此时数据为[3, 2, 1]rpush numbers 0 -1# 此时数据为[3, 2, 1, 0, -1]lpop numbers # 3rpop numbers # -1llen numbers # 3lrange numbers 0 -1 # 获取所有元素lremlindex list-key 1 想把列表当栈使用, 用 lpush 和 lpop 或 rpush和 rpop想当队列使用, 用 lpush 和 rpop 或 rpush 和 lpop set 集合集合通过散列表保证自己存储的每个字符串是各不相同的(这些散列表只有键，没有与键相关联的值) 集合与列表对比|对比项|集合|散列||–|—-|—||存储内容|至多2(32)-1个字符串|至多2(32)-1个字符串||有序性|否|是||唯一性|是|否| 集合使用无序(unordered)方式存储元素.形如: setkey: [item, item2, item3] 集合类型在Redis内部是使用值为空的散列表(hash table)实现的 常用操作是加入或删除元素，判断某个元素是否存在等，时间复杂度都是O(1) 多个集合类型键之间还可以进行并集，交集和差集运算 集合命令|命令|行为||—|—-||sadd |将给定元素添加到集合||smembers |返回集合所有元素(慢，慎用)||sismember |检查给定元素是否存在||srem |如果给定元素存在，移除| 12345678910sadd setkey itemsadd setkey item2sadd setkey item3sadd setkey item // 失败smembers setkeysismember setkey item4sismember setkey itemsrem setkey item2srem setkey item2 hash 散列散列可以存储多个键值对之间的映射，和字符串一样，既可以是字符串也可以是数字值，并且可以对散列存储的数字值执行自增自减操作。 散列很多当面像一个微缩版的redis，不少字符串命令都有相应的散列版本。 形如：hashset: [{subkey1: value1},{subkey2: value2},{subkey3: value3},] 散列命令|命令| 行为||—|——||hset |在散列里关联给定的键值对||hget |获取给定散列键的值||hgetall|获取散列所有键值对||hdel |如果键存在，移除| 12345678hset hashkey subkey1 value1hset hashkey subkey2 value2hset hashkey subkey3 value3hgetall hashkeyhdel hashkey subkey2hdel hashkey subkey2hdel hashkey subkey1hgetall hashkey zset 有序集合有序集合和散列一样，都用于存储键值对，有序集合的键值被称为成员(member)，每个成员都是各不相同的；而有序集合的值被称为分值(score)，分值必须为浮点数。有序集合是Redis里唯一一个既可以根据成员访问元素，又可以根据分值及分值的排序顺序来访问元素的结构 有序集合和列表类型区别 相同点: 都是有序的 都可以获得某一范围的元素 不同点: 列表通过链表实现，获取靠近两端的数据速度极快，当元素增多，访问会变慢，所以更适合实现如’新鲜事’或’日志’这样很少访问中间元素的应用 有序集合类型是使用散列表和跳跃表(Skip list)实现的，及时读取中间部分的数据速度也很快(时间复杂度O(log(N))) 列表中不能简单的调整某个元素的位置，但有序集合可以(通过更改这个元素的分数) 有序集合比列表类型更耗内存 有序集合命令 命令 行为 zadd 将带有给定分值的成员添加到有序集合里 zrange 根据元素在有序排列中所处的位置，从有序集合李获取多少个元素 zrangebyscore 获取有序集合在给定分值范围内的所有元素 zrem 如果给定成员存在，移除 1234567891011zadd zsetkey 728 member1zadd zsetkey 928 member0zadd zsetkey 928 member0zrange zsetkey 0 -1 withscoreszrangebyscore zsetkey 0 800 withscoreszrem zsetkey member1zrem zsetkey member1zrange zsetkey 0 -1 withscores","link":"/posts/Redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"VSCode","text":"插件列表 主命令框Command+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下Backspace会进入到Command+P模式 在Command+P下输入&gt;可以进入Command+Shift+P模式 在Command+P窗口下还可以: ○ 文件名 跳转到对应文件 ○ ? 列出当前可执行的动作 ○ ! 显示 Errors或 Warnings，也可以Command+Shift+M ○ : 跳转到行数，也可以Command+G直接进入 ○ @ 跳转到 symbol（搜索变量或者函数），也可以Command+Shift+O直接进入 ○ @ 根据分类跳转 symbol，查找属性或函数，也可以Command+Shift+O后输入:进入 ○ # 根据名字查找 symbol，也可以 Command+T 2.2、常用快捷键2.2.1、编辑器与终端窗口管理同时打开多个Vscode（查看多个项目） Command+Shift+N 打开一个新窗口Command+Shift+W 关闭窗口 同时打开多个编辑器（查看多个文件）Command+N 新建文件Ctrl+Tab 文件之间切换Command+\\ 分割出一个新的编辑器Command+1、Command+2、Command+3左中右 3 个编辑器的快捷键Editor之间的互相切换： Shift + Command + [(]) 2.2.2、工作区的快捷键工作区的显示和隐藏： Command + B工作区和编辑区的切换： Command + shift + E工作区文件资源管理器的文件选择：H/J/K/L代表文件夹折叠(如果不是一个文件夹，将会跳到这个文件所属的文件夹上，以便可以后面折叠整个文件夹)、聚焦下一个文件、聚焦上一个文件、文件夹展开(如果不是一个文件夹，将会在编辑区打开这个文件)打开文件之后需要固定在开启状态下：Command + K + Enter打开调试面板：Command + Shift + D 2.2.3、终端区的快捷键`Ctrl + ``打开终端 主题：winter is comingDracula 主题espresso 主题 这个是左侧黑色，编辑区白色的~~monokai lightsunrisewoolentheme-bluloco-darktheme-bluloco-lightgithub 非常给力 快捷键： ctrl + p 快速打开一个文件ctrl + G 跳转到指定行ctrl + F 在当前文件中搜索ctrl + shift + k 删除当前行 home 跳转到行的开始end 跳转到行的结尾 ctrl + home 跳转到文件的开始ctrl + end 跳转到文件的结尾 ctrl + shift + [ 折叠一个代码块ctrl + shift + ] 展开一个代码块 f3/shift + f3 发现下一处/发现上一处ctrl + D 可以批量选中同一个元素，然后进行变量或方法名的重命名ctrl + shift + o 在当前文件查找一个方法 alt + shift + f 格式化代码 F12 跳转到定义处 ctrl + i 选中当前行 另外，通过路径 File -&gt; Preferences -&gt; Keyboard Shortcuts中的链接，可以打开keybindings.json文件，定义自己的快捷键 例如：定义把所有字符转化为大写/小写，修改文件keybindings.json文件。然后，通过 ctrl+shift+u 快捷键就可以把一个变量修改为大写。通过ctrl+shift+l把大写的变量变成小写。8405da39ed76ac45f91c7ac4261fa687eb7566a2 Settings Sync 同步插件插件：ESLint //js文件规范化HTML CSS Support //html,csshtml css snippets html,css 提示，自动补全 Vetur //vue文件支持vscode-icons 文件前显示图标mithril emmet // zen codingPath AutocompletePHP IntelliSense waka Time //统计写代码时间 自动闭合标签Auto Close Tag颜色变值的实际颜色Color Highlight括号高亮Bracket Pair Colorizer，， markdown preview enhanced 预览markdown非常好Prettier - Code formatter 自动格式化代码 ，可以自动格式化“editor.formatOnSave”: true VS Code 终端字体间距过宽解决办法：终端用VSCode的默认字体，编辑器可以用自定义的字体终端使用的字体不能是等宽字体，否则会出现这样的问题 vscode自动给所有的import改为实际路径而不是相对路径，解决办法自动更新 import 语句的路径 默认用户设置// 启用或禁用在 VS Code 中重命名或移动文件时自动更新 import 语句的路径。可选值有: “prompt” (在每次重命名时提示)、”always” (始终自动更新路径) 和 “never” (从不重命名路径且不要提示)。要求工作区使用高于 2.9 版本的 TypeScript。“typescript.updateImportsOnFileMove.enabled”: “prompt” 如果把这个值改成always，就会自动修改所有的import VS Code setting Sync插件配置经验：按照教程提示按shift+alt+u 会弹出输入框要求输入github中的token，第一次可以输入如果输入错误，再次按快捷键会不断提示token过期或错误。 解决办法: 找到settings.json文件同目录下的syncLocalSettings.json查找办法，鼠标放到setting.json的打开标签上会显示文件目录，右键可打开所在目录。C:\\Users\\zhaojianpeng3\\AppData\\Roaming\\Code\\User 修改文件中的token为github中对应的token，保存文件。重新按快捷键即可启用。","link":"/posts/VSCode/"},{"title":"Vue理论","text":"前端理论Vue.js 优势主要是基于以下几个方面的考虑。 体积：19kB（min+gzip） API 和学习成本： 声明式组件模板和分离样式表，更接近于传统开发模式，抵触心理小。 响应式的组件状态跟踪：更新状态代码更简洁，组件树重新渲染效率更高。 清晰简洁的生命周期钩子函数和单向数据流：页面逻辑和状态更新更可控。 运行时报错和告警详细：方便新手入门和规避常见错误。 工具链完整性：webpackLoader（加载 Vue 单文件组件）、开发者工具（DevTools）、脚手架（vue-cli）、单元测试友好（vue-test-utils）。 运行时性能： VirtualDOM 来管理组件树渲染到真实 DOM 的状态同步，使用高效的算法来最小化 DOM 操作的次数。 由于响应式设计，不需要优化组件树再次渲染的范围。 组件树静态部分被单独处理，重新渲染不需要重新构建。 同构渲染： 高性能、开箱即用的方案，包括前后端可用的路由和状态管理组件，降低了使用的门槛。 深度 webpack 集成，简化了代码分割和构建调试流程。 前后端分离：前端拥有完整独立的开发、测试、部署的流程，与后端完全分离，减少沟通成本。 模块化与组件化：封装可重用 UI 组件、业务逻辑，提升代码库的可复用性、可测试性。 流程自动化：提升效率、避免重复手工工作、保证质量、自动资源优化等等。 页面加载性能优化：建立前端监控体系、优化资源加载、使用离线化策略。 前后端分离的关键点在于前端拥有完整独立的开发、测试、部署的流程，与后端完全分离1234在赫尔墨斯项目中，我们把页面的组装完全放置到了前端项目，后端只提供AJAX 的接口用于获取和提交数据。前端页面完全静态化，构建完毕之后连同相应的静态资源通过 CI 直接发布到 CDN 模块化模块化开发的优势主要有以下几个方面。 更好的代码组织结构和开发协作：通过细致的文件夹、文件拆分，更易于管理复杂的代码库，更易于多人协作开发，降低文件合并时候冲突的发生概率，方便编写单元测试。 依赖管理：不再需要手动管理脚本的加载顺序。 优化： 代码打包（Bundle）：合并小模块，抽取公共模块，在资源请求数和浏览器缓存利用方面进行合适的取舍。 代码分割（Split）：允许按需加载 JS 代码（分路由、异步组件），解决单页面应用（SPA）首屏加载速度问题。 Tree Shaking：利用 ES6 模块的静态化特性，可以在构建过程中分析出代码库中未使用到的代码，从最终的 bundle 中去除，从而减少 JS●Bundle 的尺寸。 Scope Hoisting：ES6 模块内容导入和导出绑定是活动的，可以将多个小模块合并到一个函数当中，对于重复变量名进行合适的重命名，从而减少Bundle 的尺寸和提升加载速度。 组件化模块化是解决如何封装和复用一段逻辑代码的话，组件化要解决的是如何封装和复用一个用户界面元素，例如，一个按钮、一个弹出框，亦或是一个轮播图。 页面 = 静态页面(树 + 节点描述 + 数据) + 功能逻辑技术领域有一个软件设计范式：==“约定大于配置”==，旨在减少 软件开发人员需要做决定的数量，做到简单而又不失灵活。在插件编写过程中开发者应多注意使用场景和性能的有机结合，使用恰当的语法，尽可能减少开发者的配●置，不求迎合各个场景。 webView性能优化所以与浏览器不同，App 中打开 WebView 的第一步并不是建立连接，而是启动浏览器内核。 WebView 初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。 后端处理慢，可以让服务器分 trunk 输出，在后端计算的同时前端也加载网络静态资源。 脚本执行慢，就让脚本在最后运行，不阻塞页面解析。 同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。 WebView 初始化慢，就随时初始化好一个 WebView 待用。 DNS 和链接慢，想办法复用客户端使用的域名和链接。 脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。","link":"/posts/Vue%E7%90%86%E8%AE%BA/"},{"title":"antDesign","text":"记录踩过的坑数组必须要key的解决办法 由于有些数据没有唯一key值。需要自行添加 12345678910111213var localCounter = 1;this.data.forEach(el=&gt;{ el.id = localCounter++;});//向数组中动态添加元素时，function createUser(user) { return { ...user, id: localCounter++ }} 动态路由，传参获取参数定义路由 123'/coupons/relateProducts/:couponBatchId': { component: dynamicWrapper(app, ['coupons'], () =&gt; import('../routes/Coupons/RelateProducts'))}, 在组件中获取 1this.props.match.params.couponBatchId 路由跳转多级对象setState可以单独取出来，修改后再整体放进去 一个组件是modal，打开就查询一次，在哪执行查询在componentWillReceiveProps里 1234567componentWillReceiveProps(nextProps){ // 这里的nextProps为修改后的状态值 用this.props可以获取到修改之前的props 通过this.props和nextProps两者对比可以看是否需要更新和操作} componentwillreceiveprops会自动接收参数，导致页面不断渲染需要配合this.props使用componentDidMount不会触发 lodash.has select 用setFieldsValue赋值，类型要一样，数字就是数字，字符串就是字符串，才能正常显示form表单重置按钮123handleReset = () =&gt; { this.props.form.resetFields();} Select 组件使用Select 赋值，用this.props.form.setFieldsValues(); select动态赋值给select。，只显示value，没显示label，显示label无法提交类型要匹配，数字就是数字，字符串就是字符串 a元素绑定事件给a绑定事件，一定要这样绑 1234 &lt;a onClick={e =&gt; this.showDetail(record.key)}&gt;详情&lt;/a&gt;handleMouseOver = (key) =&gt; (e) =&gt; { this.setState({ display: key })} 写了models一定要在common的router.js中getRouterData的dynamicWrapper中引入文件夹名字，才能自动引入到app._models中 service 中的api要添加request. models中要添加reducer， 在页面中要用redux定义好的state，需要在connect中引入@connect(({loading, coupons}) =&gt; ({ data: coupons,})) action调用成功后，在reducer里改了状态， 打印出来发生变化了，但页面没变化。 在div中写的可以变化，在input或textarea中不会发生变化。 加了mapPropsToFields后，修改的值回响应到textarea上， 但所有输入框输入的值被清空了 不想用redux，直接用组件里的state，怎么搞？ 在dispatch后添加callback.直接用 this.props.form.setFieldsValue({ uids: payload.data.join()}); 一个页面多个form，点击每个form的提交，其他form的字段会跟着提交 1Form的FormItem如果是rangePicker，则设置`style={{width:100%}}`，可以让输入框响应容器 Form的label和input输入框的宽度通过调节labelCol，wrapperCol来设置，总长度为24 啊啊啊啊大经验啊！！！！ nginx的proxy配置一定要前后路径一致 'POST /coupon/v1/(.*)': '&lt;http://10.64.38.89:8081/coupon/v1/',&gt; 前面是coupon/v1后面也一定是coupon/v1,不能前面是coupon 后面是coupon/v1项目一定要放在www目录下","link":"/posts/antDesign/"},{"title":"axios积累","text":"使用axios在url后统一加参数遇到的问题如果是get请求，直接加在url后面 https://www.baidu.com?a=1&amp;b=2 如果要get, post, put都加呢？ 123456789101112131415const data = { ...params, a: 1, b: 2}axios.get(url, { params: data,})axios.post(url, { params: data,})axios.put(url, { params: data,}) 注意: 如果在url和post的data中都加同样参数的话，有的后端服务会报错，无法正常解析。 axios在data中添加参数后，会根据get，post不同请求方法，选择不同的参数拼接方式. get: 加到url后，post, put加到post的data中。 综上: 添加url参数可以根据具体需求选择直接加在url后还是加到data中。","link":"/posts/axios%E7%A7%AF%E7%B4%AF/"},{"title":"canvas实战","text":"CANVAS游戏实战思路 绘图基础 添加图形、图片、设置颜色 动起来 画布定时重绘 加入键盘鼠标控制 可操控 动画框架PixiJS","link":"/posts/canvas%E5%AE%9E%E6%88%98/"},{"title":"centos安装git","text":"centos安装git安装yum install -y git 检查版本git –version 生成公钥并复制到服务器上生成公钥ssh-keygen -t rsa 查看公钥cat .ssh/id_rsa.pub 复制id_rsa.pub里的公钥到服务器上的authorized_keys文件拷贝出来，复制到github.com的settings的SSH and GPG keys中 安装nodejsyum install -y nodejs//行不通，版本太旧了 参考：http://wiki.jikexueyuan.com/project/nodejs-guide/install.html 卸载yum remove nodejs -y 正确方法1.确保系统下 g++ 版本在 4.6 以上，python 版本在 2.6 以上。 2.从 nodejs.org 下载 tar.gz 后缀的 NodeJS 最新版源代码包并解压到某个位置。 wget https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz 3.进入解压到的目录，使用以下命令编译和安装。 1234tar -zvxf node-v4.5.0.tar.gz./configuremakesudo make install","link":"/posts/centos%E5%AE%89%E8%A3%85git/"},{"title":"h5开发积累","text":"图片切图高度750*1334 h5滚动画布插件 scroller animateJs TweenJS pixi.js H5 要考虑的因素:. 屏幕旋转自动适配元素根据屏幕确定位置 网易(^o^)/~ h5总网站 睡姿大比拼—加密 滑向童年 不是pixi jquery实现的 pixi 学习资料官网例子声音插件都可以在npm中找到 手机端video标签不能自动显示封面，需设置poster 遗留问题 微信里面的音乐不能自动播放，如果用dom的自动播放，浏览器里的又不能自动播放。网易也是选择一种实现的。 图片虚化，原因：最外层容器缩小了0.5，导致所有素材缩小0.5.但这不是虚化的原因，因为其他网页也是这样虚化的。","link":"/posts/h5%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/posts/hello-world/"},{"title":"iTerm2完美的终端体验","text":"[TOC] mac 自带的终端实在是差劲，改用 iTerm2 可以 6 到飞起~~~ 安装直接下载安装即可。 安装oh-my-zsh安装方法由于会经常更新，请点击链接跳转查看安装办法 配置主题修改 ZSH_THEME=”主题名” 打开配置文件 1vi ~/.zshrc 找到如下配置ZSH_THEME=”robbyrussell”修改为ZSH_THEME=”ys” 可以根据自己喜好选择不同的主题 主题配置库 代码高亮(zsh-syntax-highlighting)安装方法详见链接 自动提示命令(zsh-autosuggestions)安装方法详见链接 自动切换目录(autojump)1brew install autojump 根据提示将以下内容添加到~/.zshrc 1[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh 刚开始装了不会有效果，需多进几个目录，就可以看到效果 快捷键 j按 tab 可以选择下拉里提示的内容 权重值越高，优先级越高要调整某个目录的优先级，需要先进入到文件目录下，进行调整 常用命令1234567891011# 显示数据库中的统计数据, (前面的数字是权重值)j -s# 增加某个目录的权重j -i 10# 降低某个目录权重j -d 10# 清除无用数据j --purge 使用中发现的问题如果两个目录后面的文件夹名相同，例如/home/abc/de和/home/de，权重级别不一样，直接用j de不会每次都跳转到权重高的目录，如果不是想要的可以再次执行j de即可 homebrew 更新1brew update 在安装一些软件时，会遇到 updating homebrew 卡住的问题，这时 control+c 断开，执行 brew update. 会成功更新。 网上还有说法是更换 brew 镜像源—没试过。 启动问候语设置123456cd /etcsudo pico motd输入密码后输入问候语按control+x退出，按y确认， 按回车确认，用 y保存退出，再 y一次确认文件名motd 打开新标签页，即可看到提示语 安装 iTerm2 后替换为系统自带的 bash打开 iTerm2-&gt;prefrences-&gt;profiles-command选择 command 输入/bin/bash即可 12345# 修改iterm 默认程序chsh -s /bin/zsh# 恢复原来的bashchsh -s /bin/bash 常用快捷键12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 打开新标签command+t# 关闭标签command+w# 同一个Tab内的分屏切换Command + [# Tab之间的切换Command + 数字# 垂直切分窗口command+d# 水平切分窗口command+shift+d# 复制窗口左上角shell-&gt;duplicate Tab 以当前路径下打开新的窗口# 进入与返回全屏模式command+enter# 保存当前快照Window &gt; Save Window Arrangement.# 恢复快照：Window &gt; Restore Window Arrangement可以在Preferences &gt; General &gt; Open saved window arrangement.设置自动恢复快照# 从终端进入Finder进入某个目录open .# Finder 进终端直接拖拽# 查看历史命令command + ;# 查看剪贴板历史command + shift + h# 命令搜索Ctrl + r# 清除当前行命令Ctrl + u# 跳转到行首Ctrl + a# 跳转到行尾Ctrl + e 自动补全插件 incr —如果提示多了会卡的很严重，曾经用过，后来替换成 zsh-autosuggestions下载此插件： 12345678wget http://mimosa-pudica.net/src/incr-0.2.zsh# 将此插件放到oh-my-zsh目录的插件库下：# 在~/.zshrc文件末尾加上source ~/.oh-my-zsh/plugins/incr/incr*.zsh# 更新配置source ~/.zshrc 命令参数提示举个栗子，之前偶尔需要用到删除文件夹的操作，rm -r [path]，但是常常会忘记中间的参数是什么，现在我只需要这么做： 12345# 输入 rm - ， 然后按tabrm --R -r -- remove directories and their contents recursively-f -- ignore nonexistent files, never prompt-i -- prompt before every removal git 快捷键插件git.plugin.zsh地址 12cd ~/.oh-my-zsh/plugins/gitless git.plugin.zsh 在这里可以看到常用的git命令别名 官方插件列表看别人在用的插件 fasd history 常用命令12345# 查看当前所用的 Shellecho $SHELL# 查看系统内已安装的 Shellcat /etc/shells iterm中git status 显示字符，不显示中文 解决方法：在命令行执行命令 1git config --global core.quotepath false rz/sz上传下载文件 安装lrzsz brew install lrzsz 下载配置iTerm2的相关脚本 脚本地址 在/usr/local/bin目录下直接执行： wget https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh https://raw.githubusercontent.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh 赋予可执行权限 chmod +x /usr/local/bin/iterm2-send-zmodem.sh /usr/local/bin/iterm2-recv-zmodem.sh 配置ITerm2 Term2的配置项：iTerm2的Preferences-&gt; Profiles -&gt; Default -&gt; Advanced -&gt; Triggers的Edit按钮。 然后配置项如下： Regular Expression Action Parameters Instant rz waiting to receive.\\\\B0100 Run Silent Coprocess /usr/local/bin/iterm2-send-zmodem.sh checked \\\\B00000000000000 Run Silent Coprocess /usr/local/bin/iterm2-recv-zmodem.sh checked 注意最后一项需要你将Instant选项勾上，否则将不生效","link":"/posts/iTerm2%E5%AE%8C%E7%BE%8E%E7%9A%84%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C/"},{"title":"jQuery插件思路整理","text":"jQuery插件的封装123(function($){ // do something})(jQuery); 闭包的作用–避免全局依赖–避免第三方破坏–兼容jQuery操作符‘$’和jQuery 开发方式 类级别组件开发 即给jQuery命名空间下添加新的全局函数，也称静态方法。 123jQuery.myPlugin = function(){ // do something}; 例如：$.ajax,$.extend() 对象级别组件开发 即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法, 也称动态方法。 123$.fn.myPlugin = function(){ // do something}; 这里 $.fn === $.prototype例如：addClass()、attr() 等，需要创建实例来调用 链式调用eg: $(&quot;div&quot;).next().addClass() 12345$.fn.myPlugin = function(){ return this.each(function(){ // do something });}; 代码说明： return this 返回当前对象，来维护插件的链式调用 each 循环实现每个元素的访问 单例模式 1234567$.fn.myPlugin = function(){ var me = $(this), instance = me.data(&quot;myPlugin&quot;); if (!instance) { me.data(&quot;myPlugin&quot;,(instance= new Plugin())); }}; 代码说明：-如果实例存在则不再重新创建实例-利用data()来存放插件对象的实例 jQuery插件的开发包括两种：一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。1、类级别的插件开发类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：1.1 添加一个新的全局函数添加一个全局函数，我们只需如下定义：Java代码 jQuery.foo = function() {alert(‘This is a test. This is only a test.’);}; 1.2 增加多个全局函数添加多个全局函数，可采用如下定义：Java代码 jQuery.foo = function() {alert(‘This is a test. This is only a test.’);};jQuery.bar = function(param) {alert(‘This function takes a parameter, which is “‘ + param + ‘“.’);};调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar(‘bar’);1.3 使用jQuery.extend(object);Java代码 jQuery.extend({foo: function() {alert(‘This is a test. This is only a test.’);},bar: function(param) {alert(‘This function takes a parameter, which is “‘ + param +’”.’);}}); 1.4 使用命名空间虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。Java代码 jQuery.myPlugin = {foo:function() {alert(‘This is a test. This is only a test.’);},bar:function(param) {alert(‘This function takes a parameter, which is “‘ + param + ‘“.’);}};采用命名空间的函数仍然是全局函数，调用时采用的方法：$.myPlugin.foo();$.myPlugin.bar(‘baz’); 通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。2、对象级别的插件开发对象级别的插件开发需要如下的两种形式：、形式1：Java代码 (function($){$.fn.extend({pluginName:function(opt,callback){ // Our plugin implementation code goes here.}})})(jQuery);形式2：Java代码 (function($) {$.fn.pluginName = function() { // Our plugin implementation code goes here.};})(jQuery); 上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突.2.1 在JQuery名称空间下申明一个名字这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和$.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“ Java代码 $.fn.hilight = function() { // Our plugin implementation code goes here.};我们的插件通过这样被调用：$(‘#myDiv’).hilight(); 但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易或更易读的实现；而且这样更符合面向对象。 这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样，函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们需要暴露出来的，都可以在”hilight” 函数中被声明属性。稍后继续。2.2 接受options参数以控制插件的行为让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给插件函数。例如：Java代码 // plugin definition$.fn.hilight = function(options) { var defaults = { foreground: ‘red’, background: ‘yellow’ }; // Extend our default options with those provided. var opts = $.extend(defaults, options); // Our plugin implementation code goes here.};我们的插件可以这样被调用：$(‘#myDiv’).hilight({ foreground: ‘blue’}); 2.3 暴露插件的默认设置我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖和修改插件。接下来我们开始利用函数对象。 Java代码 // plugin definition$.fn.hilight = function(options) { // Extend our default options with those provided. // Note that the first arg to extend is an empty object - // this is to keep from overriding our “defaults” object. var opts = $.extend({}, $.fn.hilight.defaults, options); // Our plugin implementation code goes here.};// plugin defaults - added as a property on our plugin function$.fn.hilight.defaults = { foreground: ‘red’, background: ‘yellow’};现在使用者可以包含像这样的一行在他们的脚本里：//这个只需要调用一次，且不一定要在ready块中调用$.fn.hilight.defaults.foreground = ‘blue’;接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色：$(‘#myDiv’).hilight(); 如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的覆盖这些新的默认值：// 覆盖插件缺省的背景颜色$.fn.hilight.defaults.foreground = ‘blue’;// …// 使用一个新的缺省设置调用插件$(‘.hilightDiv’).hilight();// …// 通过传递配置参数给插件方法来覆盖缺省设置$(‘#green’).hilight({ foreground: ‘green’});2.4 适当的暴露一些函数这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如，我们插件的实现里面可以定义一个名叫”format”的函数来格式化高亮文本。我们的插件现在看起来像这样，默认的format方法的实现部分在hiligth函数下面。Java代码 // plugin definition$.fn.hilight = function(options) { // iterate and reformat each matched element return this.each(function() { var $this = $(this); // … var markup = $this.html(); // call our format function markup = $.fn.hilight.format(markup); $this.html(markup); });};// define our format function$.fn.hilight.format = function(txt) {return ‘‘ + txt + ‘‘;}; 我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。 考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用者暴露”transitions”对象，使他们添加自己变换定义。插件中定义就像这样：$.fn.cycle.transitions = {// …};这个技巧使其他人能定义和传递变换设置到Cycle插件。2.5 保持私有函数的私有性这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯定是否暴露特定的函数，那么你也许不需要那样做。那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。Java代码 (function($) { // plugin definition $.fn.hilight = function(options) { debug(this); // … }; // private function for debugging function debug($obj) { if (window.console &amp;&amp; window.console.log) window.console.log(‘hilight selection count: ‘ + $obj.size()); };// …})(jQuery); 我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。2.6 支持Metadata插件在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个Metadata插件，因为它让你使用不多的”markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它非常简单。更新：注释中有一点优化建议。Java代码 $.fn.hilight = function(options) { // … // build main options before element iteration var opts = $.extend({}, $.fn.hilight.defaults, options); return this.each(function() { var $this = $(this); // build element specific options var o = $.meta ? $.extend({}, opts, $this.data()) : opts; //… 这些变动行做了一些事情：它是测试Metadata插件是否被安装如果它被安装了，它能扩展我们的options对象通过抽取元数据这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从”markup”处驱动行为,如果我们选择了“markup”： 调用的时候可以这样写： jQuery.foo(); 或 $.foo(); Java代码 Have a nice day! Have a nice day! Have a nice day! 现在我们能高亮哪些div仅使用一行脚本： $('.hilight').hilight(); 2.7 整合下面使我们的例子完成后的代码： Java代码 // 创建一个闭包(function($) { // 插件的定义 $.fn.hilight = function(options) { debug(this); // build main options before element iteration var opts = $.extend({}, $.fn.hilight.defaults, options); // iterate and reformat each matched element return this.each(function() { $this = $(this); // build element specific options var o = $.meta ? $.extend({}, opts, $this.data()) : opts; // update element styles $this.css({ backgroundColor: o.background, color: o.foreground }); var markup = $this.html(); // call our format function markup = $.fn.hilight.format(markup); $this.html(markup); }); }; // 私有函数：debugging function debug($obj) { if (window.console &amp;&amp; window.console.log) window.console.log(‘hilight selection count: ‘ + $obj.size()); }; // 定义暴露format函数 $.fn.hilight.format = function(txt) { return ‘‘ + txt + ‘‘; }; // 插件的defaults $.fn.hilight.defaults = { foreground: ‘red’, background: ‘yellow’ };// 闭包结束})(jQuery); 这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。3、总结jQuery为开发插件提拱了两个方法，分别是：jQuery.fn.extend(object); 给jQuery对象添加方法。jQuery.extend(object); 为扩展jQuery类本身.为类添加新的方法。3.1 jQuery.fn.extend(object);fn 是什么东西呢。查看jQuery代码，就不难发现。jQuery.fn = jQuery.prototype = {init: function( selector, context ) {//….//……};原来 jQuery.fn = jQuery.prototype.对prototype肯定不会陌生啦。虽然 javascript 没有明确的类的概念，但是用类来理解它，会更方便。jQuery便是一个封装得非常好的类，比如我们用 语句 $(“#btn1”) 会生成一个 jQuery类的实例。jQuery.fn.extend(object); 对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这么做：$.fn.extend({ alertWhileClick:function(){ $(this).click(function(){ alert($(this).val()); }); }});$(“#input1”).alertWhileClick(); //页面上为：$(“#input1”) 为一个jQuery实例，当它调用成员方法 alertWhileClick后，便实现了扩展，每次被点击时它会先弹出目前编辑里的内容。3.2 jQuery.extend(object);为jQuery类添加添加类方法，可以理解为添加静态方法。如：$.extend({ add:function(a,b){return a+b;}});便为 jQuery 添加一个为 add 的 “静态方法”，之后便可以在引入 jQuery 的地方，使用这个方法了，$.add(3,4); //return 7","link":"/posts/jQuery%E6%8F%92%E4%BB%B6%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/"},{"title":"java基础","text":"String是复合类型，int ,float 是基本类型 复合类型是对象类型，对象自己提供了比较方法 12String a = &quot;A&quot;; String b = a+&quot;&quot;;System.out.println(a==b);-----------false; 串与子串substring(begin,end) 包含begin，不含end，半开区间[begin,end); 进制转换 Integer.parseInt(串,进制) Integer.toString(整数,进制) Integer.toBinaryString(数值) Integer.toHexString(数值) 时间计算long a = 365L2460601000 ———-转为long型，自动向long型转换long a = (long)……long a = 1L*……————-非侵入式 类型转换 自动向高级别转换 byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double 无需特殊需要，尽量使用int 构造 初始化一个对象的时候对他进行一次初生的洗礼，设置一些初始值。 123456789101112131415161718192021class Age{ public Age(){//没有返回值。没有void比有void更牛。构造方法也可以有多个。 多种出生方式， 只选择一种 没有提供构造方法，默认提供一种，当提供了以后，需要提供一个默认的。 重载 overload 名字相同，但参数不同，（个数，类型） //成员数据(字段)的初始化 x=1;}public Age(int type) { if(type==1) x==1; else if(type==2) x==18; else x =1;}}Class B { public B(int x ){} public B(){}} 堆栈，一般指栈。 定义数组 1234int[] a = [3,7,9,5];int[] a = new int[4];//默认为0int[] a = null;a =new int[][2,6,8]; 斐波那契数列 1，1，2，3，5，8，18，21 123456789101112131415int a = 1;int b =1;for(int i=3;i&lt;=30;i++){ int c = a+b; System.out.println(c); a= b; b= c;}int[] a = new int[30];a[0] = 1;a[1] = 1;for(int i=2;i&lt;a.length;i++){ a[i] = a[i-1]+a[i-2]; System.out.println(a[i]);}int[][] a = {{2,9,4},{7,5,3},{6,1,8}}; 传递的参数最大为8字节，实际上java不可能传递对象，至多，java传递对象的引用。 数组的应用 12String s = &quot;1234567&quot;;char[] cc = s.toCharArray(); 数组弱点 1.大小固定，不能扩展 2.在数组中插入、删除元素操作复杂动态数组–Vector ArrayList. 任意位置插入，删除容易 可以动态增长 随机访问比数组慢 this this是隐藏的形参变量，是一个地址值(对象内存中地址)，是栈变量 形式参数的值从实参拷贝过来 static 构造方法不适合 构造方法在每次创建对象的时候，自动执行 不创建对象，构造方法就没有机会执行 static块在类加载入内存时执行一次 仅仅执行一次，不会反复执行 与类同时存在 继承 封装是基础，继承是桥梁，多态是华彩乐章 继承的目的，重用代码，为多态铺平代码 java采用接口代替多继承 java类只能继承一个类，但可以实现多个接口 方法覆盖 子类与父类中同名的方法 重载 重载是编译时可以区分的 覆盖是在运行时决定调用哪个方法 覆盖是多态的基础 泛化 对象不发生变化，只是指针发生变化 是指针引用的泛化，并不是对象的泛化，并不是类的泛化 多态 意义 很牛！！！ 多态，泛化 final 惯用法 静态常量 用来定义若干个选项，增加可读性 异常控制 把异常的发现和处理分离 分工 专门的人做专门的事 生产不断社会化的过程。 设计与编码分离 功能和实现分离 错误的发现和控制分离 异常处理 123456789// 1try{// 2//出异常 }catch{// 3}finally{// 4} 执行顺序: 1243 重定向 追加输出到&lt;导入 抽象方法，有一个抽象方法就是抽象类abstract松耦合的秘诀 内部类对象 外部类对象不存在无法创建内部类对象 外部类对象.new 内部类() 匿名对象类 匿名对象 ：对象只用了一次 匿名类 想临时创建实现某个接口类，只用一次，不值得命名 继承类是临时的 对象，继承类所创建的对象是临时的；继承类所创建对象需要多次使用，注意泛化。 编译javac -classpath d:\\abc\\xyz A.java命令行选项，编译选项可以简写成-cp寻找class文件 javac.exe所在位置的相对位置 -classpath参数所指定的位置 classpath环境变量所声称的位置 打包jar.exe 能处理打包和解包的工作 jar -cvf A.java 文档自动化 javadoc -d 文档位置 xx.java javadoc -d 文档位置 -encoding utf-8 制定编码方式 12345678910111213141516171819@param x 参数的描述@return 返回值的描述@exception 可能抛出的异常@see 参见其他模块@version 版本号@author 作者/***我的文档自动化示例类&lt;br&gt;*第二行 x&lt;sup&gt;2&lt;/sup&gt;+Y&lt;sup&gt;2&lt;/sup&gt;*/public class A{ /** *在数组中处理查找整数，返回位置 */ public init search(int[] x,int a ){ }} android 开发环境搭建经验积累 Android Studio中显示：HAX is not working and emulator runs in emulation mode时，去Tools-&gt;Android-&gt;SDK Manager然后选中Extras-&gt;Intel X86 Emulator Accelerator (HAXM installer)并安装即可。记得如果HAX效果没生效，则试试重启Android Studio试试，或许就可以了。相对来说：和之前的Eclipse+ADT时代，要先后自己手动下载HAX相关工具并安装和配置，的做法相比，Android Studio中只需要选中并安装即可搞定，要方便多了。","link":"/posts/java%E5%9F%BA%E7%A1%80/"},{"title":"js 定时器","text":"一、定时器setTimeout: 设置一个定时器，在定时器到期后，执行一段代码或代码段123var timeoutId = window.setTimeout(func[, delay, param1, param2, ... ]);var timeoutId = window.setTimeout(code[, delay]); timeoutId: 定时器ID func: 延迟执行的函数 code: 延迟执行的代码字符串，不推荐使用，原理类似eval delay: 延迟的时间(单位：毫秒)，默认值0 param1, param2: 向延迟函数传递的参数。 setInterval: 以固定时间间隔重复调用一个函数或代码段12var intervalId = window.setInterval(func, delay[, param1, param2, ...]);var intervalId = window.setInterval(code, delay); intarvalId: 重复操作的ID func: 延迟调用的函数 code: 代码段 delay: 延迟时间，没有默认值 setImmediate： 在浏览器完全结束当前运行的操作之后立即执行指定的函数(仅IE10和Node0.10+实现)，类似setTimeout(func, 0)setImmediate设计来是为保证让代码在下一次事件循环执行，以前setTimeout(0)这种不可靠的方式可以丢掉了。 123456789101112var immediateId = setImmediate(func[, param1, param2, ...]);var immediateId = setImmediate(func);(function testSetImmediate() { const label = 'setImmediate'; console.time(label); setImmediate(() =&gt; { console.timeEnd(label); });})(); immediateId: 定时器ID func: 回调 requestAnimationFrame: 帧动画的API,根据浏览器的刷新频率而定1var requestId = window.requestAnimationFrame(func); func: 回调 Promisees6中的异步模型。在setTimeout(0), setImmediate,requestAnimationFrame和Promise中，Promise优先级最高。 1234567891011121314151617181920212223function testSetImmediate() { const label = 'setImmediate'; console.time(label); setImmediate(() =&gt; { console.timeEnd(label); });}function testPromise() { const label = 'Promise'; console.time(label); new Promise((resolve, reject) =&gt; { resolve(); }).then(() =&gt; { console.timeEnd(label); });}testSetImmediate();testPromise(); 尽管setImmediated 先注册，Promise先执行 process.nextTick是Nodejs中的API，比Promise更早执行 事实上，Promise不会进入异步队列，而是直接在主线程队列尾强插一个任务，虽然不会阻塞主线程，但会阻塞异步任务的执行。如果有嵌套的process.nextTick，那异步任务就永远没机会被执行到了。使用的时候要谨慎。但Vue中的nextTick是这个实现的吗？？？ 二、 show me the code基本用法12345678910111213141516171819var intervalId, timeoutId;timeoutId = setTimeout(function(){ console.log(1);}, 300);setTimeout(function(){ clearTimeout(timeoutId); console.log(2);}, 100);setTimeout('console.log(5)', 400);intervalId = setInterval(function(){ console.log(4); clearInterval(intervalId);}, 200);// 分别输出2,4,5 setInterval 和setTimeout 的区别1234567891011121314151617181920212223242526272829303132333435363738394041424344setTimeout(function(){ console.log('timeout');}, 1000);setInterval(function(){ console.log('interval');}, 1000);// 输出一次timeout，每隔1s输出一次interval/*****-------------------***///通过setTimeout模拟setInterval和setInterval的区别var callback = function(){ if (times++ &gt; max) { clearTimeout(timeoutId); clearInterval(intervalId); } console.log('start', Date.now() - start); for(var i=0; i&lt; 990000000; i++){} console.log('end', Date.now() - start);},delay = 100,times = 0,max = 5,start = Date.now(),intervalId,timeoutId;function imitateInterval(fn, delay) { timeoutId = setTimeout(function(){ fn(); if(times &lt;= max) { imitateInterval(fn, delay); } }, delay);}imitateInterval(callback, delay);intervalId = setInterval(callback, delay); setTimeout 和setInterval 仅在执行次数上有区别：setTimeout只执行一次，setInterval执行n次。 通过setTimeout模拟的setInterval与setInterval的区别在于： setTimeout只在回调完成之后才回去调用下一次定时器， 而setInterval不管回调函数执行情况，到达规定时间就会在事件队列中插入一个执行回调的事件，所以，用setInterval时要谨慎，比如发送请求失败，会造成死链堆积。 show me what you can do12345678910111213141516171819202122232425262728293031323334353637383940//题目1var t = true;setTimeout(function(){ t = false;}, 1000);while(t){}alert('end');/**----------------------*/// 题目2for(var i=0; i&lt;5; i++){ setTimeout(function(){ console.log(i); }, 0);}/**----------------------*/// 题目3var obj = { msg: 'obj', shout: function (){ alert(this.msg); }, waitAndShout: function(){ setTimeout(function (){ this.shout(); }, 0); }};obj.waitAndShout(); The truth 第一题： alert永远不会执行，因为js是单线程，且定时器的回调在等待当前正在执行的任务完成后才执行，而while(true){}进入死循环一直占用线程，不给回调函数执行机会 第二题 输出55555. 当i=0时，生成一个定时器，将回调插入事件队列中，等待当前队列无任务执行再执行。此时for循环正在执行，回调被搁置。当for循环执行完成后，队列中有5个回调函数，都执行console.log(i),因为当前js没有使用块级作用域，所以i的值在for循环结束后一直为5，输出5个5. 第三题 报错：Uncaught TypeError: this.shout is not a functionsetTimeout()调用的代码运行在与所在函数完全分离的执行环境上，导致代码中的this指向window(或全局)对象，window对象不存在shout方法，所以报错。 修改方案 1234567891011121314var obj = { msg: 'obj', shout: function () { alert(this.msg); }, waitAndShout: function() { var self = this; // 这里将this赋给一个变量 setTimeout(function () { self.shout(); }, 0); }};obj.waitAndShout(); 需要注意 JS引擎基于事件循环，只有一个线程，会强制异步事件排队执行 如果setInterval的回调执行时间长于指定的延迟，setInterval将无间隔的一个接一个执行 this的指向问题可以通过bind函数，定义变量，箭头函数的方式解决。 多个定时器如不及时清除，会存在干扰，是延迟时间捉摸不透。所以不管定时器有没有执行完，及时清除已经不需要的定时器是个好习惯。 如果setTimeout和setInterval都在延迟100ms之后执行，那么谁先注册谁就先执行回调函数。 JavaScript定时器与执行机制解析参考","link":"/posts/js-%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"title":"js-组合函数","text":"概念compose函数，会接收若干个函数作为参数，每个函数执行后的输出作为下一个函数的输出，直至最后一个函数的输出作为最终的结果。 show code~~~ 123456789let n = '3.56';let data = parseFloat(n);let result = Math.round(data); // =&gt; 最终结果 4// 用 组合函数let n = '3.56';let number = compose(Math.round,parseFloat);let result = number(n); // =&gt;4 最终结果 以上代码的核心是通过compose将parseFloat和Math.round组合到一个返回一个新函数 number 这就是函数式组合，将两个函数组合在一起以便能及时的构造出一个新函数。 应用需求: 一个字符串，将字符串转化为大写，然后逆序。 常规思路： 123456789let str = 'jspool';// 先转成大写，再逆序function fn(str) { let upperStr = str.toUpperCase(); return upperStr.split('').reverse().join();}fn(str); 代码没问题，现在改需求。将字符串大写之后，每个字符拆开并封装成一个数组。&quot;jspool&quot; =&gt; [&quot;J&quot;,&quot;S&quot;,&quot;P&quot;,&quot;O&quot;,&quot;O&quot;,&quot;L&quot;] 为了修改这个目标，需要修改之前封装的函数，这就破坏了设计模式的开闭原则。 开闭原则：软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。 用组合思想怎么写呢? 原需求实现： 12345678910111213let str = 'jspool'function stringToUpper(str) { return str.toUpperCase()}function stringReverse(str) { return str.split('').reverse().join('')}let toUpperAndReverse = compose(stringReverse, stringToUpper)let result = toUpperAndReverse(str) // &quot;LOOPSJ&quot; 现在实现新需求 12345678910111213141516let str = 'jspool'function stringToUpper(str) { return str.toUpperCase()}function stringReverse(str) { return str.split('').reverse().join('')}function stringToArray(str) { return str.split('')}let toUpperAndArray = compose(stringToArray, stringToUpper)let result = toUpperAndArray(str) // =&gt; [&quot;J&quot;,&quot;S&quot;,&quot;P&quot;,&quot;O&quot;,&quot;O&quot;,&quot;L&quot;] 可以看到，需求变更时，没有打破封装以前的代码，只是新增了函数功能，把函数进行重新组合。 可能有人会有疑问，应用组合的方式书写代码，当需求变更时，依然也修改了代码，不是也算破坏了开闭原则么？其实我们修改的是调用的逻辑代码，并没有修改封装、抽象出来的代码，而这种书写方式也正是开闭原则所提倡的。 现在又改需求: 字符串转大写后，截取前3个字符，然后转为数组。 123456789101112131415161718192021let str = 'jspool'function stringToUpper(str) { return str.toUpperCase()}function stringReverse(str) { return str.split('').reverse().join('')}function getThreeCharacters(str){ return str.substring(0,3)}function stringToArray(str) { return str.split('')}let toUpperAndGetThreeAndArray = compose(stringToArray, getThreeCharacters,stringToUpper)let result = toUpperAndGetThreeAndArray(str) // =&gt; [&quot;J&quot;,&quot;S&quot;,&quot;P&quot;] 以上，组合的方式是抽象单一功能的函数，再组成复杂功能，代码逻辑更清晰，也给维护带来巨大方便。 实现组合新函数执行时，按照由右向左的顺序依次执行传入compose中的函数，每个函数的执行结果作为下一个函数的入参，直到最后一个函数的输出作为最终的输出结果。 如果compose函数接收的函数数量是固定的。 1234567891011function compose(f,g){ return function(x){ return f(g(x)); }}function compose(f,g){ return function(x){ return f(g(x)); }} 但实际compose接收的参数个数是不确定的，我们考虑用rest参数来接收： 12345function compose(...fns) { return function(x) { // ... }} 现在compose接收的参数fns是一个数组，如何将数组中的函数从右向左依次执行. 用数组的reduceRight来实现 1234567function compose(...fns) { return function(x) { return fns.reduceRight(function(arg, fn) { return fn(arg); }, x) }} 这样就实现了compose函数~~ 实现管道compose的数据流是从右到左, 因为右侧函数首先执行，左侧最后执行。但有人喜欢从左至右的执行方式。 从左至右处理数据流的过程称之为管道(pipeline) 只需将reduceRight替换为reduce 1234567function pipe(...fns) { return function(x) { return fns.reduce(function(arg, fn) { return fn(arg); }, x); }}","link":"/posts/js-%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/"},{"title":"leetcode刷题答案记录","text":"[TOC] LeetCode刷题答案记录常见算法思路二分查找二分搜索是一种在有序数组中查找某一特定元素的搜索算法。 二分搜索算法的时间复杂度为 O(log n)，相比较顺序搜索的 O(n) 时间复杂度，它要快很多。 首先要求出数组的中间下标（整数），从而获取到中间值： `const mid = Math.floor((start + end) / 2)` 但在一些极端情况下 `start+ end` 可能直接超出最大安全数，所以更谨慎的写法 `const mid = Math.floor(start + (end - start) / 2)` 12345678while (start &lt; end) { const mid = Math.floor(start + (end - start) / 2) if (arr[mid]` &lt; target) { start = mid + 1 } else { end = mid }} 第一题 求和，在数组中找两个元素加起来等于一个数1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param {number[]} nums * @param {number} target * @return {number[]} * 暴力查找，循环两次 * 时间复杂度O(n^2)， 空间复杂度：O(1) */var twoSum = function(nums, target) { let i = 0, il = nums.length, sumArr = []; for(; i &lt; il; i++ ) { for (let j = i + 1; j &lt; il; j++) { if (**nums**[i] === target - nums[j]) { return [i, j]; } } } throw Error('not find~');};/** * @param {number[]} nums * @param {number} target * @return {number[]} * 匹配不到的存入map, 循环的时候去map里找是否有匹配的 * 时间复杂度：O(n) * 空间复杂度：O(n) 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。 */var twoSum = function(nums, target) { let arrObj = {}, i = 0, il = nums.length; for(; i &lt; il; i++ ) { let extra = target - nums[i]; // 放进去的值可能是0，不能用if(arrObj[extra]) 判断是否有值 if (arrObj[extra] !== undefined) { // 放入数组的顺序，前面的先放进去的，所以i在后面 return [arrObj[extra], i]; } arrObj[nums[i]] = i; }}; 第2题 两个链表求和给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 这个题是参考答案做的。 12345678910111213141516171819202122232425262728293031323334353637/*** function ListNode(val) {* this.val = val;* this.next = null;* }* @param {ListNode} l1* @param {ListNode} l2* @return {ListNode}*/var addTwoNumbers = function(l1, l2) { var List = new ListNode(0); var head = List; var sum = 0; var carry = 0; while (l1 !== null || l2 !== null || sum &gt; 0) { if (l1 !== null) { sum = sum + l1.val; l1 = l1.next; } if (l2 !== null) { sum = sum + l2.val; l2 = l2.next; } if (sum &gt;= 10) { carry = 1; sum -= 10; } head.next = new ListNode(sum); head = head.next; sum = carry; carry = 0; } return List.next;}; 第3题 查找字符串中子字符串最长长度刚开始的思路是放到map里，后来发现会有bdfb的情况，所以不能用map来判断是否存在，改为用数组判断是否存在，存在就从所在位置删除之前的数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** @lc app=leetcode id=3 lang=javascript** [3] Longest Substring Without Repeating Characters*//*** @param {string} s* @return {number}*/var lengthOfLongestSubstring = function(s) { let sArr = s.split(''); let maxArr = []; let l = 0; let max = 0; for (let i = 0, il = sArr.length; i &lt; il; i++) { let tmp = sArr[i]; if (maxArr.includes(tmp)) { maxArr = maxArr.slice(maxArr.indexOf(tmp) + 1, maxArr.length); maxArr.push(tmp); l = maxArr.length; } else { maxArr.push(tmp); ++l; } if (l &gt; max) { max = l; } } return max;};// 厉害的解法function lengthOfLongestSubstring(s) { const map = {}; let left = 0; return s.split('').reduce((max, v, i) =&gt; { left = map[v] &gt;= left ? map[v] + 1 : left; map[v] = i; return Math.max(max, i - left + 1); }, 0);} 4. 寻找两个有序数组的中位数两个有序数组求中位数，问题一般化为，求两个有序数组的第k个数，当k = (m+n)/2时为原问题的解。 怎么求第k个数？分别求出第一个和第二个数组的第 k / 2个数 a 和 b，然后比较 a 和 b，当a &lt; b ，说明第 k 个数位于 a数组的第 k / 2个数后半段，或者b数组的 第 k / 2 个数前半段，问题规模缩小了一半，然后递归处理就行。 时间复杂度是 O(log(m+n)) 链接 解法二： 将两个数组合成一个数组，用二分法查找中间位置的元素。(因为二分法的复杂度是O(log(m+n))) 367. 有效的完全平方数–二分法给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 1234567891011121314151617181920212223var isPerfectSquare = function(num) { if (num === 0 || num === 1) { return true; } let start = 1; let end = num; while(start &lt;= end) { const mid = Math.floor(start + (end - start) / 2); const tmp = mid * mid; if (tmp === num) { return true; } if (tmp &gt; num) { end = mid -1; } else { start = mid + 1; } } return false;}; 744. 寻找比目标字母大的最小字母–二分法给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。 数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。 123456789101112131415161718192021222324252627282930313233343536373839var nextGreatestLetter = function(letters, target) { const max = letters.length; // 边界处理， if (letters[max -1] &lt; target) { return letters[0]; } const last = binarySearch(letters, 0, max, target); // 这里取值时候不能直接用last，可能会有last === letters.length return letters[last % letters.length];};function binarySearch(arr, start, end, target) { while(start &lt; end) { const mid = Math.floor(start + (end - start)/2); if (target &lt; arr[mid]) { end = mid; } else { start = mid + 1; } } return end;}// 最优解var nextGreatestLetter = function(letters, target) { let res = letters[0]; let l = 0, r = letters.length - 1; while (l &lt;= r) { let mid = Math.floor((l + r) / 2); if (letters[mid] &gt; target) { res = letters[mid]; r = mid - 1; } else { l = mid + 1; } } return res;}; 852. 山脉数组的峰顶索引 Peak Index in a Mountain Array我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。 123456789101112131415161718192021222324252627282930313233343536var peakIndexInMountainArray = function(A) { let start = 0; let end = A.length -1; debugger while(start &lt;= end) { const mid = Math.floor(start + (end - start) / 2); if (A[mid] &lt; A[mid + 1]) { start = mid + 1; } else if (A[mid] &lt; A[mid - 1]) { end = mid - 1; } else { return mid; } }};// 递归解法const peakIndexInMountainArray = function(A) { function recursive(i, j) { const mid = (i + j) &gt;&gt; 1 if (A[mid - 1] &lt; A[mid] &amp;&amp; A[mid] &gt; A[mid + 1]) { return mid } else if (A[mid] &lt; A[mid + 1]) { return recursive(mid + 1, j) } else { return recursive(i, mid - 1) } } return recursive(1, A.length - 1)}// reduce 解法var peakIndexInMountainArray = function(A) { return A.reduce((acc, curr, i) =&gt; ('undefined' === typeof acc || A[acc] &lt; curr ? i : acc), undefined);}; 475. 供暖器 Heaters冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。示例 1: 输入: [1,2,3],[2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。示例 2: 输入: [1,2,3,4],[1,4]输出: 1解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// 第一种，没通过var findRadius = function(houses, heaters) { // 现将房屋和加热器从小到大排序 houses.sort(sortNum); heaters.sort(sortNum); const housesL = houses.length; const heatersL = heaters.length; // 先定义半径为0 let radius = 0; // 循环每个house for(let i=0; i&lt;housesL; i++) { // 比较房间和加热器最大值，取最大值作为最小值？ let min = houses[housesL - 1] &gt; heaters[heatersL - 1] ? houses[housesL - 1] : heaters[heatersL - 1]; // 比较house到每个heater的距离 for(let j=0; j&lt;heatersL; j++) { // 计算当前house到当前heater的绝对距离 const diff = Math.abs(heaters[j] - houses[i]); // 最小值大于绝对值，取绝对值，反之取最小值 min = min &gt;= diff? diff : min; // 如果绝对值大于最小值，跳出循环 if (diff &gt; min) { break; } // 如果半径小于最小值，用最小值，反之用当前半径 radius = radius &lt; min ? min : radius; } // 循环结束，返回最小的radius return radius; }};function sortNum(a, b) { return a - b;}// 第二种，可以通过var findRadius = function(houses, heaters) { houses.sort((a, b) =&gt; a - b); heaters.sort((a, b) =&gt; a - b); const n = houses.length; const m = heaters.length; let radius = 0; let j = 0; for (let i = 0; i &lt; n; i++) { let temp = Infinity; for (let k = j; k &lt; m; k++) { // console.log('check!!', houses[i], heaters[k]); // 获取当前heaters到每个屋子的最小值 temp = Math.min(temp, Math.abs(heaters[k] - houses[i])); // 如果heater的值小于house的值，从heater当前的值开始循环 if (heaters[k] &lt; houses[i]) { j = k; } // 如果heater的值大于house的值，取当前house到heater的距离和当前tmp的最小值，并跳出循环 if (heaters[k] &gt; houses[i]) { if (j &gt; 0) temp = Math.min(temp, Math.abs(houses[i] - heaters[j - 1]); break; } } radius = Math.max(radius, temp); // console.log('==', temp, radius); } return radius;};// 最优解var findRadius = function(houses, heaters) { heaters.sort((a, b) =&gt; a - b); let dist = 0; let left; let right; let mid; let target; for (let i = 0, size = houses.length; i &lt; size; i++) { target = houses[i]; left = 0; right = heaters.length - 1; while (left &lt;= right) { mid = left + ((right - left) &gt;&gt; 1); if (heaters[mid] === target) { break; } else if (heaters[mid] &gt; target) { right = mid - 1; } else { left = mid + 1; } } if (left &lt;= right) continue; let distLeft = left &gt;= 0 &amp;&amp; left &lt; heaters.length ? Math.abs(houses[i] - heaters[left]) : Number.MAX_SAFE_INTEGER; let distRight = right &gt;= 0 &amp;&amp; right &lt; heaters.length ? Math.abs(houses[i] - heaters[right]) : Number.MAX_SAFE_INTEGER; dist = Math.max(dist, Math.min(distLeft, distRight)); } return dist;};","link":"/posts/leetcode%E5%88%B7%E9%A2%98%E7%AD%94%E6%A1%88%E8%AE%B0%E5%BD%95/"},{"title":"node cli开发调试经验总结","text":"node命令行工具开发调试npm link命令通过链接目录和可执行文件，实现npm包命令的全局可执行。 简要地讲，这个命令主要做了两件事： 为npm包目录创建软链接，将其链到{prefix}/lib/node_modules/package(包名) 为可执行文件(bin)创建软链接，将其链到{prefix}/bin/{name} 在package.json中配置 123&quot;bin&quot;: { &quot;ltsnode&quot;: &quot;bin/ltsnode.js&quot;} 在ltsnode.js中 12345#!/usr/bin/env node// 指定运行环境为nodeconsole.log('运行ltsnode命令') 在VsCode里debug模式里调试12345678910111213141516171819{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], // 这里是命令行需要传入的参数 &quot;args&quot;: [ &quot;10&quot; ], // 这里是命令行入口文件的位置，一般放在bin文件夹下 &quot;program&quot;: &quot;${workspaceFolder}/bin/ltsnode.js&quot; } ]} 配置完成后，点击启动程序，即可开始调试。上一步下一步在VsCode正中间顶部。可以使用console.log输出结果到调试控制台 在命令行里里调试npm link 再运行npm link即可 然后再命令行里执行命令ltsnode看效果 进入/usr/local/lib/node_modules会发现一个软链，指向自己项目目录ltsnode -&gt; /Users/zhaojianpeng/Desktop/workspaces/ltsnode 开发中遇到的问题 执行npm link报错 开发过程遇到的报错 ENOENT: no such file or directory, chmod '/usr/local/lib/node_modules/videocount/bin/videocount' 解决办法：在package.json中 123&quot;bin&quot;: { &quot;videocount&quot;: &quot;bin/videocount.js&quot;}, 这里一定要加后缀名js npm ERR! Refusing to delete /usr/local/bin/ltsnode: ../../../Users/zhaojianpeng/.config/yarn/link/ltsnode/bin/ltsnode symlink target is not controlled by npm /usr/local/bin npm ERR! EEXIST: file already exists, symlink '../lib/node_modules/ltsnode/bin/ltsnode.js' -&gt; '/usr/local/bin/ltsnode' 解决办法：尝试了各种办法，删缓存，升级npm版本。执行npm link总是报错。执行rm /usr/local/bin/ltsnode删除软链搞定~~~ 在/usr/local/bin/node_modules里删除软链不好使 期间用到知识 一、使用淘宝镜像1.临时使用npm –registry https://registry.npm.taobao.org install express 2.持久使用npm config set registry https://registry.npm.taobao.org 3.通过cnpmnpm install -g cnpm –registry=https://registry.npm.taobao.org 二、使用官方镜像npm config set registry https://registry.npmjs.org/ 三、查看npm源地址npm config get registry 删除软链rm -rf ltsnode","link":"/posts/node-cli%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"},{"title":"php积累","text":"boolean值传到前端的时候转成了1 PHP 脚本可放置于文档中的任何位置。PHP 脚本以 ` 结尾： 123456&lt;?php// 此处是 PHP 代码?&gt;&lt;?php //这里是代码，哈哈?&gt; PHP 文件的默认文件扩展名是 “.php”。PHP 文件通常包含 HTML 标签以及一些 PHP 脚本代码 12345678910&lt;?phpecho &quot; Hello World!&quot;;?&gt;&lt;?php //这是单行注释 #这也是 单行注释 /* 这是多行注释 */?&gt; 变量大小写分明 1234567&lt;?php $color = &quot;red&quot;; echo &quot;My car is&quot; .$color.&quot;&lt;br&gt;&quot;; echo &quot;My car is&quot; .$COLOR.&quot;&lt;br&gt;&quot;; echo &quot;My car is&quot; .$coLOR.&quot;&lt;br&gt;&quot;;?&gt; PHP 变量规则：变量以 $ 符号开头，其后是变量的名称变量名称必须以字母或下划线开头变量名称不能以数字开头变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）==注释：PHP 变量名称对大小写敏感！== PHP 有三种不同的变量作用域：local（局部）global（全局）static（静态）PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。 12345678function myTest() { $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];}function myTest() { static $x=0; echo $x; $x++;} echo 和 print 语句 echo 和 print 之间的差异：echo - 能够输出一个以上的字符串print - 只能输出一个字符串，并始终返回 1 并置运算符（Concatenation Operator）在 PHP 中，只有一个字符串运算符。并置运算符 . 用于把两个字符串值连接起来。要把两个变量连接在一起，请使用这个点运算符 .严格区别于其他语言的+ strlen()和strpos()strlen() 函数用于计算字符串的长度。strpos() 函数用于在字符串内检索一段字符串或一个字符。 PHP 的真正威力源自于它的函数。在 PHP 中，提供了超过 700 个内建的函数。 创建 PHP 函数：所有的函数都使用关键词 function() 来开始命名函数 - 函数的名称应该提示出它的功能。函数名称以字母或下划线开头。 $_REQUEST 变量PHP 的 $_REQUEST 变量包含了 $_GET, $_POST 以及 $_COOKIE 的内容。PHP 的 $_REQUEST 变量可用来取得通过 GET 和 POST 方法发送的表单数据的结果。 mktime() 函数返回一个日期的 UNIX 时间戳mktime(hour,minute,second,month,day,year,is_dst) 服务器端引用（Server Side Includes）通过 include() 或 require() 函数，您可以在服务器执行 PHP 文件之前在该文件中插入一个文件的内容。 除了它们处理错误的方式不同之外，这两个函数在其他方面都是相同的。include() 函数会生成一个警告（但是脚本会继续执行），而 require() 函数会生成一个致命错误（fatal error）（在错误发生后脚本会停止执行）。 PHP Session在您把用户信息存储到 PHP session 中之前，首先必须启动会话。注释：session_start() 函数必须位于 html 标签之前： 1234567&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码会向服务器注册用户的会话，以便您可以开始保存用户信息，同时会为用户会话分配一个 UID。","link":"/posts/php%E7%A7%AF%E7%B4%AF/"},{"title":"test","text":"Welcome test page.post to github.commit new line.add new line for git test.","link":"/posts/test/"},{"title":"《我生有涯愿无尽》读书笔记","text":"摘自得到APP 怎样像梁漱溟那样，依靠自学，建立独立的思想体系梁漱溟说，人们总以为知道很多，处处显得很渊博才算学问。 其实渊博并不算学问。什么才是学问呢？是能把眼前的道理和材料加以系统化、深刻化。 他把这个建立独立思想、获得真正学问的过程，分成了八个步骤。 第一步是通过用心思来建立主见。梁漱溟说，什么是哲学的道理？其实就是偏见，美其名曰的话，可以说是主见。只要是哲学家，就一定是极端的。哲学家用心思地思考问题，寻找能够贯通一切的普遍性道理。只要这个主见建立起来，他就不会再接受模棱两可、混乱矛盾的东西，会坚定地排斥不同观点。人通过独立思考获得的主见也许是浅薄的，但纵然浅薄，也是真正属于自己的。 他说，胡适的主见就很浅，但因为是他独立的心得，而且理论亲切动人，所以能自成一派。别人不行，因为连浅薄的主见都没有。 有了主见之后，第二步就是去思考旁人的意见与自己不同在哪里？这后面隐藏着什么问题？梁漱溟对学问两个字的解释是“学着认识问题”。比较糟糕的学习是：道理知道了一大堆，却提不出一个问题来。 最初的主见和问题是通往思想和学问的萌芽，有了这个萌芽，才能在不断的学习中吸收养料，长出学问的大树。在此之后的第三步，就能进入真正的读书和学习了。经过了之前的训练，在读书时，人会自然而然地注意到不一样的见解，发现不能解释的事情，思考和推求背后的解决办法，吸收成为真实的知识。 第四步，是学然后知不足。用心之后，你自然就知道，自己那一点儿浅显的见识，是不足以解决问题的。这就像木心说过的一句话：“有人一看书就卖弄，多看几遍再卖弄吧。多看几遍就不卖弄了。” 梁漱溟在一次面向哲学系学生的讲演时说：学哲学千万不要轻易说自己懂。你要是真懂了柏拉图，那你就等于是柏拉图。只有自己知道自己不懂，才有可能找到解决问题的方法。 前面这四步，是从问题到学习，再到逐渐形成思想的修炼过程。在这个过程里不断打磨，就可以把范围很广的知识，收集整理成为一个思想系统。到了这个时候，就可以进入第五步：由浅入深，以简化繁。梁漱溟说，凡是有系统的思想，经过整合和抽象，表现出来的形式都很简单，仿佛只有一两句话。 有些人谈论学问时堆砌一堆名词，论证繁复，旁征博引，实际上却没有自己的思想，学问也是不通的。 后三个步骤，是判断思想和学识高度的标准。第六步是运用自如。有则禅宗故事说，一位禅师对人讲：“你们有一车兵器，拿出一件又一件，却不会使用。老僧虽然只有寸铁，便能杀人。”因为这寸铁就是他自己的思想方法，所以知道怎么运用。当问题来了，他能认识，能判断，能抓住中心所在。而茫然地判断不出问题的关键和解决方向，就说明没有自己的思想和学问。 第七步的标准是对他人的清晰判断力。当人站在一个思想高度上以后，就会对旁人的思想水平一目了然。到了思想圆熟、炉火纯青的第八步，人说出来的每句话，都是精巧透彻的。有大学问的人，说出来的话，形式上是平常的、随意的，其中却蕴含着万变不离其宗的高明道理。 梁漱溟说，这八个层次，他一直是在前四层，也就是建立主见、寻找问题和寻求解答上下功夫；至于后面四层，只能说是虽不能至，心向往之。 芝加哥大学历史教授、汉学家艾恺一直从事梁漱溟研究。在接受艾恺的访谈时，梁漱溟说：孔子和王阳明是圣人，我是个普通人。但我与普通人有一点不同，我“在雾中远远地看见了孔子是怎么回事，王阳明是怎么回事，远远地看见”。儒家解决了他的人生问题，让他不再认为“人生是苦”，转而以躬身入局的态度，谨慎地相信“这个世界会好起来”。对于现实的中国，无论他的主张是否行得通，他都遵照郑重的人生观思考过、求索过了，他远远的历史背影，已经加入了古代儒者的行列。 梁漱溟认为拥有独立思想，要从建立主见、学会对比思想差异、寻求问题开始。通过在学习中寻求解决方案，建立自己的思想系统。真正的学问，是把眼前的道理和材料系统化，深刻化。","link":"/posts/%E3%80%8A%E6%88%91%E7%94%9F%E6%9C%89%E6%B6%AF%E6%84%BF%E6%97%A0%E5%B0%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"俗语","text":"宁可荤口念佛，不可素口骂人字面上的意思是说，我们宁可吃肉喝酒，口中念佛，但是不能吃素却骂人。 这里所说的“荤口”，是指的我们普通人，因为这些人酒肉穿肠过，没有什么吃喝忌讳。虽然不刻意去戒口，但是每时每刻心中友善，口中念佛。这句话是老祖宗嘱咐他们的子孙后代，不必拘泥于形式主义，只要我们心中有佛，口中有德，不吃斋吃素也可以。因为人必定是杂食动物，只要做到不浪费，就难能可贵了，做到口出善言就很好了，所以就有了农村俗语“宁可荤口念佛”这句话。 “不可素口骂人”，它引申的意义就是，一个每天吃斋吃素的人，却张口就骂人，这是万万不可的。这就说明他吃斋念佛只是表象，而内心是丑恶的，从他口吐脏言就能说明一切，他所做的修行也是假的。 在古代有个封建思想，说这样的人会遭到报应，因为这些人是“伪善者”。老祖宗告诫后人，千万不要每天吃斋吃素，以为就成了修行人，如果不修口德也是做无用功。就像有些人“居庙堂之上”，却不理民生疾苦，是一个道理，要知道“法网恢恢，疏而不漏”。念佛其实就是为了让人无欲无求，心存善心，骂人显然就是违背了这样的理念。而吃荤不会伤害到别人，但是骂人却可以影响着其它人，也会伤害到其它人，这样看来就宁可荤口念佛，不可素口骂人了。 所以“宁可荤口念佛，不可素口骂人”，就是老祖宗告诫后人，我们宁可做一个“酒肉穿肠过”的善良人，也不要做一个“假仁假义”的伪君子。因为有一些人打着“修行人”的旗号，却做着下流人的事情，或者利用信仰到处去骗钱，这就是对信仰的欺骗，迷信的说法就是会“遭天谴”。 其实吃荤是犯了戒律，但是就算是吃荤了，只要心中有佛，那还是可以念佛的，心存善念，就可成佛。而就算是不吃荤天天念着佛经，但是却口上不留德，天天就知道骂人，这显然违背了做人道德，一边骂着人一边念着佛，那可是非常虚伪的行为。 总之，这句话说的就是骂人可比吃荤更加严重，就算吃荤也可以成佛，但是嘴上无德的话，是始终都得不到别人的尊重，也会影响自身修行的。 过去农村老人都会教育自己的子女，一定不要随便骂人，否则宁愿去吃荤念佛，也不能表里不一，对人不尊。现实生活当中不乏这样的人，表面上吃斋念佛，一副虔诚，实质上举止乖张，动不动就爆粗口，根本没有一点儒雅的样子。这样的人是最令人讨厌的，也是最不受欢迎的人。 如果我们往深层次剖析，这个农村俗语的意义就非常深刻了。不仅显示出了现实生活中，一些人的本性，也告诉我们通过人的表象，要看看他的本质属性，也就能够分清善恶，把好坏人进行区分了。","link":"/posts/%E4%BF%97%E8%AF%AD/"},{"title":"前端性能的监控和优化","text":"[TOC] 目标 理解性能监控和优化的一般方法 移动端的性能 运用工具来监控和优化 性能优化的重要性1. 性能和PV直接相关 2. 性能与收入有关 3. 前端容易产生性能的瓶颈 4. 无线设备性能问题更明显 反面案例: 百科某次上线，性能下降20% ====&gt; PV流失近15%====&gt; 收入下降10% 移动端更严重DOM ready时间： wifi 2.3s, 3G/4G 4.2s, 2G 首字节5-6s， 8s+ 一、何为前端性能打开一个网站，需要经过多少步 性能优化的一般思路 减少请求次数 减少请求体积 加快请求速度 缩短渲染时间 二、指标的确定、采集和分析基于用户角度的关键指标选取 页面打不开 – 白屏时间(DNS查询，TCP连接，发送请求，等待响应) 页面显示不出来 – 首屏时间(html传输，静态资源下载) 按钮点击不了 – 用户可操作(解析文档，执行JS/CSS规则，计算布局) 图片显示慢 – 页面总下载(渲染完成) 怎么采集展示页面打开的时间起点到页面渲染完成的时间各阶段时间分布，总占比 数据波动波动即意味着性能发生变化，需要注意 占比更重要总下载的时间，各阶段的用户下载占比(很快0-2，较快2-4，可接受4-8，很慢8+) 数据采集-首屏时间图片是制约首屏的主要因素 获取首屏图片的加载耗时即可获取大概首屏时间 首屏统计流程 首屏大概位置执行统计JS 绑定所有图片加载事件 页面onload之后找到最慢一张图片加载时间 数据采集- 可操作时间DomReady或核心JS加载完毕 数据采集-总下载时间onload or 异步渲染完成 浏览器性能APIPerformance Timing Resource Timing 三、常用的优化方法 雅虎性能优化军规 可优化的点 DNS查询 DNS缓存(浏览器、操作系统) 减少DNS数(一个页面不超过4个, DNS预查询dns-prefetch) 建立连接 使用CDN 提速10%-20%(缩短距离，降低连接时间) 发送请求 减少HTTP请求(打包JS，CSS文件，图片合并) Keep alive 减少TCP请求连接数 内容传输 文件压缩(js, css, html),代码混淆 60%+ 代码精简 减少无用代码，提高质量 gzip 缓存 Expires、Cache-Control Last-Modified Etag 充分利用缓存–强缓存(文件名md5后缀) 前端工程化与性能优化–静态资源管理 自动将样式表放在头部，脚本放在底部，并按需加载 代码的性能–css 书写高效的CSS selectors 删除没用的CSS代码 避免使用CSS expressions(实践中比较难~~~) 把CSS放到页面顶部 不要缩放图片–很大的图片缩到很小展示，耗性能 代码的性能–JavaScript 数据结构和算法优化 避免with, eval 减少跨上下文查找: 全部变量、属性 避免arguments、debugger 缓存计算结果 DOM才是性能大头 避免DOM重绘(避免访问childNode数组，读写分离)，不在for循环重绘DOM 收回、重复利用DOM 缓存数据而不是DOM MVVM 框架的DOM 只在需要时才更新DOM 性能：JS Engine &gt; Render Engine React的性能优化 shouldComponentUpdate / PureComponent 全局数据store管理(redux) + immutable 在shouldComponentUpdate里全部return false,在componentWillReceiveProps里判断是否需要更新 12345678910111213export class Line extends React.Component { shouldComponentUpdate(nextProps) { return false; } componentWillReceiveProps(nextProps) { // 只有某些数据发生改变时进行绘图 if (this.props.data !== nextProps.data) { this.refresh(); } } ...} Debounce防抖延迟更新 compositionstart, compositionend 解决中文输入时的频繁更新 1234567891011121314151617export default class DebounceText extends Component { componentWillMount() { this.props_onChange = debounce(this.props.onchange, 300); } onChange = val =&gt; { this.setState({ value: val }); this.props_onChange(val); } render() { let props = Object.assign({}, this.props, {value: this.state.value}); delete props.onChange; return &lt;Input value={this.state.value} onChange={this.onChange} /&gt; }} React 性能优化 redux –&gt; mobx, mobx-state-tree 对redux性能优化，主动用observer观察数据的变化… 避免过度的动画效果 四、极致的性能优化 懒加载(lazy render), 逐屏加载，优化首屏时间 bigRender 减少DOM数，提升首屏（DOM树转为注释，页面滚动到指定位置才加载） bigpipe 一次请求，分chunk方式获取所有内容，后端并发 Request-header (http 1.1) transfer-encoding: chunked content-length先给前端吐一个结构，在HTML结束后，输出一些js代码渲染内容上去性能提升 贴吧首页白屏提升40% FRS页贴吧列表区展示时间提升20%弊端 代码复杂度 后端成本 五、移动端的性能 显性加载- loading页 首屏优先 单页应用首屏后端渲染 逐屏加载 滚动加载(用户无感知，提速30%) 减少首屏图片数量，减少请求 使用其他方式代替图片: css3,svg,iconfont 合适的图片类型: webP &gt; jpg, png8&gt;gif 避免使用dataURL 响应式图片 分辨率、Retina srcset, picture 加载过程的优化 预加载: 提前加载下一页 避免302重定向 异步加载广告等第三方资源 减少cookie：静态资源域名不适用cookie 长缓存 执行过程的优化 合理使用CSS 3D加速 避免批量绑定数量，使用事件代理 严格控制DOM数，缓存数据而不是DOM（不超20层） 用touchstart, touchend代替click 利用Native的能力 将一些不频繁更新的一些东西本地化 Hybird的加速方式 模板资源本地化，极大提速首屏 模板资源的增量下发 图片缓存：imageCache 利用NA(native)的Request、socket长连接 利用NA获取用户信息、位置等 手百使用Hybird的性能收益 相比H5方案，首屏时间降低60%+ 模板增量下发，体积减小90% 总结前端性能十分关键，影响PV 和收入找到关键指标，用统计到的数据说话性能优化贯穿页面的整个响应过程无线端更需要优化监控-分析-优化，利用现有的工具方案","link":"/posts/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96/"},{"title":"学习方法","text":"学习方法：如何在工作内外获得持续的技术成长参考链接 学习方法：如何在工作内外获得持续的技术成长 看文章写的很好，摘一些对自己有用的东西保存下来 成长本质是突破天花板成长是一件很难捉摸和量化的事情，完全不同的环境和主观意识加上完全不同的行动措施既可以让一个人快速成为某个领域的顶尖高手，也可能完全相反。 了解技术的成本和门槛对技术寻根溯源追求本质是最重要的，但比这个更重要的是自己的时间分配和如何选择，你的时间远比你以为的要值钱的多，请珍惜它。 哪些技术栈是时间长度相对可被接受，也就是哪些学习成本可以被接受是你需要思考的，思考清楚后，再去选择，会更有侧重，然后再来看不同的技术学习成本背后，哪个更贴合自己。 求变之前要先认清自己1我是谁？我的身份是？未来我想要做什么？当下我可以做什么？我擅长什么？我还需要学会什么？ 答案永远在变化，也永远没在变，时间越久思考的越久经历也越多，就会距离它最真实的答案越近。 其实有太多太多的问题，我们可以尝试问自己，但我们往往找别人去问，挑选跟自己内心与未来无关的话题，其实所有的答案都取决于自己接下来 3 ~ 9 个月具体的行动，这些答案来源于内心的原动力以及自己规划的最优或者最可执行路径，可一旦我们眼睛看到 9 个月后的结果，而忽视这个可执行路径，甚至忽略原动力的时候，结果就变得非常惋惜，忽略整个思考过程，也就压根无法了解自己的真实诉求和真实能力。 习惯养成与定目标计划在经过深思熟虑后去制定的目标成功的概率更大，而脑袋一热跑出来的目标往往会泡汤，泡汤倒也罢了，这会让自己陷入定目标 - 执行难度过大 - 放弃 - 再定目标这样的死循环，信心和成就感一天天挫败下去，就变成了今日的自己，晚上想千万条路早上起来走原路，越来越麻木越来越气馁。 建议: 制定目标要考虑能不能坚持下来，如果不能坚持下来，就修正。坚持两三周慢慢形成习惯，并从中受益获取一些兴趣和成就感，这时候才是定目标的时候，因为这时候，习惯正在养成。 当有了一种正在建立或者成熟的习惯，也定了具体的目标后，就可以定具体的计划了。计划就是行动指南，要一板一眼的去执行，坚决不能马虎大意，最好一条条写下来。比如： 每周晚上10点钟，花10分钟读书 每周六花一小时整理笔记 每周日花2小时对遇到的问题进行深入研究 再把这个规律性的事项，分解到每一天，每一天都要打一个对勾，任务才算完成，完成后给自己一个激励，比如说连续5天完成，看场电影之类。指定明确的奖惩细则，叠加到每日的手机/电脑行程中，给自己强有力的提醒，坚持三个月，一个习惯大概率就能养成了，就可以定第二个目标去养成第二个习惯了。 所以习惯和目标及计划的关系是，定目标前要尽可能先养成一个潜在的习惯，把自己的底线测试出来，然后调整目标，再拆解目标形成规律性的计划，最后把计划完成跟奖惩关联起来，并通过软硬件来跟自己进行互动提醒。这注定是一个单调的过程，但这一定是一个越坚持越好玩的过程，等习惯训练有了雏形的时候，才会真正启动持续成长这件事情。 训练稳定的思维路径我们前面对自己有了更客观的认知，也培养了完成目标的习惯，这两个前提条件就成立了，还缺第三样东西，就是稳定的思维路径，最刻板也最简单的思维方式就是穷尽式的提问，也就是前面认清自己这里，我用列举问题的这种办法，来让自己不断的接近某一个真相，那么面对任何一个困局的时候，都可以用这种方法。实际上，当你把几十个问题都回答一遍的过程中，你可以继续写下更击中灵魂的问题，而这次问题写下去的时候，往往答案就自然浮出水面。 提问的套路可以更简单一些，就是 What Why How，这个问题是什么，当前的真相是什么，为什么发生，为什么走到这个地步，基于这些原因要如何解决，无论任何事情，都逼自己去捉摸它去思考它的前因后果，慢慢会发现自己会变成一个喜欢上思考和善于思考的人，再也不是之前的那个鲁莽的毛头小子，看问题只看负面看现象只看表面。 认识自己、习惯养成、思维训练这三个要成年累月持续的做，当这些都逐渐变成长在自己身体内的一种能力的时候，所以你面临的问题都不会让你像之前那样焦虑，在做完这么长铺垫后，我们再来看如何获得持续的技术成长。 工作内外的技术成长成长是经常不符合预期的，请记住，它大概率是不符合预期的，原因是自己的预期本身是非常主观不准确的，同时成长只是过程的积累并不是一个很直观的结果。基于这样的背景，我们希望达成的共识是，无论成长是否预期，我都希望有持续的成长，同时盼望奇迹的发生 - 就是远超预期的成长会发生在我身上。 工作内的成长主要来自项目带着这样的期望，我们回到工作内工作外会发现，所有的成长最核心的过程指标就是项目经验，工作内天然就可以沉淀，那么如何沉淀或者挖掘成长点呢？ 很多人在面试中会被问到一个问题「你做的项目有什么难点」。可能大家会把思维局限在我做的这个业务有什么难的地方，我用了什么牛逼的技术去解决了业务上的什么难题。我相信大部分人不会有这样的经历，由此会觉得这个问题很难答。那么这个问题其实就可以引申为我们如何在工作中、业务中发现问题并得到成长？ 如何实现业务在大部分情况下不会是一个难题，但是如何把业务中相关的组件、逻辑等等可以复用的东西抽象出来，这就是一个难题了。你可以通过学习比你厉害的同事的代码，也可以学习这方面业内顶尖的库是如何实现的，这就是在工作中学习及成长。 在实现业务的过程中，大家肯定会使用各种各样的库及框架。那么当我们熟练使用这个库的时候，就应该尽可能的去了解常用的库的实现原理。我们可以通过文章去了解，也可以通过阅读源码去了解，这也是在工作中学习及成长。 实际上大部分工作场景中的项目，深度的思考持续的思考都会带来较大的技术成长，但往往我们没有耐心和动力去做这件事情，因为会有雇佣心态，也就是你付我那点工资，凭什么我想破头皮去捉摸怎么优化它，这就等于是把自己拦到了池子之外，公司付薪水（无论多少）是购买了你的时间，而你的成长是基于这些时间如何在池子里学游泳技能，池子大小水温深浅甚至形状你都很难有控制权，但蛙泳仰泳自由泳甚至闭气潜水这些都是自己说了算，如果这些都玩溜了，去任意一个池子都能如鱼得水，不是么？ 例如：打造工作相关的工具链，让每个流程不独立进行。 所以工作内，不仅靠耐心，还要有不怕吃亏的心态，更要有善于发现的双眼，无数机会都在你面前，都可以持续不断的带来成长，同时给自己团队和个人带来更多效率和体验的提升。 工作外的成长主要来自尝试与思考工作外的成长更简单易操作一些，往往就是技术储备、技术尝鲜和总结思考，技术储备一部分是为了自己的职业考虑，比如学习 RN/Flutter/Go 等，另一方面也可以是为了自己公司业务未来的可能性领域，比如 NodeJS/Taro/MPVue 等等，所有感兴趣的方向都可以去学习储备。另外就是自己的想法，可以把他变成现实，比如一个行程提醒小工具，一个萝莉妹子叫起床小工具，一个自动生成周末食谱的工具等等，任何一个生活痛点和创意想法，都可以动手把它实现出来，前后端可以一起做，技术栈可以激进，所有的这些尝鲜都会带来技术视野的扩张，也会带来技术深度的沉淀。最值得尝试的就是思考和总结，把任何自己学习的框架，看过的书，做过的项目，甚至解决过的 Bug，都可以有序的整理起来，把这些整理变成文字和图表，来强化自己对于技术的记忆，所有的这些记忆重复训练的次数越多，对于他们的理解和运营就越娴熟，往往最慢的反而是最有效的。 小结成长是一个永恒的话题，互联网几十年来，无数的新人问成长，也无数的新人变老人，有的混成一方大拿，有的混成螺丝工头，抛开经济环境、行业趋势和公司经营，更多时候取决于我们成长的是一些学习方法，更根本上依然是我们对于自己的理解、规划和持之以恒的执行，这里面无关运气更关乎实力，不是环境带来的成长去选择你，而是你选择在任何环境中都能成长，具备选择权后，剩下的无非是规划、执行与坚持，无它！","link":"/posts/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"title":"原型","text":"js原型继承的几种方式 原型链继承 2，构造函数继承（对象冒充继承） 3，组合继承（原型链继承+构造函数继承） 4，原型式继承 5, 寄生组合式继承 一。原型链继承 1234567891011function Show(){ this.name=&quot;run&quot;;}function Run(){ this.age=&quot;20&quot;; //Run继承了Show,通过原型，形成链条}Run.prototype=new Show();var show=new Run();alert(show.name)//结果：run 二。构造函数继承（对象冒充继承） 为了解决引用共享和超类型无法传参的问题，我们采用一种叫借用构造函数的技术，或者成为对象冒充(伪造对象、经典继承)的技术来解决这两种问题 2.优缺点可以实现多继承,不能继承原型属性/方法 123456789101112function Box(age){ this.name=['Lee','Jack','Hello'] this.age=age;}function Desk(age){ Box.call(this,age); //对象冒充，给超类型传参}var desk = new Desk(200);alert(desk.age);//200alert(desk.name);//['Lee','Jack','Hello']desk.name.push('AAA'); //添加的新数据，只给 deskalert(desk.name)//['Lee','Jack','Hello','AAA'] 三。组合继承（原型链继承+构造函数继承） 借用构造函数虽然解决了刚才两种问题， 但没有原型， 复用则无从谈起。 所以， 我们需要原型链+借用构造函数的模式，这种模式成为组合继承。 通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 1234567891011121314function Box(age) { this.name = ['Lee', 'Jack', 'Hello'] this.age = age;}Box.prototype.run = function () { return this.name + this.age;};function Desk(age) { Box.call(this, age); //对象冒充}Desk.prototype = new Box(); //原型链继承Desk.prototype.constructor = Desk; // 组合继承也是需要修复构造函数指向的。var desk = new Desk(100);alert(desk.run()); 四。原型式继承 这种继承借助原型并基于已有的对象创建新对象，同时还不必因此创建自定义类型 12345678910111213141516171819function obj(o) { //传递一个字面量函数function F() {} //创建一个构造函数F.prototype = o; //把字面量函数赋值给构造函数的原型 return new F(); //最终返回出实例化的构造函数}var box = { //字面量对象 name : 'Lee', arr : ['哥哥','妹妹','姐姐']};var box1 = obj(box); //传递alert(box1.name);box1.name = 'Jack';alert(box1.name);alert(box1.arr);box1.arr.push('父母');alert(box1.arr);var box2 = obj(box); //传递alert(box2.name);alert(box2.arr); //引用类型共享了 五。寄生组合式继承 寄生组合式继承解决了两次调用的问题，组合式继承就会有两次调用的情况 基本模型如下： 1234567891011function object(o) { function F() {} F.prototype = o; return new F();}function inheritPrototype(subType, superType) { var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象} 后面的寄生式继承和寄生组合模型式继承还搞不懂，哈哈哈，好尴尬 寄生组合继承，解决了两次调用的问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192Person.prototype.constructor == Person;person1.__proto__ == Person.prototype;person1.constructor == Person;person1.__proto__ === Person.prototypePerson.__proto__ === Function.prototypePerson.prototype.__proto__ === Object.prototypeObject.__proto__Object.prototype.__proto__ === nullvar b = new Array();b.constructor === Array;b.__proto__ === Array.prototype;var c = new Date();c.constructor === Date;c.__proto__ === Date.prototype;var d = new Function();d.constructor === Function;d.__proto__ === Function.prototype;// 所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function）Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // trueDate.constructor == Function //trueconsole.log(typeof Function.prototype) // functionconsole.log(typeof Object.prototype) // objectconsole.log(typeof Number.prototype) // objectconsole.log(typeof Boolean.prototype) // objectconsole.log(typeof String.prototype) // objectconsole.log(typeof Array.prototype) // objectconsole.log(typeof RegExp.prototype) // objectconsole.log(typeof Error.prototype) // objectconsole.log(typeof Date.prototype) // objectconsole.log(typeof Object.prototype) // objectfunction Person(){}var person1 = new Person();console.log(person1.__proto__ === Person.prototype); // trueconsole.log(Person.prototype.__proto__ === Object.prototype) //trueconsole.log(Object.prototype.__proto__) //nullPerson.__proto__ == Function.prototype; //trueconsole.log(Function.prototype)// function(){} (空函数)var num = new Array()console.log(num.__proto__ == Array.prototype) // trueconsole.log( Array.prototype.__proto__ == Object.prototype) // trueconsole.log(Array.prototype) // [] (空数组)console.log(Object.prototype.__proto__) //nullconsole.log(Array.__proto__ == Function.prototype)// truevar animal = function(){}; var dog = function(){}; animal.price = 2000; dog.prototype = animal; var tidy = new dog(); console.log(dog.price) //undefined console.log(tidy.price) // 2000 原型和原型链是JS实现继承的一种模型。原型链的形成是真正是靠proto 而非prototype JavaScript继承实现1234567891011121314151617181920212223242526272829303132333435363738394041424344function Animal() {}Animal.prototype.speak = function () { console.log('动物发声:');}function Dog(name) { this.name = name;}Dog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;Dog.prototype.speak = function () { //通过原型链找‘基本类’原型里的同名方法 this.__proto__.__proto__.speak.call(this); console.log('汪汪, 我是', this.name);}function Cat(name) { this.name = name;}Cat.prototype = Object.create(Animal.prototype);Cat.prototype.constructor = Cat;Cat.prototype.speak = function () { //通过原型链找‘基本类’原型里的同名方法 this.__proto__.__proto__.speak.call(this); console.log('喵喵, 我是', this.name);}//调用代码function animalSpeak(animal) { animal.speak();}animalSpeak(new Dog('大黄'))console.log()animalSpeak(new Cat('小喵'))//动物发声://汪汪, 我是 大黄//动物发声://喵喵, 我是 小喵 Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享我在写的时候,用了两种,一个是 ES5和 ES6的方案 ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function ParentClass(name) { this.name = name;}ParentClass.prototype.sayHello = function () { console.log(&quot;I'm parent!&quot; + this.name);}function SubClass(name, age) { //若是要多个参数可以用apply 结合 ...解构 ParentClass.call(this, name); this.age = age;}SubClass.prototype = Object.create(ParentClass.prototype);SubClass.prototype.constructor = SubClass;SubClass.prototype.sayChildHello = function (name) { console.log(&quot;I'm child &quot; + this.name)}let testA = new SubClass('CRPER')// Object.create()的polyfill /* function pureObject(o){ //定义了一个临时构造函数 function F() {} //将这个临时构造函数的原型指向了传入进来的对象。 F.prototype = obj; //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。 //因为该实例的原型是obj对象。 return new F(); } */// ES6: 其实就是ES5的语法糖,不过可读性很强..class ParentClass { constructor(name) { this.name = name; } sayHello() { console.log(&quot;I'm parent!&quot; + this.name); }}class SubClass extends ParentClass { constructor(name) { super(name); } sayChildHello() { console.log(&quot;I'm child &quot; + this.name) } // 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上 sayHello(){ console.log(&quot;override parent method !,I'm sayHello Method&quot;) }}let testA = new SubClass('CRPER') 到这里就结束了么…不,这只是笔试, 问的时候你用过静态方法,静态属性,私有变量么? 这个静态方法是ES6之后才有这么个玩意,有这么些特点 方法不能给 this引用,可以给类直接引用静态不可以给实例调用,比如 let a = new ParentClass =&gt; a.sayHello() 会抛出异常父类静态方法,子类非 static 方法没法覆盖父类静态方法可以给子类继承静态属性可以继承也可以被修改看下面的代码.. 1234567891011121314151617181920212223242526272829303132333435363738class ParentClass { constructor(name) { this.name = name; } static sayHello() { console.log(&quot;I'm parent!&quot; + this.name); } static testFunc(){ console.log('emm...Parent test static Func') }}class SubClass extends ParentClass { constructor(name) { super(name); } sayChildHello() { console.log(&quot;I'm child &quot; + this.name) } static sayHello() { console.log(&quot;override parent method !,I'm sayHello Method&quot;) } static testFunc2() { console.log(super.testFunc() + 'fsdafasdf'); }}ParentClass.sayHello(); // success printlet a = new ParentClass('test');a.sayHello() // throw errorSubClass.sayHello(); // 同名 static 可以继承且覆盖SubClass.testFunc2(); // 可以继承let testA = new SubClass('CRPER'); 私有变量这个我没答出来,只是说了下没有 private 这个关键字和基本用下划线的人为区分 所以回来只是找了下相关的资料,发现有一个比较好的模拟方案,就是 WeakMap ; WeakMap 可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了. const _ = new WeakMap(); // 实例化,value 必须为对象,有 delete,get,has,set四个方法,看名字都知道了 12345678910class TestWeakMap { constructor(id, barcode) { __.set(this, { id,barcode }); } testFunc() { let { id,barcode } = __.get(this); // 获取对应的值 return { id,barcode }; }}","link":"/posts/%E5%8E%9F%E5%9E%8B/"},{"title":"富文本编辑器调研","text":"富文本编辑器draft-js调研需求移动端和PC端富文本编辑器技术选型, Facebook开源框架draft-js调研 与现有富文本编辑器比较 项目 draft 现有 样式 可以自定义，引用css文件，内联样式 可以自定义，引用css文件 自定义块组件 用draft提供的语法，自定义块，定义策略类型，根据类型渲染组件 拼HTML 移动端支持 官网申明不支持 未测试 上手 需熟悉提供的接口及一些概念，一系列接口 操作DOM,调用原生浏览器提供的方法 数据存储 自定义的object对象，带来调试难点，需熟悉数据格式 html 格式转换 提供convertToRaw接口，将draft的ContentState转成js对象，不直接提供HTML(点击事件，交互等). 需要插件转HTML(自定义组件特殊功能插件可能不支持) 以HTML格式存储 编辑器中DOM操作，获取焦点(删除商品块无法整个删除，编辑区有video，按删除键，无法删除) demo中有问题 实际使用也有问题，可以通过hack方式解决 存在的风险点 移动端兼容性 数据存储为draft自定义格式，开发调试困难，在展示时，需要转成HTML，官方未提供转换插件，转换过程会造成所见非所得的情况 对外提供的API封装原生的方法，开发难度大 由于内部封装逻辑过重，遇到问题从根源处解决难度大 结论 由于存在风险点较多，暂时不考虑以draft为基础框架。 目前富文本编辑器框架对移动端支持普遍不够，会持续调研现有框架，如quilljs, 小米社区等。","link":"/posts/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E8%B0%83%E7%A0%94/"},{"title":"小程序开发积累","text":"[TOC] 小程序开发经验积累小程序setData时，数据没更新由于小程序不支持将 data 中任何一项的 value 设为 undefined ，在 setState 的时候也请避免这么用。你可以使用 null 来替代。 setData有的值之前有值，重新set为undefined时，会导致页面不更新解决办法判断是undefined时，将值设为null key ? key : null 小程序用get请求传数组时，取到的值不正确12345request({ data: { list: ['11','sss'] }}) 应改为 123456request({ data: { list: ['11','sss'].join(','gst) }}) js判断小程序环境小程序内置web-view引入页面时，官方文档建议通过 window.__wxjs_environment === 'miniprogram' 判断小程序环境。经测试在安卓有些设备上会失效。 wx.miniProgram.getEnv也会失效 123456wx.miniProgram.getEnv(function(res) { if (res.miniProgram) { // 走在小程序的逻辑 alert(&quot;小程序环境&quot; + window.__wxjs_environment); }}); 解决方案通过userAgent 判断const isMiniProgram = /miniProgram/i.test(navigator.userAgent.toLowerCase()); UserAgent 详解通过UA来判断不同的设备或浏览器是开发者最常用的方法 在控制台打印navigator.userAgent查看 Android 系统下的微信 User Agent 1Mozilla/5.0 (Linux; Android 7.1.1; MI 6 Build/NMF26X; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/043807 Mobile Safari/537.36 MicroMessenger/6.6.1.1220(0x26060135) NetType/WIFI Language/zh_CN iPhone 系统下的微信 User Agent 1Mozilla/5.0 (iPhone; CPU iPhone OS 9_3_2 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13F69 MicroMessenger/6.6.1 NetType/4G Language/zh_CN 微信内置浏览器与小程序中的User Agent 对比 1234// 安卓系统中小程序 User AgentMozilla/5.0 (Linux; Android 7.1.1; MI 6 Build/NMF26X; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/043807 Mobile Safari/537.36 MicroMessenger/6.6.1.1220(0x26060135) NetType/4G Language/zh_CN MicroMessenger/6.6.1.1220(0x26060135) NetType/4G Language/zh_CN miniProgram// 安卓系统中微信内置浏览器 User AgentMozilla/5.0 (Linux; Android 7.1.1; MI 6 Build/NMF26X; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/043807 Mobile Safari/537.36 MicroMessenger/6.6.1.1220(0x26060135) NetType/4G Language/zh_CN 以上字符串为MI6安卓设备中获得。可以看出微信小程的UA和微信内置浏览器UA是不同的，特别是最后的’miniProgram’字符串。而在iPhone系统设备中UA是一致的， 小程序和微信内置浏览器UA没有区别。 UA检测和判断方法123if (/MicroMessenger/i.test(navigator.userAgent)) { console.log('当前为微信访问');} 开源工具推荐UAParser.js 目前生产环境使用该库来判断移动，Android，iOS等环境。 小程序里一定要用https, 无法访问http解决办法：配置Charleshttps://www.cnblogs.com/xcsn/p/7538371.html 小程序生命周期onload —-&gt; onshow —-&gt; onready即使在onload阶段发生跳转，后面的流程还是会继续执行。 原则上onload 只会执行一次，onshow每次页面显示才会显示。 所有页面onload阶段的options是从跳转的page url后跟的参数取到的。 组件button样式button去掉边框(适用于百度小程序) 123456.btn{ backgrond:none;}.btn::after{ border: none;} button 阻止冒泡有的button 设置了默认操作例如open-type=’share’点击以后父容器有click事件，也会触发。 解决办法：在button绑定一个方法 return false; 开发框架用过wepy各种坑，弃坑 优化微信小程序：一些运行细节及针对性的优化策略 微信小程序开发资源汇总好的目录结构123456789101112131415161718192021222324252627282930313233343536373839404142├── README.md // 说明文档├── dist // 编译后的代码，用小程序开发工具打开此文件夹├── mock.js // 模拟数据的文件├── package-lock.json├── package.json├── project.config.json // 项目配置文件├── src // 项目代码都在这个文件夹下│ ├── app.js // 等同于小程序根目录下的app.js│ ├── app.json // 等同于小程序根目录下的app.json│ ├── app.wxss // 等同于小程序根目录下的app.wxss│ ├── assets // 项目中使用到的静态资源│ │ └── images│ │ ├── example│ │ └── tab│ ├── components // 公用的组件│ ├── page // 存放小程序的各个页面文件│ │ ├── example // example 页面│ │ │ ├── components // example页面中的组件│ │ │ ├── index.js│ │ │ ├── index.json│ │ │ ├── index.wxml│ │ │ ├── index.wxss│ │ │ ├── services // example页面中接口│ │ │ ├── template // example页面中的模板│ │ │ └── wxs // example页面中的wxs文件│ │ ├── globalStore.js // 全局共享的数据│ │ └── test│ │ ├── index.js│ │ ├── index.json│ │ ├── index.wxml│ │ └── index.wxss│ ├── template // 公用的模板│ └── utils // 公用的方法或工具│ ├── config.js // 全局的一些配置信息│ ├── create.js // 状态管理插件│ ├── mitt.js // 状态管理插件│ ├── obaa.js // 状态管理插件│ ├── util.js // 公用方法│ ├── wxRequest.js // 封装的小程序请求数据方法│ └── wxapi.js // 对小程序api进行Promise封装└── weapp.config.js // 对脚手架的配置文件 小程序的双线程结构与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。 小程序更新视图数据的通信流程每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下： 小程序逻辑层调用宿主环境的 setData 方法。 逻辑层执行 JSON.stringify 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过evaluateJavascript 执行脚本将数据传输到渲染层。 渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。 ebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。 经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到UI视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。 引发渲染性能问题的原因 setData传递大量新数据 数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程。 频繁的执行setData操作 频繁的执行 setData 会让 WebView JS 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。 过多的页面节点数 页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。 每次执行 setData 更新视图，WebView JS 线程都要遍历节点树计算新旧节点数差异部分。当页面节点数量越多，计算的时间开销越大，减少节点树节点数量可以有效降低重渲染的时间开销。 渲染性能优化setData优化 减少 setData 数据传输量 仅传输视图层使用到的数据，其他 JS 环境用到的数据存放到 data 对象外。 合理利用局部更新。 setData 支持使用 数据路径 的方式对对象的局部字段进行更新。 1234567891011// 只更新需要更新的数据！！！// 后台获取列表数据const list = requestSync();// 更新整个列表----错误❌this.setData({ list });// 局部更新列表---√this.setData({ 'list[0].src': list[0].src}); 降低 setData 执行频率 在不影响业务流程的前提下，将多个 setData 调用合并执行，减少线程间通信频次。 善用自定义组件 小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似. 在页面引用自定义组件后，当初始化页面时，Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用. 基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。 当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。 当然，并不是使用自定义组件越多会越好，页面每新增一个自定义组件， Exparser 需要多管理一个组件实例，内存消耗会更大，当内存占用上升到一定程度，有可能导致 iOS 将部分 WKWebView 回收，安卓机体验会变得更加卡顿。因此要合理的使用自定义组件，同时页面设计也要注意不滥用标签。 总结小程序双线程架构决定了数据通信优化会是性能优化中一个比较重要的点。而上述提到的几个优化建议只是优化渲染性能中的一部分，要想让你的页面体验变得更加丝滑，就要熟悉小程序框架的底层原理，根据小程序框架的特点，编写出“合身”的前端代码。 小程序传递url里有特殊字符，比如+用 encodeURIComponent(JSON.stringify(address)),方式传递，在接收时，不用decode,直接获取即可如果不用encode，获取到的值里+会丢失 小程序textarea适配问题在页面中用到了textarea，测试发现的问题： 高度无法自适应 删除时，光标会自动到第一个 有的手机上多行展示不自动换行 解决办法: 挨个排除每个属性，看是哪个属性影响导致的。发现 auto-height 导致的问题，去掉auto-height，采用css设置height为固定高度，解决问题 处理一些兼容性问题时，要先看手百APP是不是最新版的，有可能是旧版的APP导致的问题","link":"/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/"},{"title":"小程序高性能打造之路","text":"原文链接 小程序页面的标准 极致的页面性能 友好的产品体验 稳定的系统服务","link":"/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%AB%98%E6%80%A7%E8%83%BD%E6%89%93%E9%80%A0%E4%B9%8B%E8%B7%AF/"},{"title":"思维导图列表","text":"执行有道四步法","link":"/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%97%E8%A1%A8/"},{"title":"思维导图笔记","text":"1.要想高效的利用本书，很重要的一点就是必须加强练习！！！ 2.左脑处理逻辑、词汇、表单、数字、线性和分析等所谓的学术活动。右脑主司节奏、想象、色彩、幻想、空间感、完整倾向(整体观念)和维度。 3.鼓励人们去开发他们以前认为很弱的脑区。会产生一种协同效应，使整个脑区的智力水平都随之提高。 4.当我们说自己某些方面行，某些方面不行时，我们实际是指已经很成功的开发出来了的潜力和尚未开发出来的，仍然处在蛰伏状态的潜能。如果能将蛰伏状态下的潜能开发出来，大脑将释放出巨大的“能量”。 5.大脑每分钟约要进行10万~100万次不同的化学反应。 记忆曲线 6.感知模型：眼睛-大脑-相机 按照一般人做白日梦的样子，闭上眼睛，想象你最喜欢的物体，在你心目中已经很清晰地记住其图像后，再做下列这些练习: 在面前转动它从顶部看它从底部看它改变它的颜色，至少3次。把她移开，就好像在很远处看它一样。再把它移回来。把它变的极大。把他变小。完全改变它的形状。让它消失。再让它出来。这些活动你做起来好不费事，可是相机的零件却完全无法做到。 思维导图_启动大脑 33页—————————————-2014/10/27 00:03 ————————————————————————– 大脑受限制的原因 与承认失败相比，更多人会说”我们只是普通人”，这种说法不足以令人信服！我们必须学习大脑是如何工作的，以便充分发挥自身无限的潜力。 2.我们的表现与我们甚至最小潜力不相符的原因就是，我们对自己所拥有的内在潜力一无所知，更不用说如何去充分利用了。3.一个普遍并且被严重误导的神话：人类本身就有不足之处，因此，这场灾难的责任应归结于人类本身的“缺陷”。 4.在全世界范围的教育系统内，人们之所以几乎没有花时间去学习如何学习，是因为我们对这台生物计算机的基本操作规则一无所知。 《启动大脑》 是第一本“大脑使用说明书”，它是专门用来帮助你了解、充实和保养你自己的“超级生物计算机”的，并教你如何释放你所拥有的自然且非凡的智能。 更快、更有效的阅读 1.我阅读存在的问题 阅读速度慢，阅读后会忘记、阅读的时间不能保证、阅读后当时掌握回头就会忘记、阅读的时候有些不能很快的理解 阅读定义:“从书中捕捉作者的意图”或“吸收所写文字的内容”。阅读是个人与符号信息之间发生的全部相互联系；它通常是指学习的视觉方面，并包含下述7个步骤。 辨识、吸收、内部整合、外部整合、保持、回忆、交流 4.3阅读问题存在的原因 答案除了我们早先对大脑缺乏认识之外，主要是因为我们早期的阅读教育方法不当。 眼睛在阅读时，实际是以一系列的停顿和快速跳跃的方式移动的。 提高速度 1.消除回读----90%的回跳和回读是因为担心不能对阅读材料完全理解而引起的。 2.每次凝视的时间可减到最低的1/4秒，------人的眼睛可以在1/100秒的时间内摄入5个单词。 3.凝视的间隔可扩展到一次摄入3~5个单词。 快速阅读的好处 快速阅读者的优势是他的眼睛在每一页上话费的物理运动较少，不会像慢速阅读者那样，每页紧张的聚焦凝视500多次。快速阅读者每页只凝视100次，其眼肌就不会疲劳。 另一个好处：能有节奏、流畅的阅读和轻松愉快的领略文章的意思。4.6 对阅读的误解 1.一次只能看一个单词————错。人的凝视能力就可以扩展，我们阅读的目的不是理解单个的词，而是整体意思。 2.阅读速度不可能超过每分钟500个单词—-错，每次凝视可以摄入6个单词，而且每秒钟可以凝视4次。这就意味着每分钟1000个单词的阅读速度是完全能达到的。 3.快速阅读者没法欣赏文章———-错。因为快速阅读者能更多的理解所读的内容，能更专注地看材料，所以他有更多的时间去回顾他认为特别有趣的和重要的部分。 4.速度越快注意力就越低——-错。读的越快，得到的刺激就越多，注意力就越集中。 5.一般阅读速度更自然，因此也就最好——错。因为一般阅读速度并不自然。它是早期不完善的训练，加之缺乏眼睛和大脑能以各种可能的速度阅读等方面的知识所造成的。 4.7.1 高级阅读技巧——快上加快 我们要做的不是叫他们把手指从书本上拿开，而是让他们更快的移动手指。它在帮助养成流畅的阅读节奏方面有着不可估量的作用。 用辅助物 阅读时阅读的速度更快。4.7.2 ———扩大焦点 结合视觉辅助技巧，特别适用于阅读一些轻松的材料和用来预习和复习，还可以提高正常的阅读速度。 很重要的一点是必须使用视觉导引物 试着采用如斜对角线、曲线和沿书页直线向下等各种视觉导引物。4.7.3 快速理解 尽快从一页浏览到下一页，并尽可能多看一些单词。这种训练可增加每次凝视时摄入更大范围的单词群的能力，也适用于练习纵览和预览技巧，并能把大脑调整到适应更快速、更有效的整体阅读练习状态。 4.8 动机训练 计算每分钟阅读速度的公式： 阅读速度=（所读页数*每页平均单词书）/阅读的分钟数4.9 节拍训练 调整到合理的节奏、即每一拍代表视觉引导物的一次移动的话，用这种方式可以保持一种稳定、连贯的节奏、并可克服阅读开始后不久出现的阅读速度下降的问题。一旦找到最佳的节奏，就可通过每分钟偶尔加一拍的方式提高你的阅读速度。————2014/10/28 00:15——————- 5.3 记忆趋势：在学习期间的开头和结尾记得多；多次重复、易感知、有节奏的内容记得多；突出或独特的内容记得多———–冯-雷斯托夫效应，而学习期间的中间阶段所能机翼的内容却相当少。 要想保持在一个相当高的水准，必须找到记忆与理解最和谐的工作点。 在正常情况下，这一点出现在学习开始的20~50分钟之间。 学习期间的短暂间隔也常用于放松、消遣。可以使集中注意力学习时紧张的肌肉和神经得以放松。 学习后的回忆量最初是上升，之后才是下降，再后是一条逐渐下降的、以水平线结尾的凹形曲线。 短暂上升的原因：在学习结束的瞬间，大脑没有足够的时间去整合刚学的新信息，尤其是最后的部分。它需要几分钟的时间将新材料之间的相关联系牢固地连接起来，即使之“沉淀下来”。 小幅上升之后是一个陡峻的下降，在学习一个小时之后的24小时之内，至少有80%的细节被遗忘了。 5.5 记忆–复习的技巧和理论 安排有计划的复习，而且每次复习必须安排在回忆刚开始下降之前。 eg:第一次复习应该在学习1小时之后的10分钟开始，复习时间以5分钟为宜。这样可以使记忆在高位保持1天左右，然后应该进行第二次复习，时间为2~4分钟。此后，记忆将保持一周左右，然后在一个月之后再次复习约2分钟。经过这最后一次复习，此项知识将被转为长期记忆。 如果已经做过笔记的话，第一次复习应该是对笔记的全面修订过程，这就意味着要取代原来的笔记的“最终版本”。而第二、三和四次复习则应采用下列方式:不看整理过的笔记，用一张纸概括记下所能回忆的一切，然后将其与整理后的笔记对照，再进行修改和补充。笔记和草稿都应做成思维导图。 合理复习最重要的一个方面是作用于学习、思维和记忆等各方面的累计效应。 每次接触新知识时，人们对已学知识的记忆处于低谷，原有知识间自动产生的连接会解体。这样，他对新知识的理解就不能达到应有的水平，效率和速度也必然很低。这种连续的消极过程会使人感到沮丧，最终对能学好的东西也失去了信心-----只要一学新东西就会忘记，一接触新东西心理上就会感到压抑。结果是很多人在完成了正式的考试之后，就很少甚至根本不再碰书本。 失败的复习对整体记忆同样有害，如果忽略每条新信息的话，那么它将不再保持在意识层中，也不能形成新的记忆链接。由于记忆是一个以连接和联想为基础的过程，因而“记忆库”中的东西越少，其接纳和连接新知识的可能性就越小。 相反，复习的好处是无穷的。 2014/10/29 10:54 使用某些方法使我们能利用记忆的连接和联想能力，来把这些事项与其对应的数字关联起来。 最好的方法是数字-韵律法。 5.7记忆的“SMASHIN” SCOPE 法 在这种方法中最重要的是要保证押韵字与所要记忆的单词必须全部准确的连接起来。 1.通感/感官(Synaesthesia/Sensuality) 通感，指的是多种感觉的融合。 视觉、听觉、嗅觉、味觉、触觉、动觉—对身体在空间中的位置与运动的感觉。 2.运动(Movenment) 在任何记忆的形象中，运动可以极大的增加大脑连接和记住东西的可能性。—-这里指记忆的形象的运动性。 3.联想(Association) 确保使它与你的内省的某些稳定不变的事物联想或连接起来。衣钩法：1=面包。 4.性(Sexuality) 要加以利用! 5.幽默(Humour) 想象越有趣、越荒谬、越愚蠢、超越现实，就越容易被记住。 6.想象(Imagination) 爱因斯坦说：“想象比知识更重要，因为知识是有限的，而想象却能包容全世界、促进进步、孕育革新。” 在记忆中应用的想象越多，记忆就会越好。 7.编号(Number) 按数字编号使顺序及次序的规则更有针对性，更有效。 8.符号(Symbolism) 用丰富多彩的想象；可以用传统的符号，如休止符、灯泡。 9.颜色(Color) 在适当的地方尽可能使用各种颜色，可使你的想法色彩斑斓，更易于记忆。 10.顺序和/或次序(Order and /or Seguence) 结合其他规则，排列顺序和次序起到了更直接的参考作用，并增加了大脑“随机存取”的可能性。将排列顺序和次序的应用加以扩展，能使你开发记忆矩阵，如自我增强型记忆矩阵。 11.“积极”的形象(Positive Images) 积极愉快的形象更利于记忆，这使大脑乐于工作。 12.夸张(Exageration) 在所想象的情景中，夸大尺寸、形象和声音。 12个记忆要素很容易用它们的首字母组成的单词“SMASHIN” SCOPE 来记。 5.8 数字–韵律法 在形成头脑中的形象时，很重要的一点是,要在“心目”中看到清晰的图像。经常闭上眼睛，将想象的情景投影到你的眼脸内部，或投影到你大脑的屏幕上，并且去听、去感觉、去闻，或者用对你来说最有效的方式去体验。原书84页。 所有方法中尤其有效的是基本记忆法。它能以“数字-韵律法”的方式记住1000条以上的信息，并且能给出记忆数字与日期的关键方法。“名字-面孔记忆法”能避免你在碰到曾经见过面的人时，避免尴尬。5.9 不可能完成的任务 记忆基本上是一个联想和连接的过程，而且很大程度上取决于关键字，以及用于恰当想象的关键概念。 6.思维导图–词汇与思维特征的介绍6.1 练习与讨论蟋蟀 四象限法则策略：如果你总是有紧急又重要的事情要做，说明你在时间管理上存在问题，设法减少它。尽可能地把时间花在重要但不紧急（第二象限）的事情上，这样才能减少第一象限的工作量。对于紧急但不重要的事情的处理原则是授权，让别人去做。不重要也不紧急的事情尽量少做。","link":"/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/"},{"title":"数据库分享","text":"Sharding-Sphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar这3款相互独立的产品组成。他们均提供标准化的数据分片、读写分离、柔性事务和数据治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。","link":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E4%BA%AB/"},{"title":"日常掉坑记","text":"日常掉坑记1. scrollIntoView该方法可以很好的解决页面内锚点跳转，不用在url里加#锚点 在QQ浏览器下会无法滚动到指定锚点, 在有些版本的Chrome里也会遇到 12const element = document.getElementById('box');element.scrollIntoView({behavior: &quot;smooth&quot;}); 去掉{behavior: &quot;smooth&quot;}可以正常滚动 解决方案123456const button = document.querySelector('#box');window.scrollTo({ top: button.offsetTop, left: 0, behavior: 'smooth'}); 经测试，在IE和UC中这个方法也不好使。所以最终方案是 12const element = document.getElementById('box');element.scrollIntoView(); 缺点是没有动画效果。可以根据兼容性要求来选择方案。 Clipboard 触发事件的元素一定要用button才能生效。 视频播放到最后一帧黑屏经测试，是视频本身黑屏 浏览器用window.innerWidth 为1280，为何浏览器截图为1920，因为电脑设置了显示比例。150%，所以会出现显示异常。 背景透明不要用opacity，要用rgba()用opacity会导致背景透明文字也透明。 背景透明，文字也透明解决办法 设置z-index失效， 发现在容器中可用，position absolute离开容器后就看不到了， 原因： 父容器设置了overflow:hidden, 所以如果要移到合适的位置，需要把合适的位置也放到父容器中。 bootstrap每列之间没有间隔，看起来中间有间隔，点击的时候还是会触发点击事件， 解决办法： 把绑定事件加在每列中的内容区域，而不是col-md上。 form表单提交文字带图片 如图片是单独的字段，没有问题{‘pic’:url, text: ‘’} 如果是富文本？文字图片混在一起，怎么处理。答案：在富文本编辑器里，上传图片会要求配置上传图片路径，放入的图片会先上传返回图片地址。 2018-7-11 16:31:43 滚动条吸顶效果经验总结 12345678910111213141516var menu= document.getElementById(&quot;nav&quot;);//获取距离页面顶端的距离var titleTop = menu.offsetTop;//滚动事件window.addEventListener(&quot;scroll&quot;, function() { var btop = document.documentElement.scrollTop || document.body.scrollTop; //如果滚动距离大于导航条据顶部的距离 if(btop &gt; titleTop) { //为导航条设置fix $(&quot;.nav&quot;).addClass(&quot;fixed&quot;) } else { //移除fixed $(&quot;.nav&quot;).removeClass(&quot;fixed&quot;) }}); 为了减少页面重绘次数增加延时功能 123456789101112function callback(){ //do something console.log('scroll once..');}var timeoutRef;window.addEventListener('scroll' , function(){ if(timeoutRef){ clearTimeout(timeoutRef); } timeoutRef = setTimeout(callback , 50);}) 如果要吸顶的元素在页面中间，会造成页面抖动，需要吸顶的元素设置position:fixed后移到顶部造成页面高度发生变化重新触发scroll方法， 解决办法： 将需要吸顶的元素父容器设定最小高度，即使位置发生移动，也有固定高度在，不会触发scroll方法。","link":"/posts/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91%E8%AE%B0/"},{"title":"沟通技巧","text":"2. 如何跟爸妈打电话—哄父母开心的三心技法安心，舒心，开心， 我们才能放心 父母不知道说什么，我们也不知道说什么提升跟父母的童话质量 细节–安心大而笼统的话越不放心少操心，早睡早起，多吃饭，一切都好请放心–会觉得藏着掖着报喜不报忧 说细节，看了什么电影，电视剧，跟哪个朋友吃了饭 细节暗示比信誓旦旦更有效 问题–舒心问题使他们舒心经常在电话中向他们提问，最好问生活中他们得心应手的问题 排骨汤怎么炖 衣服怎么洗好 夏天吃什么水果比较健康 耐心听取答案，做出恍然大悟的回应 最好不要问工作中的问题 拿对比使他们开心父母们在儿女这个话题上要有发言权让他们有值得骄傲和炫耀的话题点，实际成就并不重要，只需要多说说和同事朋友的八卦。 某同事没女朋友，某同事还没结婚，某同事没工作了。让父母有谈资，舒缓父母社交压力 父母主动社交能力在不断下降，孩子承担起主动沟通的责任，并提供父母沟通的谈资 人的一生都是社交的一生 用细节让父母安心，意味着你要向他们呈现真实生活，把自己置于汇报者的地位用问题让父母舒心，你要让他们感觉到他们对你的生活是有意义的，是能够提出指导意见的，是有权威的用对比让他们开心，你要向他们证明你是值得他们炫耀的，是能够让他们在社交的时候特别有面子的。 这样的沟通技巧还能用在其他很多方面，开通脑筋，好好说话 3. 观冲突，该怎么聊","link":"/posts/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/"},{"title":"百度小程序经验积累","text":"[TOC] 重启大法如果遇到以下问题，不要怀疑自己，请重启 样式不生效 页面不能正常渲染 项目编译失败 写的新组件，引用后不生效 编译报错开发者工具报一堆不是代码的错误，检查调试基础库的版本 查看项目信息-&gt; 调试基础库-&gt; 3.40.28 组件编写 新创建的文件夹在引用时不生效 解决方案： 重启开发者工具 引用组件名称不能是驼峰写法(arrivalDialog)，必须用arrival-dialog 组件引用后，在页面出现两个相同的DOM 原因: 组件中有语法错误 json文件 1234567{ &quot;component&quot;: true, &quot;usingComponents&quot;: { &quot;popup&quot;: &quot;/pages/components/popup/popup&quot;, &quot;btn-group&quot;:&quot;../btngroup/index&quot; }} 子组件接收参数要在properties中定义 123456789properties: { dataSource: { type: Object, value: null, observer: function(newVal, oldVal) { this.renderView(); } }} 如果子组件里要根据父组件里传来的数据进行业务逻辑处理，需要在observer里重新setData 组件的方法要写到methods: {}里 事件绑定 在子组件调用父组件的方法，要逐级传递，不能漏掉其中一层 子组件调用父组件的方法 123closeModal(e) { this.triggerEvent('toggleReservationDialog', {isShow: false});} 引用子组件 123&lt;order-dialog bind:toggleReservationDialog = &quot;toggleReservationDialog&quot;/&gt; 事件传参 1this.triggerEvent('arrivalSubmit', {telephone: input}); 在父组件arrivalSubmit中，获取参数不能直接取到telephone这个对象小程序会再包一层，用以下方式获取 1const telephone = e.detail.telephone; 小程序自身缺陷 s-if中的表达式 12345&lt;!-- 无法识别，会报错 --&gt;&lt;!-- &lt;swan s-if=&quot;{{+res.code === 1}}&quot;&gt; --&gt;&lt;swan s-if=&quot;{{res.code === 1}}&quot;&gt;&lt;/swan&gt; 表达式过于复杂，会导致DOM无法渲染 for循环无法一次循环两条数据，不能修改当前index. 解决办法: 先处理好数据结构再循环 css语法不能识别color: var(--color-white);(之前可以识别~~~) React代码迁移到小程序经验html结构直接拷贝到swan文件 div替换为view p, h1-h6 等替换为view, 原来的标签样式替换为view后加class。如: &lt;view class=&quot;h1&quot;&gt;&lt;/view className替换为class onClick替换为bindtap onclick传参需要在js方法里传递，参数具体值可以用data-绑定到dom上，在js中通过e.currentTarget.dataset.获取, 如果当前组件只有一个data，不是数组类型的数据, 可以直接从this.data中获取 less通过转换工具转成css，px替换为rpx，数值都需要*2。如：width:20px---&gt; width: 40rpx; js setState替换为setData jsx中根据条件渲染的DOM可以根据具体情况看拆分成新组件还是通过s-if, s-else解决 想查看某个js变量的值，可以绑定到DOM上查看，如 1&lt;swan item=&quot;{{item}}&quot;&gt;&lt;/swan&gt; 强制触发小程序页面渲染的方法 在组件properties里定义变量名, 以及监听事件 123456789properties: { data: { type: Object, value: {}, observer(newVal, oldVal) { this.processData(); } }} 设置变量为null,再设值 1234567this.setData({ dataList: null}, () =&gt; { this.setData({ dataList: [1, 2, 3] });}); 强制销毁DOM, s-if设为false，再设为true在设置style=background-color: rgba(255, 255, 255, ${opacity});时, data已经发生变化，但页面没改变 样式问题在view里包一个image元素，如下 12345678&lt;view class=&quot;con&quot;&gt; &lt;image src=&quot;https://cms-dumall.cdn.bcebos.com/cms_upload_pro/cms_1569467395902.jpg&quot; mode=&quot;widthFix&quot; class=&quot;image&quot; /&gt;&lt;/view&gt; css 12345678.con { background-color:crimson;}.image { width: 100%; margin-top: 12rpx;} 这时候image会有多余的背景色出现, 原因是image元素为inline-block元素，通过设置`display: block;`解决 动画实现一些复杂的动画不能通过样式来实现，只能通过提供的Animation API来实现，非常麻烦~~~ scroll-view高度必须固定通过css设置height: 100vh; 解释：使用竖向滚动时，需要给定一个固定高度，可以通过css来设置height。 终于支持async了啊， 真不容易2019-12-26 20:06:33音频播放不要用audio组件，直接用API里的innerAudioContext开发。拖动条用slider组件 跳到指定位置播放用InnerAudioContext.seek 音频播放器播放时控制slider问题播放会自动设置slider的值，但是拖动时也会设置值，会有闪烁的效果 解决方法： 拖动时，暂停播放，结束后开始播放","link":"/posts/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"},{"title":"知识点","text":"xss限制脚本执行方法 csp content script policy setState多次调用，怎么执行，原理 css header固定，下面百分百布局 css画各种图形 组件添加自定义内容， 浏览器渲染页面过程 css动画不触发layout react diff 算法 promise多级调用 字符串加减乘除类型的转二叉树执行结果 两个数组去重，这个里不包含那个里有的 异步用action，同步的请求怎么处理 Dispatch了action，是怎么识别这个action的 redux流程，代码要写出来action怎么定义，怎么dispatch到reducer中，怎么触发dispatch 发送action action怎么反馈到reducer reducer处理数据的目的是什么 webpack 清除缓存思路hashchunk和chunk区别 promise多次依赖异步调用手写代码1 Promise.then().then()多个promise.then().then() 如果前面的.then报错后，后面的还会执行吗 flex如何超出范围后出现滚动条？？？ Typeof还是要看的 √ 对象后面跟数字，排序 sort √ Vue的一些常用指令 √显示Html v-html Fouc， √ V-text Watch深度监听 deep: true √Data和computed区别，缓存 Pop，push, 对应栈 在尾部删除添加shift，unshift 对应列，在头部删除添加 React vue生命周期结合路由钩子说明 Promise是什么√ Let和var的区别√ 闭包，回调 事件委托 Redux的原理，流程 浏览器url包含什么 √ Jsonp缺点，原理√ Vue，react区别 Ajax是什么，状态码 Git回滚上一个版本√ Git pull和rebase merge√ 左右布局方法 Audio Promise实现异步队列 Map和set区别，怎么用Set和arrayset key不能重复Map和foreach Js数组转对象用reduce实现map jQuery扩展组件怎么写 Ajax有哪些参数 大文件怎么上传，低版本浏览器怎么兼容 React同级组件传值 Clone方法克隆绑定事件 slice,splice长连接实现方式 socket和websocket区别 轮询和长轮询区别 map和reduce，用map实现reduce 实现a().b().c() 定义{}，每个方法return this for in for of 区别 可枚举和不可枚举的区别 上传文件方式，url-form，formData是什么 浏览器中的缓存有哪几种，具体怎么工作的 强缓存和协商缓存 实现并发请求多次，依次返回结果。 如果第二个结果依赖第一个结果怎么写 nextTick, setImmediate, promise require ,exports ,module.exports 区别 面试总结：js: this指向，Promise this 闭包是什么，说出来， 写出来，能读懂程序 原型链 原型说出来，写出来，读懂。。。 react和vue区别 设计模式 算法 个人项目中遇到哪些难处理的问题，怎么解决。 性能问题有哪些，怎么解决， 移动端有哪些兼容方案(rem) Generator 是什么， Promise是什么 给一个数组，找出最大最小值，什么方法最快 测试的话有哪些边界值需要考虑， 状态码 深拷贝，浅拷贝 区别 react生命周期，每个生命周期都是什么，有哪些特殊用过的， 不用Promise怎么实现Promise.all 写个方法克隆js原始类型 CSS: 瀑布流原理 column 居中布局有哪些方法 http相关http协议理解 http是什么描述，有哪些层，每层都有什么， ip在哪一层 网络层是干嘛的 传输层有哪些协议， tcp/ip协议 数据从http传过来，每一层都做什么处理 tcp和udp有什么区别 个人亮点是什么 有遇到什么特殊的经验 公司待遇，薪资福利 工作内容 因为状态不好因为不自信 面试态度，心态很重要啊，要微笑，面试之前微笑，给自己打气！释当缓和气氛，说话不要着急，不要抢答，慢条斯理说出自己知道的，不知道的猜猜，猜不出来微笑大胆承认不知道，把谈话的氛围搞好很重要，即使不会，也让面试官觉得你是暂时忘了，演技要上线不能大意失荆州，一些基础的css样式要完全正确手写出来！！！ 学习知识要全面，了解了异步不能不知道同步该怎么写， 判断两个元素是否为包含关系 contain, indexOf css flex 模型 一个元素 如div 从top为0 移动到top 任意 的动画效果 原生代码 52张牌 平均 随机分给4个人 快速排序 10进制转64进制 轮播导航：慢滑无惯性滑动效果，快滑要惯性滑动 原生 给你一个网站 如何分析它的性能 以及 说说 优化策略 vue angularjs 实现数据绑定的原理 react 虚拟dom原理 用过哪些h5的api localStorage 使用有什么想法 好处 缺点 你怎么用的 如何用js获取一个元素的宽 和 高 1234567891011121314151617181920212223&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;#box{ background-color: lightgrey; width: 300px; border: 25px solid green; padding: 25px; margin: 25px; height:60px;}//获取盒子的内容高度，内容高度也可用用box.clientHeight获取，内容高度不包括边框和外边距和滚动条var box = document.getElementById(&quot;box&quot;)var contentHeight = window.getComputedStyle(box).height //输出 '60px'//获取盒子客户端的高度box.clientHeight //输出110 (内容高度+padding * 2)//获取盒子自身实际高度box.offsetHeight //输出160 (内容高度 + 内边距*2 +边框*2)如果box的父容器没有设置定位，则box.offsetLeft是相对body而言，否则是根据离它最近且有设置定位的父容器而言box.offsetLeft //获取box盒子相对它的父容器水平的偏移box.offsetTop //获取box盒子相对它的父容器垂直的偏移 盒子模型有几种 行内元素 块元素 有哪些 区别有哪些 实现 左边定宽 右边自适应布局 字符串反转 递归和循环 互相转换 性能调优策略 事件模型 原型链 以及 如何判断一个属性 是属于该对象 还是继承自原型链 单页应用你怎么理解 做过吗 聊聊 你常用什么设计模式 聊聊 跨域解决策略和原理 浏览器渲染过程 有哪几浏览器内核 css 动画 用过哪些模块加载工具 聊聊 写出几个常见的块级元素和行内元素 如何转换这两种标签的行为 请写出”me” “you” 所在元素的实际行高 12345&lt;div style=&quot;font-size:14px;line-height:3&quot;&gt; &lt;div style=&quot;font-size:2em&quot;&gt;you &lt;span style=&quot;font-size:3em;line-height:3em;&quot;&gt;me&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 列举5种 触发ie hasLayout的属性及其值 画出css盒子模型 请写出至少3个css3种新添加的样式属性 实现以下方法（与标准一致）a.Element.prototype.getElementsByClassNameb.Function.prototype.bindc.Array.prototype.everyd.Object.create 写出javascript有几种基本数据类型 以及如何判断一个变量是数组 编写一个方法 去掉一个数组的重复元素 写出以下程序的计算结果var str = “hello”;var fn1 = function(){console.log(str); //hello}var fn2 = function(){var str = “world”;fn1();}fn2()//结果 编写一个方法shuffle得到一个数组的随机副本要求var arr1 = [2,5,3,1,7,12,57,234]var arr2 = shuffle(arr1);// arr2 =&gt; [234,2,3,1,7,57,12,5] 写一个判断 传入的字符串是数字的 方法 说出思路 （isNaN） 用过数组的哪些api 处理兼容性问题有哪些hack 考事件委托：如果你有一个列表,需求是 原生来写 点击li要触发一些行为，但是这个列表是动态的，比如我可能下拉刷新 新加载上5条数据 那么这个事件怎么绑定 css 布局如何实现垂直居中 都有哪些方法 怎么看一个css动画 是否流畅 重绘和重排 ，什么情况引起重绘 什么情况引起重排 怎么避免；重绘能引起重排吗 重排能引起重绘吗 考察闭包：写一个函数 作用是 第一次执行输出1 第二次输出2 第三次输出3 考察算法： 比如你有一个广告点击的排名列表 从高到底 ，现在你有一个广告 点击次数500 如何快速从这个列表里 返回这个广告的位置 jsonp的原理和缺陷 为什么通常放在后面 有没有什么情况必须放在head里，script标签中async 和 defer的作用 除了 做雪碧图 、 压缩混淆js 还有什么提升网页加载速度的方法 前端安全 有哪些了解 javascript的作用域分析 cookies sessionstorge 和 localstorage的区别 分析给出的代码localstorage.setItem(“test”,{a:”1”,b:”2”})localstorage.getItem(“test”) //拿出来的是什么//“[object Object]” 用到了哪些css3的东西 通过 循环每个列表里的元素 来跟 目标元素做对比 ，找到这个元素的时间复杂度是多少 写一个判断正整数、小数、负数的正则 http 通信的四个方法 delete get post pull 都干嘛的 get和delete的区别 实现$.ready() 几种模块加载工具的对比 amd cmd规范 构建工具用过哪些 你做过技术选型吗 聊聊 ajax原理，状态码，阶段值（需要能够当场手写原生XMLHttpRequest 实现get post） 写过node吗 回调金字塔 你如何理解的 如何应对（想考promise 聊聊promise的理念和api 异常处理方法） setTimeout 和setInterval 可靠吗如果回答可靠 考官会给你写一段代码 问你执行情况如果回答不可靠 考官会问你 为毛不可靠 聊聊css定位 （如果你想加分 可以说fixed情况下的坑） 移动端开发经验 写过视觉差效果咩 怎么写的","link":"/posts/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"算法","text":"十大经典排序算法总结（JavaScript描述）链接 冒泡排序 &amp; 选择排序 &amp; 插入排序 &amp; 希尔排序 JavaScript 实现 递归，while遍历树结构8个苹果一个坏的，外形与其他相同，只有重量不同有个天平，用2次把坏的找出来，怎么称 答案： (3,3)+ (1,1)两次 首先我们来确定一件事,就是坏的苹果应该是比其他的要轻.第一步,把苹果分为3+3+1+1;第二步,称重; 3+3 放到天平两端,如果平等 再放1+1,也就是两边各放一个,倾斜,向上端,最后放的是坏的. 3+3 放到天平两端,如果倾斜, 取向上端3个苹果,分为1+1+1,两边一边一个随便放,如果平衡,没放的一个是坏的,如果倾斜,向上的是坏的.没有其他情况了,两次就可以称出. 1. 冒泡排序重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 平均情况：T(n) = O(n^2) 复杂度时间复杂度：平均时间复杂度O(nn) 、最好情况O(n)、最差情况O(nn)空间复杂度： O(1)稳定性：稳定关键：两次循环 i=0,i&lt;len; j=0, j&lt;len-1-i j 和j+1置换 123456789101112131415161718function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len; i++) { // 注意这里的len-1-i, 如果写len-1也是可以的，但是会有多余的内层循环 for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 2.选择排序（Selection Sort）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 最佳情况：T(n) = O(n²)最差情况：T(n) = O(n²)平均情况：T(n) = O(n²) 12345678910111213141516171819function selectionSort(arr) { const len = arr.length; let minIndex, temp; for (let i = 0; i &lt; len - 1; i++) { minIndex = i; for (let j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { //寻找最小的数 minIndex = j; //将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr;}var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 3.插入排序（Insertion Sort）1234567891011121314151617181920function insertionSort(array) { if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') { console.time('插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) { var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } console.timeEnd('插入排序耗时：'); return array; } else { return 'array is not an Array!'; }} 6.快速排序（Quick Sort） 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Javascript代码实现：/*方法说明：快速排序@param array 待排序数组*///方法一function quickSort(array, left, right) { console.time('1.快速排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') { if (left &lt; right) { var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) { if (array[j] &lt;= x) { i++; temp = array[i]; array[i] = array[j]; array[j] = temp; } } quickSort(array, left, i - 1); quickSort(array, i + 1, right); } console.timeEnd('1.快速排序耗时'); return array; } else { return 'array is not an Array or left or right is not a number!'; }}//方法二var quickSort2 = function(arr) { console.time('2.快速排序耗时'); if (arr.length &lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++){ if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } }console.timeEnd('2.快速排序耗时'); return quickSort2(left).concat([pivot], quickSort2(right));};var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]作者：Damonare链接：https://juejin.im/post/57dcd394a22b9d00610c5ec8来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 讲的好的算法快速链接 阮一峰快速排序链接 js算法目录 二叉树的概念二叉树节点定义如下： 1234567struct BinaryTreeNode{ int m_nValue; BinaryTreeNode* m_pLeft; BinaryTreeNode* m_pRight;}; 完全二叉树一个深度为k，节点个数为 2^k - 1 的二叉树为满二叉树（完全二叉树） 二叉树的性质二叉树的性质一：在二叉树的第i层上至多有2^(i-1)个结点(i&gt;=1) 二叉树的性质二：深度为k的二叉树至多有2^k-1个结点(k&gt;=1) 二叉链表lchild data rchild data为根节点， lchild为左子树，rchild为右子树 二叉树的遍历有三种方式，如下12345678910111213141516171819202122232425262728293031323334353637383940（1）前序遍历（DLR）， 首先访问根结点，然后遍历左子树，最后遍历右子树。 简记根-左-右。（2）中序遍历（LDR）， 首先遍历左子树，然后访问根结点，最后遍历右子树。 简记左-根-右。（3）后序遍历（LRD）， 首先遍历左子树，然后遍历右子树，最后访问根结点。 简记左-右-根。//先序遍历function preOrder(node){ if(node){ console.log(node.value); preOrder(node.left); preOrder(node.right); }}//使用递归方式实现中序遍历function inOrder(node){ if(node){ inOrder(node.left);//先访问左子树 console.log(node.value); inOrder(node.right);//最后访问右子树 }}//后序遍历function postOrder(node){ if(node){ postOrder(node.left); postOrder(node.right); console.log(node.value); }} 二分查找概念在一个已排序的数组seq中，使用二分查找 v (要查找的元素)，假如这个数组的范围是[low…high]，我们要的v就在这个范围里。 查找的方法是拿low到high的正中间的值，我们假设是m，来跟v相比，如果m&gt;v，说明我们要查找的v在前数组seq的前半部，否则就在后半部。无论是在前半部还是后半部，将那部分再次折半查找，重复这个过程，知道查找到v值所在的地方。实现二分查找可以用循环，也可以递归，先给出两种方式的伪代码。 Java版使用循环实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public static int search(int[] seq, int v, int low, int high) { while (low &lt;= high) { int mid = (low + high) / 2; if (v == seq[mid]) { return mid; } else if (v &gt; seq[mid]) { low = mid + 1; } else { high = mid - 1; } } return Integer.MIN_VALUE;}使用递归实现 public static int search2(int[] seq, int v, int low, int high) { if (low &gt; high) { return Integer.MIN_VALUE; } int mid = (low + high) / 2; if (v == seq[mid]) { return mid; } else if (v &gt; seq[mid]) { return search2(seq, v, mid + 1, high); } else { return search2(seq, v, low, mid - 1); } }JS 版本// 非递归算法 function binary_search(arr, key) { var low = 0, high = arr.length - 1; while(low &lt;= high){ var mid = parseInt((high + low) / 2); if(key == arr[mid]){ return mid; }else if(key &gt; arr[mid]){ low = mid + 1; }else if(key &lt; arr[mid]){ high = mid -1; }else{ return -1; } } }; var arr = [1,2,3,4,5,6,7,8,9,10,11,23,44,86]; var result = binary_search(arr,10); alert(result); // 9 返回目标元素的索引值// 递归算法 function binary_search(arr,low, high, key) { if (low &gt; high){ return -1; } var mid = parseInt((high + low) / 2); if(arr[mid] == key){ return mid; }else if (arr[mid] &gt; key){ high = mid - 1; return binary_search(arr, low, high, key); }else if (arr[mid] &lt; key){ low = mid + 1; return binary_search(arr, low, high, key); } }; var arr = [1,2,3,4,5,6,7,8,9,10,11,23,44,86]; var result = binary_search(arr, 0, 13, 10); alert(result); // 9 返回目标元素的索引值","link":"/posts/%E7%AE%97%E6%B3%95/"},{"title":"线上问题追查通用方法","text":"处理原则 止损原则 及时通告 逻辑方法 分维度，判定影响面，缩小范围 有胆有识 心态准备迅速精准，–脚本功底，信心大胆假设，–思路清晰开放，没有SOP止损意识 —无损判断质疑所有 —各个数据、结论(监控系统)有效性有的放矢 —逻辑思维 知识准备日志—各字段意义要非常熟悉配置—尤其是调度相关的要了然于胸细节—每次更细一点命令—基本功(linux每个命令，每个参数) 知识积累 演进过程","link":"/posts/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E8%BF%BD%E6%9F%A5%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"编辑器掉坑记","text":"最近项目经常遇到定制化开发上传视频的需求，现在一些通用的视频基本不满足需求。 这篇文字记录一下遇到的问题和学到的知识。 前端常见的编辑器一般都不支持上传视频 ueditor除外,但现在还没看到ueEditor在React项目中使用。 插入视频解决方案：在编辑器值中插入html的video标签poster用于设置视频封面 12&lt;video src=&quot;&quot; poster=&quot;&quot;&gt;&lt;/video&gt; 插入自定义内容比如插入一段HTML 原理，先拼装好html，调用编辑器API将HTML插入。 本质是执行了document.execCommand(MDN链接) 其中的参数可以设置包括加粗(bold), 插入图片(insertImage) 自定义内容的话，insertHTML可以插入HTML。 之前还考虑过将一段html复制到剪切板，通过paste命令将自定义的一段HTML拷贝到编辑器中。 关键问题，插入后，怎么作为整体处理，删除一起删除，按回车会(或不会)生成同一个相同的块. 考虑将插入的一段HTML最外层设置成contentEditable=false，可以使整段插入的HTML不能编辑。但在回车或删除时，会遇到无法删除等问题。 现在的编辑器机制都是通过修改div的contentEditable=true来实现插入HTML。","link":"/posts/%E7%BC%96%E8%BE%91%E5%99%A8%E6%8E%89%E5%9D%91%E8%AE%B0/"},{"title":"网站搭建","text":"网站创建历程1. 买域名https://wanwang.aliyun.com/domain/searchresult/ 先要起名字，找到合适的域名。 找好后直接付款支付就ok了。 1.1 实名制需要身份证照片。 直接拍照，上传，ok，等2个工作日。 服务器 购买地址 云服务器ECS（包年包月）地域: 华北 1可用区: 华北 1 可用区 BI/O 优化实例: 非 I/O 优化实例实例规格: 1 核 2GB网络类型: 经典网络带宽: 1Mbps（按固定带宽）操作系统: CentOS 7.2 64位系统盘: 40GB 普通云盘密码: 已设置实例名称: oriht linux学习：http://wiki.jikexueyuan.com/project/linux-command/chap03.html 登陆的操作：ssh root@ip 三：连接数据库：mysql -uroot -proot //p 还有就是遇到死链接的问题需要 配置路由：‘URL_MODEL’=2;或者配置为0 和3 这里需要仔细查看TP手册部署那里。 直接写路径就可以 3。chkconfig –level 35 vsftpd on4.yum -y install vsftpd;5 cd /home/wwwroot/default/6 chmod 777 /home/wwwroot/default/chmod 777 /home/wwwroot/default/ -R这里要注意的是权限问题：你要把application目录权限-777例如：chmod 777 /home/wwwroot/default/ -Rchmod -R 777 /home/wwwroot/default/ 在centos上安装git 备案流程 网站备案信息真实性核验单 [查看样例] 请打印3份，按照样例分别填写并全部邮寄 申请邮寄幕布 您自行拍照后上传 远程拷贝拷贝远程服务器的文件到本地: 1scp -r -P 端口号 用户名@IP地址:/usr/local/tomcat_airc/webapps/ /tmp/kyj/ 拷贝本地文件到远程服务器: 1scp -r /tmp/kyj/sys.war 用户名@IP地址:/usr/local/tomcat_airc/webapps/ 服务器信息 php的默认端口是8080 nginx的默认端口改成80 https配置 在阿里云买好证书， 在nginx安装目录下新建cert目录cd /usr/local/nginxmkdir cert 将证书下载下来，复制到cert目录下 scp -r 本地文件目录 root@(ip):/usr/local/nginx/cert/ 这里有123.pem 和123.key,两个都要传到远程服务器 配置后不生效 curl -l http://oriht.com wget http://oriht.com 需要进入阿里云服务器的实例里，找到安全组规则，配置443访问权限。才能访问https的端口 nginx no input file specified 查看nginx error.log, 发现是nginx之前的配置找不到路径之类的问题，先将所有的其他配置注释掉，mv **.conf **.conf.bak 又报502 Bad Gateway 说是nginx-fpm的占用内存太多，默认进程数太少 1、查看php fastcgi的进程数（max_children值） netstat -anop | grep php-cgi | wc -l1、查看php fastcgi的进程数（max_children值） netstat -anop | grep php-cgi | wc -l 3、调整/usr/local/php/etc/php-fpm.conf 的相关设置 12pm.max_children = 5request_terminate_timeout = 60 部分PHP程序的执行时间超过了Nginx的等待时间，可以适当增加nginx.conf配置文件中FastCGI的timeout时间，例如： 12345678http{……fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;……}","link":"/posts/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"title":"羽毛球速成","text":"握球拍的手势 时刻保持主动出击状态， 不要打完一个球后，就定住不动站着看，等球再过来就没有时间启动身体反应了 网前挑球时对手是轻打过来的，要使劲打到后场 如果对手轻挑过来，你再轻挑，球的弹力不够很难过网 后场球挥拍扣杀姿势要好好练 练好扣球才能得分赢球 打球姿势要录视频看是否正确，可能自己觉得正确，实际是错的。 握拍手势和挥拍姿势是基础！！！ 要有刚有柔, 才能对球控制自如。","link":"/posts/%E7%BE%BD%E6%AF%9B%E7%90%83%E9%80%9F%E6%88%90/"},{"title":"自动格式化-md,js,css,html等","text":"自动格式化md文档文档链接 用VSCode编辑器安装markdownlint扩展 保存时自动格式化需要在settings.json中配置 打开setting.json方法按command+p,输入settings.json 123&quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll.markdownlint&quot;: true} 即可生效 js文件自动格式化尝试了用Prettier, 发现配置项没有直接用ESLint多，改用ESLint ESLint趟坑 官方文档 中文文档 习惯用VSCode扩展的用户，默认会先在扩展市场直接搜索插件，然后再settings.json中修改配置项来使插件生效。这样的思维惯性导致了ESLint插件的初始化工作直接被忽略掉，一直不生效。 首先需要要按照ESLint的文档来初始化 对应文档指南 先决条件：Node.js (&gt;=6.14), npm version 3+。 你可以使用 npm 安装 ESLint： 在项目根目录运行 npm install eslint --save-dev 紧接着你应该设置一个配置文件： ./node_modules/.bin/eslint --init 或npx --init 这个命令执行完后会自动生成eslintrc.js文件 之后，你可以在任何文件或目录上运行ESLint如下： ./node_modules/.bin/eslint yourfile.js 以上初始化工作就完成了。 接下来开始自动格式化的各种配置 在VSCode中如下配置(配置说明) 123&quot;eslint.autoFixOnSave&quot;: true,&quot;eslint.alwaysShowStatus&quot;: true,&quot;eslint.run&quot;: &quot;onSave&quot;, 设置自己的代码风格 规则列表 因为公司有自己的代码格式校验，所以这里的配置是和公司代码风格一致的，不同的配置可以按照规则自己配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @file: file * @author: believeZJP */module.exports = { 'env': { 'browser': true, 'commonjs': true, 'es6': true }, 'extends': 'eslint:recommended', 'globals': { 'Component': 'readonly', 'swan': 'readonly', 'Page': 'readonly', 'getApp': 'readonly', 'Atomics': 'readonly', 'SharedArrayBuffer': 'readonly' }, 'parserOptions': { 'ecmaVersion': 2018, 'sourceType': 'module' }, 'rules': { 'semi': ['error', 'always'], // 操作符在行首 'operator-linebreak': ['error', 'before'], // 删除最后一个逗号 'comma-dangle': ['error', 'never'], // 对象两边加空格 'object-curly-spacing': ['error', 'always'], // 数组类型左右不加空格 'array-bracket-spacing': ['error', 'never'], // 计算属性类型加空格，同上 'computed-property-spacing': ['error', 'never'], // 操作符加空格 'space-infix-ops': ['error', { 'int32Hint': true }], // 删除多余空格和空行 'no-multi-spaces': 'error', // 禁止行尾空格 'no-trailing-spaces': 'error', // 方法参数是单个是不加括号 'arrow-parens': ['error', 'as-needed'], // console警告 'no-console': ['error', { allow: ['warn'] }], // 要求使用 === 和 !== (eqeqeq) 'eqeqeq': ['error', 'always'], // 函数圆括号之前有一个空格 'space-before-function-paren': ['error', 'never'], // 大括号之前有空格 'block-spacing': ['error', 'always'], // 语句块之前的空格 'space-before-blocks': ['error', 'always'], // 对象字面量的键和值之间使用一致的空格 'key-spacing': ['error', { 'afterColon': true, 'beforeColon': false }], // 使用骆驼拼写法 'camelcase': ['error', { allow: ['Component'] }], // 文件末尾保留一行空行 'eol-last': ['error', 'always'], 'no-multiple-empty-lines': ['error', { 'max': 2, 'maxEOF': 1 }], // 单引号 'quotes': ['error', 'single'] }}; 说明:globals: 是为了忽略一些全局变量没有定义的报错rules: 是对应的详细规则，有些规则查不到的可以先查询报错信息再找对应的配置会容易点，官网的规则解释不是很清楚 如上配置，即可自动格式化大部分代码错误 但语法错误什么的需要手动解决 看到有的人用husky+lint-staged 但这个是在提交代码之前校验，因为这里已经在onSave时格式化了，所以没必要加这步.(当然，加了可以强制校验提交的代码) 新项目可以尝试，旧项目因为历史遗留代码就没必要了。 发布为npm包 在项目的eslintrc.js中引用extends: lint-4bd 自动加文件头部注释公司要求js文件必须加文件头，所以这里用插件解决 插件名: koro1FileHeader 在VSCode扩展市场搜索直接安装要注意，搜索名字是koroFileHeader没有1配置 12345678910111213&quot;fileheader.customMade&quot;: { &quot;file&quot;: &quot;file&quot;, &quot;author&quot;: &quot;believeZJP&quot;, }, &quot;fileheader.configObj&quot;: { &quot;autoAdd&quot;: false, &quot;language&quot;: { &quot;js&quot;: { &quot;head&quot;: &quot;/**&quot;, &quot;middle&quot;: &quot; * @&quot;, &quot;end&quot;: &quot; */&quot; }, } 配置自定义时发现对全局修改不生效，必须指定语言进行修改，如上的js。 autoAdd设成false比较好，这个插件不能自动识别文件里是否已经存在注释，会添加多个 需要注意的是，每次修改settings.json后要重启VSCode","link":"/posts/%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96-md-js-css-html%E7%AD%89/"},{"title":"自己实现EventBus","text":"","link":"/posts/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0EventBus/"},{"title":"行业术语","text":"软件行业术语 软件开发中遇到的所有问题都可以通过增加一层抽象而得以解决。 过早的优化并不是一件好事。 代码开发中, 难点有时不是实现的思路， 而是细节的处理 常数变易法 小步走，及时反馈 人类的思考习惯是从具体到抽象 可以从某个具体的情况入手，把所有变化的要素都固定下来 从最简单的情况入手，再逐步扩展到复杂情况 抛开变化 变化会干扰我们的思路，先把变的东西固定死，写出应对死数据的处理过程 找规律 从对死数据的处理过程中找规律，有时可以通过适当变换使得规律一致 代换 把常量代换为变量，并保持程序执行的结果 会多语言的好处，可以根据不同的场景和要求来决定使用哪种语言实现某些功能。 读书千遍其义自见 简化知识点–读书读目录 多读书， 看不懂也要看完，知识是递归结构","link":"/posts/%E8%A1%8C%E4%B8%9A%E6%9C%AF%E8%AF%AD/"},{"title":"计算机小知识","text":"零宽字体列表 找到空的字符 找到空字符的编码, 如U+034F 将U+换成\\u 在浏览器控制台执行 copy('\\u034F') 即可粘贴到聊天输入框 火狐最新版完整安装包：http://download.firefox.com.cn/releases/full/zh-CN/Firefox-full-latest.exe","link":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"title":"调试经验","text":"[TOC] 微信里访问页面出错，浏览器访问没错在微信开发者工具中打开该链接，可以模拟微信访问链接 手机访问本地服务设置 手机–无线局域网–选择链接的wifi–配置DNS–改为手动，添加本地机器的IP。 用手机访问本机IP加服务地址即可访问本地服务. 在页面中加调试工具vConsole 一个轻量、可拓展、针对手机网页的前端开发者调试面板。 123456&lt;script src=&quot;https://cdn.bootcss.com/vConsole/3.2.0/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // init vConsole var vConsole = new VConsole(); console.log('Hello world');&lt;/script&gt; 出错要看异常错误码, 302 Not Found 为请求链接未找到。会导致异常","link":"/posts/%E8%B0%83%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"title":"跑步训练及经验","text":"跑步姿势身体微微前倾，双臂尽可能贴近身体，前后摆动 身体直立，重心稍向前，保持身体稳定 摆臂技术 前不漏肘后不漏手 ， 短跑可以大幅度，长跑小幅度 大臂小臂呈90度或小于90度 不能耸肩 不要左右摆臂 三个基础练习降低受伤几率，保证安全健康跑步 练习一， 提踵提高小腿肌肉力量及跟腱强度 抬脚后跟，尽可能提到最高幅度，双腿加紧 鞋子前面的线呈一字型 注意事项： 动作标准性 速度一定要慢，足下支撑力量不足会导致腱鞘炎 一定要做正确，不然不如不做 练习二、弓步上下起加强膝盖力量和大腿股四头肌力量，避免跑步时的膝盖伤害 弓步上下运动，身体直立，小腿几乎不动，靠大腿上下浮动，速度要慢， 每次动态做完做一次静力，感觉腿很酸胀才有效果 练习三、髋部练习三部曲增加腰部力量。髋部没有力量，只能用大腿拖着跑，会造成腿粗。 正起正踢，身体直立 往前踢，身体不要后仰，中间不可以落地， 身体不要歪，中间腿不要落地 前，侧，后 三个练习两个月后，跑步会非常轻松~~~~~ 参赛跑步训练一年以上，每周训练量超过半马30公里，全马60公里 具备2到3次，35到38公里 训练计划 比赛注意事项 频繁抽筋 突然觉得很累，直接坐到路边 冲刺之后立即休息 摆腿动作后收前摆连贯 步幅慢小快大 前摆到位，膝盖上提 高级技巧送髋–？？？","link":"/posts/%E8%B7%91%E6%AD%A5%E8%AE%AD%E7%BB%83%E5%8F%8A%E7%BB%8F%E9%AA%8C/"},{"title":"链表","text":"单向链表链表节点定义-Node 123456class Node { constructor(el) { this.el = el; this.next = null; }} 链表-LinkedList 1234567891011121314151617class LinkedList { constructor() { this.head = new Node('head'); } // 查找 find() { } // 插入节点 insert() { } // 删除节点 remove() { }} 查找节点 123456789function find(item) { // 从链表的头节点开始遍历 let currentNode = this.head; while(currentNode &amp;&amp; currentNode.el !== item) { currentNode = currentNode.next; } return currentNode;} 插入节点 1234567function insert(el, item) { const newNode = new Node(el); const currentNode = this.find(item); // 将当前节点的next给了新节点的next newNode.next = currentNode.next; currentNode.next = newNode;} 删除节点 删除当前节点要找到当前节点的上一个节点。将上一个节点的next指向下一个 123456789101112131415function findPre(item) { let node = this.head; while(node.next !== null &amp;&amp; node.next.el !== item) { node = node.next; } return node;}function remove(item) { const preNode = this.findPre(item); if (preNode.next !== null) { // 指向下一个元素，这行代码很关键 preNode.next = preNode.next.next; }} 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 定义单个节点class Node { constructor(el) { this.el = el; this.next = null; }}class LinkedList { constructor() { this.head = new Node('head'); } // 用于查找 find(item) { let node = this.head; while (node !== null &amp;&amp; node.el !== item) { node = node.next; } return node; } findPrev(item) { let node = this.head; while (node.next !== null &amp;&amp; node.next.el !== item) { node = node.next; } return node; } // 插入节点 insert(el, item) { const newNode = new Node(el); const currentNode = this.find(item); newNode.next = currentNode.next; currentNode.next = newNode; } // 删除节点 remove(item) { const prevNode = this.findPrev(item); if (prevNode.next !== null) { // 指向下一个元素，这行代码很关键 prevNode.next = prevNode.next.next; } }} 双向链表定义节点 1234567class Node() { constructor(el) { this.el = el; this.prev = null; this.next = null; }} 查找同单向链表 插入节点 1234567891011function insert(el, item) { const newNode = new Node(el); const currentNode = this.find(item); // 先将新节点的指针指向对应位置 newNode.next = currentNode.next; newNode.prev = currentNode; // 将当前节点的next指针指向新节点 currentNode.next = newNode; // 当前节点的next节点的prev指针指向新节点 currentNode.next.prev = newNode;} 删除节点 12345678function remove(item) { const node = this.find(item); node.prev.next = node.next; node.next.prev = node.prev; node.prev = null; node.next = null;}","link":"/posts/%E9%93%BE%E8%A1%A8/"},{"title":"项目使用standard规范并用eslint自动格式化代码","text":"在vscode插件中安装standard插件 先禁用，再在工作区启用，即可只在当前工作区生效 在项目中安装standard和eslintnpm i eslint standard -D 在命令行执行eslint --init初始化生成.eslintrc.js文件 生成过程中根据自己需求选择即可 在vsCode配置中(setting.json)增加如下配置, 即可自动格式化 123&quot;standard.run&quot;: &quot;onSave&quot;,&quot;standard.autoFixOnSave&quot;: true,&quot;javascript.validate.enable&quot;: false","link":"/posts/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8standard%E8%A7%84%E8%8C%83%E5%B9%B6%E7%94%A8eslint%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/"},{"title":"驾照学习","text":"优选海淀驾校 好处：练车不缺场地 考试通过率高 考前有一次免费的集训 经验： 1. 不要完美心态： 只要能倒进库不压线， 不出库就行，方向正不正无所谓 2. 离合一定要时刻压好，手刹没拉好， 档位不在空挡，刹车没踩紧 ，都不能松离合！！！！ 3. 车速一定要慢 4. 千万不能熄火 ，一熄火就完了 5. 一挡，二灯，三喇叭，四看镜， 五离合，六手刹。 6. 松手刹诀窍： 松之前，往上拉一点，按下按钮 ，下压到底，如果按不动按钮， 就往上拉一点，就可以了。 7. 偶尔挂不上倒挡： 不要太快 ，靠到最右侧，使劲往后侧压， 8. 到点后打方向盘一定要快。 科二：上车三要素： 1. 调座位，要领：能将离合器踩到底。 双手伸出，手腕正好超过方向盘。 2. 调后视镜 要领：门把手上的小黑点正好在镜子上沿。 车身占镜子的1/3 左侧后视镜要能看到后车轮，右侧的看不到。 3. 系安全带！！！ 倒车入库： 1. 入库标准。左侧后视镜的下沿稍微 超过库口的白线即可停车。 2. 出库 车头到7米线时立刻打方向盘。 3. 进库前准备： 1. 身体与库线平行，右打一圈 2. 左后视镜进入库区 ，左后视镜最外沿进入白线，左打两圈 3. 待车身与库平行，回正（右打一圈） 右倒库口诀： 1. 向右1圈半， 开车到7米线， 2. 向左一圈半 到右侧的白线--超过后视镜一指宽的距离 3. 向右一圈半 后视镜底部与右侧白线重合 4. 向左一圈 右侧库直角距车身30公分（白线宽10公分，大约是两倍白线宽时立马 打方向盘） 5. 向右一圈 右侧库角从后视镜消失 6. 向左两圈 车身回正 7. 停车 左侧后视镜稍微超过白线一点 左倒库口诀： 1. 向左一圈半 开车到7米线 2. 向右一圈半 到左侧的白线超过后视镜一指宽的距离 3. 向左一圈半 后视镜底部与右侧白线重合 4. 向右一圈 左侧直角距车身30公分（这里的30公分和左侧的不同，角刚出来点 就立刻左回一圈） 5. 向左一圈 左侧库角从左侧后视镜消失 6. 向右两圈 车身回正 7. 停车 左侧后视镜稍微超过白线一点 直角转弯口诀： 1.进入直角前，方向盘， 车座和路中间的直角转弯提示线成一条直线， 2. 待方向盘与直角转弯的线平行时， 左打死，一圈半， 3. 车身与路平行时，回正。 曲线行驶口诀： 1.保证车始终在路中间，这个没有固定的口诀， 需要根据不同的曲线具体确定什么时候动方向盘 ，无论如何确保车身不出弯道 侧方停车口诀： 1. 方向盘与路中的直行箭头在一条直线，打右灯（！！！）， 2. 车头刚好过白线时，停车， 3. 倒车，右侧后视镜的虚线消失时，立刻右打死，（右一圈半） 4. 左侧 里边的库角刚出现时，回正（左一圈半） 5. 左侧 后车轮触碰到，注意不是压到库口虚线，左打死（左一圈半）这是关键点，打晚了会导致进太多！！ 6. 车身与库平行，停车，不回正！！！ 7. 打左灯（！！！），挂一档 8. 左车角与白线重合，回正(右一圈半) 9. 车头在白线中间，右一圈，（这个与8步时间间隔很短） 10. 车身与白线平行，左一圈回正。 坡道定点起步口诀： 1. 进入坡道，方向盘，与指示箭头在一条线上，打右灯（！！！） 2. 上坡前松开离合，快到白线区，压离合，放慢车速 3. 左侧后视镜下沿与黄线重合，踩死刹车，停车。 4. 拉手刹（！！！），松开刹车，打左灯（！！！），不用动档（！！！） 5. 踩油门，松离合，看车头抬起，保持油门和离合位置不动（！！！） 6. 松开手刹，微抬离合，（可以不抬，保持不动），如果起步缓慢的话，轰油门， 待到坡顶后，松油门，微踩刹车","link":"/posts/%E9%A9%BE%E7%85%A7%E5%AD%A6%E4%B9%A0/"},{"title":"面试积累","text":"积累基础OS、数据结构与算法、网络这几块内容是必须要掌握的基础的，这些基础不扎实，天花板势必不高。 基础不好虽然也同样能干活，但是天花板不高会导致你的技术成长会随着年龄增长变得越来越低，最后结果也基本是停留于二三线公司。 大部分人问基础知识点还是能够说出来的，但是仅限于知道。对于如何将多个知识点串联起来或者知识点的更深层次的问题就很少有人能够答好。 建议学好计算机基础 框架学习框架前，我觉得你应该先打好基础，而不是好高骛远的先使用框架。再者，几大热门的框架底层的思想都是一致的，并没有哪个好哪个差之分。 学习一件事物，熟练使用它是基本，在熟练使用以后，应该转而去学习他底层的原理机制，甚至自己去实现一个类似的东西。当你这样去做的时候，永远不需要担心自己是否会淘汰，因为你已经领先所有只会用 API 的人了，这部分绝对是最多的。 总结想在面试中获得好的结果的人来说，都应该做到以下几点： 夯实自己的基础，基础决定了大楼的高度 有深入挖掘知识的思想，对于每个知识点都应该考虑一下这玩意怎么实现的，为什么要有这玩意 不要做框架 API 的熟练工，尽量去了解框架底层的原理机制 4、面试是一种输出学习是一种输入，但面试是一种输出。 面试需要的不是你懂，而是要让面试官知道你懂，你必须有能力将考点中的要点联系起来，连贯的说出来，这并不是看过一次就能达到的。但不少人以为看过这类文章，知道这个点，就可以了。事实上，只是“知道”远远不够。 这种问题，根本上，是对技术点的不够深入，不够熟悉，没有形成自己的理解。我也经历过这一过程，你知道这些概念，自己也能分清，但难以向别人讲明白。简单测试一个CSS问题：什么是BFC？ 你肯定知道叫块级格式化上下文，问题是，怎么向面试官解释这个东西？ 为了解决这个问题，首先，学习过程注重理解而不是记忆。 第二，一个知识点，需要通过多篇文章学习，重复学习，加深理解，总结出自己的答案和看法。 第三，刻意练习。如果你有伙伴，可以相互提问。如果没有，也可以自问自答。 5、注重表达逻辑如果上一点是说能正确回答问题，这点则是能更好的回答问题。一个逻辑清晰的回答，能让面试官感受到，面试者不仅熟悉这个问题，还有比较优秀的语言能力和逻辑能力。 比如，常见问题：说说 var, let/const 的区别。大部分人都能罗列出它们的区别和注意点，但这很难给面试官留下什么印象。但是，如果你添加几句联系性的语句，效果就不一样了： var是 ES5 之前的变量声明方式，存在很多容易产生误解的缺陷，具体体现在：……（罗列 var 的一些不足）, 针对这些问题，ES6 提出了 let/const 的变量声明方式，它们具有一些新的特性：……（罗列 let/const 特性）。 这几句简单的连接，让整个回答从一个简单的要点堆砌变成关系密切的表达。 然而，这并非易事。前提是必须要有较好的逻辑思维。 在学习每一个技术点的时候，都要注意一些问题：是什么？为了解决什么问题？如何实现的，有没有更深的原理？如何使用？使用的时候需要注意什么？有哪些应用的场景？有什么不足？这些不足能否避免？ 这些问题能让你更加全面地体会各个问题的联系。 需要指出一点，写博客对这方面有很大的帮助。 即使你没有写过博客，建议在备考的时候，使用思维导图等工具，并且经常整理已学知识的联系。 可能有人跟我一样面试会紧张，一紧张就容易脑子空白。我的方法是，把面试官假想成是来请教我问题的同学，不得不说这种效果真的很好。 6、扬长避短，但尽量争取对于那些每个应聘者必备的技能，必须要熟悉再熟悉，不要让基础成为自己的短板。而对于其它技能，深入学习其中的几个，然后想办法引导面试官提问这些方面的问题。 最有效最常见的引导方式是简历。简历信息往往是面试官出题的依据，所以简历一定不要写自己没接触过的技术，即使招聘信息有这项要求，如果面试官提问简历上的内容，发现你根本不会，那么，你简历上的所有技能点，面试官都会打个问号。对于你有深入学习的方面，可以单点列出，比如，熟悉 JavaScript，能熟练操作 DOM，尽管 JavaScript 包含了 DOM，但你依然可以强调一下。面试官往往会根据应聘者的回答来决定下一个问题，我们也可以利用这点，在面试回答中引导。在回答开放性问题时，这种方法十分有效，但切记点到为止，不要过分深入导致偏题。比如，面试官提问：对一个已有的网站，你哪些的性能优化方案？ 当你阐述性能改进提议之后，末了，加一句“除了性能，一个网站考虑还可以从安全性和 SEO 这些方面进行优化”。 如果面试官 Web 安全和 SEO 感兴趣，那他就中套了。 如果面试官抛出了一个你稍有了解但不熟悉的问题。不要慌，先思考片刻。整合自己知道的，做一些合理的推测。然后在回答的时候，先表明自己不是很熟悉，但在学习其他知识的时候有接触过，简单说说自己的了解和推断。不少面试官会故意提出一些稍微超出面试者能力的问题，考量面试者的临场能力和迁移学习能力。 万一，明确面试官问题后，发现自己丝毫不会，直接表明，把面试官的注意力转移到下一道题，停留的时候长了，可能会放大这道题的影响。从容应对接下来的题目，面试官不会因为一两道题淘汰一个各方面都很优秀的面试者。","link":"/posts/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/"},{"title":"CSS 知识点","text":"参考链接 写好CSS代码的70个专业建议 项目统一样式为了解决浏览器默认样式不统一的问题。 一般有两个库 Normalize.css Reset CSS 还可以根据自己需求定制初始化样式. 好处： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 解释代码：用注释和详细的文档来 用overflow: auto 必须给容器指定高度height: 固定值 页面首次加载动画展示 WOW中文文档 进入和离开屏幕时动画scrollreveal Animate.css 常见布局方案整理 CSS布局方案 经典布局 使用 flex 实现 5 种常用布局 flex布局详解 css负margin运用 CSS3实现动画功能主要通过两个属性1.transition2.animation transition:&lt;过渡属性名称&gt; &lt;过渡时间&gt; 1234transition: color 1s;transition: height 3s;transition-property: color;transition-duration: 1s; 多个属性的过渡效果-webkit-transition:&lt;属性1&gt; &lt;时间1&gt;,&lt;属性2&gt; &lt;时间2&gt;,&lt;属性3&gt; &lt;时间3&gt;; 第三个属性值：transition:&lt;过渡属性名称&gt; &lt;过渡时间&gt; &lt;过渡模式&gt;transition-timing-function值: ease 缓慢开始，缓慢结束 liner 匀速 ease-in 缓慢开始 ease-out 缓慢结束 ease-in-out 缓慢开始，缓慢结束（和ease稍有区别） CSS3创建3D场景 属性介绍perspective:800 平面距离三维中方框的距离perspective-origin:50% 50% transform属性 –translete :位移操作 translateX(X px) translateY(Y px) translateZ(Z px) –rotate：旋转操作 rotateX(X deg) rotateY(Y deg) rotateZ(Z deg) 设置3D transform-style:preserve-3d; 如何通过css使div 实现全屏效果–全屏要素： 1.全屏的元素及其父元素都要设置为height:100%, 2.将html,body标签设置为height100%,注：height:100%是跟随其父元素高度变化而变化的 css中 link 和 @import 区别@import 指令 会阻止浏览并行下载。link 加载外部样式表不会阻止并行下载。 px,em,rem的区别 PX特点 IE无法调整那些使用px作为单位的字体大小; 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位; Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。px像素(Pixel)。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册)em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 EM特点 em的值并不是固定的; em会继承父级元素的字体大小。所以我们在写CSS的时候，需要注意两点： body选择器中声明Font-size=62.5%; 将你的原来的px数值除以10，然后换上em作为单位; 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。 rem特点rem是CSS3新增的一个相对单位(root em，根em)，这个单位引起了广泛关注。这个单位与em有什么区别呢?区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。一个例子：p {font-size:14px; font-size:.875rem;} CSS3 动画性能问题https://www.cnblogs.com/shytong/p/5419565.htmla、是否导致layout如果是，尽可能将动画元素absolute或者fixed化以避免影响文档树，以减少重排.b、是否启用硬件加速“用到了CSS3动画”和“开启了硬件加速”是两件事情，虽然前者有可能导致后者。开启硬件加速在webkit中有神奇的万金油：opacity: 1;或者-webkit-backface-visibility: hidden;。c、是否是有高消耗的属性（css shadow、gradients、background-attachment: fixed等）有的话，图片也是一种选择。这算得上是用空间换时间的优化了。d、repaint的面积如果是，只好缩小动画面积了。这一步的优化有限;e、尽量使用 transform 生成动画，避免使用 height,width,margin,padding 等；transform 动画由GPU控制，支持硬件加速，并不需要软件方面的渲染为动画DOM元素添加 CSS3 样式 -webkit-transform:transition3d(0,0,0) 或 -webkit-transform:translateZ(0); ，这两个属性都会开启 GPU硬件加速 模式，从而让浏览器在渲染动画时从CPU转向GPU， 字体加粗用哪个&lt;b&gt;&lt;/b&gt;标签的加粗只是为了加粗&lt;strong&gt;&lt;/strong&gt;标签加粗是为了突出重点在网页中使用&lt;strong&gt;&lt;/strong&gt;突出的内容更容易被网页搜索蜘蛛搜索到。盲人朋友使用阅读设备阅读网络时：&lt;strong&gt;会重读，&lt;b&gt;不会 CSS优先级算法如何计算 元素选择符： 1 class选择符： 10 id选择符：100 元素标签：1000 !important声明的样式优先级最高，如果冲突再进行计算。 如果优先级相同，则选择最后出现的样式。继承得到的样式的优先级最低。 box-sizing属性用来控制元素的盒子模型的解析模式，默认为content-boxcontext-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽inherit: 应从父元素继承 box-sizing 属性的值 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin nth-child与nth-of-type区别123456789101112.product-list .item:nth-child(2n) { margin-left: 6px;}.product-list .item:nth-child(2n+1) { margin-right: 6px;}.product-list .item:nth-of-type(2n) { margin-left: 6px;}.product-list .item:nth-of-type(2n+1) { margin-right: 6px;} :nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类型。:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素. justify-content设置居左CSS语法:justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit; 默认值为flex-start, 如果要居左可以设置这个值， 注意：设置left不生效，因为没有left这个值。 css换行12word-break: break-all;word-break: break-word; max-width 和 !importantmax-width在比width小时，即使width使用!important来加权，仍会max-width生效； 以下代码宽度为300px 12&lt;img src=&quot;1.jpg&quot; style=&quot;width:480px!important; max-width: 300px&quot;&gt;&lt;img src=&quot;1.jpg&quot; style=&quot;width:480px!important; transform: scale(0.625, 1);&quot; &gt; overflow 基本属性： visible （默认） hidden 超出的部分被隐藏 scroll 两边都会出现 auto 智能路线 inherit(IE8+才支持) 兼容性： 1.燕环肥瘦，各有春秋 2.宽度设定机制ie7中莫名出现滚动条，可能是设置了100%，做法是删除width:100%; 作用的前提1.非display:inline 水平~ display不能设置为inline2.对应方位的尺寸限制。width/height/max-width/max-height/absolute拉伸3.对于单元格td等，还需要设置table为table-layout:fixed; overflow:visible妙用 ie7下文字越多，按钮两侧padding留白就越大给所有按钮添加css样式 overflow:visible 滚动条出现的条件 1.overflow:auto,overflow:scroll —自带html，textarea 2.草窝藏不住凤凰，潜水困不住蛟龙 内容过多 body/html 与滚动条 无论什么浏览器，默认滚动条均来自&lt;html&gt;，而不是&lt;body&gt; ie7- html{overflow-y:scroll;}ie8+ html{overflow:auto;} 想要去掉页面默认的滚动条 html {overflow:hidden;}html,body{overflow:hidden;} ——× js与滚动高度 chrome document.body.scrollTop 其他：document.documentElement.scrollTop标准写法： var st = document.body.scrollTop || document.documentElement.scrollTop; overflow的padding-bottom缺失现象 导致不一样的scrollHeight (元素内容高度)滚动条的宽度机制 滚动条会占用容器的可用高度或高度 宽度均为17px 1.怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。2.IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。例如：HTML： 1&lt; span&gt;div class=&quot;myDiv&quot;&lt;div&lt; CSS： .myDiv{ width:100px; height:100px; border:1px solid #000; float:left; margin-left:30px;} IE6预览结果：很明显的，在IE6中，margin-left:30px的边距翻倍成60px了。解决问题：设置display:inline： .myDiv{ width:100px; height:100px; border:1px solid #000; float:left; display:inline; margin-left:30px;} IE6预览结果：3.上下margin重合：margin是个有点特殊的样式，相邻的margin-left和margin-right是不会重合的，但相邻的margin-top和margin-bottom会产生重合。不管IE还是Firefox都存在这问题。例如：HTML： 12&lt; span&gt;div class=&quot;topDiv&quot;&lt;div&lt;&lt; span&gt;div class=&quot;bottomDiv&quot;&lt;div&lt; CSS： .topDiv{ width:100px; height:100px; border:1px solid #000; margin-bottom:25px;}.bottomDiv{ width:100px; height:100px; border:1px solid #000; margin-top:50px;} 我们对上面的div设置了25px的下边距，对下方的div设置了50px的上边距。为了便于观察，这里将div的高度都设为100px。浏览器预览结果：可见，结果不是预期的上下div拉开75px的距离，而是拉开了半个div高度(50px)的距离。解决问题：统一使用margin-top或者margin-bottom，不要混合使用。这并不是技术上的必需，但却是个良好的习惯。4.超链接访问后hover样式不出现：有时候我们同时设置了a:visited和a:hover样式，但一旦超链接访问后，hover的样式就不再出现，这是怎么回事呢？是因为将样式顺序放错了，调整为先a:visited再a:hover。关于a标签的四种状态的排序问题，有个简单好记的原则，叫做love hate原则，即i(link)ov(visited)e h(hover)a(active)e。5.IE6、IE7的hasLayout问题：很多时候，CSS在IE下的解析十分奇怪，明明在Firefox中显示得非常正确，但到了IE下却出现了问题，有的时候，这些问题甚至表现得非常诡异。例如一个比较经典的Bug就是设置border的时候，有时候border会断开，刷新页面或者拖下滚动条的时候，断掉的部分又会连接起来。再比如在IE6&amp;IE7中对元素设置浮动后，其后的元素并未占据这部分空间，造成了IE6&amp;IE7中浮动元素未脱离文档流的假象。也就是说，实际上IE6&amp;IE7浮动元素也脱离了文档流，只是由于其后元素的hasLayout被自动触发而导致的。这里说的hasLayout被触发，即指元素的hasLayout属性为true。下列元素默认hasLayout=”true”：下列 CSS 属性和取值将会自动让一个元素的hasLayout=”true”：position: absolute绝对定位元素的包含区块(containing block)就会经常在这一方面出问题。float: left|right由于 layout 元素的特性，浮动模型会有很多怪异的表现。display: inline-block当一个内联级别的元素需要 layout 的时候往往就要用到它，这也可能也是这个 CSS 属性的唯一效果–让某个元素拥有 layout。”inline-block行为”在IE中是可以实现的，但是需要注意的是： IE/Win: inline-block and hasLayout 。width: 除 “auto” 外的任意值很多人遇到 layout 相关问题发生时，一般都会先尝试用这个来修复。height: 除 “auto” 外的任意值height: 1% 就在 Holly Hack 中用到。zoom: 除 “normal” 外的任意值IE专有属性。不过 zoom: 1 可以临时用做调试。writing-mode: tb-rlMS专有属性。overflow: hidden|scroll|auto在 IE7 中，overflow 也变成了一个 layout 触发器，这个属性在之前版本 IE 中没有触发 layout 的功能。overflow-x|-y: hidden|scroll|autooverflow-x 和 overflow-y 是 CSS3 盒模型中的属性，尚未得到浏览器的广泛支持。他们在之前版本IE中没有触发 layout 的功能。另外 IE7 的荧幕上又新添了几个 haslayout 的演员，如果只从 hasLayout 这个方面考虑，min/max 和 width/height 的表现类似，position 的 fixed 和 absolute 也是一模一样。position: fixedmin-width: 任意值就算设为0也可以让该元素获得 layout。max-width: 除 “none” 之外的任意值min-height: 任意值。即使设为0也可以让该元素的 haslayout=truemax-height: 除 “none” 之外的任意值如果BUG是由于hasLayout未触发所引起的，则可采用手动触发hasLayout来解决：办法是使用一个生僻的CSS属性zoom来触发，引用样式.zoom{zoom:1}。如果BUG是hasLayout被自动触发而引起的，则要看触发是什么引起的，若这元素本身就会自动触发hasLayout，可以考虑换一个元素。若是对于这元素设置的某个CSS属性引起的，则可以考虑删除这属性，倘若这属性又是必要的，则就需要自己根据具体情况去编写CSS Hack，因为hasLayout是只读的，一旦hasLayout=”true”后，便不可逆转。6.行内元素上下margin及padding不拉开元素间距的问题：行内元素的margin和padding属性很奇怪，水平方向的padding-left、padding-right、margin-left、margin-right都产生边距效果，但竖直方向的padding-top、padding-bottom、margin-top、margin-bottom却不会产生边距效果。例如：HTML： CSS:div{background:gray;padding:20px;}span{background:green;padding:20px;margin:20px;}各浏览器预览结果：可见竖直方向的padding、margin虽然增大了行内元素的面积，但并没有和相邻元素拉开距离，导致了元素重叠。解决问题：将行内元素display设置为block即可解决修改后CSS：span{background:green;padding:20px;margin:20px;display:block;}各浏览器预览结果：但由于块级元素与行内元素的默认样式不同，可能会因此书写额外的样式代码。比如width样式，因为块级元素默认占据整行。7.IE6下select元素显示问题：浏览器解析页面时，会先判断元素的类型，如果是窗口类型的，会优先于非窗口类型的元素，显示在页面最顶端，如果同属于非窗口类型的，才会去判断z-index的大小。select元素在IE6下是以窗口形式显示的，这是IE6的一个Bug。导致的情况是往往想要弹出一个层，结果select元素出现在层上方。例如：HTML： CSS： 12345678910div{ position:absolute; background:#CCDCEE; top:0px; left:0px; width:300px; height:300px; border:1px solid #000; margin:5px;} IE6预览结果：解决问题：我们可以用一个和弹出层同样大小的iframe放在层下面，select上面，用iframe遮住select。比如设置弹出层的样式z-index:2，iframe的样式z-index:1，使iframe位于层下方。修改后HTML： 修改后CSS： div{ position:absolute; background:#CCDCEE; top:0px; left:0px; width:300px; height:300px; border:1px solid #000; margin:5px; z-index:2;}iframe{ position:absolute; top:0px; left:0px; width:300px; height:300px; margin:5px; z-index:1;} 我们让iframe位于div下方，大小以及与浏览器的距离调整成与div一致。IE6预览结果：8.IE6对png的透明度支持问题：png格式因为其优秀的压缩算法和对透明度的完美支持，成为Web中最流行的图片格式之一。但它存在一个众所周知的头疼问题—IE6下对png的透明度支持并不好。本该是透明的地方，在IE6下会显示为浅蓝色。可以使用IE下私有的滤镜功能来解决问题，格式如下：filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=’png图片路径’,sizingMethod=’crop’)。9.ul的不同表现：ul列表也是在IE与Firefox中容易发生问题的对象，主要源自浏览器对ul对象的默认值设置。在IE与Firefox中，一部分对象有默认的属性（比如h1~h6），他们本身就带有大字号、加粗样式以及一些边距效果。ul也是如此，默认情况下ul是有边距的。例如：HTML： CSS： 1# layout{border:1px solid #333;} ul{list-style:none;}代码非常简单，仅去除了ul的列表圆点。看下在IE和Firefox的预览效果：IE预览结果：Firefox预览结果：显示都很正常，关键在于我们对ul接下来的设置：修改后的CSS： 123456# layout{border:1px solid #333;}ul{ list-style:none; margin-left:0px;} 设置ul左外边距为0后。IE预览结果： Firefox预览结果： 预览后发现问题出现了。IE中的ul已与div靠齐，而Firefox中的ul却丝毫不动。这是为什么？不妨把样式修改下再看看。修改后的CSS： 123456#layout{border:1px solid #333;}ul{ list-style:none; padding-left:0px;} 这次我们把margin-left换成padding-left。再来看看预览结果。IE预览结果： Firefox预览结果： 可见效果正好相反，Firefox中实现了靠齐，而IE中丝毫未动。通过以上例子我们发现：在IE中，ul的默认边距是margin，在Firefox中，ul的默认边距是padding。我们单独定义margin或padding时，自然不能在两个浏览器达到一致效果。这就是ul在不同浏览器下表现不同的问题所在。解决问题：可以用hack方法分别针对IE和Firefox单独写样式，但更好的做法是样式开头先统一ul边距，ul{padding:0px;margin:0px;}。10.IE3px问题：3px问题不是经常被人发现，因为它的影响只产生3px的位移。如果是精确到像素级的设计，3px的影响可谓不小。先来看下例子：HTML： 12&lt;div id=&quot;left&quot;&gt;左浮动div&lt;/div&gt;&lt;div id=&quot;mydiv&quot;&gt;段落div&lt;/div&gt; CSS： 12345678910111213#left{ float:left; border:1px solid #333; width:100px; height:100px;}#mydiv{ border:1px solid #f66; margin-left:130px;} left是引发Bug的一个浮动div，同时设置了边框便于观察IE预览结果： Firefox预览结果： 从理论上讲，我们还没有设置#mydiv的padding，它们理所当然是紧贴边框的。但在IE中，“段落”文字并未紧紧贴住#left。在实际中可能会因此导致内部元素宽度超出外部div固定宽度而引发布局问题。解决问题：是把#mydiv设置为display:inline-block。修改后CSS： 1234567891011121314#left{ float:left; border:1px solid #333; width:100px; height:100px;}#mydiv{ border:1px solid #f66; margin-left:130px; +display:inline-block;} 用hack方法为IE单独设置display:inline-block后。IE各版本预览结果： 结果与Firefox一致。11.高度不适应问题：高度不适应指的是，当内层对象的高度发生变化时，外层对象的高度不能自动扩展，特别是当内层对象使用padding或margin之后。高度不适应问题不是IE的专利，Firefox也出现这种问题。先来看看例子：HTML：CSS： 1234567891011#box{ background-color:#eee;}#box p{ margin-top:20px; margin-bottom:20px; text-align:center;} 看看代码做了什么，除了背景之外，#box仅是一个没有任何样式的div，而p加了2个关键属性margin-top:20px，margin-bottom:20px;，即上下外边距都是20px，p对象的高度应当是20+20+文字高度，即应当在40px以上。理论上#box这个div的高度会被挤开，至少达到40px以上。我们看看预览效果。浏览器预览结果： 似乎并非预想的结果，看上去带背景的#box还是和文字一样高，并没有超过40px，这是为什么呢？为了验证一些事情，我们在html前后加上一个带背景的div。修改后的HTML：修改后的CSS： 1234567891011121314#box{ background-color:#eee;}#box p{ margin-top:20px; margin-bottom:20px; text-align:center;}.box2{ background-color:#aaa;} 再来看下预览结果：浏览器预览结果： 可以看到上下两个div并没有紧贴#box对象，而是有一定的间距。测量下会发现，这个间距刚好是p对象的margin上下各20px。这个测验证明了一个问题，就是#box对象并没有因其中的p对象的margin变化而改变自身的高度。而p对象的margin高度的确在整个页面中占据了一定的空间。相当于#box不动，而p把自己撑到了#box外面去了。无论是IE还是Firefox，测试中都会发现这个问题。解决问题：经过一些测试，我们发现对#box定义padding或者border，就会迫使#box重新计算自己的高度，从而使自身能够适应内容的高度变化。但如果强制给对象设置了边距又会带来位移。我们需要找到一个新方法，不再从对象本身的属性入手，而是在对象的内部进行修复。我们可以在对象上下增加2个高度为0的空div，并强制内容不显示。修改后的HTML： 这2个div只充当了占位符的角色，而不发生实际的占位。而对它的外层对象而言，由于其中多了一些逻辑占位对象使得它会重新计算高度，从而实现高度的自适应。预览效果： 12.IE6断头台问题：断头台问题是国外的CSS设计者给这个问题起的一个非常形象的名字，与之相反的，被切断的不是对象的头部，而是对象的底部。先来看下例子：HTML： XHTML代码有三部分组成，一个是主对象#layout，主框架中有#left为左浮动对象，右侧为普通的4个链接，类似于左右分栏的布局。CSS： 1234567891011121314151617# layout{ border:5px solid #35BB0C; width:400px; background-color:#F2F2F2;}# left{ border:5px solid #D4CA25; width:200px; float:left; background-color:#fff;}a:hover{ background-color:#fff;} 在CSS代码部分，主要设置了链接的背景色，#left的左浮动，以便于我们观察的粗边框效果。先通过浏览器看看问题是如何发生的，见下图：IE6预览效果： 这里列出了IE6网页效果的2个状态，当网页被打开时，页面正常显示，与CSS编码指定样式一致。当鼠标右侧的“链接4”时，问题出现了，主对象#layout下面被切掉了，而剩下的高度正好是4个链接的高度。而当鼠标移到“链接1”或“链接2”时，#layout对象的高度又恢复正常。这便是IE6断头台问题。这个问题的主要原因在于链接上，去除链接的a:hover{background-color:#fff}样式后，一切正常。经测试发现，不仅仅是background-color的变化，如果改变hover状态下链接的其他属性，也会引发同样的问题。例如设置padding、border、加粗、斜体等，都会引发断头台问题。值得注意的是，在#layout中，#left是个浮动对象，而右测是若干链接对象。对于未指定高度的对象而言，IE6会根据其中的内容（不管浮动与否）来计算高度的大小，而当例子中的链接对象是个非浮动对象，并具有hover改变border,background及padding属性时，IE6会认为这些属性同时会改变#layout的高度，因此它重新计算对象高度。而令人失望的是，IE6的这种自以为是的行为并没有达到预期目的，它会把非浮动对象的总高度作为高度给了#layout，从而切断了#left的内容。基于这类问题的产生原因，解决方案可以有多种。解决问题：根据问题产生的原因，我们可以做出多套解决方案。我们知道因为非浮动对象与浮动对象都在#layout中，所以我们可以从浮动方式入手，把非浮动对象改为浮动对象，这样便可以解决问题。例如对XHTML修改如下： 对链接加上个div，并设置浮动#right{float:left}。这样使得两个对象都成为浮动对象，不会引发问题。也可以在#layout底部增加一个div来强制IE浏览器重新计算高度，这个清除浮动内容的div会帮助浏览器重新找到合适的高度，从而解决断头台问题。13.容器不扩展问题：容器不扩展问题是我们经常遇到的。比如我们创建了一个div嵌套结构:HTML： CSS： 1234567891011# divGroup{ border:2px solid #333;}# a,#b{ border:2px solid #333; float:left; margin:5px;} IE预览结果： Firefox预览结果： 可见外层的高度并没有随着子容器的高度自动扩展，却是形成了一条线。这是因为当子容器成为浮动元素后，并脱离了文档流。因此父容器认为自己内容为空，从而造成了这样的结果。解决问题：解决方案是在容器的末尾加入个清理浮动的div。修改后的HTML： 如果还想防止这个元素占据父元素的高度，可以进一步优化成 ，这样这个清除浮动的容器被认为是个不占任何高度的空格字符。在网页中的任何地方，当遇到容器不扩展时，只需加入此段便能修复问题。14.IE8和FireFox父子元素上下margin叠加问题：先看下效果：&lt; span&gt;div class=”gray”&lt;&lt; span&gt;div class=”blue”&lt;div&lt;&lt; span&gt;div class=”black”&lt;div&lt;div&lt; .gray{ background:gray; width:200px; margin:20px;}.blue{ background:blue; width:100px; height:100px; margin:20px;}.black{ background:black; width:100px; height:100px; margin:20px;} 上图中，蓝色div和黑色div是灰色div的子元素，三个div的margin都是20，但是我们看到蓝色div与其父元素的上边界并没有20px的间隙，黑色div与其父元素的下边界也没有20px的间隙，也就是说蓝色div的上外边距与其父元素的上外边距叠加在了一起，就好像是蓝色div的上外边距跑出去了一样。黑色div也是同理。这就是父元素与子元素的边距叠加效果，叠加后的取值取的是两者中较大的那个。经测试，只要父元素有border或padding，就不会触发这个问题。然而刻意给父元素设置border或padding又会带来位移。可采用如下方法来根本解决问题：解决问题：给父元素设置overflow:hidden;即可解决。再来预览下：IE8： 解决了。FireFox： 也解决了。15.IE6高度不固定问题：典型BUG1：IE6下，即使给父元素设了固定高度，子元素还是会将其撑开。典型BUG2：如果一个元素没有子元素，而这个元素设置的length又小于div默认高度，则这个元素在IE6里显示的高度仍然是div的默认高度。引发以上2个BUG的原因在于length属性在IE6里被当作min-length（最小高度）解析了，（换句话说，你压根在IE6中就没设置过固定高度，因为你设置的是最小高度）解决办法是再给父元素设置overflow:hidden;16.IE6设置了最小高度并撑满父元素高度：默认情况下如果对IE6设置了最小高度200px，那么如果实际内容有250px，则只会显示250px的高度。也就是高度会跟随着内容显示。如果此时希望无论里面内容有多少，都让其填充满父元素高度，则要这么设置：height:auto!important;height:200px;min-height:200px;17.IE6、IE7下浮动元素未脱离文档流假象的问题：对元素设置浮动后，在IE6&amp;IE7下预览，会产生元素未脱离文档流的假象的现象。其实元素脱离文档流了，这问题其实是其后的元素引起的。由于其后的元素因某些原因造成hasLayout被触发而导致的它未去占据浮动元素的空间（这问题说起来话长，你就这么理解好了：这个大概追朔到表格布局的年代，由于单元格都是有hasLayout的，而后面单元格里的元素肯定不会跑前面的单元格里去的）。关于hasLayout，在第5条里有详细说明，这里单独提出来作为一条来说明，仅因为这个浮动未脱离文档流假象的问题比较典型。18.全屏遮罩后居中显示一个对话层：下面是遮罩层：绝对定位，宽高都100%，并且半透明 .over{ position:absolute; width:100%; height:100%; top:0px; left:0px; background-color:#7E9898; filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity:0.5; opacity:0.5;} 下面是对话层：也是绝对定位： .confirm{ position:absolute; width:400px; height:300px; background:#FFFFFF; top:300px; left:0px;} 这里的提示层不要嵌套在遮罩层里面，否则也会受影响，变成半透明的了。要让提示层跟遮罩层并列。这里还有2个问题：1.单单对遮罩层使用height:100%，只有IE6会达到效果，而其他浏览器一旦只会是当前可见区域遮上了，如果拖动纵向滚动条，发现下方还有没遮盖上。2.用户电脑分辨率不同，而绝对定位的提示层使用margin:300px auto也无效。为了达到各浏览器网页可见区域全部遮盖的效果，这里用了下jquery脚本，解决以上2个问题：$(document).ready(function(){ $(“div[class=’cover’]”).height($(document).height());//将可见区域都遮罩起来 $(“div[class=’confirm’]”).css(“left”,($(document).width()-($(“div[class=’confirm’]”).width()))/2+”px”);//提示层居中});最佳实践：1.写DTD声明：&lt;!DOCTYPE html&gt;2.引入base.css重置各浏览器默认属性值： html,body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td{margin:0px;padding:0px;}table{border-collapse:collapse;border-spacing:0px;}fieldset,img,abbr,acronym{border:0px;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}ol,ul{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:’’;} 3.同时为一个元素写float和margin-left（margin-right）的时候，习惯性地想到IE6会双倍边距，用display:inline解决。4.为子元素写margin-top或margin-bottom的时候，习惯性的去思考父元素是否有padding或border属性，从而断定是否会在IE6&amp;IE7上产生上下外边距重合问题。如果有问题用overflow:hidden;解决。5.给元素设了固定高度后，习惯性地再设个overflow:hidden;从而避免IE6上高度继续扩展的问题。6.必要时候要clear，。7.对于文本，在使用margin-left、padding-left、margin-top、padding-top之前优先考虑是否可用text-indent和line-height代替。因为计算尺寸的代价相对来说要大些。如能做到以上几点，就已经避免了90%的浏览器兼容性问题。","link":"/posts/CSS-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"ES6新语法积累","text":"[TOC] es6强制让一个函数有一个默认值123if (!a) { throw Error('cuowu')} 装饰器PromisePromise迷你书 js中Map和Set区别Set 对象类似于数组，且成员的值都是唯一的 Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是对象 set中存储无序并且不可重复的元素。map存储的是键值对。key=&gt;VALUE 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： Map：键值对集合，对应于 Object，ES6 中map的key 可以是对象List：有序可重复的列表，对应于 ArraySet：无序且不可重复的列表 123456789101112131415161718192021222324252627282930313233343536const arr = [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]const set = new Set()arr.forEach(item =&gt; set.add(item))console.log(set) // 1, 2, 3, 4, 5var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3重复元素在Set中自动被过滤：var s = new Set([1, 2, 3, 3, '3']);s; // Set {1, 2, 3, &quot;3&quot;}注意数字3和字符串'3'是不同的元素。通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：s.add(4);s; // Set {1, 2, 3, 4}s.add(4);s; // 仍然是 Set {1, 2, 3, 4}// 数组快速去重console.log([...new Set(arr)])var map = new Map()var obj = { name: '小缘', age: 14 }map.set(obj, '小缘喵')map.get(obj) // 小缘喵map.has(obj) // truemap.delete(obj) // truemap.has(obj) // false 模版字符串使用${variable}插入变量 123var fName = 'Peter', sName = 'Smith', age = 43, job = 'photographer';var a = 'Hi, I\\'m ' + fName + ' ' + sName + ', I\\'m ' + age + ' and work as a ' + job + '.';var b = `Hi, I'm ${ fName } ${ sName }, I'm ${ age } and work as a ${ job }.`; 块级作用域 let constJavaScript 本身一直是函数式作用域，这就是我们经常将整个 JavaScript 文件封装在一个空的立即调用函数表达式（IIFE）中的原因。这样做是为了隔离文件中的所有变量，因此全局中就不会存在变量名冲突。 ES5 中如果你想限制变量 tmp 的作用范围仅在某一块代码中有效，你不得不使用一个叫 IIFE(Immediately-Invoked Function Expression，立即执行函数表达式) 的模式： 12345678910111213(function () { // IIFE 开始 var tmp = ···; ···}()); // IIFE 结束console.log(tmp); // ReferenceError// ECMAScript 6 中可以简单地使用块和 let 申明(或 const 申明)：{ // 块起始 let tmp = ···; ···} // 块结束console.log(tmp); // ReferenceError letlet 声明的变量具有块级作用域，所以可以在不影响外部变量的情况下声明具有相同名称的新局部（内部）变量。==同一个块级作用域不能申明同一个变量== 1234567var a = 'car' ;{ let a = 5; console.log(a) // 5 let a = 6 // Identifier 'a' has already been declared}console.log(a) // car var和let之间的另一个区别是let不会像var一样被提升。 123456{ console.log(a); // undefined console.log(b); // ReferenceError var a = 'car'; let b = 5;} 经典面试题 123for (var i = 1; i &lt; 5; i++) { setTimeout(() =&gt; { console.log(i); }, 1000);} ConstJavaScript 中声明一个常量变量，那么惯例是将变量命名大写。然而，这并不能保证它是一个常量 - 它只是让其他开发人员知道这是一个常量，不应该改变。 ==const 不会使变量不可变，只是锁定它的赋值。 如果你有一个复杂的赋值（对象或数组），那么该值仍然可以修改。== 123456789101112131415161718192021{ const c = &quot;tree&quot;; console.log(c); // tree c = 46; // TypeError!}{ const d = [1, 2, 3, 4]; const dave = { name: 'David Jones', age: 32}; d.push(5); dave.job = &quot;salesman&quot;; console.log(d); // [1, 2, 3, 4, 5] console.log(dave); // { age: 32, job: &quot;salesman&quot;, name: 'David Jones'} // 上面的方式给const赋值不报错， 直接给const赋值，报错。 dave = {name: 'salesman'} // Assignment to constant variable.} 块级作用域函数问题12345678910111213141516171819函数声明现在被指定为必须绑定到块级作用域。{ bar(); // works function bar() { /* do something */ }}bar(); // doesn't workif ( something) { function baz() { console.log('I passed') }} else { function baz() { console.log('I didn\\'t pass') }}baz();在 ES6 之前，这两个函数声明都会被提升，\\结果就是 ‘I didn\\’t pass’，不管something 是什么东西。现在我们会得到 ‘ReferenceError’，因为baz()总是受到块范围的约束。 建议： 首选 const。所有不会改变值的变量都可以使用它。 其它的使用 let，用于值会被改变的变量。 避免使用 var。 扩展运算符…运算符，它被称为“扩展运算符”。 它有两个主要用途：将数组或对象分散到新的数组或对象中，并将多个参数合并到一个数组中。 … 运算符的另一个特点是它创建一个新的数组或对象。 将变量一起收集到一个数组中。 当你不知道有多少变量传递给函数时，这非常有用。 1234567891011121314151617181920212223let a = [3, 4, 5];let b = [1, 2, ...a, 6];console.log(b); // [1, 2, 3, 4, 5, 6]let car = { type: 'vehicle ', wheels: 4};let fordGt = { make: 'Ford', ...car, model: 'GT'};console.log(fordGt); // {make: 'Ford', model: 'GT', type: 'vehicle', wheels: 4}let a = [1, 2, 3];let b = [ ...a ];let c = a;b.push(4);console.log(a); // [1, 2, 3]console.log(b); // [1, 2, 3, 4] referencing different arraysc.push(5);console.log(a); // [1, 2, 3, 5]console.log(c); // [1, 2, 3, 5] referencing the same arrayfunction foo(...args) { console.log(args);}foo( 'car', 54, 'tree'); // [ 'car', 54, 'tree' ] 函数默认参数以使用默认参数定义函数。缺少或未定义的值将使用默认值进行初始化。只要小心 - 因为空值和假值会被强制为0。 默认值可以不仅仅是值 - 它们也可以是表达式或函数。 123456789101112131415161718function foo( a = 5, b = 10) { console.log( a + b);}foo(); // 15foo( 7, 12 ); // 19foo( undefined, 8 ); // 13foo( 8 ); // 18foo( null ); // 10 as null is coerced to 0// 默认值为函数function foo( a ) { return a * 4; }function bar( x = 2, y = x + 4, z = foo(x)) { console.log([ x, y, z ]);}bar(); // [ 2, 6, 8 ]bar( 1, 2, 3 ); //[ 1, 2, 3 ]bar( 10, undefined, 3 ); // [ 10, 14, 3 ] 解构解构是拆分等号左侧的数组或对象的过程。数组或对象可以来自变量，函数或等式。 有时，你想取值，将它们分配给一个新的变量。 这是通过在等号左边的 key: variable 配对完成的。 对象解构允许的另一件事是为多个变量赋值。 123456789101112131415161718192021let [ a, b, c ] = [ 6, 2, 9];console.log(`a=${a}, b=${b}, c=${c}`); //a=6, b=2, c=9function foo() { return ['car', 'dog', 6 ]; }let [ x, y, z ] = foo();console.log(`x=${x}, y=${y}, z=${z}`); // x=car, y=dog, z=6function baz() { return { x: 'car', y: 'London', z: { name: 'John', age: 21} };}let { x: vehicle, y: city, z: { name: driver } } = baz();console.log( `I'm going to ${city} with ${driver} in their ${vehicle}.`); // I'm going to London with John in their car.let { x: first, x: second } = { x: 4 };console.log( first, second ); // 4, 4 对象字面量和简明参数当您从变量创建对象字面量时，ES6 允许您在与 key 与变量名称相同的情况下省略 key 名。 1234let a = 4, b = 7;let c = { a: a, b: b };let concise = { a, b };console.log(c, concise) // {a: 4, b: 7}, {a: 4, b: 7} 动态属性名称使用动态分配的 key 创建或添加属性的功能。 123456let city= 'sheffield_';let a = { [ city + 'population' ]: 350000};a[ city + 'county' ] = 'South Yorkshire';console.log(a); // {sheffield_population: 350000, sheffield_county: 'South Yorkshire' } 箭头函数箭头函数有两个主要方面：结构和this绑定。 不需要功能关键字，并且它们自动返回箭头之后的任何内容。 如果函数需要的不仅仅是一个简单的计算，可以使用大括号，并且该函数会返回花括号块范围返回的任何内容。 对于箭头函数最有用的地方之一是在map()，forEach()或sort()之类的数组函数中。 1234var foo = function( a, b ) { return a * b;}let bar = ( a, b ) =&gt; a * b; 数字字面量ES5 代码很好地处理了十进制和十六进制数字格式，但未指定八进制格式。事实上，它在严格的模式下被禁止。 ES6添加了一种新格式，在最初的 0 之后添加一个 o （注意是字母）以将该数字声明为八进制数。ES6 还添加了二进制格式。 12345Number( 29 ) // 29Number( 035 ) // 35 in old octal form.Number( 0o35 ) // 29 in new octal formNumber( 0x1d ) // 29 in hexadecimalNumber( 0b11101 ) // 29 in binary form 静态方法（Static Methods）在类中，我们可以使用static关键字来声明静态方法。类的实例无法访问静态方法，因为声明静态方法的类属于类对象（class object）。 1234567891011class Repo{ static getName() { return &quot;Repo name is modern-js-cheatsheet&quot; }}// Note that we did not have to create an instance of the Repo classconsole.log(Repo.getName()) // Repo name is modern-js-cheatsheetlet r = new Repo();console.log(r.getName()) // Uncaught TypeError: repo.getName is not a function 通过使用this关键字，静态方法可以调用另一个静态方法，但这不适用于非静态方法（non-static methods）。非静态方法不能直接使用this关键词访问静态方法。 静态方法调用另一个静态方法要想静态方法调用另一个静态方法，可以这样使用this关键字; 1234567891011class Repo{ static getName() { return &quot;Repo name is modern-js-cheatsheet&quot; } static modifyName(){ return this.getName() + '-added-this' }}console.log(Repo.modifyName()) // Repo name is modern-js-cheatsheet-added-this 非静态方法调用静态方法非静态方法可以通过这两种方式调用静态方法; 使用类名称。 为了在非静态方法里访问静态方法，我们使用类名称（class name）并像属性一样调用静态方法。例如ClassName.StaticMethodName 1234567891011121314class Repo{ static getName() { return &quot;Repo name is modern-js-cheatsheet&quot; } useName(){ return Repo.getName() + ' and it contains some really important stuff' }}// we need to instantiate the class to use non-static methodslet r = new Repo()console.log(r.useName()) // Repo name is modern-js-cheatsheet and it contains some really important stuff 使用构造函数 静态方法可以作为构造函数对象（constructor object）的属性来调用。 1234567891011121314class Repo{ static getName() { return &quot;Repo name is modern-js-cheatsheet&quot; } useName(){ // Calls the static method as a property of the constructor return this.constructor.getName() + ' and it contains some really important stuff' }}// we need to instantiate the class to use non-static methodslet r = new Repo()console.log(r.useName()) // Repo name is modern-js-cheatsheet and it contains some really important stuff 新对象替换老对象12345state.obj = {...state.obj, newProp: 123}oldObj = Object.assign({}, newObj)oldObj = JSON.parse(JSON.stringify(newObj)) 在对象上添加新属性1Vue.set(obj, 'newProp', 123) let1234567var a = [];for(let i=0;i&lt;10;i++){ a[i] = function(){ console.log(i); }}a[6](); 不存在变量提升 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 不允许重复声明不能在函数内部重新声明参数 12345678910111213141516171819202122232425 function func(arg) { let arg; // 报错 } function func(arg) { { let arg; // 不报错 } }``` 块级作用域的不合理场景1. 内层变量可能会覆盖外层变量。```js var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = 'hello world'; } } f(); // undefined 用来计数的循环变量泄露为全局变量 循环结束后，i并没有消失，泄露成了全局变量。 块级作用域： 可以任意嵌套 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () { var tmp = ...; ...}());// 块级作用域写法{ let tmp = ...; ...} 避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 123456789101112131415// 函数声明语句{ let a = 'secret'; function f() { return a; }}// 函数表达式{ let a = 'secret'; let f = function () { return a; };} ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 12345678910// 不报错'use strict';if (true) { function f() {}}// 报错'use strict';if (true) function f() {} const声明一个只读的常量。一旦声明，常量的值就不能改变。 改变常量的值会报错。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 只声明不赋值，报错 const foo; // SyntaxError: Missing initializer in const declaration 作用域与let命令相同：只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined 声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 if (true) { console.log(MAX); // ReferenceError const MAX = 5; } 声明的常量，也与let一样不可重复声明。 let age = 25; var message = “Hello!”; // 以下两行都会报错 const message = “Goodbye!”; const age = 30; 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678910111213const foo = {};// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = {}; // TypeError: &quot;foo&quot; is read-onlyconst a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 ES6 声明变量的六种方法var命令和function命令，let和const命令，import命令和class命令。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。","link":"/es6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E7%A7%AF%E7%B4%AF/"},{"title":"Git 经验积累","text":"客户端推荐 SmartGit✨✨✨(开始用的，后来放弃) Sourcetree✨✨✨✨✨(现在用的这个，需要翻墙注册) GitKraken 很好用，可以替代SourceTree, 全平台免费(也开始收费了) github contributions 展示问题正常情况下会将每天的提交记录展示到图表中。有天突然发现之前好多提交记录没展示，查看原因发现是提交账号和github的账号不一致的原因导致的。 GitHub默认只有账号绑定的邮箱提交的commits才会展示. 解决办法: 将公司邮箱加到GitHub账户下–链接 将当前项目的提交设置为个人邮箱 1git config user.email &quot;email@example.com&quot; centos安装git安装yum install -y git 检查版本git –version 生成公钥并复制到服务器上生成公钥ssh-keygen -t rsa 查看公钥cat ~/.ssh/id_rsa.pub mac中直接复制到剪贴板 pbcopy &lt; ~/.ssh/id_rsa.pub 复制id_rsa.pub里的公钥到服务器上的authorized_keys文件拷贝，复制到github.com的settings的SSH and GPG keys中 安装nodejs参考：https://nodejs.org/ 卸载yum remove nodejs -y 正确方法1.确保系统下 g++ 版本在 4.6 以上，python 版本在 2.6 以上。 2.从 nodejs.org 下载 tar.gz 后缀的 NodeJS 最新版源代码包并解压到某个位置。 wget https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz 3.进入解压到的目录，使用以下命令编译和安装。 1234tar -zvxf node-v4.5.0.tar.gz./configuremakesudo make install git提交commit后，想撤回重新commitgit reset --soft HEAD^ 这样就成功的撤销了你的commit注意，仅仅是撤回commit操作，您写的代码仍然保留。 --hard会删除本地修改代码，回到上次commit状态 查看分支 git branch -a (可以查看所有分支)创建分支 git branch name切换分支 git checkout name创建并切换 git checkout -b name合并某分支到当前分支 git merge name 用于合并指定分支到当前分支删除分支 git branch -d name 注，合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支记录，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。9.团队多人开发协作 1).查看远程仓库分支查看远程仓库的信息 git remote命令可以查看远程仓库，加-v选项可以查看详细信息。 2).分支推送 首先，可以试图用git push origin branch-name推送自己的修改如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并如果合并有冲突，则解决冲突，并在本地提交没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 git 创建tag用 -a （译注：取 annotated 的首字母）git tag -a v0.1 -m ‘sidebar is ok’ git tag : 查看tag列表git show v1.4 ： 查看tag的具体信息 git tag -l ‘v0.1.*’ # 搜索符合模式的Tag 给指定的commit打Tag git tag -a v1.2 9fceb02 切换到Tag与切换分支命令相同，用git checkout [tagname]删除Tag误打或需要修改Tag时，需要先将Tag删除，再打新Tag。$ git tag -d v0.1.2 # 删除Tag 分享标签Tag推送到服务器 git push origin v1.5 一次推送所有本地新增的标签上去，可以使用 –tags 选项：git push origin –tags 注意：如果想看之前某个Tag状态下的文件，可以这样操作1.git tag 查看当前分支下的Tag2.git checkout v0.21 此时会指向打v0.21 Tag时的代码状态，（但现在处于一个空的分支上） git pull origin master /修改提交用到的命令**/git push origin gitcafe-pages //提交到远端的服务器上git commit -m ‘gitabc first commit’ //在本地创建一个版本git add -A/**修改提交用到的命令/git add -A 添加多个文件及文件夹 进入某个文件夹路径：cd D:/gitCafe 即可进入D:\\gitCafecd believeZJP 即可进入 D:\\gitCafe\\believeZJP git log常用命令以及技巧1.git log如果不带任何参数，它会列出所有历史记录，最近的排在最上方，显示提交对象的哈希值，作者、提交日期、和提交说明。如果记录过多，则按Page Up、Page Down、↓、↑来控制显示；按q退出历史记录列表。 当git出现 Please enter a commit message to explain why this merge is necessary especially if it merges an updated upstream into a topic branch Lines starting with ‘#’ will be ignored, and an empty message aborts the commit~“.git/MERGE_MSG” 7L, 293C这个画面时： type i to insert a comment then press esc and type :wq vi编辑模式：进入：vi test.txt从插入模式切换为命令行模式 按「ESC」键。按esc退出编辑模式退出vi及保存文件 别忘了wq前面的::w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出viq: 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑cat test.txt //查看文件内容 配置SSH KEYS步骤严格按照https://help.github.com/articles/generating-ssh-keys/ 是可以成功的。 转 push本地代码到github出错刚创建的github版本库，在push代码时出错： $ git push -u origin master 解决办法： 2.push前先将远程repository修改pull下来 123git pull origin mastergit push -u origin master 添加公钥: 应将id_rsa.pub中的内容拷贝到文本框中，而不是id_rsa中的！！！！！！！！！！！！！！ git 合并： 1.先git pull 将远程的文件更新过来 2.有冲突的，会在文件中有 这样的提示，解决冲突， 3.git add ，然后再commit 4.git push origin master git add -Agit commit -m ‘dd’git push origin master github 提交时，多次要求输入用户名密码的解决方法 git生成ssh key ssh-keygen.exe vim ~/.ssh/id_rsa.pub将ssh key 复制到添加页面 git diff 以后，按q 退出git 强制覆盖本地某个文件git checkout – file git切换分支： git checkout 分支名称git 只添加文件夹， 用git status 是不会检测到添加的文件夹，(多级文件夹也无法检测到) 只有文件夹中有文件，才会检测到， 给本次存储加个备注，以防时间久了忘了git stash save &quot;存储&quot; git stash 经验，当遇到本地已经commit后，发现忘记了git pull 时，此时，git pull会提示：you have unstaged changes.可以先git stash ，将本地的状态存起来，然后就可以git pull,再从本地恢复之前的状态，git stash pop git stash list 可以查看本地有哪些状态，git stash pop stash@{0} 可以将原先保存的状态还原。直接git stash pop 也可以。此时再git commit -m “”，git push就可以正常提交了。回退到某个版本 sudo git reset –hard 3943d5c74a08a8f6ad113e63ed191ecb4f48b053git强制覆盖本地所有修改：git fetch –allgit reset –hard origin/master error: cannot lock ref ‘refs/remotes/origin/master’: unable to resolve reference refs/remotes/origin/master: Invalid argument发生原因：git push origin master 写成了git push origin/master 解决办法：rm .git/refs/remotes/origin/mastergit fetch 修复bug的流程说明：从生产环境的分支上修改，再逐渐改到测试环境，dev环境操作步骤： 1.在主分支master拉一个分支branch1出来，修改， 2.将branch1合并到master,并提交，git push 3.切换到test分支，git merge branch1,并提交，git push 4.切换到dev分支，git merge branch1 并提交，git push 5.登录到每个环境的服务器中，分别git pull，即可看到更改的结果。 让某个分支和另外一个分支一样的话，直接将另一个分支merge过来。 Read-Search-Ask methodology git pull的时候遇到这样的问题：The following untracked working tree files would be overwritten by merge balabala…解决办法：git clean -d -fx备注：会删除掉没有add到仓库的文件，操作记得慎重，以免改动文件的丢失。本质上就是操作仓库中没有被追踪的本地文件$ git clean -f -n # 1$ git clean -f # 2$ git clean -fd # 3$ git clean -fX # 4$ git clean -fx # 5(1): 选项-n将显示执行（2）时将会移除哪些文件。(2): 该命令会移除所有命令（1）中显示的文件。(3): 如果你还想移除文件件，请使用选项-d。(4): 如果你只想移除已被忽略的文件，请使用选项-X。(5): 如果你想移除已被忽略和未被忽略的文件，请使用选项-x。 mkdir learngitcd learngitpwdgit initgit add readme.txtgit commit -m “wrote a readme file”git status git diff readme.txt //查看文件的区别git log 历史记录git log –pretty=oneline 一行显示 git reset –hard HEAD^ 回退上一个版本上上一个版本就是HEAD^^ 写成HEAD~100 上100个版本git reset –hard 3628164 指定回到未来的某个版本。版本号没必要写全，前几位就可以了，Git会自动去找gitreflog 记录每一次命令git diff //查看修改的内容git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别git checkout – readme.txt 丢弃工作区的修改 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。–很重要，没有–，就变成了“切换到另一个分支”的命令，git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。git reset HEAD readme.txt 可以把暂存区的修改撤销掉（unstage），重新放回工作区： 小结： 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git rese t HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，不过前提是没有推送到远程库 。—–删除文件—-rm test.txt 直接在文件管理器中把没用的文件删了，或者用rm命令删了：—相当于从文件管理器删除 git rm test.txt 从版本库中删除该文件，那就用命令git rm删掉，并且git commit：git commit -m “remove test.txt” 文件就从版本库中被删除了。———–远程关联————git remote add origin git@server-name:path/repo-name.git； eg: $ git remote add origin git@github.com:michaelliao/learngit.gitgit push -u origin master第一次推送master分支的所有内容；每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；git remote -v 看有没有权限推送 ————用命令克隆一个远程库—————-git clone git@github.com:michaelliao/gitskills.git 用命令git clone克隆一个本地库：git@github.com/believeZJP/believeZJP.github.io.git https://gitcafe.com/believeZJP/believeZJP.git git 只克隆一个分支 git clone -b &lt;branch&gt; &lt;remote_repo&gt; eg: git clone -b gitcafe-pages git@gitcafe.com:believeZJP/believeZJP.git ————–切换分支————-git checkout -b dev checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch devgit checkout devgit branch 查看当前分支：会列出所有分支，当前分支前面会标一个*号git checkout master 切换回master分支： git merge dev 把dev分支的工作成果合并到master分支上git branch -d dev 删除dev分支了git branch -D feature-vulcan 强行删除分支 小结Git鼓励大量使用分支：查看分支：git branch // git branch -a创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d git log –graph –pretty=oneline –abbrev-commit 分支的合并情况： git merge –no-ff -m “merge with no-ff” dev 请注意–no-ff参数，表示禁用Fast forward：因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 ————–从远程获取文件——————-将修改的文件推送到远程git push origin mastergit push origin dev ———Bug分支—————–git stash 把当前工作现场“储藏”起来，等以后恢复现场后继续工作：git stash list 查看工作现场 Git把stash内容存在某个地方，需要恢复，有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了： 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：$ git stash apply stash@{0}修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 —————–多人协作——————–小结查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 —————创建标签—————git tag v1.0 默认标签是打在最新提交的commit上git tag 查看所有标签git tag v0.96224937 打标签到某一个commit上 git show v0.9 查看标签信息git tag -a v0.1 -m “version 0.1 released”3628164 创建带有说明的标签，用-a指定标签名，-m指定说明文字git tag -s -m “blablabla…”可以用PGP签名标签；git tag -d v0.1 删除标签git push origin v1.0 推送某个标签到远程 git push origin –tags 一次性推送全部尚未推送到远程的本地标签git push origin :refs/tags/v0.9签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：从远程删除。删除命令也是push，但是格式如下：git push origin :refs/tags/v0.9// To git@github.com:michaelliao/learngit.git 不知道有没有这个 小结命令git push origin 可以推送一个本地标签；命令git push origin –tags可以推送全部未推送过的本地标签；命令git tag -d 可以删除一个本地标签；命令git push origin :refs/tags/可以删除一个远程标签。 ———-使用GitHub———————小结在GitHub上，可以任意Fork开源仓库；自己拥有Fork后的仓库的读写权限；可以推送pull request给官方仓库来贡献代码。 ——————自定义Git————————git config –global color.ui true 让Git显示颜色，会让命令输出看起来更醒目——————配置别名—————————– git config –global alias.st statusgit config –global alias.co checkoutgit config –global alias.ci commitgit config –global alias.br branch以后st就表示status co表示checkout，ci表示commit，br表示branch –global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用 git config –global alias.unstage ‘reset HEAD’ 当你敲入命令：$ git unstage test.py 实际上Git执行的是： $ git reset HEAD test.pygit config –global alias.last ‘log -1’ 让其显示最后一次提交信息 git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”git lg 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： …or create a new repository on the command lineecho “# node-server” &gt;&gt; README.mdgit initgit add README.mdgit commit -m “first commit”git remote add origin https://github.com/believeZJP/node-server.gitgit push -u origin master …or push an existing repository from the command linegit remote add origin https://github.com/believeZJP/node-server.gitgit push -u origin master git远程有分支，本地没有，解决办法git fetch 命令会更新 remote 索引。 git fetch origin git存储git分区git存储分成四个部分 workspace：工作空间（我们的开发代码目录） index： 暂存区，.git目录下的index文件 Repository：本地仓库，通过git clone将远程的代码下载到本地；代码库的元数据信息在根目录下的.git目录下 Remote：远程仓库（比如GitHub就是一个远程仓库） 整个过程就是： 工作区–git add–暂存区–git commit–本地仓库– git push–远程仓库 远程仓库区–-fetch–-使用refs\\remotes下对应分支文件记录远程分支末端commit_id 和 本地仓库区 –merge–-工作区 远程仓库区–-pull–-使用refs\\remotes下对应分支文件记录远程分支末端commit_id and 本地仓库区 and 工作区 git fetch和git pull的区别git fetch: 是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。具体操作如下: 12345678git fetch origin master:temp//本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git diff temp//比较远程代码与本地代码的区别git merge temp//将temp分支合并到本地master分支git branch -d temp//如果不想保留分支，可以将其删除 git pull: 基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD与远程仓库的版本号，然后git fetch获得当前的远程分支的后续版本的数据，然后利用git merge将其与本地的分支合并，可以认为是git pull是git fetch和git merge两个步骤的合并。实际的git pull过程可以理解为： 12git fetch origin master //将远端的master分支拉取最新内容git merge FETCH_HEAD //将拉取的最新内容与当前分支合并 git pull用法： 12git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;`// 将远程主机的某个分支，与本地的指定分支合并 git pull合并后可能会出现冲突，需要手动解决冲突。出现的错误提示如下 error: Your local changes to the following files would be overwritten by merge:Please commit your changes or stash them before you merge.// 更新的代码与本地的修改代码有冲突，先提交你的改变或者先将本地修改暂存起来 解决冲突的方式：先将本地的代码暂存 1234git stash //先将本地修改暂存起来git stash list //查看保存信息git pull //拉取内容git stash pop //还原暂存的内容 git status Changes to be committed：代表被add的文件，被加载到了暂存区 Changes not staged for commit：代表在当前分支中被修改的文件，还没有被add，存储在工作区 git内部存储本地git项目里面的.git目录下的文件如下： refs：存储git各种引用的目录，包含分支、远程分支和标签 objects：是存储git各种对象及备用的对象库，包含正常的压缩和压缩后的 info：存储git信息的目录，比如判处特定后缀的文件 index：暂存区 hooks：存储git钩子的目录，钩子只在特定事件发生时触的脚本，比如：提交之前，提交之后 description：项目描述 config：代码库几倍的配置文件 ORIG_HEAD：针对某些 危险操作 ，Git通过记录HEAD指针的上次所在的位置 ORIG_HEAD提供了回退的功能。当你发现某些操作失误了，比如错误的reset到了一个很早很早的版本，可以使用 git reset –hard ORIG_HEAD回退到上一次reset之前。 HEAD：代码库当前分支的指向 FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。 COMMIT_EDITMSG：commit编辑 git 常用插件 commitizen 规范commit message git show在当前分支，运行git show &lt;其他分支名&gt; k可以查看当前分支与其他分支的diff git diff master f_tmp 可以查看master和f_tmp分支的区别","link":"/posts/Git-%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"},{"title":"HTML 小知识","text":"1.设置input 语法检查spellcheck=&quot;false/true&quot; 2.设置input是否自动补全autocomplete=&quot;off/on&quot; 3.页面加载时，自动获取焦点autofocus=&quot;autofocus&quot; 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; 上面代码的意思是，让布局视口的宽度等于理想视口的宽度，页面的初始缩放比例以及最大缩放比例都为1，且不允许用户对页面进行缩放操作。 input标签只能输入数字js实现(且不能输入e或者其他各种符号)1&lt;input id=&quot;xxx&quot; type=&quot;number&quot; onKeypress=&quot;return (/[\\d]/.test(String.fromCharCode(event.keyCode)))&quot; style=&quot;ime-mode: Disabled&quot; &gt; ime-mode的语法解释如下： ime-mode : auto | active | inactive | disabled 取值： auto : 默认值。不影响IME的状态。与不指定 ime-mode 属性时相同 active : 指定所有使用IME输入的字符。即激活本地语言输入法。用户仍可以撤销激活IME inactive : 指定所有不使用IME输入的字符。即激活非本地语言。用户仍可以撤销激活IME disabled : 完全禁用IME。对于有焦点的控件(如输入框)，用户不可以激活IME IME 是指 Input Method Editors 输入法编辑器 慕课网学习 1.html基础 em标签：强调，斜体；strong:强调 &lt;address&gt;斜体，用于显示地址&lt;q&gt;标签的真正关键点不是它的默认样式双引号，而是它的语义：引用别人的话。 &lt;blockquote&gt;的作用也是引用别人的文本。但它是对长文本的引用，如在文章中引入大段某知名作家的文字，这时需要这个标签。 html4.01版本 &lt;hr&gt; &lt;br&gt;xhtml1.0版本 &lt;hr /&gt; &lt;br/&gt; 显示代码段 一行—&lt;code&gt;&lt;/code&gt; 多行—-&lt;pre&gt;&lt;/pre&gt;select 多选 &lt;select multiple=&quot;multiple&quot;&gt;Label中的for事件label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该 label标签相关连的表单控件上）。placeholder属性&lt;input type=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Enter email&quot;&gt; css样式三种样式是有优先级的，记住他们的优先级：内联式 &gt; 嵌入式 &gt; 外部式 类选择器和id选择器的相同、不同点 相同点和不同点：相同点：可以应用于任何元素 不同点：1、ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。2、可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。 子选择器还有一个比较有用的选择器子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。如右侧代码编辑器中的代码：.food&gt;li{border:1px solid red;} 包含(后代)选择器包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如右侧代码编辑器中的代码：.first span{color:red;}请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过“&gt;”进行选择。 总结：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 通用选择器 * 伪类选择符更有趣的是伪类选择符，为什么叫做伪类选择符，它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：a:hover{color:red;} 分组选择符当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码为右侧代码编辑器中的h1、span标签同时设置字体颜色为红色：h1,span{color:red;} 继承CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于p标签，这个颜色设置不仅应用p标签，还应用于p标签中的所有子元素文本，这里子元素为span标签。p{color:red;} 12345&lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt;可见右侧结果窗口中p中的文本与span中的文本都设置为了红色。但注意有一些css样式是不具有继承性的。如border:1px solid red;p{border:1px solid red;}&lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 特殊性根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。下面是权值的规则：标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码： 123456p{color:red;} /*权值为1*/p span{color:green;} /*权值为1+1=2*/.warning{color:white;} /*权值为10*/p span.warning{color:purple;} /*权值为1+1+10=12*/# footer .note p{color:yellow;} /*权值为100+10+1=111*/ 注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 层叠内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 重要性 样式优先级为：浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。 现在一般网页喜欢设置“微软雅黑”，如下代码：body{font-family:&quot;Microsoft Yahei&quot;;} 文字排版–斜体以下代码可以实现文字以斜体样式在浏览器中显示：p a{font-style:italic;} 文字排版–下划线有些情况下想为文字设置为下划线样式，这样可以在视觉上强调文字，可以使用下面代码来实现：p a{text-decoration:underline;}删除线使用下面代码就可以实现：.oldPrice{text-decoration:line-through;} 段落排版–缩进中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现：p{text-indent:2em;}注意：2em的意思就是文字的2倍大小 段落排版–行间距这一小节我们来学习一下另一个在段落排版中起重要作用的行间距属性（line-height），如下代码实现设置段落行间距为1.5倍。p{line-height:1.5em;} 段落排版–字间距、字母间距文字间隔、字母间隔设置：如果想在网页排版中设置文字间隔或者字母间隔就可以使用 letter-spacing来实现，如下面代码： 123h1{ letter-spacing:50px;} 注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。单词间距设置：如果我想设置英文单词之间的间距呢？可以使用word-spacing来实现。如下代码： 123h1{ word-spacing:50px;} 段落排版–对齐想为块状元素中的文本、图片设置居中样式吗？可以使用text-align样式代码，如下代码可实现文本居中显示。(那么什么是块状元素呢？在后面的11-1、11-2小节中会讲到。) 123h1{ text-align:center;} 元素分类在讲解CSS布局之前，我们需要提前知道一些知识，在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。常用的块状元素有： 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt;、&lt;form&gt; 常用的内联元素有： 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 常用的内联块状元素有： 1&lt;img&gt;、&lt;input&gt; 元素分类–块级元素什么是块级元素？在html中&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;就是块级元素。设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。a{display:block;}块级元素特点：1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 元素分类–内联元素在html中，&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、&lt;input&gt;、 &lt;img&gt;、 &lt;strong&gt; 和&lt;em&gt;就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码display:inline将元素设置为内联元素。如下代码就是将块状元素div转换为内联元素，从页使用div元素具有内联元素特点。内联元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。小伙伴们你们观查一下右侧代码段，有没有发现一个问题，内联元素之间有一个间距问题，这个问题在本小节的wiki中有介绍，感兴趣的小伙伴可以去查看。解决行内元素间隙bug问题行内元素之间会产生间隙bug问题的场景：1、当行内元素之间有“回车”、“tab”、“空格”时就会出现间隙。如下代码： 12345678910111213&lt;div&gt; &lt;a&gt;1&lt;/a&gt; &lt;a&gt;2&lt;/a&gt; &lt;span&gt;33333&lt;/span&gt; &lt;span&gt;44444&lt;/span&gt; &lt;em&gt;555555&lt;/em&gt;&lt;/div&gt; 解决方法：1、写在一行，之间不要有空格之类的符号。 12345&lt;div&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;span&gt;33333&lt;/span&gt;&lt;span&gt;44444&lt;/span&gt;&lt;em&gt;555555&lt;/em&gt;&lt;/div&gt; 2、使用font-size:0 123div{font-size:0;}a,span,em{font-size:16px;} 元素分类–内联块状元素内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。(css2.1新增)，&lt;img&gt;、&lt;input&gt;标签就是这种内联块状标签。 inline-block元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;&lt;title&gt;内联块状元素&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;a{ display:inline-block; width:20px;/*在默认情况下宽度不起作用*/ height:20px;/*在默认情况下高度不起作用*/ background:pink;/*设置背景颜色为粉色*/ text-align:center; /*设置文本居中显示*/}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;a&gt;4&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 内填充，外边距，边框盒模型–边框（一）盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。 123div{ border:2px solid red;} 上面是border代码的缩写形式，可以分开写： 12345div{ border-width:2px; border-style:solid; border-color:red;} 注意：1、border-style（边框样式）常见样式有：dashed（虚线）| dotted（点线）| solid（实线）。2、border-color（边框颜色）中的颜色可设置为十六进制颜色，如:border-color:#888;//前面的井号不要忘掉。3、border-width（边框宽度）中的宽度也可以设置为：thin | medium | thick（但不是很常用），最常还是用象素（px）。盒模型–宽度和高度盒模型宽度和高度和我们平常所说的物体的宽度和高度理解是不一样的，css内定义的宽（width）和高（height），指的是填充以里的内容范围。 因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 元素的高度也是同理。盒模型–填充元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。如下代码：div{padding:20px 10px 15px 30px;}顺序一定不要搞混。可以分开写上面代码： 123456div{ padding-top:20px; padding-right:10px; padding-bottom:15px; padding-left:30px;} 如果上、右、下、左的填充都为10px;可以这么写div{padding:10px;}如果上下填充一样为10px，左右一样为20px，可以这么写：div{padding:10px 20px;}盒模型–边界元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。如下代码：div{margin:20px 10px 15px 30px;}也可以分开写： 123456div{ margin-top:20px; margin-right:10px; margin-bottom:15px; margin-left:30px;} 如果上右下左的边界都为10px;可以这么写：div{ margin:10px;}如果上下边界一样为10px，左右一样为20px，可以这么写：div{ margin:10px 20px;}总结一下：padding和margin的区别，padding在边框里，margin在边框外。 12-1 CSS布局模型css布局模型清楚了CSS 盒模型的基本概念、 盒模型类型，我们就可以深入探讨网页布局的基本模型了。布局模型与盒模型一样都是 CSS 最基本、 最核心的概念。但布局模型是建立在盒模型基础之上，又不同于我们常说的 CSS 布局样式或 CSS 布局模板。如果说布局模型是本，那么 CSS布局模板就是末了，是外在的表现形式。CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。在网页中，元素有三种布局模型：1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer）s流动模型（一）先来说一说流动模型，流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征：第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。块状元素的特点：“在默认状态下，块状元素的宽度都为100%”。 12-3 流动模型二 流动模型（二） 第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 右侧代码编辑器中内联元素标签a、span、em、strong都是内联元素。内联元素的特点：“包含元素内从左到右水平分布显示” 12-4 浮动模型 浮动模型 块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。任何元素在默认情况下是不能浮动的，但可以用CSS定义为浮动，如div、p、table、img等元素都可以被定义为浮动。float 浮动 12-5什么是层模型？ 什么是层布局模型？层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧。但是在网页上局部使用层布局还是有其方便之处的。下面我们来学习一下html中的层布局。 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作。CSS定义了一组定位（positioning）属性来支持层布局模型。 层模型有三种形式： 1、绝对定位(position: absolute) 2、相对定位(position: relative) 3、固定定位(position: fixed) 12-6层模型–绝对定位如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。12-7层元素相对定位层模型–相对定位 如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 如下代码实现相对于以前位置向下移动50px，向右移动100px; 1234567891011# div1{ width:200px; height:200px; border:2px red solid; position:relative; left:100px; top:50px;}&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 什么叫做“偏移前的位置保留不动”呢？ 大家可以做一个实验，在右侧代码编辑器的19行div标签的后面加入一个span标签，在标并在span标签中写入一些文字。如下代码： 123&lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;span&gt;偏移前的位置还保留不动，覆盖不了前面的div没有偏移前的位置&lt;/span&gt;&lt;/body&gt; 效果图： 从效果图中可以明显的看出，虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 12-8层模型–固定定位 fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 12-9Relative与Absolute组合使用 小伙伴们学习了12-6小节的绝对定位的方法：使用position:absolute可以实现被设置元素相对于浏览器（body）设置定位以后，大家有没有想过可不可以相对于其它元素进行定位呢？答案是肯定的，当然可以。使用position:relative来帮忙，但是必须遵守下面规范： 1、参照定位的元素必须是相对定位元素的前辈元素： 123&lt;div id=&quot;box1&quot;&gt;&lt;!--参照定位的元素--&gt; &lt;div id=&quot;box2&quot;&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;&lt;/div&gt; 从上面代码可以看出box1是box2的父元素（父元素当然也是前辈元素了）。 2、参照定位的元素必须加入position:relative; 123456# box1{ width:200px; height:200px; position:relative;} 3、定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了。 123456# box2{ position:absolute; top:20px; left:30px;} 这样box2就可以相对于父元素box1定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。 13.1盒模型代码简写 还记得在讲盒模型时外边距(margin)、内边距(padding)和边框(border)设置上下左右四个方向的边距是按照顺时针方向设置的：上右下左。具体应用在margin和padding的例子如下： margin:10px 15px 12px 14px;/上设置为10px、右设置为15px、下设置为12px、左设置为14px/ 通常有下面三种缩写方法: 1、如果top、right、bottom、left的值相同，如下面代码： margin:10px 10px 10px 10px; 可缩写为： margin:10px; 2、如果top和bottom值相同、left和 right的值相同，如下面代码： margin:10px 20px 10px 20px; 可缩写为： margin:10px 20px; 3、如果left和right的值相同，如下面代码： margin:10px 20px 30px 20px; 可缩写为： margin:10px 20px 30px; 注意：padding、border的缩写方法和margin是一致的。 13-2颜色值缩写 关于颜色的css样式也是可以缩写的，当你设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。 例子1： p{color:#000000;} 可以缩写为： p{color: #000;} 例子2： p{color: #336699;} 可以缩写为： p{color: #369;} 13-3字体缩写 网页中的字体css样式代码也有他自己的缩写方式，下面是给网页设置字体的代码： 12345678body{ font-style:italic; font-variant:small-caps; font-weight:bold; font-size:12px; line-height:1.5em; font-family:&quot;宋体&quot;,sans-serif;} 这么多行的代码其实可以缩写为一句： 123body{ font:italic small-caps bold 12px/1.5em &quot;宋体&quot;,sans-serif;} 注意： 1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-varient、line-height)如未指定将自动使用默认值。 2、在缩写时 font-size 与 line-height 中间要加入“/”斜扛。 一般情况下因为对于中文网站，英文还是比较少的，所以下面缩写代码比较常用： body{ font:12px/1.5em “宋体”,sans-serif;} 只是有字号、行间距、中文字体、英文字体设置。 第二阶段 网页设计特点，宽度可以自适应，长度无限制 2-1一列布局 12.main{width:800px;height:300px;margin:0 auto;background:#ccc;}&lt;div class=&quot;main&quot;&gt;&lt;/div&gt; 三列布局 12345.left{ width:200px; height:600px; background:#ccc; position:absolute; left:0; top:0}.main{ height:600px; margin:0 200px 0 200px; background:#9CF}.right{ height:600px; width:200px; position:absolute; top:0; position:absolute;right:0; background:#FCC;} w3c倡导倡导结构、样式、行为分离 css中，存在3中定位机制标准文档流(Normal flow)浮动 (Floats)绝对定位(Absolute positioning) 标准文档流特点：从上到下、从左到右、输出文档内容由块级标签和行级标签组成 块级 特点从左到右撑满页面，独占一行；触碰到页面边缘时，会自动换行div,ul,li,dl,dt,p… 行级元素特点：能在同一行内显示，不会改变html文档结构span,strong,img,input 块级元素和行级元素都是盒子模型 如果想让页面自动居中，当设置margin属性为auto时，不能再设置浮动或绝对定位属性 float属性：left,right,none;当元素没有设置宽度值，而设置了浮动属性，元素的宽度随内容的变化而变化。 清除浮动的常用方法clear:both;或clear:left;或clear:right; 同时设置width:100%(或固定高度)+overflow:hidden;清除浮动时，只设置宽度不行，必须设置overflow:hidden;才能实现清除浮动的效果 横向两列布局主要应用技能 float:使纵向排列的块级元素，横向排列 margin属性，设置两列之间的间距当父块包含块2缩成一条时，用clear:both清除浮动无效，它一般用于紧邻后面的元素的清除浮动 position属性 拥有3种定位方式 1.静态定位 2.相对定位 3.绝对定位可以设置4个属性值 static （静态定位） relative （相对定位） absolute（绝对定位） fixed（固定定位） 相对定位 特点：相对于自身原有位置进行定位，仍处于标准文档流中，随即拥有偏移属性和z-index属性 相对于自己本来应该在的位置进行偏移，设置top,left,right,bottom属性。 绝对定位： 特点：建立了以包含块为基准的定位，完全脱离了标准文档流，随即拥有偏移属性和z-inde属性 未设置偏移量特点 无论是否存在已定位祖先元素，都保持在原始位置 脱离了标准文档流 设置偏移量 偏移参照基准 无定位祖先元素，以&lt;html&gt;为偏移参照标准 有已定位祖先元素，以距其最近的已定位祖先元素为偏移参照基准 使用absolute实现横向两列布局 –常用于一列固定长度，另一列宽度自适应的情况 主要技能 relative 氟元素相对定位 absolute 自适应元素绝对定位 注意 ：固定宽度列的高度&gt;自适应宽度的列 不设置长宽，用absolute 绝对定位本身就是自适应宽度 网页简单布局之结构与表现 html css javascript结构 表现 行为 先按照结构和语义编写代码，然后进行css样式设置，减少html和css的契合度 1/1. 在网页制作中，面对设计图，网页制作人员一般要遵循的原则是什么？C先考虑设计图中的文字内容和内容模块之间的关系，重点放在编写html结构和语义化，然后考虑布局和表现形式。 第二步 案例实现 按钮特效1.1幽灵按钮 透明按钮 css3关键技术点 transform transition box-sizing border-radius transfrom属性向元素应用2D或3D转换。该元素允许我们对元素进行旋转、缩放、移动或倾斜。 css 雪碧效果 1.原则：1.静态图片，不随用户信息变化而变化 2.小图片，图片容量比较小 一些大图不建议拼成雪碧图 2.目的1.减少 http请求数量 2.加速内容显示 实现原理 background-position 控制一个层，可显示的区域范围大小， 通过一个窗口，进行背景图的滑动 实现方式 1.ps手动拼图， 2.使用sprite工具自动生成 工具 ：cssgaga css圆角设计 使用css2.0+html标签模拟圆角优缺点分析 1.代码量少，不需要增加http请求 2.后期维护性好，但是圆角像素的增加 3.无意义代码将成倍增加 4.实现的圆角局限性 5.只能实现纯色圆角 css3.0圆角属性border-radius 属性值：表示圆角半径，可使用长度单位px,或百分比 简写属性:border-radius 分量属性：border-top-left-radius(上左)、border-top-right-radius(上右) border-bottom-right-radius(下右)、border-bottom-left-radius(下左) 属性值设置,与margin相同。 1个，四个角半径相同。2个，互为对角。 浏览器私有前缀 解决浏览器显示差异，针对浏览器写私有前缀 IE内核：-ms- Firefox内核：-moz- 谷歌浏览器、safari内核:-webkit- 使用dl,dt,dd的原因 语义化，使一些内容在一个dl内，而ul，li做不到un 响应式设计优缺点: 优点：解决了设备之间的差异化展示 缺点:兼容性代码多，工作量大，加载速度受影响 对原有网站布局产生影响，用户判断未必精确设计原则： 移动优先：在设计的初期就要考虑页面如何在多终端展示 渐进增强:充分发挥硬件设备的最大功能如何实现:响应式布局 css3-Media query 最简单的方式 原生javascript 成本高，不推荐使用 第三方开源框架 可以很好的支持浏览器响应式布局 css3-Media Query 常见的属性： device-width,deivce-height—屏幕宽高 width,height —渲染窗口，展示页面的宽高 orientation —设备方向 resolution—设备分辨率 Yahoo军规1.尽可能减少http请求数量2.使用CDN 内容分发网络 在离你最近的地方，放置一台性能好链接顺畅 的副本服务器，让你能够以最近的距离，最快的速度 获取内容。靠money解决问题3.添加expire/Cache-Control头 expire头的内容是一个时间值， 值就是资源在本地的过期时间、存在本地。 在本地缓存阶段，找到一个对应的资源值， 当前时间还没超过资源的过期时间，就直接使用这一个资源，不会发送http请求。 cache-control 是http协议中常用的头部之一， 负责控制页面的缓存机制4.启用Gzip压缩 把文件先放在服务器压缩再传输 html,php,js,css,xml,css5.将css放在页面最上面 放在head中，先进行加载和渲染6.将script放在页面最下面 首先将页面呈现出来，这样页面不会等太久7.避免在css中使用Expressions css Expressions:css表达式–javascript 页面显示缩放，页面滚动，移动鼠标都会重新计算8.把js和css放到外部文件中 单独提取： 提高了js和css的复用性 减小页面体积 提高了js和css的可维护性 写在页面里 减少页面请求 提升页面渲染速度 写在页面内的情况： 样式只应用于一个页面 不经常被访问到 脚本和样式很少（不多于20行）9.减少dns查询 当缓存时间长时：减少dns的重复查找，节省时间 当缓存时间短时：及时检测网站服务器的变化，保证正确性。 多域，单域10.压缩javascript和css 去除不必要的空白符，格式符，注释符 简写方法名，参数名压缩js脚本11.避免重定向 原始请求被重新转向到了其他请求 301 被移动到了另外的位置(永久重定向) 302 用户所请求的页面找到了，但不在原始位置（临时重定向） 301更智能 12.移除重复脚本 13.配置实体标签(ETag)??14.使用ajax缓存 post每次都执行，不被缓存 get同一地址不重复执行，可以被缓存 14.yslow工具简介 对网站进行分析，给一些建议，规则， 一步步优化网站使用： 按f12会出现在console之后","link":"/posts/HTML-%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"title":"Javascript设计模式与开发实践-读书笔记","text":"读《JavaScript设计模式与开发实践》笔记摘要 设计模式定义设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。通俗的说：设计模式是在某种场合下对某个问题的一种解决方案。设计模式是给面向对象软件开发中的一些好的设计取的名字。 在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。熟悉这些模式 的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到 某种模式作为解决方案。 设计模式的主题总是把不变的事物和变化的事物分离开作用让人们写出可复用和可维护性高的程序. 所有设计模式都遵循一条原则，即’找出程序中变化的地方，并将变化封装起来’。一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部 分封装起来，那么剩下的就是不变和稳定的部分。这些不变和稳定的部分是非常容易复用的。这 也是设计模式为什么描写的是可复用面向对象软件基础的原因。 设计模式被人误解的一个重要原因是人们对它的误用和滥用，比如将一些模式用在了错误的 场景中，或者说在不该使用模式的地方刻意使用模式。 分辨模式的关键是意图而不是结构在设计模式的学习中，有人经常发出这样的疑问:代理模式和装饰者模式，策略模式和状态 模式，策略模式和智能命令模式，这些模式的类图看起来几乎一模一样，它们到底有什么区别? 辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题。 对JavaScript设计模式的误解一些资料中对JavaScript模式存在的两个问题: 第一个问题是习惯把静态类型语言的设计模式照搬到JavaScript中. 比如有人为了模拟 JavaScript版本的工厂方法(Factory Method)模式，而生硬地把创建对象的步骤延迟到子类中。 实际上，在Java等静态类型语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依赖倒置原则(DIP)。 在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。 而在JavaScript这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另外一个类。 JavaScript不存在类型耦合的问题，自然也没有必要刻意去把对象“延迟”到子类创建，也就是说，JavaScript实际上是不需要工厂方法模式的。 模式的存在首先是能为我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既难懂又没什么用处。 另一个问题是习惯根据模式的名字去臆测该模式的一切。 比如命令模式本意是把请求封装到对象中，利用命令模式可以解开请求发送者和请求接受者之间的耦合关系。 但命令模式经常被人误解为只是一个名为execute的普通方法调用。这个方法除了叫作execute之外，其实并没有看出其他用处。 所以许多人会误会命令模式的意图，以为它其实没什么用处，从而联想到其他设计模式 也没有用处。 这些误解都影响了设计模式在JavaScript语言中的发展。 JavaScript中的原型继承 所有的数据都是对象 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它 JavaScript的根对象是Object.prototype对象。 12345var obj1 = new Object();var obj2 = {};console.log(Object.getPrototypeOf(obj1) === Object.prototype); // trueconsole.log(Object.getPrototypeOf(obj2) === Object.prototype); // true JavaScript对象会记住它的原型 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型 工厂模式列表 抽象工厂模式（Abstract Factory） 定义: 提供一个创建一系列相关或相互依赖对象的接口，而无需制定它们具体的类。 本质: 选择产品簇的实现。 生成器模式（Builder） 定义: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 本质： 分离整体构建算法和部件构造。 生成器模式的重心在于分离整体构建算法和部件构造，而分步骤构建对象不过是整体构建算法的一个简单实现，或者说是一个附带产物。 生成器模式与抽象工厂模式 这两个模式既相似又有区别，也可以组合使用。 区别：抽象工厂模式的主要目的是创建产品簇，这个产品簇里面的单个产品就相当于是构成一个复杂对象的部件对象，抽象工厂对象创建完成后就立即返回整个产品簇；而生成器模式的主要目的是按照构造算法，一步一步来构建一个复杂的产品对象，桐城要等到整个构建过程结束以后没才会得到最终的产品对象。 组合使用：在生成器模式的Builder实现中，需要创建各个部件对象，而这些部件对象是有关联的，通常是构成一个复杂对象的部件对象。也就是说，Builder实现中，需要获取构成一个复杂对象的产品簇，就可以使用抽象工厂模式来实现。有抽象工厂模式负责部件对象创建，Builder实现里面则主要负责产品对象整体的构建了。 策略模式策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。 12345678910111213141516var strategies = { &quot;S&quot;: function( salary ){ return salary * 4; }, &quot;A&quot;: function( salary ){ return salary * 3; }, &quot;B&quot;: function( salary ){ return salary * 2; };var calculateBonus = function(level, salary){ return strategies[level](salary);};console.log(calculateBonus('S', 20000));console.log(calculateBonus('A', 10000));// 输出:80000 // 输出:30000 发布-订阅模式发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。 优点： 一为时间上的解耦二为对象之间的解耦。还可以用来帮助实现一些别的设计模式，比如中介者模式。 缺点: 创建订阅者本身要消耗一定的时间和内存.发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一 起的时候，要跟踪一个 bug 不是件轻松的事情。 组合模式组合模式: 用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更 小的“孙对象”构成的。 组合对象和叶对象会各自做自己正确的事情。–组合模式最重要的能力 使用场景： 1. 代表对象的部分-整体层次结构。 2. 对树中所有对象统一对待 组合模式可以让我们使用树形方式创建对象的结构，把相同的操作应用在组合对象和单个对象上。大多数情况下可以忽略掉两者的差别，用一致的方式来处理。 缺点： 每个对象看你起来与其他对象差不多，但区别会在运行时显现出来，会让代码难以理解； 如果组合模式创建的对象太多，可能让系统负担不起。 模板方法模式(Template Method)模板方法模式是一种只需使用继承就可以实现的非常简单的模式。 模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 如果子类未实现父类要求实现的方法，可以throw new Error('子类必须重写xxx方法')来做检查。 模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。 123var brew = param.brew || function(){ throw new Error( '必须传递 brew 方法' );}; 模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架， 程序员继承框架的结构之后，负责往里面填空， 钩子方法(hook)用来解决一些特殊的子类，不符合父类的执行顺序等。 享元模式(flyweight)是一种用时间换空间的优化模式，为解决性能而生 核心: 运用共享技术来有效支持大量细粒度的对象 目标: 尽量减少共享对象的数量 享元模式要求将对象的属性分为内部状态和外部状态。划分内外部状态规则： 内部状态存储于对象内部 内部状态可以被一些对象共享 内部状态独立于具体的场景，通常不会变 外部状态取决于具体的场景，根据场景而变，外部状态不能共享 使用场景： 一个程序中使用了大量的相似对象 由于使用了大量的相似对象，造成很大的内存开销 对象的大多数状态都可以变为外部状态 剥离出对象的外部状态后，可以用相对较少的共享对象取代大量对象 思考： 创建出的共享对象在每次绑定事件后会执行自己的绑定时间还是会覆盖 职责链模式定义: 使多个对象都有机会处理请求，避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，连着这条链传递该请求，直到有一个对象处理它为止。 把大函数拆成小函数，去掉许多嵌套的条件分支语句 此外 Chain 的 prototype 中还有两个函数，它们的作用如下所示: // Chain.prototype.setNextSuccessor 指定在链中的下一个节点// Chain.prototype.passRequest 传递请求给某个节点 123456789101112131415161718192021222324var Chain = function( fn ){ this.fn = fn; this.successor = null;};Chain.prototype.setNextSuccessor = function( successor ){ return this.successor = successor;};Chain.prototype.passRequest = function(){ var ret = this.fn.apply( this, arguments ); if ( ret === 'nextSuccessor' ){ return this.successor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments ); } return ret;};// 使用var chainOrder500 = new Chain( order500 );var chainOrder200 = new Chain( order200 );var chainOrderNormal = new Chain( orderNormal );chainOrder500.setNextSuccessor( chainOrder200 );chainOrder200.setNextSuccessor( chainOrderNormal); 优点： 解耦了请求发送者和N个接收者之间的复杂关系 链中的节点可以灵活的拆分重组 可以手动指定起始节点 可以在链尾增加一个保底的接受者节点处理前面无法处理的请求 要避免过长的职责链带来的性能损耗 中介者模式通过增加一个中介者对象，所有相关的对象都通过中介者来通信，而不是互相引用。当一个对象发生改变，只需通知中介者。 使网状的多对多关系变成相对简单的一对多关系 作用 解除对象与对象之间的紧耦合关系。 缺点 系统会增加一个中介者对象。对象之间复杂的交互性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身就是一个难以维护的对象。 总结中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。 装饰者模式动态的给某个对象添加一些额外的职责，而不会影响这个类中派生的其他对象。 装饰者能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。 传统语言中，给对象添加功能常用继承方式，但继承会带来以下问题: 1. 导致子类和超类之间存在强耦合性， 超类改变，子类也随之改变 2. 继承的复用方式是白箱复用，超类的内部细节对子类可见。继承常常被认为破坏了封装性。 3. 完成功能复用时，有可能创造出大量的子类。 装饰者模式跟继承者模式相比更轻便灵活。 代理者模式和装饰者模式区别 在于他们的意图和设计目的 代理模式的目的是直接访问本体不方便或不需要时，提供一个替代者，本体定义了关键功能。代理者模式强调一种关系(proxy和它本体之间的关系), 这种关系可以静态的表达。这种关系一开始就可以确定。而装饰器模式用于一开始不能确定对象的全部功能时。 代理模式通常只有一层代理-本体的引用，装饰者模式会形成一条长长的链条。 状态模式定义允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这 个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。 状态模式的关键是区分事物内部的状态，事物内部状态的改变，往往会带来事物行为的改变。 把事物的每个状态都封装成单独的类，跟此种状态有关的行为都封装在这个类的内部。要修改时，把请求委托给当前的状态对象即可，该状态对象负责执行相应的方法。 优点 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过 5 多的条件分支。 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。 Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。 缺点会在系统中定义许多状态类，系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。 性能优化管理 state 对象的创建和销毁。 第一种是仅当 state 对象被需要时才创建并随后销毁，另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果 state 对象比较庞大，可以用第一种方式来节省内存，这样可以避免创建一些不会用到的对象并及时地回收它们。 状态模式和策略模式区别相同点 它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。 区别 策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系， 所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法;而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。 适配器模式当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。两种解决办法，第一种是修改原来的接口实现。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。 适配器作用解决两个软件间的接口不兼容的问题。 适配器和其他模式的区别关键仍然是模式的意图 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。 装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。 外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外 观模式最显著的特点是定义了一个新的接口。 设计原则和编程技巧单一职责原则SRP(Single Responsibility Principle)一个对象(方法)只做一件事情。 SRP 原则在很多设计模式中都有着广泛的运用，例如代理模式、迭代器模式、单例模式和装饰者模式。 要明确的是，并不是所有的职责都应该一一分离。一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。 另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。 在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而 是要取决于具体的应用环境。 SRP 原则的优缺点优点 降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度， 这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。 缺点 最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。 最少知识原则(LKP)一个软件实体应当尽可能少地与其他实体发生相互作用。 例如：中介者模式和外观模式。 终结者模式：通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。 外观模式：为一组子系统提供一个简单便利的访问入口, 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。 封装：封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口 API 供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。 虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难 以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则， 要根据具体的环境来定。 开放封闭原则(OCP)当需要改变一个程序的功能或者给这个程序增加新功 能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。 用对象的多态性消除条件分支过多的条件分支语句是造成程序违反开放封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。把 if 换成 switch-case 是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。 利用对象的多态性来让程序遵守开放封闭原则，是一个常用的技巧。 找到一些让程序尽量遵守开放封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。 其他方式 放置挂钩(hook) 在程序有可能发生变化的地方放置挂钩，挂钩返回的结果决定程序下一步走向。 使用回调函数 策略模式和命令模式等都可以用回调函数轻松实现。 代码重构 提炼函数函数要有良好的命名，函数体内包含的逻辑清晰明了。好处 避免出现超大函数。 独立出来的函数有助于代码复用。 独立出来的函数更容易被覆写。 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。 合并重复的条件片段 把条件分支语句提炼成函数 1234567891011if ( date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9 ){ // ...}// 提炼出来var isSummer = function(){ var date = new Date(); return date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9;};if (isSummer) { // ...} 合理使用循环 提前让函数退出代替嵌套条件分支 传递对象参数代替过长的参数列表可以把参数都放入一个对象内 尽量减少参数数量 少用三目运算符 少用三目运算符 分解大型类 用return退出多重循环 链接 工厂模式简单的工厂模式可以理解为解决多个相似的问题; 123456789101112131415161718192021function CreatePerson(name,age,sex) { var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function(){ return this.name; } return obj;}var p1 = new CreatePerson(&quot;longen&quot;,'28','男');var p2 = new CreatePerson(&quot;tugenhua&quot;,'27','女');console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua 单例模式只能被实例化(构造函数给实例添加属性与方法)一次 1234567891011121314151617181920// 单体模式var Singleton = function(name){ this.name = name;};Singleton.prototype.getName = function(){ return this.name;}// 获取实例对象var getInstance = (function() { var instance = null; return function(name) { if(!instance) {//相当于一个一次性阀门,只能实例化一次 instance = new Singleton(name); } return instance; }})();// 测试单体模式的实例,所以a===bvar a = getInstance(&quot;aa&quot;);var b = getInstance(&quot;bb&quot;); 沙箱模式将一些函数放到自执行函数里面,但要用闭包暴露接口,用变量接收暴露的接口,再调用里面的值,否则无法使用里面的值 12345678let sandboxModel=(function(){ function sayName(){}; function sayAge(){}; return{ sayName:sayName, sayAge:sayAge }})() 发布者订阅模式就例如如我们关注了某一个公众号,然后他对应的有新的消息就会给你推送, 代码实现逻辑是用数组存贮订阅者, 发布者回调函数里面通知的方式是遍历订阅者数组,并将发布者内容传入订阅者数组 12345678910111213141516171819202122232425262728//发布者与订阅模式var shoeObj = {}; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数// 增加订阅者shoeObj.listen = function(fn) { shoeObj.list.push(fn); // 订阅消息添加到缓存列表}// 发布消息shoeObj.trigger = function() { for (var i = 0, fn; fn = this.list[i++];) { fn.apply(this, arguments);//第一个参数只是改变fn的this, } } // 小红订阅如下消息shoeObj.listen(function(color, size) { console.log(&quot;颜色是：&quot; + color); console.log(&quot;尺码是：&quot; + size);});// 小花订阅如下消息shoeObj.listen(function(color, size) { console.log(&quot;再次打印颜色是：&quot; + color); console.log(&quot;再次打印尺码是：&quot; + size);});shoeObj.trigger(&quot;红色&quot;, 40);shoeObj.trigger(&quot;黑色&quot;, 42);","link":"/posts/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Koa2 进阶","text":"Koa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。 前置知识：js,ES6,node ,npm 第一节 Koa开发环境搭建 新建目录 12mkdir koa2Tutorialcd koa2Tutorial 生成package.json 文件 1npm init -y 安装koa包 1npm install --save koa coding 开始编写koa启动代码 12345678910const Koa = require('koa')const app = new Koa()app.use( async (ctx) =&gt; {ctx.body = 'Hello Koa2' })app.listen(8040)console.log('[demo] start quick is starting at port 8040') 启动 在命令行输入 1node index.js 在浏览器中输入： localhost:8040就能看到结果了 第2节 async/await 使用方法什么是async和await async是异步的简写 await这里是async await简写 async是声明一个方法是异步的，await是等待异步完成。 注意await必须是在async方法中才可以使用因为await访问本身会造成程序停止，所以必须在异步方法中才可以使用 async 到底起什么作用async是让方法变成异步，关键是他的返回值是什么，得到后如何处理？ 看一下async方法的返回值 123456async function testAsync() { return 'Hello Async'}const result = testAsync()console.log(result) 在终端中运行node testAsync.js，发现返回的是Promise 12node test.jsPromise { 'Hello async' } await在等什么await一般是在等async方法执行完毕。但其实await等待的只是一个表达式(Promise对象)，也可以接收普通值。看代码： 12345678910111213141516function getSomething(){ return 'something'}async function testAsync(){ return 'Hello Async'}async function test () { const v1 = await getSomething() const v2 = await testAsync() console.log(v1, v2)}test() 上面代码一个是异步函数，一个是普通函数。 可以看到都是直接返回结果。 async/await 同时使用通过前面两个例子，已经分别了解到async和await。现在做个虚假的例子，看下等待问题。 1234567891011121314function takeLongTime(){ return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve('long_time_value') }, 1000) })}async function test(){ const v = await takeLongTime() console.log(v)}test() 第3节 Get请求接收这节课看一下Koa如何处理get请求 query和querystring区别在Koa2中，Get请求通过request接收，但接收方法有两种：query和querystring。 query： 返回的是格式化好的参数对象 querystring： 返回的是请求字符串 写个简单的例子看下输出结果。 demo1.js 1234567891011121314151617const Koa = require('koa')const app = new Koa()app.use( async (ctx) =&gt; { let url = ctx.url let request = ctx.request let req_query = ctx.request.query let req_querystring = ctx.request.querystring ctx.body = { url, req_query, req_querystring }})app.listen(8040)console.log('[demo] start quick is starting at port 8040') 上面的代码，在body中返回了从ctx中取到的url, request, requeststring. 在终端用node demo1.js启动服务，在浏览器输入查看页面效果 http://localhost:8040/?user=admin&amp;age=18 页面输出的结果 1{&quot;url&quot;:&quot;/?user=admin&amp;age=18&quot;,&quot;req_query&quot;:{&quot;user&quot;:&quot;admin&quot;,&quot;age&quot;:&quot;18&quot;},&quot;req_querystring&quot;:&quot;user=admin&amp;age=18&quot;} 直接从ctx中获取Get请求上面代码是在ctx.request中获取的request和requeststring， 还可以直接从ctx中得到Get请求。 12345678910111213141516171819202122232425262728const Koa = require('koa')const app = new Koa()app.use( async (ctx) =&gt; { let url = ctx.url // 从 request 中获取GET请求 let request = ctx.request let req_query = ctx.request.query let req_querystring = ctx.request.querystring // 从上下文获取GET请求 let ctx_query = ctx.query let ctx_querystring = ctx.querystring ctx.body = { url, req_query, req_querystring, ctx_query, ctx_querystring }})app.listen(8040)console.log('[demo] start quick is starting at port 8040') 可以在浏览器中看效果。 总结 获取GET请求方式有两种 从request获取 从ctx中获取。 获取的格式也有两种 request requeststring 第4节 POST请求如何接收(1)这节学习POST请求的接收方法。 对于POST，Koa2没有封装方便的获取参数方法，需要通过解析上下文context中的原生node.js请求对象req来获取。 获取Post请求的步骤： 解析上下文ctx中的原生node.js对象req 将post表单数据解析成query string 字符串。 将字符串转换成JSON ctx.request和ctx.req区别 ctx.request:是Koa2中context经过封装的请求对象，用起来更简单直观 ctx.req: 是context提供的node.js原生HTTP请求对象。可以得到更多的内容。 ctx.mothed得到的请求类型Koa2提供了ctx.method属性，来获取请求类型。根据不同类型编写不同的响应。在工作中很常用。 先做个小例子。根据请求类型获取不同的页面内容。GET请求时得到表单填写页面，POST请求时，得到POST处理页面。 12345678910111213141516171819202122232425262728293031const Koa = require('koa')const app = new Koa()app.use( async (ctx) =&gt; { // 当请求是get时，显示表单让用户填写 if(ctx.url === '/' &amp;&amp; ctx.method === 'GET'){ let html = ` &lt;h1&gt;Koa2 request post demo&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=&quot;userName&quot; /&gt; &lt;br/&gt; &lt;p&gt;age&lt;/p&gt; &lt;input name=&quot;age&quot; /&gt; &lt;br/&gt; &lt;p&gt;webSite&lt;/p&gt; &lt;input name='webSite' /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html }else if(ctx.url === '/' &amp;&amp; ctx.method === 'POST'){ ctx.body = '接收到的请求' }else { ctx.body = ` &lt;h1&gt;404&lt;/h1&gt; ` }})app.listen(8040)console.log('[demo] start quick is starting at port 8040') 写完执行node index.js，在浏览器中输入http://localhost:8040/，第一次展现的是表单页面，点击提交后，返回接收到的请求。输入其他地址，返回404. 总结-4这节课理论上学习了如何获取POST请求参数。学习了如何获取请求类型，ctx.method,并编写了一个小案例。 第5节 POST请求如何接收参数(2)这节课具体学习怎么解析POST参数。 解析Node原生POST参数先声明一个对象，用Promise对象解析。这里使用ctx.req.on接收事件。 12345678910111213141516function parsePostData(ctx) { return new Promise((resolve, reject) =&gt; { try{ let postData = '' ctx.req.on('data', (data) =&gt; { postData += data }) ctx.req.addListener('end', function(){ resolve(postData) }) }catch(err){ reject(err) } })} 修改上节接收POST请求的处理方法，如下 123// ctx.body = '接收到的请求'let postData = await parsePostData(ctx)ctx.body = postData 现在，点击提交可以看到返回字符串 POST字符串解析成JSON对象上面返回的是字符串，这里写一个封装JSON对象的方法 1234567891011function parseQueryStr(queryStr) { let queryData = {} let queryStrList = queryStr.split('&amp;') console.log(queryStrList) for(let [index, queryStr] of queryStrList.entries()) { let itemList = queryStr.split('=') console.log(itemList, 'item') queryData[itemList[0]] = decodeURIComponent(itemList[1]); } return queryData} 修改parsePostData中resolve返回前的调用 12345678910111213141516171819// 处理post参数，合并为字符串function parsePostData(ctx) { return new Promise((resolve, reject) =&gt; { try{ let postData = '' ctx.req.on('data', (data) =&gt; { postData += data }) ctx.req.addListener('end', function(){ let parseData = parseQueryStr(postData) resolve(parseData) }) }catch(err){ reject(err) } })} 现在返回的是json对象。 第6节 koa-bodyparser中间件上面已经学会如何自己编写代码接收并解析POST请求。有现成的工具可以直接使用，koa-bodyparser. 这种轮子叫做中间件。对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文呢的formData数据解析到ctx.request.body中 安装中间件 1npm install --save koa-bodyparser 引用 123const bodyParser = require('koa-bodyparser')app.use(bodyParser) 直接用ctx.request.body获取POST请求参数，中间件自动做了解析 1234567891011121314151617181920212223242526272829303132333435363738const Koa = require('koa')const app = new Koa()const bodyParser = require('koa-bodyparser')// app.use(bodyParser) 错误写法！！！！！！！！！！！！！！！！！app.use(bodyParser())app.use( async (ctx) =&gt; { // 当请求是get时，显示表单让用户填写 if(ctx.url === '/' &amp;&amp; ctx.method === 'GET'){ let html = ` &lt;h1&gt;Koa2 request post demo&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=&quot;userName&quot; /&gt; &lt;br/&gt; &lt;p&gt;age&lt;/p&gt; &lt;input name=&quot;age&quot; /&gt; &lt;br/&gt; &lt;p&gt;webSite&lt;/p&gt; &lt;input name='webSite' /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html }else if(ctx.url === '/' &amp;&amp; ctx.method === 'POST'){ // ctx.body = '接收到的请求' // 这里是新增的 let postData = ctx.request.body ctx.body = postData }else { ctx.body = ` &lt;h1&gt;404&lt;/h1&gt; ` }})app.listen(8040)console.log('[demo] start quick is starting at port 8040') 经验注意在引用时，切记 ==app.use(bodyParser())== 中的括号，不写括号会报错 1koa-bodyparser ctx.onerror is not a function 第7节 Koa2原生路由实现路由用来根据不同的url切换显示的页面内容。这节课不借助中间件，用原生方法实现简单路由。 ctx.request.url要实现路由，需要得到地址栏的请求路径。根据路径的不同进行跳转。 通过一个简单的例子，了解如何通过ctx.request.url来获取访问路径。 123456789101112const Koa = require('koa')const app = new Koa()app.use(bodyParser())app.use( async (ctx) =&gt; { let url = ctx.request.url ctx.body = url})app.listen(8040) 这时，访问http://localhost:8040/demo,页面输出/demo。 根据这个，可以获取到不同的请求链接。 原生路由实现大体思路： 根据传入的url，选择对应的页面名称 调用fs读取文件，将文件内容传给ctx.body。 页面显示 注意case中写选项时，要注意url的全路径，刚开始写的’todo’, ‘404’ 这是不生效的，要写成’/todo’, ‘/404’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const fs = require('fs')const Koa = require('koa')const app = new Koa()app.use( async (ctx) =&gt; { let url = ctx.request.url ctx.body = await router(url)})async function router(url) { let page = '404.html' switch(url) { case '/': page = 'index.html' break case '/index': page = 'index.html' break case '/todo': page = 'todo.html' break case '/404': page = '404.html' break default: break } // 用异步来接收html，防止页面卡死 let html = await render(page) return html}function render(page){ return new Promise((resolve, reject)=&gt;{ let pageUrl = `./page/${page}` fs.readFile(pageUrl, 'UTF-8', (err, data)=&gt;{ if(err){ reject(err) }else{ resolve(data) } }) })}app.listen(8040)console.log('[demo] start quick is starting at port 8040') 总结-7这节课了解了如何原生实现路由。 第8节 Koa-router中间件入门(1)上节写的路由只是很简单的例子，实际项目中都会用开源的中间件来完成路由配置。 这节课用koa-router来实现。 1. 安装koa-router1npm install --save koa-router 2. koa-router基础案例先写一个最简单的koa-router例子。 引入 新建一个实例 不同路由配置 use 12345678910111213141516const Koa = require('koa')const Router = require('koa-router')const app = new Koa()const router = new Router()router.get('/', function(ctx, next){ ctx.body = 'Hello Koa2'})app.use(router.routes()) .use(router.allowedMethods())app.listen(8040, ()=&gt;{ console.log('[demo] start quick is starting at port 8040')}) 多页面配置多页面配置，只需要加get,post即可。现在增加一个todo页面。 123456789101112131415161718192021const Koa = require('koa')const Router = require('koa-router')const app = new Koa()const router = new Router()router.get('/', function(ctx, next){ ctx.body = 'Hello Koa2'}).get('/todo', function(ctx, next){ ctx.body = 'Todo Page'})app.use(router.routes()) .use(router.allowedMethods())app.listen(8040, ()=&gt;{ console.log('[demo] start quick is starting at port 8040')}) 分别访问http://localhost:8040 和http://localhost:8040/todo，可以看到不同的结果。 第9节 Koa-router中间件 层级(2)设置前缀有时需要把所有路径前加一个层级，例如， http://localhost:8040/todo 加一个demo层级，变成http://localhost:8040/demo/todo. 路由在创建时可以指定一个前缀。这个前缀会被添加到路由最顶层。 1234const router = new Router({ prefix: '/demo'}) 访问： http://localhost:8040/demo/todo http://localhost:8040/demo 可以看到页面，访问原来的路径，会提示Not Found 路由层级上面是为全局设置层级，这里为单个页面设置层级，只要在use时，使用路径就可以了。 这里演示两个不同层级的路由设置。一个是home,一个是page,通过use赋予不同的前层级。 123456789101112131415161718192021222324252627282930313233343536// 使用koa-routerconst Koa = require('koa')const Router = require('koa-router')const app = new Koa()// 两个单独的路由let home = new Router()home.get('/koa', async(ctx) =&gt;{ ctx.body = 'Hello Koa'}).get('/todo', async(ctx) =&gt; { ctx.body = 'learning Koa'})let page = new Router()page.get('/koa', async(ctx) =&gt;{ ctx.body = 'Hello Koa Page'}).get('/todo', async(ctx) =&gt; { ctx.body = 'learning Koa Page'})// 装载所有子路由let router = new Router()router.use('/home', home.routes(), home.allowedMethods())router.use('/page', page.routes(), page.allowedMethods())// 加载路由中间件app.use(router.routes()).use(router.allowedMethods())app.listen(8040, ()=&gt;{ console.log('[demo] start quick is starting at port 8040')}) 分别访问/home/todo,/home/koa,/page/todo, /page/koa可以看到结果。 第10节 Koa-router 中间件参数 (3)这节学习如何传参 用ctx.query接收参数 第11节 Koa中使用Cookie这节学习操作cookie。 Koa的上下文(ctx)直接提供了读取和写入的方法。 ctx.cookies.get(name, [options]): 读取cookie ctx.cookies.set(name, value, [options]): 写入cookie 这里的cookie是写入浏览器中了 代码 12345678910111213141516171819// 操作cookieconst Koa = require('koa')const app = new Koa()app.use(async(ctx) =&gt; { if(ctx.url === '/index'){ ctx.cookies.set('name', 'Hello Koa') ctx.body = 'cookie is set.' }else{ ctx.body = 'Hello Koa' }})app.listen(8040, ()=&gt;{ console.log('[demo] start quick is starting at port 8040')}) 访问localhost:8040/index ，按F12可以看到cookies Cookie选项一些配置项 domain: cookie所在域名 path: 所在路径 maxAge: 最大有效时长 expires: cookie失效时间 httpOnly: 是否只从http请求中获取 overwrite: 是否允许重写 12345678ctx.cookies.set('name', 'Hello Koa',{ domain:'localhost', // 写cookie所在的域名 path:'/index', // 写cookie所在的路径 maxAge:1000*60*60*24, // cookie有效时长 expires:new Date('2018-12-31'), // cookie失效时间 httpOnly:false, // 是否只用于http请求中获取 overwrite:false // 是否允许重写}) 读取cookie用ctx.cookies.get()来读取 12345if(ctx.cookies.get('name')){ ctx.body = ctx.cookies.get('name')}else{ ctx.body = 'No cookie is set~~'} 注意，如果上面的path设置的是index的话，访问localhost:8040是获取不到name这个cookie的,需要将path设为’’ 第12节 Koa2 的模板初识 (ejs)开发不可能把所有的html代码全加载到JS里，也没办法完成大型web开发。必须借用模板来帮助我们开发。 这节简单了解一下Koa2的模板机制。需要靠中间件来完成开发。 安装中间件1npm install --save koa-views 安装 ejs 模板引擎ejs是著名并且强大的模板引擎，可以单独安装。 1npm install --save ejs 编写模板为了模板统一管理，新建一个view文件夹，并新建index.ejs文件 views/index.ejs 1234567891011121314151617181920212223// 引用ejs模板const Koa = require('koa')const views = require('koa-views')const path = require('path')const app = new Koa()app.use(views(path.join(__dirname, './views'), { extension: 'ejs'}))app.use(async(ctx)=&gt; { let title = 'Hello Koa2' await ctx.render('index', { title })})app.listen(8040, ()=&gt;{ console.log('[demo] start quick is starting at port 8040')}) 总结-12这里只是简单的讲解了koa2的模板机制。 第13节： koa-static静态资源中间件开发中不只要处理业务逻辑请求，也会有很多静态资源请求，如js, css, jpg, png 这些静态请求。有时候也会访问静态资源路径 用koa可以直接访问这些静态文件，但代码会冗长，这节课利用 koa-static 来实现静态资源访问。 安装koa-static1npm install --save koa-static 新建 static 文件夹在static文件夹中放js, css, imgkoa.png, test.js, style.css 使用koa-static12345678910111213141516171819// 引用静态资源const Koa = require('koa')const path = require('path')const static = require('koa-static')const app = new Koa()const staticPath = './static'app.use(static(path.join(__dirname, staticPath)))app.use( async ( ctx ) =&gt; { ctx.body = '访问静态资源试试 koa.png, test.js, style.css' }) app.listen(8040, ()=&gt;{ console.log('[demo] start quick is starting at port 8040')}) 在浏览器中访问： &lt;http://localhost:8040/style.css&gt; &lt;http://localhost:8040/test.js&gt; &lt;http://localhost:8040/koa.png&gt;","link":"/posts/Koa2-%E8%BF%9B%E9%98%B6/"},{"title":"React Native入门","text":"开发环境搭建 Android studio python2 java sdk 并配置java环境变量 12npm install -g react-nativenpm install -g react-native-cli 启动虚拟器avd 是灰色 无法点击配置AndroidSDK tools到path变量删除.android文件，重新导入，即可 如果打包失败报错12Error:Execution failed for task ':app:transformClassesWithInstantRunForAcproductionDebug'.&gt; Invalid signature file digest for Manifest main attributes 在android studio中的settings搜instant run，将enable instant run to hot swap关闭，取消选中。 调试js打开模拟器后，按Ctrl+M,（ios按ctrl+D） 选择debug remote js. 浏览器会自动打开一个窗口，在那个窗口中按ctrl+shift+J ，在console窗口会看到打印出来的信息。 选择 Enable Hot Reloading,可以开启热加载 按(r,r) 刷新，（ios按command+r） 如果android模拟器无法连接本地服务按ctrl+ M dev Setting Debug server host &amp; port for device 设置IP:8081 联调硬件 先要给设备配网(按中间的按钮 5s) 然后绑定设备 react native 绑定事件12345678910111213onPressSwitch() { console.log('changed') let status = this.props.powerStatus status == 'off' ? status = 'on' : status = 'off' this.props.callbackPowerChanged(status)}&lt;!--之前的绑定事件是要用bind的 --&gt; &lt;TouchableOpacity onPress={this.onPressSwitch.bind(this)}&gt; &lt;Image source={require('../../assets/light-close.png')}/&gt; &lt;Text style={styles.switchInfo}&gt;轻触开启&lt;/Text&gt;&lt;/TouchableOpacity&gt; 用es6的箭头函数之后， 1234567&lt;!--这里是箭头函数--&gt;onPressSwitch = () =&gt; { console.log('changed') let status = this.props.powerStatus status == 'off' ? status = 'on' : status = 'off' this.props.callbackPowerChanged(status)} 这是用新的绑定 ，不要bind ，==[正确的写法]== 12345 &lt;TouchableOpacity onPress={this.onPressSwitch}&gt; &lt;Image source={require('../../assets/light-close.png')}/&gt; &lt;Text style={styles.switchInfo}&gt;轻触开启&lt;/Text&gt;&lt;/TouchableOpacity&gt; 需要传参的写法 ==[传参的写法]== 123&lt;TouchableOpacity onPress={() =&gt; this.onPressSwitch(item)}&gt; &lt;Image source={getPicture('switch-'+item.status)}/&gt;&lt;/TouchableOpacity&gt; 如果不传参的话，不能写为空如下： ==[错误的写法]== 123&lt;TouchableOpacity onPress={() =&gt; this.onPressSwitch}&gt; &lt;Image source={getPicture('switch-'+item.status)}/&gt;&lt;/TouchableOpacity&gt; 这样会无法进入点击事件！！！！！ 解决办法就是不用() =&gt; {} 改用[正确的写法] setState 语法setState括号里必须是个对象，不是会报错。 1this.setState({'item': newItem}) 报错信息： 1setState(...): takes an object of state variables to update or a function which returns an object of state variables. 父与子组件传值在父组件中定义props。通过props传入子组件中。 父组件传给子组件父组件调用子组件 12&lt;ControlArea powerStatus={this.state.powerStatus} callbackPowerChanged={this.changePowerStatus.bind(this)}&gt;&lt;/ControlArea&gt; 其中powerSatatus是props，callbackPowerChanged是供子组件调用的方法。changePowerStatus是在父组件中供子组件调用时执行的方法。 子组件调用父组件子组件： 12345678onPressSwitch = () =&gt; { console.log('changed') let status = this.props.powerStatus status == 'off' ? status = 'on' : status = 'off'&lt;!--这个是调用父组件的方法。把修改后的状态值传给父组件，供父组件修改状态，父组件修改状态后，子组件会自动根据状态值更新页面。--&gt; this.props.callbackPowerChanged(status)} 注意有些数据既可以放在pros，又可以放在state中，那么建议不要放在state中， 子组件修改props需调用父组件的方法，体现了从上至下的数据流 根据数组，循环生成dom12345678&lt;View style={[styles.topCon]}&gt; {this.props.dataList.map((item, index) =&gt; ( &lt;TouchableOpacity key={index} onPress={() =&gt; this.onPressSwitch(item)}&gt; &lt;Image source={getPicture('switch-'+item.status)}/&gt; &lt;Text style={styles.itemText}&gt;{item.name}&gt;&lt;/Text&gt; &lt;/TouchableOpacity&gt; ))}&lt;/View&gt; 注意： this.props.dataList是父组件传给子组件的数据。 循环数据用的map 一定要有key键值，否则报错 注意绑定事件的写法，会将当前循环的元素传给事件。注意箭头函数写法。 路由跳转使用的是v0.50,官方推荐使用React Navigation 如果之前用的是其他路由，没有办法，只能全部换成这个了。 经验如果一时半会看不明白的话，可以先照着官网和其他人的示例先做一个简单的出来，然后照着改项目里的代码。 遇到的问题1. 初始化导航后，需要给初始的组件传值看文档好不容易找到了screenProps. 123&lt;SimpleApp screenProps={{tintColor: 'blue'}}/&gt; 在组件内取值 12345this.state = { // deviceInfo: JSON.parse(this.props.deviceInfoStr), 其他路由的取值 pageConfig: JSON.parse(this.props.screenProps.pageConfigStr), deviceInfo: JSON.parse(this.props.screenProps.deviceInfoStr),} 2. 路由跳转目前测试只能这样写，将navigate提取出来好像不可以。以后需做测试 123456789101112render() { const { navigate } = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;Hello, Chat App!&lt;/Text&gt; &lt;Button onPress={() =&gt; navigate('Chat')} title=&quot;Chat with Lucy&quot; /&gt; &lt;/View&gt; )} 3. 导航跳转到的组件是父页面， 而子页面中想用导航的navigation，此时是无法用的， 需要在父组件中将navigation传给子组件，这样，子组件就可以用父组件的navigation父组件中调用子组件，并把navigation传给子组件 1234&lt;Content pageConfig={this.state.pageConfig} navigation = {this.state.navigation} callbackPowerChanged={this.changePowerStatus.bind(this)}/&gt; 在子组件中 1234567891011 render() { const { navigate } = this.props.navigation return ( &lt;View style={[styles.container]}&gt; &lt;TouchableOpacity onPress={() =&gt;{ console.log(this.props, 'click'); navigate('Detail', {info: '这是传入的参数'})}}&gt; &lt;Text style={styles.itemText}&gt;啊啊&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; )} 4. 返回上一级注意，用之前确保有navigation这个属性，没有的话看上面的例子。 123456goBack = () =&gt; { this.props.navigation.goBack()}// 在按钮上加事件onPress={this.goBack} 3.无关组件间传值官方文档只找到这句话： JavaScript模块可以通过使用DeviceEventEmitter模块来监听事件： 引用 1import { View, DeviceEventEmitter } from 'react-native' 监听事件 123456789componentDidMount() { this.subSwitchEmitter = DeviceEventEmitter.addListener('subSwitch', (e) =&gt; { this.changePowerStatus(e.item) }); // 修改子页面名称用 this.modifyItemEmitter = DeviceEventEmitter.addListener('modifyItemProp', (e) =&gt; { this.modifyItemProp(e.item) });} 触发监听事件，发出通知 1DeviceEventEmitter.emit('subSwitch', {item: this.state.item}); 移除监听 1234567 componentWillUnmount() { // 移除所有的事件 DeviceEventEmitter.remove(); // 单个移除 this.subSwitchEmitter.remove(); this.modifyItemEmitter.remove();} ref的使用 父传子，通过ref 1234// 定义ref&lt;SonCompoent ref=&quot;son&quot; /&gt;// 获取子组件，执行指定方法，方法参数中传值this.refs.son.receiveMoney(1000); Ref 使用场景 触发焦点，文本选择，媒体播放 触发强制性动画 集成第三方DOM库 给DOM 添加Refs, 参考 弹框用Modal组件 mac配置连接windows的服务1234567NSURL *jsCodeLocation;[[RCTBundleURLProvider sharedSettings] setDefaults];#if DEBUG[[RCTBundleURLProvider sharedSettings] setJsLocation:@&quot;192.168.1.101&quot;];#endifjsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil]; reactnative 有的按钮点击事件无法触发可能原因是布局问题，先给要点击的元素加边框，看所在位置， 再确认有没有其他元素占用了他的位置，遮挡在他上面了，导致无法点击。 ios调试一直报无法连接package server，其实packageserver已经启动解决办法： 重新安装APP. setState设置状态后，直接console.log获取到的还是旧数据12this.setState({data:data});console.log(this.state.data); 解决办法： setstate后，获取的数据还是旧的原因： 1.setState异步调用2. 批量处理 并不是调用一次就会更新一次render setState之后，需要走完RN生命周期，也就是走到render时，state的值才会变成setState的值，要立即使用state的值，需要在回调中使用 正确写法 12345678this.setState(state,()=&gt;{ console.log(this.state);});this.setState({'dataList': this.state.lastStatus}, ()=&gt;{ console.log(this.state.dataList, '回调') this.changeBgColor();}) 第二种办法在store中定义，根据action请求返回的值 ，根据逻辑处理需要显示的值 mac调试总是提示：Xcode Error输出1Runtime is not ready for debugging. Make sure Packager server is running. 解决办法 在RCTWebSocketExecutor.m文件中，把localhost修改为与AppDelegate.m中相同的IP地址(一般为电脑IP). 12NSString *host = [[_bridge bundleURL] host] ?: @&quot;localhost; 12NSString *host = [[_bridge bundleURL] host] ?: @&quot;172.16.126.97&quot;; http://www.jianshu.com/p/90ceb04da552 上行 下行设备发给云端 设备上报 上行 app或者云端给设备发消息属于下行 修改为redux后，思路整理我有一个state(deviceData),设备端有个对应的state,deviceProperty 也有个对应的state, 然后三者要统一。 先在deviceProperty中根据设备返回的设置一模一样的参数，，然后等上报以后根据不同的值，再整理值放到state中。 页面渲染，根据deviceProperty进行渲染。 最终结果，都放到了deviceProperty中了。 引入Redux后数据处理逻辑原来用父子组件处理state 父组件中存有父组件相关的state, 子组件相关的state, 子组件用父组件中的state时，父组件通过prop传给子组件 子组件要修改父组件时，通过父组件传递过来的事件，调用父组件定义好的事件，由父组件更改状态， 子组件自动更新 子组件中可以有一套自己的state redux的数据处理逻辑 所有的数据都在store中定义好,可以有不同的对象 123456789101112const initState = { deviceInfo: { deviceId: 0, }, deviceProperty: { id: 0, timestamp: 0, finalColor: 'rgba(56,171,193,0.90)', },}export default initState 在store中引用 1234567891011const store = createStore( reducers, initState, applyMiddleware( thunk, createPromise(), createLogger() ))export default store 要更改store中的数据，都通过action去调用事件触发 12345678910111213141516const powerOn = (subDomainName, physicalDeviceId, command) =&gt; ({ type: types.powerOn, payload: { promise: BindManager.sendDevice( subDomainName, physicalDeviceId, { code: command.code, content: new Uint8Array(command.content) } ), data: { } }}) action请求回调返回结果，根据返回成功失败，在reducer中分别处理store中的数据。 123456789101112131415161718192021222324case `${types.powerOn}_PENDING`: return Object.assign({}, state, { isFetching: true, })case `${types.powerOn}_FULFILLED`: return Object.assign({}, state, { powerStatus: 'on', lineStart: state.finalColor, lineEnd: state.finalColor, isFetching: false })case `${types.powerOn}_REJECTED`: if(action.payload.errorCode){ console.log(getInfoByCode(action.payload.errorCode), '信息') } return Object.assign({}, state, { isFetching: false, toastTip: { showNum: state.toastTip.showNum + 1, text: '开启失败.'+action.payload } }) 开关逻辑修改设备只要传 id，对应的开关值，0,1 就行。 对应到代码： 发送command时，需要组合好开关id，状态。 指令发送成功需要根据开关id和值改变store中的值。 还要进行背景颜色的判断。 尼玛，修改名称找谁改。—干掉了 子页面的开关控制逻辑修改之前是用的navigation将当前点击的item传入子页面 传入后根据事件监听触发修改，用的是 ==DeviceEventEmitter== , 改成redux后， 直接在store中读取props的属性根据传入item 的id找到当前的item,根据不同的状态值， (注意，此处传入也是通过navigation传入的。) 再子页面中直接发送action， reducer修改store中的数据后， 在子页面中用 ==componentWillReceiveProps== 来监听数据的变化，并根据相应的值，来切换状态。 国际化插件react-native-i18n这个插件需要改动android和iOS 的代码！！！！ 安装 npm install react-native-i18n --save 关联android react-native link 注意： 这里执行命令后，android测试会报错。 根据文档挨个检查对应的文件夹，看哪个没有添加，添加对应的调用语句即可。 ./android/settings.gradle ./android/app/build.gradle (我这里↑没有自动添加，手动添加的) ./android/app/src/main/java/your/bundle/MainApplication.java IOS还没有测试 使用1. 封装一个单独的js出来新建一个文件夹i18n index.js 1234567891011121314import i18n from 'react-native-i18n';import translations from './translations';// 这个为默认，的如果没有找到对应的语言，则为默认的。i18n.defaultLocale = 'en';i18n.fallbacks = true;i18n.translations = { en: translations.en, zh: translations.zh,};export default i18n; 2. translations为中英文对应的文字信息translations.js 123456789101112131415161718export default { en: { greeting: 'Greeting in en', exit: 'exit?', tapSwitch: 'Tap to switch', Switch: 'Switch', Timing: 'Timing', Countdown: 'Countdown', }, zh: { greeting: '欢迎欢迎热烈欢迎', exit: '是否退出?', tapSwitch: '轻触可开关', Switch: '开关', Timing: '定时', Countdown: '倒计时', },}; 注意，这里的中英文可以单独出来，做成两个单独的文件。zh.js 12345678export default { greeting: '欢迎欢迎热烈欢迎', exit: '是否退出?', tapSwitch: '轻触可开关', Switch: '开关', Timing: '定时', Countdown: '倒计时',}; en.js 12345678export default { greeting: 'Greeting in en', exit: 'exit?', tapSwitch: 'Tap to switch', Switch: 'Switch', Timing: 'Timing', Countdown: 'Countdown',}; 在单独引入文件 123456789101112import i18n from 'react-native-i18n';import en from './en';import zh from './zh';i18n.defaultLocale = 'en';i18n.fallbacks = true;i18n.translations = { en, zh,};export default i18n; 3. 业务层调用1234567import {i18n} from '你预设的index的目录';// jsi18n.t('Timing')// html&lt;Text style={styles.text}&gt;{i18n.t('Timing')}&lt;/Text&gt; 总结首先Native那里获取本手机的LocaleList然后格式化取第一个元素交由I18n.js处理， 然后I18n.js根据key选用一套有效的语言规则， 再之后流程就和使用时候的顺序一样了。 toast插件 react-native-easy-toast这个插件不需要改动android和ios代码 安装 1npm i react-native-easy-toast --save 引用 1import Toast, {DURATION} from 'react-native-easy-toast' 在html中需要写在View底部引用 1&lt;Toast ref=&quot;toast&quot;/&gt; js调用显示 1234567891011// 默认250ms消失this.refs.toast.show('hello world!');// 不消失this.refs.toast.show('hello world!', DURATION.FOREVER);// 默认2s消失this.refs.toast.show('hello world!', DURATION.LENGTH_LONG);// 自定义时间消失this.refs.toast.show('hello world!', 3000); 问题在position设置为居中时，是去掉导航栏以外的区域居中的，所以感觉整体偏下，可以改源码里的position为center时，减去positionValue的值。 但打包时怎么办，好像看到有的demo里是居中的，也有可能是自己代码css问题。 硬件APP开发功能点 第一次打开APP获取设备状态，所有属性值都要 设备不在线时对页面遮罩，禁用所有功能， 设备上报获取所有属性，并根据不同值重置页面 设备发送指令，成功后，修改APP状态 失败后，提示信息显示，不能更改APP状态 PropTypes在编写组件时，希望每个地方都能用到，但别人怎么用，就不知道了。所以需要制定一些规则，比如必须传什么参数，参数是什么类型的。 因为JavaScript语言特点，这种情况下，页面虽显示不正常，但不会报错。很难找到bug位置。 react提供了一种类型检测机制，用来确保接收到的参数是有效的。 例如，我们可以使用PropTypes.string 语句。当给 prop 传递了一个不正确的值时，JavaScript控制台将会显示一条警告。出于性能的原因，propTypes 仅在开发模式中检测。 首先，要安装react提供的第三方库 prop-types：(貌似只针对15.5.0之后的版本，公司项目15.4.2 并不需要install， 直接用就行了） 1npm install --save prop-types 使用 12345678910111213import PropTypes from 'prop-types';class Greeting extends React.Component { render() { return ( &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt; ); }}Greeting.propTypes = { name: PropTypes.string}; React.PropTypes.element.isRequired，可以为组件指定必须项 defaultProps：为props指定一个默认值 123Greeting.defaultProps = { name: 'Stranger'}; adb.exe目录C:\\Users\\z\\AppData\\Local\\Android\\Sdk\\platform-tools添加到系统环境变量，可以直接执行adb命令 adb install -r name.apk用命令行安装apk js用switch case实现区间重点是switch(true){} 123456789101112131415161718192021222324252627function getAQIDegree(jq){ switch(true){ case jq&lt;51: return '优' break case jq&lt;101: return '良' break case jq&lt;151: return '轻度污染' break case jq&lt;201: return '中度污染' break case jq&lt;301: return '重度污染' break case 300&lt;jq: return '严重污染' break default: break }}","link":"/posts/React%20Native%E5%85%A5%E9%97%A8/"},{"title":"React SSR 梳理","text":"基本概念什么是服务器端渲染？什么是客户端渲染？什么是同构？ 客户端渲染 CSR页面初始加载的HTML中无网页展示内容，需要加载JavaScript中的React代码,通过JavaScript渲染生成页面，同时，JavaScript代码会完成页面交互事件的绑定。 流程如下： 服务端返回HTML到浏览器 浏览器下载JS 浏览器执行js, React——-在这之前都是loading(包括3) 页面显示，可交互 服务器渲染用户请求服务器，服务器上直接生成HTML内容并返回浏览器。页面内容直接由Server端生成。服务器端渲染的页面交互能力有限，要实现复杂交互，还是要通过引入JavaScript文件来辅助实现。 同构SSR这个概念存在于Vue， React这些新型的前端框架中，同构实际是客户端渲染和服务器渲染的一个整合。把页面的展示内容和交互写在一起，让代码执行两次。服务器端执行一次，用于实现服务器端渲染，客户端再执行一次，用于接管页面交互。 流程如下： 服务器发送已经渲染好的HTML到浏览器—-仅在这一过程页面loading 浏览器渲染页面,页面显示，开始下载JS 浏览器执行JS/React 页面可交互 为什么使用SSR技术主要因素： CSR项目的TTFP(Time To First Page)时间较长。加载HTML，下载JavaScript，JavaScript渲染生成页面。在这个渲染过程中至少涉及到两个HTTP请求周期，所以会有一定的耗时。这也是为什么低俗网络下，初始页面会有白屏的原因。 CSR项目的SEO能力极弱。搜索引擎主要识别的内容还是HTML，对JavaScript文件内容的识别都还比较弱。 减少API请求次数 SSR的产生，主要就是为了解决上面两个问题。在React中使用SSR，让React在服务器端先执行一次，使得用户下载的HTML已经包含了所有的页面展示内容，这样页面展示的过程只需经历一个HTTP请求周期，TTFP时间得到一倍以上缩减。同时HTML中已经包含了网页的所有内容，SEO效果也会变得非常好。 之后React在客户端再次执行，为HTML中的内容添加数据及事件的绑定，页面就具备了React的各种交互能力。 主要区别：客户端从无到有的渲染，服务端是先在服务端渲染一部分，在再客户端渲染一小部分。 SSR技术架构图1234567891011121314客户端(浏览器) Node服务器 API服务器访问地址--------- 1.接收请求 2.路由分析获取即将展示的组件信息 3. 获取组件所需数据----------- 4.接收请求，返回接口数据6.显示HTML, 5.渲染组件，返回渲染后的HTML加载需要的bundle.js (服务端渲染完成) 7.获取bundle.js文件 8.接收请求 9.返回bundle.js 10. 加载运行bundle.js进行客户端渲染11. bundle.js发送请求 12.收到请求，代理到业务接口 13. 接受请求，返回接口数据 14.获取到数据返回15.获取到请求数据，完成客户端渲染 缺点使用SSR使得原本简单的React项目变得非常复杂，项目的可维护性降低，代码追溯变得困难。有时这些副作用比起优势要大得多。一般除非特别依赖搜索引擎流量，或对首屏时间有特殊要求，不建议使用SSR。只有NodeJS环境可以SSR：若后端使用python或是ruby等语言，处理React SSR就要多开一台NodeJS Render Server，多了维护上的麻烦。 SSR技术难点剖析虚拟DOM和SSR的关系SSR之所以能实现，本质上上因为虚拟DOM的存在 SSR的工程中，React代码会在客户端和服务端各执行一次。如果React代码中存在直接操作DOM的代码，那么就无法实现SSR这种技术。因为在node环境中，没有DOM这个概念存在。所以这些代码在node环境下会报错。 虚拟DOM是真实DOM的一个JavaScript对象映射。React在做页面操作时，实际上不是直接操作DOM，而是操作虚拟DOM，也就是操作普通JavaScript对象，这就使得SSR成为了可能。 在服务端，可以操作JavaScript对象，判断环境是服务器环境，把虚拟DOM映射成字符串输出；在客户端，操作JavaScript对象，判断是客户端环境，将虚拟DOM映射成真实DOM，完成页面挂载。 细说流程图第3步：服务器要根据请求地址，判断展示什么页面。这一步叫做服务器端路由。第10步：客户端接收到JavaScript文件后，要根据当前路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，这时，还要经历一次客户端路由(前端路由) SSR中客户端渲染与服务端渲染路由代码差异实现React的SSR架构，需要让相同的React代码在客户端和服务端各执行一次。这里说的相同的React代码，指的是各种组件代码，所以在同构中，只有组件代码是可以共用的。而路由这样的代码是没有办法公用的。 原因：服务端需要通过请求路径，找到路由组件；在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制。所以这部分代码肯定无法公用。 代码示例：客户端路由 123456789101112const App = () =&gt; { return ( &lt;Provider store={store}&gt; &lt;BrowserRouter&gt; &lt;div&gt; &lt;Route path='/' component={Home}&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; )}ReactDom.render(&lt;App/&gt;, document.querySelector('#root')) 服务端路由： 1234567891011const App = () =&gt; { return &lt;Provider store={store}&gt; &lt;StaticRouter location={req.path} context={context}&gt; &lt;div&gt; &lt;Route path='/' component={Home}&gt; &lt;/div&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt;}return ReactDom.renderToString(&lt;App/&gt;) 服务端路由代码相对复杂点，需要把location(当前请求路径)传递给StaticRouter组件，这样StaticRouter才能根据路径分析出当前所需要的组件是哪个。 StaticRouter是React-Router针对服务端渲染专门提供的一个路由组件 BrowerRouter能够匹配到浏览器即将显示的路由组件，对浏览器来说，需要将组件转化成DOM，用ReactDom.render进行DOM挂载。 StaticRouter能够在服务器端匹配到将要显示的组件，对服务端来说，需要将组件转化成字符串，用ReactDom.renderToString方法，就可以及时得到App组件对应的HTML字符串 对一个React应用来说，路由一般是整个程序的执行入口，在SSR中，服务端的路由和客户端的路由不一样，意味着服务端的入口代码和客户端的入口代码是不同的。 所以，针对代码运行环境的不同，要进行有区别的webpack打包。 服务端和客户端代码的打包差异客户端webpack配置 123456789101112131415161718192021222324252627{ entry: './src/client/index.js', output: { filename: 'index.js', path: path.resolve(__dirname, 'public') }, module: { rules: [{ test: /\\.js?$/, loader: 'babel-loader' },{ test: /\\.css?$/, use: ['style-loader', { loader: 'css-loader', options: {modules: true} }] },{ test: /\\.(png|jpeg|jpg|gif|svg)?$/, loader: 'url-loader', options: { limit: 8000, publicPath: '/' } }] }} 服务端webpack配置1234567891011121314151617181920212223242526272829303132333435{// 这里不同 target: 'node',// entry不同 entry: './src/server/index.js', output: { filename: 'bundle.js', // 输出路径不同 path: path.resolve(__dirname, 'build') },// 这里不同 externals: [nodeExternals()], module: { rules: [{ test: /\\.js?$/, loader: 'babel-loader' },{ test: /\\.css?$/, // 这里不同 use: ['isomorphic-style-loader', { loader: 'css-loader', options: {modules: true} }] },{ test: /\\.(png|jpeg|jpg|gif|svg)?$/, loader: 'url-loader', options: { limit: 8000, // 这里不同 outputPath: '../public/', publicPath: '/' } }] }}; 可以看到，服务端渲染和客户端配置是有差异的。 node核心模块: 在服务端运行的代码，需要引入Node的一些核心模块。在模块打包时，需要Webpack识别出类似的核心模块，一旦发现是核心模块，不必把模块的代码合并到最终生成的代码中。解决这个问题，只需在服务端webpack中加入target: node。 第三方模块: 服务端渲染的代码，如果加载第三方模块，这些模块不用打包到最终源码中，因为Node环境下通过NPM已经安装了这些包，直接引用就行，不需要额外再打包到代码里。解决这个问题，可以使用webpack-node-externals插件 CSS样式饮用: React代码中引入CSS样式代码，服务端打包的过程会处理一遍CSS，客户端又会处理一遍。解决：服务端使用isomorphic-style-loader它处理CSS时，只在对应的DOM元素上生成class类，返回生成的CSS样式代码。 ---看文档有点没懂，还要改组件代码?需要测一下 图片引入: 图片等类型文件的引入，url-loader会在服务端和客户端打包的过程中分别打包。上述配置无论服务端还是客户端打包，都把打包生成的文件存储在public目录下，这样虽然打包出来两遍，但后打包的会覆盖之前文件，看起来只有一份文件。这样做性能优雅性不高，可以让图片大打包只进行一次，借助webpack的插件或自己写loader。 如果React的应用中没有一部数据的获取。单纯的做静态展示。经过上面配置，简单的SSR应用就可以实现了 异步数据获取 + Redux使用客户端渲染，异步数据结合Redux的使用方式遵循下面的流程(对应上面12步): 创建Store 根据路由显示组件 派发Action获取数据 更新Store中的数据 组件Rerender 服务端，页面一旦确定，就没法Rerender了，这就要求组件显示时，把Store的数据都准备好。所以服务端流程如下(对应第4步)： 创建Store 根据路由分析Store中需要的数据 派发Action 更新Store中的数据 结合数据和组件生成HTML，一次性返回 分析服务端渲染流程 创建Store: 客户端渲染中，用户浏览器中永远只存在一个Store，所以代码如下： 12const store = createStore(reducer, defaultState)export default store; 而在服务端的Store是所有用户共用的。如果如上创建Store，Store变成一个单例，所有用户共享Store，显示就有问题了。所以在服务端渲染中，Store创建如下，返回一个函数，每个用户访问时，这个函数重新执行，为每个用户提供独立的Store： 1234const getStore = (req) =&gt; { return createStore(reducer, defaultState);}export default getStore; 根据路由分析Store中需要的数据在服务端，需要分析当前路由要加载的所有组件，借助第三方包，比如react-router-config.(所有路由path都要改为绝对路径)这个包会根据传入服务的请求路径，分析出这个路径下要展示的所有组件。 派发Action获取数据在每个组件上增加一个获取数据的方法： 123Home.loadData = (store) =&gt; { return store.dispatch(getHomeList())} 需要将服务端渲染的Store传进来，它的作用就是帮助服务端的Store获取到这个组件所需的数据。所以组件有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的loadData方法，就能获取到路由所需的所有数据内容. 更新Store中的数据需要在生成HTML之前，保证所有的数据都获取完毕。怎么处理？ 123456789101112// matchedRoutes 是当前路由对应的所有需要显示的组件集合matchedRoutes.forEach(item =&gt; { if (item.route.loadData) { const promise = new Promise((resolve, reject) =&gt; { item.route.loadData(store).then(resolve).catch(resolve); }) promises.push(promise); }})Promise.all(promises).then(() =&gt; { // 生成 HTML 逻辑}) 构建Promise队列，等待所有Promise都执行结束后，再生成HTML。 到此，就结合实现了Redux实现了SSR流程 服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。——-不都是通过React-router跳转的吗 客户端获取数据在componentDidMount阶段，这个阶段服务端不会执行，所以不必担心和loadData冲突。这也是为什么数据的获取应该放到componentDidMount阶段，可以避免服务端和客户端获取数据冲突。 Node只是一个中间层在SSR架构中，一般node只是一个中间层，用来做React代码的服务端渲染，而node需要的数据通常由API服务器单独提供。 一是为了解耦，而是规避Node服务器的一些计算性能问题。 服务端直接请求API服务没问题，但在客户端，可能存在跨越问题。通过请求node服务器，经过代理转发，拿到API的数据。可以通过express-http-proxy这样的工具搭建proxy代理功能，需要注意，让代理不服不仅转发请求，还要携带cookie，避免权限校验问题。 123456// Node 代理功能实现代码app.use('/api', proxy('http://apiServer.com', { proxyReqPathResolver: function (req) { return '/ssr' + req.url; }})); 总结整个SSR流程体系中的关键知识点和原理就讲完了。当然还有很多细节的处理。比如不同页面配置不同title和description来提示SEO，可以用react-helmet等工具，还要工程目录的设计，404，301重定向的处理等等。需要在实践中各个击破~~ 补充React16.X中的SSR hydrateReact在客户端渲染的render基础上，增加了新的方法hydrate.如果尽在客户端呈现内容，使用render方法就已经够用了，如果客户端要在服务端的基础上渲染，用hydrate。使用方法：12import {hydrate} from 'react-dom';hydrate(&lt;HomePage/&gt;,document.getElementById('app')); 运行后会提示之后版本会移除render，完全用hydrate代替。 hydrate解决的是如何复用server端，ReactDOMServer的结果。 stream 针对renderToString和renderToStaticMarkUp提供了stream方法 renderToNodeStream renderStaticNodeStream 这两个方法同样接收的参数为react element，但返回的不是HTML字符串，而是一个可读流。 React16之前用renderToString，和renderToNodeStream区别：renderToNodeStream支持直接渲染到节点流，渲染到流可以减少TTFB时间，在文档的下一部分生成之前，将文档的开头至结尾发送到浏览器。当内容从服务器流式传输时，浏览器开始解析HTML。速度是renderToString的3倍(官方)。 123456789101112131415import {renderToStaticMarkup,renderToNodeStream} from 'react-dom/server'const root = (&lt;Provider store={store}&gt; &lt;StaticRouter location={req.url} context={context} &gt; &lt;App&gt;&lt;/App&gt; &lt;/StaticRouter&gt; &lt;/Provider&gt;) const markupStream = renderToNodeStream(root) markupStream.pipe(res,{end:false}) markupStream.on('end',()=&gt;{ res.end() })}) 必须包括可选参数 {end:false}告诉流当渲染完成不自动结束响应。这允许我们完成HTML主体，并在流完全写入响应后结束响应。 注意事项 尽量避免使用window等客户端变量Server端没有window对象，如果需要使用从window开始逐级判断 客户端对象的判断用typeofif(window &amp;&amp; window.autoScroll) =&gt; if(typeof window != &quot;undefined&quot; &amp;&amp; window.autoScroll) 避免往window等全局对象挂载定时器可能内存泄漏 避免random()等不确定性输出(输出结果可预期，不依赖于环境等)可能造成server端和web端DOM匹配检验不成功 避免使用第三方非react库用react包装一个jQuery写的富文本编辑器 参考链接 React 中同构（SSR）原理脉络梳理","link":"/posts/React-SSR-%E6%A2%B3%E7%90%86/"},{"title":"React全家桶视频教程","text":"学习网址全家桶 第一节 React 简介ReactReact起源于Facebook的内部项目，该公司积极尝试引入HTML5技术用来架设Instagram网站，开发中发现HTML5的性能下降明显，达不到预期的效果。他们就自己开发了React框架。 ReactJS官方地址 GitHub地址 react 特点 虚拟DOM: React也是以数据驱动的，每次数据变化React都会扫码整个虚拟DOM树，自动计算与上次虚拟DOM的差异变化，然后针对需要变化的部分进行实际的浏览器DOM更新。 组件化： React可以从功能角度横向划分，将UI分解成不同组件，各组件都独立封装，整个UI是由一个个小组件构成的一个大组件，每个组件只关系自身的逻辑，彼此独立。 单项数据流：React设计者认为数据双向绑定虽然便捷，但在复杂场景下副作用也是很明显，所以React更倾向于单向的数据流动-从父节点传递到子节点。（使用ReactLink也可以实现双向绑定，但不建议使用） 第二节 构建：create-react-app 快速脚手架 官网creat-react-app优点 无需配置：官方的配置堪称完美，几乎不用你再配置任何东西，就可以上手开发项目。 高集成性：集成了对React，JSX，ES6和Flow的支持。 自带服务：集成了开发服务器，你可以实现开发预览一体化。 热更新：保存自动更新，让你的开发更简单。 全兼容性：自动处理CSS的兼容问题，无需添加-webkit前缀。 自动发布：集成好了发布成品功能，编译后直接发布，并且包含了sourcemaps功能。 create-react-app安装1npm install -g create-react-app 创建React项目1create-react-app react-app 注意： 目录名不要使用大小写。因为Linux下是严格区分大小写的。 启动服务1npm start 注意： 听懂不等于学会，一定要动手做一做。 第二节 构建工具 generator-react-webpack这也是个构建工具，需要yeoman支持。 优点介绍 基于webpack构建，可以很容易的配置自己需要的webpack。 支持ES6，集成了Babel-Loader。 支持不同风格的CSS（sass，less，stylus）。 支持PostCSS转换样式。 集成了esLint功能。 可以轻松配置单元测试，比如Karma和Mocha 安装需要先安装yeoman 12npm install -g yonpm install -g generator-react-webpack 创建目录1mkdir new-react-demo 进入文件 1cd new-react-demo 用生成器生成项目目录 1yo react-webpack 启动1npm start 第三节 构建： webpack一步一步构建01从头开始自己构建一个简单的React开发环境。 建立文件夹,进入文件夹 12mkdir react-webpackcd react-webpack 对webpack初始化 1npm init 如果感觉一直回车麻烦，可以加-y参数，这样npm就直接生成了。 1npm init -y 初始化后，可以安装webpack了。 1npm install --save-dev webpack 配置webpack.config.js在根目录建立webpack.config.js , 建立基本的入口出口文件 12345678910var path = require('path')module.exports = { // 入口文件 entry: './app/index.js', // 出口文件 output: { filename: 'index.js', path: path.resolve(__dirname, 'dist') }} 文件配置好后， 要根据文件的结构改造项目目录。在根目录下新建app和dist文件夹，在app文件夹里新建index.js文件 新建index.html在根目录新建index.html， 并引入webpack设置中的出口文件，代码如下。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;React全家桶&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引入出口文件 --&gt; &lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&gt; 新建index.js在/app/index.js中 1234567function component() { var element = document.createElement('div') element.innerHTML = 'Hello React' return element}document.body.appendChild(component()) 加入打包命令在package.json中，scripts属性加入build命令 123&quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;}, 在终端中输入npm run build ，就可以看到打包结果。 总结到这里为止，我们正确安装了webpack，进行了出入口配置，也看到了webpack的输出效果。 开发服务器配置添加实时更新的服务 安装webpack-dev-server1npm install --save-dev webpack-dev-server 安装完成后配置webpack.config.js 123456devServer: { contentBase: './', host: 'localhost', compress: true, port: 1717} 配置好后，在package.json里增加scripts命令 1234&quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot;}, –open是自动打开浏览器，都配置完成后可以在终端输入npm run server 看效果 自动刷新浏览器修改代码时，并不能自动刷新浏览器，查看最新效果。而是要再次npm run build才可以。只要在出口文件配置中增加一个publicPath: ‘dist/‘ 12345output: { filename: 'index.js', path: path.resolve(__dirname, 'dist'), publicPath: 'dist/'}, 在index.html中引入js 1&lt;script src=&quot;./dist/index.js&quot;&gt;&lt;/script&gt; 总结-3这节课主要配置webpack的基本配置。 第4节 构建： webpack一步一步构建02上节对webpack进行基础配置，已经能打包到页面中。这节主要针对ES6和React配置。学习之前需确保上节配置完成。 Babel安装配置webpack配置Babel需要先加入babel-loader，还需要支持es2015,React，所以安装4个包。 1npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 安装完成后，会在package.json中看到这些包和版本信息 12345678&quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;webpack&quot;: &quot;^3.8.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.4&quot;} 配置module在webpack.config.js中配置module，即loader。 123456789101112 module: { loaders: [ { test: /\\.js$/, exclude: /node_modules/, loaders: 'babel-loader', query: { presets: ['es2015', 'react'] } } ]} 编写Reactwebpakc已经配置完成。 这里写一个React文件来测试一下。 先安装React和React-dom这两个包。 安装React和React-dom1npm install --save react react-dom 安装完成后，将app/index.js中的原生js代码改写成React代码。 index.js 1234567import React from 'react'import ReactDOM from 'react-dom'ReactDOM.render( &lt;div&gt;Hello Webpack&lt;/div&gt;, document.getElementById('app')) 这里增加了#app的div，在index.html中添加 1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 配置完成后，npm run server可以看到效果。接下来就可以愉快的开发了 总结-4其实自己配置React开发环境在实际工作中并不多。因为我们的配置不是很成熟，而且支持较少。 这里学习只是为了更好的掌握React构建过程和设置参数，实际工作中尽量使用合适的脚手架工具。 第5节 路由： Hello React路由通过前面4节课已经可以顺利的构建React的基本开发环境了。 这节课开始用几节课的时间全面了解一下React Router。 路由在开发过程中都会用到。它是SPA(单页应用)的基础，可以说不会路由系统就无法使用React进行编程。 其实路由可以简单的看作我们平时访问的网址或地址。这样有助于理解，但并不正确。 router包安装1npm install --save react-router react-router-dom react-router: 是基本的router包，里面含的内容较多，但是在网页开发中有很多用不到，现在市面上的课程简单基本都是这个包的教程。 react-router-dom: 随着React生态环境的壮大，后出现的包。这个包比react-router轻巧许多。 注意： 安装了react-router就不用安装react-router-dom包了，这里只是为了讲课方便，所以安装了两个包。在实际开发中，请跟进需要进行安装。 安装时，使用–save，因为在生产环境中也要使用。 复习component之前学过React组件如何编写，这里简单复习一下。 做一个A页面的组件 在app文件夹下新建componentA.js，引入React包，并编写A页面的组件，代码如下： componentA.js 123456789import React from 'react'export default class componentA extends React.Component{ render(){ return( &lt;div&gt;A默认组件&lt;/div&gt; ) }} 这里用了ES6语法，这也是React现在推荐的，如果使用老语法会出现警告 在index.js中引入A组件，并改写渲染代码 123456789import React from 'react'import ReactDOM from 'react-dom'import Componenta from './componentA'ReactDOM.render( &lt;Componenta/&gt;, document.getElementById('app')) 预览看效果 经验 之前写的时候是 &lt;componentA/&gt;, 会报两个错误 Warning: &lt;componentA /&gt; is using uppercase HTML. Always use lowercase HTML tags in React.警告： html标签一定要用小写 Warning: The tag &lt;componentA&gt; is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.警告：标签&lt;componentA&gt;作为组件，首字母要大写 以上就是一个组件的开发和引用接下来仿照上面的方法开发两个新组件，ComponentB， ComponentC。代码如下 ComponentB.js 1234567891011import React from 'react'export default class componentB extends React.Component{ render(){ return( &lt;div&gt;这是B组件&lt;/div&gt; ) }} ComponentC.js 1234567891011import React from 'react'export default class componentC extends React.Component{ render(){ return( &lt;div&gt;这是C组件&lt;/div&gt; ) }} 写完后引入到index.js 文件 12345import Componenta from './componentA'import Componentb from './componentb'import Componentc from './componentc' 引入和书写路由页面制作好后，需要路由来切换。先引入路由包，这里用到两个模块Router，route。 123import {BrowserRouter as Router, Route} from 'react-router-dom' 改写文件，增加路由设置 123456789101112ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Route exact path=&quot;/&quot; component=&quot;{Componenta}&quot;/&gt; &lt;Route path=&quot;/componentb&quot; component=&quot;{Componentb}&quot;/&gt; &lt;Route path=&quot;/componentc&quot; component=&quot;{Componentc}&quot;/&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('app')) 注意：这里是错误的，不能加引号，正确如下123456789101112ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Route exact path=&quot;/&quot; component={Componenta}/&gt; &lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt; &lt;Route path=&quot;/componentc&quot; component={Componentc}/&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('app')) 注意，这里的exact是精确匹配的意思，如果有多层路由嵌套时，exact可以帮助我们精确匹配到想要跳转的路由 路由设置完毕还不能切换，需要做一个切换的组件。命名为&lt;nav/&gt; 开发Nav组件在app文件夹下新建一个nav.js，引入React和React-router-dom 12345678910111213141516import React from 'react'import {NavLink} from 'raect-router-dom'const NavBar = () =&gt; ( &lt;div&gt; &lt;div&gt; &lt;NavLink exact to=&quot;/&quot;&gt;ComponentA&lt;/NavLink&gt;&lt;br/&gt; &lt;NavLink to=&quot;/componentb&quot;&gt;ComponentB&lt;/NavLink&gt;&lt;br/&gt; &lt;NavLink to=&quot;/componentc&quot;&gt;ComponentC&lt;/NavLink&gt; &lt;/div&gt; &lt;/div&gt;)export default NavBar 组件编写完成后，引入index.js，并添加&lt;Nav/&gt;标签到代码里 12345678910111213ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Route exact path=&quot;/&quot; component={Componenta}/&gt; &lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt; &lt;Route path=&quot;/componentc&quot; component={Componentc}/&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('app')) 到这里，就可以进行预览了，也可以顺利的切换页面内容，说明路由已经起作用了。当然这只是路由最简单的写法。 总结这里编写代码的时候遇到点问题： 大小写要注意 html标签一定要用小写 标签&lt;componentA&gt;作为组件，首字母要大写，改为&lt;Componenta/&gt; 有的地方是不需要引号的 第6节 路由： NavLink中常用选项上节初识了React路由，并制作了小案例。这节学习NavLink标签上的选项 Route和NavLink的exact选项exact 精确匹配，一般而言，React会匹配所有能匹配的路由组件，exact可以使我们的匹配更精确。 exact的值为boolean, 为true表示严格匹配，为false表示正常匹配 1234&lt;Route path=&quot;/&quot; component={Componenta}/&gt;&lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt;// 这种情况，访问/componentb，会把component组件也显示出来 所以，用exact来解决这个问题 12&lt;Route exact path=&quot;/&quot; component={Componenta}/&gt;&lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt; 在多层(路由)路由嵌套时也会出现这个问题，要多用exact来解决精确匹配问题 NavLink使用样式怎样给NavLink添加样式呢，要先配置一下webpack.config.js文件。 先写一个css,和nav.js放在一个文件夹下，命名为nav.css nav.css 123.blue{ color: blue;} 在nav.js中引入css 1import './nav.css' 这时，会报错 12Module parse failed: Unexpected token (1:0)You may need an appropriate loader to handle this file type. 因为webpack还不能对css文件进行正确的解析，需要加入css的loader。先用npm安装style-loader和css-loader 1npm install --save-dev style-loader css-loader 安装好后，在webpack.config.js里配置css的loader。如下 1234 { test: /\\.css$/, loader: ['style-loader', 'css-loader']} 配置好后，需要重启一下服务器，才可以正确解析。 这时候，就可以在NavLink上加ClassName指定css类了。 1&lt;NavLink exact to=&quot;/&quot; className=&quot;blue&quot;&gt;ComponentA&lt;/NavLink&gt;&lt;br/&gt; 直接在NavLink上写样式除了用css文件这种方式，还可以更直接，在NavLink上写样式，看下面 12&lt;NavLink to=&quot;/componentb&quot; style={{color:'red',fontSize:'30px'}}&gt;ComponentB&lt;/NavLink&gt;&lt;br/&gt; 这种写法虽然只管好用，但是不建议在实际开发中使用，这增加了代码耦合度，不是一种好的编程方式。注意，跟原生写法完全不一样 下面是我直接写的。错误↓↓↓↓↓↓ 12&lt;NavLink to=&quot;/componentb&quot; style=&quot;{{color:red;font-size:30px;}}&quot;&gt;ComponentB&lt;/NavLink&gt;&lt;br/&gt; style后面的不能用引号引用，是个大对象 里面是key-value形式的，一个属性结束不是用分号 每个属性后面都要用引号引起来。 activeClassName作为一个链接，是有激活状态的。它接受一个类名。现在我们在nav.css定义一个active的类，把字体设为红色 .nav.css 123456.blue{ color: blue;}.active { color: red;} 修改NavLink标签 nav.js 123456789101112131415import React from 'react'import {NavLink} from 'react-router-dom'import './nav.css'const NavBar = () =&gt; ( &lt;div&gt; &lt;div&gt; &lt;NavLink exact to=&quot;/&quot; className=&quot;blue&quot;&gt;ComponentA&lt;/NavLink&gt;&lt;br/&gt; &lt;NavLink to=&quot;/componentb&quot; activeClassName=&quot;active&quot; style={{color:'#2BAB40',fontSize:'14px'}}&gt;ComponentB&lt;/NavLink&gt;&lt;br/&gt; &lt;NavLink to=&quot;/componentc&quot; activeClassName=&quot;active&quot;&gt;ComponentC&lt;/NavLink&gt; &lt;/div&gt; &lt;/div&gt;)export default NavBar 总结-6这节课虽然简单，但都是实际工作中常用到的小技巧，例如activeClassName，className，还有webpack配置也是必须掌握的。 一定要注意原生和React语法区别~~~~ 第7节 路由： 404设置和跳转项目中都要设置404页面，即路由不存在时跳转的页面。React中的404主要是靠Switch组件来完成的。 这节来学习Switch组件相关知识和跳转的相关知识。 Switch组件的使用 在index.js页面中，在引入路由的地方，引入Switch。 12import {BrowserRouter as Router, Route, Switch} from 'react-router-dom' 编写404页面 在app文件夹下新建error.js, 封装成组件，方便路由调用 error.js 123456789import React from 'react'export default class error extends React.Component{ render(){ return( &lt;h2&gt;404页面&lt;/h2&gt; ) }} 在nav.js中加入一个不存在的链接NavLink，以便错误时跳转到404页面 nav.js 12&lt;NavLink to=&quot;/notfound&quot; activeClassName=&quot;active&quot;&gt;404&lt;/NavLink&gt; Switch登场，改写index.js页面，如下： 1234567891011121314151617181920212223242526import React from 'react'import ReactDOM from 'react-dom'import {BrowserRouter as Router, Route, Switch} from 'react-router-dom'import Componenta from './componentA'import Componentb from './componentB'import Componentc from './componentC'import Nav from './nav'import Error from './error' // 新增ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Nav/&gt; //新增 &lt;Switch&gt; &lt;Redirect from=&quot;/redirect&quot; to=&quot;/componentb&quot;/&gt; &lt;Route exact path=&quot;/&quot; component={Componenta}/&gt; &lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt; &lt;Route path=&quot;/componentc&quot; component={Componentc}/&gt; &lt;Route component={Error}/&gt; //新增 &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('app')) ==注意==：Switch要将Route包括在里面 在浏览器中点击404 ，会跳转到error.js页面，这里的链接是随便写的，但是成功的跳到了错误页面。 注意顺序： 404应该在最后。 Redirect组件使用开发中有时需要在程序中根据业务逻辑进行跳转，或点击一个链接直接跳转到其他链接，这时，可以用Redirect组件来解决。 引入Redirect组件 在index.js中引入Redirect 组件 12import {BrowserRouter as Router, Route, Switch, Redirect} from 'react-router-dom' 加入跳转链接 在nav.js里加入一个准备跳转的链接，如下： 12&lt;NavLink to=&quot;/redirect&quot; activeClassName=&quot;active&quot;&gt;redirect&lt;/NavLink&gt; 这时候点击链接会跳转到404页面，但我们希望跳转到componentB页面。 加入&lt;Redirect&gt; 标签 在index.js中加入&lt;Redirect&gt;标签 1234567891011121314&lt;Router&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Switch&gt; &lt;Redirect from=&quot;/redirect&quot; to=&quot;/componentb&quot;/&gt; &lt;Route exact path=&quot;/&quot; component={Componenta}/&gt; &lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt; // 新增 &lt;Route path=&quot;/componentc&quot; component={Componentc}/&gt; &lt;Route component={Error}/&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt;, from: 表示来自于什么链接，也就是当前链接是redirect时，触发跳转命令 to: 表示要跳转到的链接，这里跳转到componentb组件。 写完后，就可以在浏览器中查看跳转效果了。 总结-7设置404和跳转都要先加入Switch的支持，在制作404时，一定要把404的Route设置到所有路由的后面。 跳转时使用Redirect标签，这个很容易实现。 第8节： 路由: 通过路由传值的方法开发中路由传值是必不可少的，虽然React有更优雅的方式，这里还是来学习一下路由如何传值。 最常见的传值传值是比较简单的，主要依靠props接收。 基础课程中已经学了组件之间的传值方法。路由和页面之间的传值也类似。 在nav.js页面传值，如下 12&lt;NavLink exact to=&quot;/componentc/ILoveWeb&quot; activeClassName=&quot;active&quot; className=&quot;blue&quot;&gt;ComponentC传值&lt;/NavLink&gt;&lt;br/&gt; 在路由后面跟了个ILoveWeb作为值传递给组件 Route中的设置， 用冒号来通知路由 1&lt;Route path=&quot;/componentc/:param&quot; component={Componentc}/&gt; 在componentc组件中获取 现在Componentc组件的生命周期中看一下props里有什么值。 componentC.js 1234567891011121314import React from 'react'export default class componentC extends React.Component{ // 新增 componentWillMount () { console.log(this.props) } render(){ return( &lt;div&gt;这是C组件&lt;/div&gt; ) }} 在console中可以看到match.params里有值了。 在页面中显示传递的参数 componentC.js 1234567891011121314import React from 'react'export default class componentC extends React.Component{ componentWillMount () { console.log(this.props) } render(){ return( // 新增 &lt;div&gt;这是C组件：参数：{this.props.match.params.param}&lt;/div&gt; ) }} 传递2个值nav.js 1&lt;NavLink exact to=&quot;/componentc/ILoveWeb/HelloReact&quot; activeClassName=&quot;active&quot; className=&quot;blue&quot;&gt;ComponentC传值&lt;/NavLink&gt;&lt;br/&gt; index.js 1&lt;Route path=&quot;/componentc/:param/:a&quot; component={Componentc}/&gt; componentC.js 12&lt;div&gt;这是C组件：参数：{this.props.match.params.param}, {this.props.match.params.a}&lt;/div&gt; 第9节 路由： Router中的属性和路由模式上节学习了React路由导航的基本方法，这节课学习标签上的属性和方法。还有一个重点是路由5种模式的讲解。 basename属性basename是增加一级导航目录，如之前访问http://localhost:1717/componentb，现在访问同一个页面，但路径是http://localhost:1717/demo/componentb.这时，就可以使用basename属性来设置。 basename是放在&lt;Router&gt;标签中的 index.js 1234567891011121314151617ReactDOM.render( &lt;Router basename=&quot;demo&quot;&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Switch&gt; &lt;Redirect from=&quot;/redirect&quot; to=&quot;/componentb&quot;/&gt; &lt;Route exact path=&quot;/&quot; component={Componenta}/&gt; &lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt; &lt;Route path=&quot;/componentc/:param/:a&quot; component={Componentc}/&gt; &lt;Route component={Error}/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('app')) 这时再点击导航，已经都加了/demo。 ==注意：==此时的设置是全局增加，如果是单个路由增加，需要特殊个性设置。 forceRefresh 属性这个属性是开启或关闭React Router，也就是说把forceRefresh 设为true，将关闭React路由系统，真实的去服务器端请求信息 现在把forceRefresh设为true，会发现路由已经不能使用 1234567891011121314151617ReactDOM.render(&lt;!--新增--&gt; &lt;Router basename=&quot;demo&quot; forceRefresh={true}&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Switch&gt; &lt;Redirect from=&quot;/redirect&quot; to=&quot;/componentb&quot;/&gt; &lt;Route exact path=&quot;/&quot; component={Componenta}/&gt; &lt;Route path=&quot;/componentb&quot; component={Componentb}/&gt; &lt;Route path=&quot;/componentc/:param/:a&quot; component={Componentc}/&gt; &lt;Route component={Error}/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('app')) 这个操作经常在大项目中使用。在服务器跳转和ReactRouter切换时使用。比如做一个APP活动页，第一次请求时到服务器请求整个页面，将整个页面缓存。生成ReactRouter实现本地单页应用，设置forceRefresh为false，即可。 5种路由方式我们一直用的是BrowserRouter，也就是浏览器的路由方式，其实React还有几种路由方式。 1.BrowserRouter 浏览器的路由方式，也是我们一直学习的路由方式。开发中最常使用。 2. HashRouter 在路径钱加入#号称为一个哈希值。Hash模式的好处是，再也不会因为刷新而找不到对应路径。 3.MemoryRouter 不存储history，所有路由过程都存在内存中，不能前进后退，浏览器地址不会发生。 4.NativeRouter 经常配合ReactNative使用，多用于移动端。 5. StaticRouter 设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用。 每中模式都有优缺点，根据项目的需求选择合适的使用即可。 示例 使用HashRouter 或MemoryRouter模式 引入 1import {BrowserRouter as Router ,HashRouter,MemoryRouter, Route , Switch ,Redirect} from 'react-router-dom'; 设置 HashRouter 12345678910111213&lt;HashRouter basename=&quot;demo&quot; &gt; &lt;div&gt; &lt;Nav/&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component={Jspang} /&gt; &lt;Route path=&quot;/Jspangb&quot; component={Jspangb} /&gt; &lt;Route path=&quot;/Jspangc/:param&quot; component={Jspangc} /&gt; &lt;Redirect from=&quot;/redirect&quot; to=&quot;/Jspangb&quot; /&gt; &lt;Route component={Error} /&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/HashRouter&gt;, MemoryRouter 12345678910111213&lt;MemoryRouter basename=&quot;demo&quot; &gt; &lt;div&gt; &lt;Nav/&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component={Jspang} /&gt; &lt;Route path=&quot;/Jspangb&quot; component={Jspangb} /&gt; &lt;Route path=&quot;/Jspangc/:param&quot; component={Jspangc} /&gt; &lt;Redirect from=&quot;/redirect&quot; to=&quot;/Jspangb&quot; /&gt; &lt;Route component={Error} /&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/MemoryRouter&gt;, 总结-9这节课重点是路由的方式。在项目开始时就应该根据需求选择好，也是要掌握的重点之一。上手项目容易遇到坑。 第10节 路由 prompt用法详解在很多项目中，离开一个页面，都会弹出一个提示框。确定是否离开。React也有这样的组件，就是Prompt。 &lt;Prompt&gt;标签要使用&lt;Prompt&gt;标签要先引入。 componentB.js 123456789101112131415import React from 'react'// 新增import { Prompt } from 'react-router-dom'export default class componentB extends React.Component{ render(){ return( &lt;div&gt; 这是B组件 // 新增 &lt;Prompt message=&quot;残忍离开?&quot; /&gt; &lt;/div&gt; ) }} 需要注意的是，如果使用MemoryRouter，&lt;Prompt&gt;不起作用。 &lt;Prompt&gt;有两个属性 message: 用于显示提示的文本信息 when： 传递布尔值，相当于标签的开关，默认是true，设置为false，prompt失效。 如何动态改变when的状态呢？做个小实例。 123456789101112131415161718192021222324252627import React from 'react'import { Prompt } from 'react-router-dom'export default class componentB extends React.Component{ constructor (props) { super(props) this.state = { power: false } this.changePower = this.changePower.bind(this) } changePower () { alert('已经开启') this.setState({ power: true }) } render(){ return( &lt;div&gt; 这是B组件 &lt;Prompt message=&quot;残忍离开?&quot; when={this.state.power}/&gt; &lt;button onClick={this.changePower}&gt;启用&lt;/button&gt; &lt;/div&gt; ) }} Flux和Redux的学习建议在官网学习。 官方文档中文文档经验-10移动端样式看起来大部分用flex就可以满足。常用组件Text，View，TextInput，ImageImage src属性为source样式的编写与原生区别","link":"/posts/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"},{"title":"TODO.md","text":"TODO如何在 JS 循环中正确使用 async 与 await参考在循环中使用异步，请使用for..of JS 精度问题123456782599.7 * 1001.1 * 1000.1 + 0.2 = 0.3？[从标准原理出发理解 JavaScript 数值精度](https://juejin.im/post/5c3db8b7e51d45515817bdeb) 1[math.js] 解决办法 无法实现的需求1. 数字输入框只唤起数字键盘，不能输入汉字&lt;input type='number'&gt; 在有的手机装了搜狗输入法或其他输入法后，唤起键盘输入法可以切换成其他输入法 有的机型没有装其他输入法，唤醒的不是数字键盘 2. 数字输入框获取不是数字的值需求: 输入.时, 在.前加0, 显示0. 输入两个..时，去掉后一个 在input为number类型时，输入 . ，但onchange 取不到 . ，取到的是空字符串 相关知识点input ime-mode: disabled[CSS]浏览器IME输入法控制禁止输入中文关于表单input type=”number”非法值时的一些探究及拓展input type=number驗證問題Script React高阶 https://github.com/dt-fe/weekly/blob/master/12.%E7%B2%BE%E8%AF%BB%20React%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.md 很好的vue源码解析https://juejin.im/post/5abe5822f265da2373149276 面试大全！！！！https://www.tuicool.com/articles/bInqieZ 腾讯一面https://juejin.im/post/5ab8d9e06fb9a028c22ac36c 浏览器的缓存(1)https://segmentfault.com/a/1190000004486640 前端思维导图https://github.com/qiu-deqing/FE-interview/blob/master/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.md?1520994177199 排序https://juejin.im/post/57dcd394a22b9d00610c5ec8 面试链接 还挺好的https://github.com/geekape/good-article/issues/2React中文官方文档https://doc.react-china.org/ React博客React构建https://segmentfault.com/a/1190000007891318https://taikongfeizhu.github.io/webpack3-in-action/index.html#16https://github.com/hujiulong/blog CSShttp://caibaojian.com/30-seconds-of-css/es6常见新特性https://segmentfault.com/a/1190000010230939 https://segmentfault.com/a/1190000010204791 闭包http://www.cnblogs.com/xxcanghai/p/4991870.html let和var的区别https://zhuanlan.zhihu.com/p/28140450 React生命周期https://www.cnblogs.com/lijie33402/p/6384080.htmlHTTP协议https://zouhangwithsweet.github.io/ 简历制作网站http://www.500d.me/ 会动的简历模板https://github.com/jirengu-inc/animating-resume https://segmentfault.com/a/1190000010868439 https://segmentfault.com/a/1190000010871559 webpack3 DOM操作成本到底高在哪儿？https://segmentfault.com/a/1190000014070240#articleHeader5 js 内存泄漏分析 https://www.tuicool.com/articles/ErIR7rE? 不错的面试题 https://github.com/WangXiZhu/frontend-interview-question 大漠的学习笔记 https://www.w3cplus.com/blogs/airen 万物皆空之 JavaScript 原型https://www.tuicool.com/articles/BN7bi2F https://www.tuicool.com/articles/aEr22ue Vue.js最佳实践（五招让你成为Vue.js大师）https://segmentfault.com/a/1190000014085613 https://segmentfault.com/a/1190000013331105 https://github.com/qiu-deqing/FE-interview https://github.com/fouber/blog BFC 经典讲解https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.htmlhttps://segmentfault.com/a/1190000013372963 实践是最好的学习方式js 最全https://github.com/mqyqingfeng/Blog 爬虫专用网站：http://books.toscrape.com/ 在服务器放打包好的文件的话， 先了解发起请求的本质：在一个服务器（注意必须是服务器，有端口可以访问的）中，访问到一个页面 这个页面由 axios 之类的http请求服务接口 在没有配置ProxyTable时，直接请求会有跨域问题存在。 开发环境 但配置proxyTable后，可以解决跨域问题，请求得到服务返回的结果。 配置了proxyTable后，请求的路径 前面的http://域名端口都可以不用写，直接在proxyTable的target里配置好，在axios里请求的url只需根据需要写后面的路径即可。 生产环境在开发环境打包好的文件请求后端接口时是不带http和域名端口的，所以请求的是相对路径。这个时候在后端起一个服务(比如node), 在这个node服务里发起请求的话，是要写全路径的，否则会找不到地址。 解决办法 在这个node服务中，封装一个axios的方法，在这个方法里写全路径，这样之前打包好的文件是相对路径，放到这个node服务的目录下，就成了全路径访问服务。 还有一种方法是在打包文件中通过配置写请求路径，然后将请求后端的全路径，打包到生成的文件中。–这个还没试过 Docker说了这么多 最全的一篇在这里 https://mp.weixin.qq.com/s/r6Zj9Umlc9v_rqplq8207A 前端书籍 https://github.com/wxyyxc1992/Web-Development-And-Engineering-Practices android，微信开发angular.jsspringmvc–上硅谷视频rollup.jsVue.jsReactES6node.jssqljavaphplinux 命令行nginxansible 自动化运维工具fetch.jspm2.jsbluebird.js 面试考察点： 思路是否清晰； 基本语法是否有错； 手写代码的能力 算法 http://www.materialscss.com/grid electron https://github.com/electron/electron 跨平台的GUI软件构建工具 https://www.html5rocks.com/en/tutorials/file/filesystem/ H5文件接口 Express http://www.expressjs.com.cn/ 基于node。js的web框架lodash http://lodashjs.com/docs/#_now js库 write a blog http://ssh.today/blog/something-about-js-timer js 正则表达式https://segmentfault.com/a/1190000008812676#articleHeader1https://juejin.im/post/5965943ff265da6c30653879 js 排序https://segmentfault.com/a/1190000008796659 微信小程序https://github.com/lin-xin/wxapp-mall 前端面试题：https://juejin.im/post/59be99a0f265da0644289dde前端程序员经常忽视的一个JavaScript面试题 https://segmentfault.com/p/1210000008946418/read#top 小菜鸟前端面试大作战https://huruji.github.io/FE-Interview/#/ 妨碍进步的因素https://juejin.im/post/59bf2a1d51882531b730b718 异步递归回调https://zhuanlan.zhihu.com/p/29534555你不知道的 CSS https://mp.weixin.qq.com/s/GxtJTIbMbFteCEFnFB7waw https://smohan.net/blog/6gr77h css 加载动画效果源码http://loading.awesomes.cn/ 使用递归遍历并转换树形数据（以 TypeScript 为例）https://segmentfault.com/a/1190000011819279 React:一篇包含了react所有基本点的文章 https://segmentfault.com/a/1190000011205580揭秘react全家桶(redux,react-redux,react-router)https://github.com/shen1992/blog/issues/2Node饿了么Node.js教程https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn https://github.com/ElemeFE/node-practice React 免费教程https://react-course.magicfun.ai/ mac读取移动硬盘http://vip.zgyjzf.com/nfm/ GitHub软件https://osxfuse.github.io/ http://www.cnblogs.com/macsoft/p/6835753.html http://www.orsoon.com/Mac/150550.html http://wm.makeding.com/redirect/url?segment=axEJmc-ik43ina5LG-TZD5_vApJ8vMxEnzLuVBELJ7z1iJBTC25zxyiSookdjOflPQ-BBKfzOu8S0TT3T6H3sDYVMbITp52pODsN82VD8jrLwXt9uhTQFq_XOsbWm65NgbxaG6R8Mk6-AfLaZNWB9aeCYPbr_mq2VQMeCsKne_U-sXLaxRW9KmP7UG0SKEAwKUWVD2m8pkHSRF5N-2o1i79iLyUwl2pjDCB93P64q753lx_QCO28E9nH_8r7BI0hD9-dXEJp9dEZkU2NL__inFM1LFFdI_6h0GOU3fWoPescmS_HrDNHlvytmT4qrypAaB5Y0_-YzFIcq1TWs79zj-nJwyETD8zaEMC43M1rThHEPYncCvFLvP7F9S140X10&amp;utm_medium=wm&amp;utm_source=http%3A%2F%2Fwww.cnblogs.com%2Fmacsoft%2Fp%2F6835753.html&amp;utm_content=Tuxera+NTFS--&amp;utm_campaign=LM_echo js事件绑定问题， 对接高德导航服务，起点终点确定坐标。 起点：输入内容，有下拉框，选择了下拉框的就有可确定坐标，没选下拉框，就要搜索， 终点： 同上 点击搜索路线。如果起点终点都确定坐标，直接搜索路线， 不确定起点终点，则先搜索结果。 怎么判定这两个状态？ 我的思路，在下拉框中选择一个结果，则给输入框赋一个坐标的属性， 点击搜索路线，判断输入框是否有坐标属性，有直接搜路线，没有，查询结果。 onchange或onkeyup清除坐标属性 node 作为中间件搭建前段代理，中转请求到后端。https://segmentfault.com/a/1190000007992200 git book中文教程https://chenyitian.gitbooks.io/react-docs 官网 不错的教程http://www.runoob.com/w3cnote/getting-started-with-react.html 极客学院教程http://wiki.jikexueyuan.com/project/react-tutorial/ React启蒙（译）https://www.gitbook.com/book/zhangwang1990/reactenlightenment/detailsReact中国https://tianxiangbing.github.io/react-cn/index.htmlReact 入门教程https://hulufei.gitbooks.io/react-tutorial/content/component.html 完美使用 React, Redux, and React-Router！最好用的脚手架https://github.com/bodyno/react-starter-kit react 中文网http://www.react-cn.com/https://segmentfault.com/blog/jasonnote https://github.com/theJian/build-a-hn-front-pageReact技术栈+Express+Mongodb实现个人博客https://github.com/Nealyang/React-Express-Blog-Demo Vuerouter文档：http://router.vuejs.org/zh-cn/ demo示例：https://github.com/cwsjoker/webpack-vue-spa-demo/tree/master 中文文档；https://vuefe.cn/v2/guide/ vue学习教程http://www.cnblogs.com/keepfool/p/5619070.html vue vue-material框架https://vuematerial.github.io 很全的vue资料 赞赞赞~~~~~~~~~~~~~https://github.com/opendigg/awesome-github-vue https://github.com/vuejs/awesome-vue 简单的后台管理系统https://github.com/monster1935/vue-element 很棒的后台管理系统http://panjiachen.github.io/vue-element-admin/#/introduction/index 这个也不错https://github.com/vue-bulma/vue-admin Vue项目中引用知乎API获取图片报403解决方案 在html设置meta 链接 http://www.cnblogs.com/dongcanliang/archive/2017/04/01/6655061.html 通过获取img src，用iframe去请求链接：https://segmentfault.com/q/1010000002581983/a-1020000002592757 https://www.xiabingbao.com/vue/2017/07/10/vue-curd.html https://www.xiabingbao.com Vue 组件编写https://segmentfault.com/a/1190000011796898ReactReact 服务端渲染如此轻松 从零开始构建前后端应用https://segmentfault.com/a/1190000010260036 Vue2.0—仿知乎日报总结 https://segmentfault.com/a/1190000009305496 VUE-WAS：一个基于Vue的Web App收集向项目 https://segmentfault.com/a/1190000010330905 Vue 与 iOS 的组件化.mdhttps://github.com/halfrost/Halfrost-Field/blob/master/contents/Vue/%E5%A4%A7%E8%AF%9D%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%97%B6%E4%BB%A3(%E4%B8%80)%20%E2%80%94%E2%80%94%20Vue%20%E4%B8%8E%20iOS%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96.md 好的js博客https://zhuanlan.zhihu.com/dreawer?author=qiangdada520 天猫前端http://tmallfe.github.io/ js 核心概念https://mp.weixin.qq.com/s/I7A1iC8Et6uOGZ234DsTlA Vue mockhttp://www.jianshu.com/p/284590b5b717https://github.com/yanm1ng/vue-starter-kit 很好的面试题https://zhoukekestar.github.io/notes/2017/06/07/interview-answers.html vue 很好的后台管理系统https://github.com/PanJiaChen/vue-element-adminhttps://github.com/PanJiaChen/vueAdmin-template Vue源码解析~~非常棒https://zhuanlan.zhihu.com/p/25869382 https://zhuanlan.zhihu.com/p/28835709 高阶函数 easy-mockhttps://easy-mock.com/ believezjp zhao110120 前端每周盘点半年清单系列 https://segmentfault.com/a/1190000010769946 https://segmentfault.com/a/1190000010716195 MVVM实现原理。https://segmentfault.com/a/1190000010744960 React 学习教程https://segmentfault.com/a/1190000005136764 Vue 脱坑记 - 查漏补缺(汇总下群里高频询问的xxx及给出不靠谱的解决方案)https://juejin.im/post/59fa9257f265da43062a1b0e 使用vscode 自动修复eslint的格式错误(空格多少，tab之类的)vscode左下角，设置配置如下：“eslint.validate”: [ “javascript”, “javascriptreact”, { “language”: “vu e”, “autoFix”: true } ] 把vue文件设为true,想修复的时候，在vscode用ctrl+shift+p打开命令行，输入Fix all auto-fixable problems即可自动修复所有的格式错误 http://www.gbtags.com/ 所有软件的书籍： https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md react 教程：https://fakefish.github.io/react-webpack-cookbook/ FLEX照着改造自己的flex 页面。https://zhuanlan.zhihu.com/p/25303493 http://www.fgm.cc/learn/ 各种实例各种视频课程 http://www.stuq.org/ http://www.chengxuyuans.com/web_technology/ajax-jsonp.html jsonp的讲解http://kb.cnblogs.com/page/159704/web前端开发十日谈http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html https://github.com/FreeCodeCamp/FreeCodeCamp/blob/staging/CONTRIBUTING.md 线下课 &lt;&lt;前端工程师与测试工程师&gt;&gt;http://www.tudou.com/programs/view/NRpKuBbeZEg密码 ydxt2016 &lt;&lt;EcmaScript6编程风格上&gt;&gt;链接: http://pan.baidu.com/s/1c1TfnUC 密码: 945t &lt;&lt;第一周考题&gt;&gt;你可以测验一下自己的水平。http://pan.baidu.com/s/1gf7BsUf 密码ceuh讲解 http://www.tudou.com/programs/view/epsKmGW-Nwg/密码YDXTpass2016 Vue.js资源分享https://github.com/maidishike/FrontEnd-Wikis/blob/master/vuejs.md JavaScript 全栈工程师培训教程http://www.ruanyifeng.com/blog/2016/11/javascript.html 简书很棒的文章：http://www.jianshu.com/p/cc1cb9a5650c http://blog.phpfamily.org http://ued.party/#序为什么前端没有前途 https://www.shiyanlou.com/paths/web实验楼 JavaScript设计模式之结构型设计模式https://segmentfault.com/a/1190000012585364 JavaScript数据类型的存储http://axuebin.com/blog/2017/08/24/javascript-data-storage/ jQuery 对应原生js怎么写~~~http://youmightnotneedjquery.com/ https://github.com/oneuijs/You-Dont-Need-jQuery/blob/master/README.zh-CN.md JavaScript深入教程–必学！！https://github.com/mqyqingfeng/Blog js专题https://segmentfault.com/blog/yayu-blog?tag=javascript%E4%B8%93%E9%A2%98%E7%B3%BB%E5%88%97 vitual-dom原理与简单实现 https://segmentfault.com/a/1190000012230659#articleHeader2 【JavaScript从入门到精通】http://www.igeekbar.com/igeekbar/mypost/113.htm 前端PDF下载http://www.menvscode.com/list/ziyuan/webpdf/1 javascript组件化http://caibaojian.com/javascript-module-2.html 从 for of 聊到 Generator深入理解 TypeScriptMDN javascript中高级教程「中高级前端」高性能渲染十万条数据「中高级前端」高性能渲染十万条数据 校园编程和职场编程的区别学校的程序解决的设计问题很少是险恶的，基本能从头到尾直线前进而设计。基本完成作业就可以，很少会对程序改动。 而专业编程中代码的修改是每日可见的真实情景。 读代码大全2笔记软件开发的隐喻，到底什么词合适 先想到的是庖丁解牛，不过是相反的过程，缺少任何一个骨头肌肉都不能完整拼成。 但播种耕种更形象，播种直到丰收，每个细节都不能马虎，最终才能有秋后的果实。 大型的房屋建筑需要超出常规的规划和建设 组合各种隐喻 软件开发金字塔 问题定义只定义问题是什么，不涉及任何可能的解决方案。 需求需求像水，冻结了才能在上面开展建设。 管理复杂度的重要性 作为软件开发人员，不应该试着在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。这么做的目的是尽量减少在任意时间索要考虑的程序量。 在软件架构层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。2019-11-29 16:49:41 97页 代码整洁之道读完 event loop","link":"/posts/TODO/"},{"title":"Vue-cli教程","text":"TODO vue插件 https://segmentfault.com/a/1190000012224638 第一节： 安装vue-cli前提是要安装node和npm。 可以在命令行输入npm -v，检测是否安装了npm和版本情况。 12$ npm -v5.4.2 用npm安装vue-cli确定npm安装成功后，在命令行全局安装vue-cli 1npm install vue-cli -g 安装成功后，尝试输入vue -V(注意V是大写)，出现版本信息则安装成功。 12$ vue -V2.9.1 mac电脑安装vue-lic失败npm install –global vue-clisudo npm install –global vue-cli 即可 初始化项目用命令vue init来初始化项目。语法介绍 官网 1vue init &lt;template-name&gt; &lt;project-name&gt; init：表示我要用vue-cli来初始化项目：表示模板名称，vue-cli官方为我们提供了5种模板， webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。 webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。 browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。 browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。 simple-一个最简单的单页应用模板。 ：标识项目名称，这个你可以根据自己的项目来起名字。 在实际开发过程中一般会使用webpack这个模板。这里也安装这个模板。 在终端输入命令1vue init webpack vue-tutorial 输入命令后，会有提示信息，按照需要填写即可。 Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写 Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。 Author：作者，如果你有配置git的作者，他会读取。 Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里输入y，如果你是大型团队开发，最好是进行配置。 setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。 Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。 可以看到提示信息: 1234567To get started: cd vue-tutorial npm install npm run devDocumentation can be found at https://vuejs-templates.github.io/webpack 1、cd vuecliTest 进入我们的vue项目目录。 2、npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。 3、npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。 至此，已经安装成功，可以开始写vue代码啦。 第二节：vue-cli项目结构讲解vue-cli为我们搭建了开发所需要的环境，省去了很多精力。有必要对这个环境进行熟悉，我们从项目的结构讲起。 123456789101112131415161718192021222324252627282930.|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico|-- index.html // 入口页面|-- package.json // 项目基本信息 重点文件讲解package.jsonpackage.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。 package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写 123456&quot;scripts&quot;: { &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;}, dependencies字段和devDependencies字段 dependencies字段指项目运行时所依赖的模块； devDependencies字段指定了项目开发时所依赖的模块； 在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。 package.json还有很多相关配置，如果你想全面了解，可以专门去百度学习一下。 webpack 配置相关我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。 dev-server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 检查 Node 和 npm 版本require('./check-versions')()// 获取 config/index.js 的默认配置var config = require('../config')// 如果 Node 的环境无法判断当前是 dev / product 环境// 使用 config.dev.env.NODE_ENV 作为当前的环境if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)// 使用 NodeJS 自带的文件路径工具var path = require('path')// 使用 expressvar express = require('express')// 使用 webpackvar webpack = require('webpack')// 一个可以强制打开浏览器并跳转到指定 url 的插件var opn = require('opn')// 使用 proxyTablevar proxyMiddleware = require('http-proxy-middleware')// 使用 dev 环境的 webpack 配置var webpackConfig = require('./webpack.dev.conf')// default port where dev server listens for incoming traffic// 如果没有指定运行端口，使用 config.dev.port 作为运行端口var port = process.env.PORT || config.dev.port// Define HTTP proxies to your custom API backend// https://github.com/chimurai/http-proxy-middleware// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置var proxyTable = config.dev.proxyTable// 使用 express 启动一个服务var app = express()// 启动 webpack 进行编译var compiler = webpack(webpackConfig)// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中var devMiddleware = require('webpack-dev-middleware')(compiler, { publicPath: webpackConfig.output.publicPath, stats: { colors: true, chunks: false }})// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reloadvar hotMiddleware = require('webpack-hot-middleware')(compiler)// force page reload when html-webpack-plugin template changescompiler.plugin('compilation', function (compilation) { compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) { hotMiddleware.publish({ action: 'reload' }) cb() })})// proxy api requests// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) { var options = proxyTable[context] if (typeof options === 'string') { options = { target: options } } app.use(proxyMiddleware(context, options))})// handle fallback for HTML5 history API// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址app.use(require('connect-history-api-fallback')())// serve webpack bundle output// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 将 Hot-reload 挂在到 express 服务上app.use(hotMiddleware)// serve pure static assets// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 为静态资源提供响应服务app.use(staticPath, express.static('./static'))// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露module.exports = app.listen(port, function (err) { if (err) { console.log(err) return } var uri = 'http://localhost:' + port console.log('Listening at ' + uri + '\\n') // when env is testing, don't need open it // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址 if (process.env.NODE_ENV !== 'testing') { opn(uri) }}) webpack.base.confg.js webpack的基础配置文件12345678910111213141516171819202122232425262728module.export = { // 编译入口文件 entry: {}, // 编译输出路径 output: {}, // 一些解决方案配置 resolve: {}, resolveLoader: {}, module: { // 各种不同类型文件加载器配置 loaders: { ... ... // js文件用babel转码 { test: /\\.js$/, loader: 'babel', include: projectRoot, // 哪些文件不需要转码 exclude: /node_modules/ }, ... ... } }, // vue文件一些相关配置 vue: {}} 详细的webpack知识可以在webpack里学习。 .babelrcBabel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。 1234567891011121314151617{ //设定转码规则 &quot;presets&quot;: [ [&quot;env&quot;, { &quot;modules&quot;: false }], &quot;stage-2&quot; ], //转码用的插件 &quot;plugins&quot;: [&quot;transform-runtime&quot;], &quot;comments&quot;: false, //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作 &quot;env&quot;: { &quot;test&quot;: { &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;], &quot;plugins&quot;: [ &quot;istanbul&quot; ] } }} .editorconfig该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。 123456789root = true[*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格 这是比较重要的关于vue-cli的配置文件，当然还有很多文件，我们会在以后的文章中讲解。 第3节： 解读vue-cli模板我们通过两节课的讲解，你对vue-cli应该有了基本的了解，这节我们主要了解一下Vue-cli的模板操作，包括增加模板，修改模板，以及一个常规模板的基本结构。 一、npm run build 命令如何把写好的Vue网页放到服务器上，这里讲解一下，主要的命令就是要用到npm run build 命令。 我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。 在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。 dist文件夹下目录包括： index.html 主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。 static 静态资源文件夹：里边js、CSS和一些图片。 二、main.js文件解读main.js是整个项目的入口文件,在src文件夹下： 12345678910111213import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false //生产环境提示，这里设置成了false/* eslint-disable no-new */new Vue({ el: '#app', router, template: '&lt;App/&gt;', components: { App }}) 通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。 三、App.vue文件123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'app'}&lt;/script&gt;&lt;style&gt;#app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; app.vue文件我们可以分成三部分解读， 标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和标签，标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。 标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。 标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的， 需要特别说明的是你==可以用来声明这些css样式只在本模板中起作用==。 四、router/index.js 路由文件在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。 12345678910111213141516import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router({ routes: [ { path: '/', name: 'Hello', component: HelloWorld } ]}) 可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。 五、Hello.vue文件解读这个文件就是我们在第一节课看到的页面文件了。也是分为三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;{{ msg }}&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://vuejs.org&quot; target=&quot;_blank&quot;&gt;Core Docs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://forum.vuejs.org&quot; target=&quot;_blank&quot;&gt;Forum&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://chat.vuejs.org&quot; target=&quot;_blank&quot;&gt;Community Chat&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://twitter.com/vuejs&quot; target=&quot;_blank&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;br&gt; &lt;li&gt;&lt;a href=&quot;http://vuejs-templates.github.io/webpack/&quot; target=&quot;_blank&quot;&gt;Docs for This Template&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Ecosystem&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://router.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-router&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://vuex.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vuex&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://vue-loader.vuejs.org/&quot; target=&quot;_blank&quot;&gt;vue-loader&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs/awesome-vue&quot; target=&quot;_blank&quot;&gt;awesome-vue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'HelloWorld', data () { return { msg: 'Welcome to Your Vue.js App' } } }&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt; h1, h2 { font-weight: normal; } ul { list-style-type: none; padding: 0; } li { display: inline-block; margin: 0 10px; } a { color: #42b983; }&lt;/style&gt; 总结这个教程只是带着你大概浏览和重点讲解了vue-cli的知识，如果你想完全弄明白vue-cli，我建议最好是有调理的阅读所有代码，这对你以后成为vue实际项目的开发很有帮助。如果你是一个初学者，了解这些已经足够向下学习了。这篇教程结束后，学习vue-router的知识，vue-router是一个重点学习任务.","link":"/posts/Vue-cli%E6%95%99%E7%A8%8B/"},{"title":"VueX入门进阶","text":"Vuex简介 Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。状态管理data中的属性 需要共享给其他vue组件使用的部分，就叫做状态。简单的说就是data中需要共用的属性。比如，用户的登录状态，用户名称等相关信息。如果不把这些属性设置为状态，每个页面遇到后，都会发送请求，从服务器端获取，再返回前端。在大型项目中会有很多共用的数据。所以提供了vuex. 第一节 初出茅庐，来个demo这个教程是基于vue-cli的项目做的开发。所以确保vue-cli，vue开发环境是ok的。 1. 安装vuex1npm install vuex --save 因为生产环境要用，所以是–save 2. 新建一个store文件夹，并在文件夹下新建index.js，文件中引入vue和vuexsrc/store/index.js 1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 这样就算引用成功了，接下来就可以使用了。 入门Demo通过做一个计数器的demo来练习vuex的基本操作，并实现数据共享。 1. 在store/index.js中增加一个常量对象。–==state==store/index.js 123const state = { count: 1} 2. 用export default封装代码，让外部可以引用123export default new Vuex.Store({ state}) 3. 新建一个vue模板，在components文件夹下，Count.vue.在模板中引入刚建的index.js, 并在模板中用输出count的值components/Count.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;h2&gt;{{msg}}&lt;/h2&gt; &lt;hr/&gt; &lt;h3&gt;{{$store.state.count}}&lt;/h3&gt; &lt;button @click=&quot;$store.commit('add')&quot;&gt; 加分 &lt;/button&gt; &lt;button @click=&quot;$store.commit('reduce')&quot;&gt; 减分 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import store from '@/store' export default{ data () { return { msg: 'Hello Vuex' } }, store }&lt;/script&gt; 4. 在store/index.js中加入两个改变state的方法–==mutation==store/index.js 123456789101112131415161718192021222324import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = { count: 1}// 新增const mutations = { add (state) { state.count ++ }, reduce (state) { state.count -- }}export default new Vuex.Store({ state, // 新增 mutations}) 这里的mutations是固定的写法，稍后会细讲。只需要知道改变state数值的方法，必须写在mutations里。 5. 在Count.vue模板中加入两个按钮，并调用mutations中的方法12&lt;button @click=&quot;$store.commit('add')&quot;&gt; 加分 &lt;/button&gt;&lt;button @click=&quot;$store.commit('reduce')&quot;&gt; 减分 &lt;/button&gt; 需要在路由中加入count，并可以跳转到count，这里不再赘述。 现在就可以对vuex中的count进行加减了。 第二节 state访问状态对象在第一节已经写了一个const state,这个就是我们说的访问状态对象，它就是我们SPA(单页应用程序)中共享值。 今天学习状态对象赋值给内部对象，也就是把store的值赋值给模板里的data中的值。 ==（读取state的值）== 问题上一节中，在Count.vue组件中获取vuex的值是通过这种方式获取的，但这种方式并不优雅。这里用3种方式改写。 有3种赋值方式。 1. 通过computed计算属性直接赋值computed属性可以在属性输出前，对data中的值进行改变，现在就利用这种特性把store.js中的state值赋给模板中的data值 注意： computed的属性是在组件中的，不是在store中。 Count.vue 1234567891011121314import store from '@/store'export default{ data () { return { msg: 'Hello Vuex' } }, computed: { count () { return this.$store.state.count } }, store} 需要注意，一定要写this, 在页面显示的地方替换为count 12&lt;!-- &lt;h3&gt;{{$store.state.count}}&lt;/h3&gt; --&gt;&lt;h3&gt;{{count}}&lt;/h3&gt; 2. 通过mapState的对象来赋值 引入mapState 1import {mapState} from 'vuex' 在computed计算属性里写如下代码 123computed: mapState({ count: state =&gt; state.count}), 这里我们用ES6的箭头函数来给count赋值。 3. 通过mapState的数组来赋值1computed: mapState(['count']) 下面这种写法是错误的 1computed: mapState['count'], 这个算是最简单的写法，在实际项目开发中也经常这样用。 总结这就是三种赋值方式，虽然简单，但实际项目中经常使用。一定要多练习。 第三节 mutations修改状态mutations修改state的数据 上节学习了怎么读取state，这节学习 ==如何修改状态==。这个在第一节课已经碰到过，并进行了加减操作，这节具体学习如何操作mutations。 $store.commit()vuex提供了commit方法来修改状态 回顾一下之前修改状态的方法 Count.vue 12&lt;button @click=&quot;$store.commit('add')&quot;&gt; 加分 &lt;/button&gt;&lt;button @click=&quot;$store.commit('reduce')&quot;&gt; 减分 &lt;/button&gt; store/index.js 12345678const mutations = { add (state) { state.count ++ }, reduce (state) { state.count -- }} 传值上面只是一个简单的修改状态操作。实际项目中常常需要在修改状态时传值。比如上边的例子每次只加1，现在要通过所传的值相加。 其实只需要在mutations里再加一个参数，并在commit的时候传递就可以了。如下 store/index.js 123456789const mutations = { // 新增 add (state, n) { state.count += n }, reduce (state) { state.count -- }} 在Count.vue里修改按钮的commit()方法的参数，传10，即每次加10 12&lt;button @click=&quot;$store.commit('add', 10)&quot;&gt; 加分 &lt;/button&gt;&lt;button @click=&quot;$store.commit('reduce')&quot;&gt; 减分 &lt;/button&gt; 这样传值就可以看到效果了。 模板获取mutations方法实际开发中也不喜欢看到$store.commit()这样的方法出现，希望跟调用组件里的方法一样调用。 例如： @click=”reduce”, 就和没引用vuex插件一样。 要达到这种写法，只需要简单的两步 在组件Count.vue里用import引入mapMutations 1import { mapState, mapMutations } from 'vuex' 在组件的script标签里添加methods属性，并加入mapMutations 12345678910111213import store from '@/store'import { mapState, mapMutations } from 'vuex'export default{ data () { return { msg: 'Hello Vuex' } }, computed: mapState(['count']), // 新增 methods: mapMutations(['add', 'reduce']), store} 在调用的地方改成直接用add和reduce. 123456789101112### action方式第二种方式：对象风格的传参方式提交 mutation 的另一种方式是直接使用包含 type 属性的对象：```jsstore.commit({ type: 'increment', // 事件名 amount: 10}) 在 Vuex 中，mutation 都是同步函数第四节 getters计算过滤操作getters从字面上是获得的意思，获取state的数据。 可以把它看作在获取数据之前进行的一种再编辑，相当于对数据的一个加工和过滤。可以看作store的计算属性 Getters 也可以理解为 Vue 中的计算属性 (computed)。 getters基本用法现在要对store的count进行一个计算属性的操作，在输出之前，加上100 首先在store/index.js里用const声明getters属性 123456const getters = { count: function (state) { state.count += 100 return state.count }} 写好getters后，还需要在Vuex.store()里引入，由于之前已经引入state和mutations，所以这里有三个引入属性。如下 12345export default new Vuex.Store({ state, mutations, getters}) 在store里的配置完成了，需要到组件页对computed进行配置，在vue的构造器里只能有一个computed属性，如果写多个，只有最后一个computed属性可用，所以要对上节课的computed属性进行改造。改造时，使用ES6中的展开运算符’…’ 123456computed: { ...mapState(['count']), count () { return this.$store.getters.count }}, 注意： 写了这个配置后，每次count的值发生变化，都会进行加100操作。 用mapGetters简化模板写法state和mutations都有map的引用方法把我们的模板中的编码进行简化，getters也是，看下代码： 用import引入mapGetters 1import { mapState, mapMutations, mapGetters } from 'vuex' 在computed属性中加入mapGetters 1234computed: { ...mapState(['count']), ...mapGetters(['count'])}, 总结-4到这里getters就学完了，还是要熟悉熟悉。注意mapGetters是写在computed中的。getter写的是函数，但我们应该把它当成计算属性来用。 第5节 actions异步修改状态actions 和 mutations的功能基本一样，不同点是actions是异步的改变state的状态，而mutations是同步改变状态。 不同模块的 actions 均可以通过 store.dispatch 直接触发。 在store里声明actionsactions可以调用mutations里的方法。 继续上节的代码，在actions里调用mutation里的add和reduce方法 123456789101112131415161718const actions = { addAction (context) { context.commit('add', 10) }, reduceAction ({commit}) { commit('reduce') }}// 导出里添加export default new Vuex.Store({ state, mutations, // 新增 actions, getters}) 注意这里的传参方式！！！！！ addAction中的10在actions里写了两个方法addAction和reduceAction，在方法体里都用commit调用了mutations里的方法。这两个方法的传的参数不一样。 context： 上下文对象，这里可理解为store本身 {commit}: 直接把commit对象传过来，可以让方法体逻辑和代码更清晰明了 模板中的使用我们需要在Count.vue中调用，让actions生效。 复制之前的两个按钮，调用addAction和reduceAction 12&lt;button @click=&quot;addAction(10)&quot;&gt; 异步加分 &lt;/button&gt;&lt;button @click=&quot;reduceAction&quot;&gt; 异步减分 &lt;/button&gt; 改造methods，用扩展运算符把mapMutations和mapActions引入 1234methods: { ...mapActions(['addAction', 'reduceAction']), ...mapMutations(['add', 'reduce'])}, 用dispatch调用action1234567store.dispatch('asyncAdd');store.dispatch('addAction', { n: 10 // 传参})store.dispatch({ type: 'addAction', n: 10 }); 增加异步校验现在看到的效果和mutations效果是一样的，怎样区别与mutations里的方法呢，现在演示actions里的异步功能。 这里增加一个计时器延迟执行。 在addAction里使用setTimeout就行延迟执行。处理逻辑，先加10，隔500毫秒，减一 12345678910111213const actions = { addAction (context) { setTimeout(() =&gt; { context.commit('reduce') console.log('我是异步执行的') }, 500) context.commit('add', 10) console.log('我先执行') }, reduceAction ({commit}) { commit('reduce') }} 总结-5mutation和action都可以对store进行操作 mutation必须是同步操作，action可以是任何异步操作。 action不直接更改状态，而是提交mutation 第6节 module模块组随着项目复杂度的增加，共享的状态越来越多，这时候，需要把我们状态的操作进行分组，分组后，再按组编写。 今天学习module: 状态管理器的模块组操作。 每个module拥有自己的state、mutation，action，getter，甚至嵌套子模块。具体结构如下:(来自官网) 12345678910111213141516171819202122const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... }}const moduleB = { state: { ... }, mutations: { ... }, actions: { ... }}const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB }})store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 声明模块组在store/index.js中，将之前定义好的state,getters，mutations，actions都提取到一个变量中，命名ModuleA。 1234567// 之前导出是将这些都导出的export default new Vuex.Store({ state, mutations, actions, getters}) 现在都装到moduleA中，导出moduleA 123456789const moduleA = { state, mutations, getters, actions}export default new Vuex.Store({ modules: { a: moduleA }}) 在模板中使用在计算属性中引入 12345computed: { count () { return this.$store.state.a.count }}, 再看效果，和之前是一样的。 这样就算创建了一个module, TODO 后续需要将module单独抽离成一个文件总结-6可以看到， 一个vuex里包含 state 用来定义通用的数据，类似于组件中的data mapState是获取state的辅助函数。获取state都是通过computed来获取的，如果获取多个会显得冗余，用mapState辅助函数可以帮助我们生成计算属性。 getter 可以认为是store的计算属性，类似于组件中的computed属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 mapGetters是getter的辅助函数 将 store 中的 getter 映射到局部计算属性： mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 Mutation 必须是同步函数 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, ‘newProp’, 123), 或者 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写： state.obj = { …state.obj, newProp: 123 } action 类似于mutation 区别: Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 module (这个不一定) 将一个大的store拆分成一个个子模块，即module mutation 只管存，你给我（dispatch）我就存action只管中间处理，处理完我就给你，你怎么存我不管Getter 我只管取，我不改的Vuex 应用场景Vuex应用场景有什么？什么时候适合使用Vuex，什么时候不适合一般回答 涉及到非父子关系的组件，例如兄弟关系、祖孙关系、甚至更远关系。 他们之间有数据交互，应该使用Vuex实现。 如果页面复杂度较低，可以考虑使用global-event-bus 实现 如果只是父子关系的组件数据交互，使用props进行单向传递 涉及到子组件向父组件的数据传递，考虑使用$emit 和 $on 更针对性的回答 https://www.tuicool.com/articles/EvYJRfv 在以下场景，我们应当使用Vuex： 1. 组件会被销毁解决办法 将值存在父组件中，实际是修改的父组件中的值 存在sessionStorage、cookie之类的东西中，在created时读取，destroyed时写入 存到global-event-bus里 存在vuex中 通过$store.state来调用，通过commit来修改值 在created时读取state里的值，在destroyed时写入state 优点： 解耦，不跟其他组件打交道 2. 组件基于数据而创建假设一个场景： 用户将登录后，读取权限配置表，这是个异步操作 这个配置表会影响很多页面。 这些组件不一定是父子关系，其他组件读取权限配置表不太方便 解决办法： 写在global-event-bus里 放在Vuex里 3. 多对多事件 – 多处触发，影响多处假设一个场景 切换页面显示风格，改变一个变量的值 在多个地方可以切换 这个变量将影响多个地方的样式 这就是多对多场景 那么： 无论这个变量放在哪个组件里，其他组件调用都很麻烦 即使存在于根组件，用this.$root.xx来获取这个变量，也是很麻烦的 解决办法： 用global-event-bus来存储这个变量 ，会比较麻烦 使用VueX 通过$store.state.xxx来获取这个变量 通过$store.commit()来提交修改(在某些条件下可禁止修改) 可以通过$store.dispatch()获取其他风格样式，并通过$store.state和$store.getters来返回新风格样式 总结-使用场景如果需要数据和组件分离，分别处理，那么使用VueX非常合适。相反，如果不需要分离处理，不使用VueX也没关系。比如某个数据只跟某组件交互，是强耦合的，其他组件用不到，那么这个组件就可以防止该组件的data属性中。 参考链接vuex不错的讲解","link":"/posts/VueX%20%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B6/"},{"title":"搭建Hexo博客笔记","text":"[toc] hexo 搭建 HEXO 官网 文档 安装 node.js git 已经安装，跳过 hexo 安装 1npm install -g hexo-cli 12不能在文章中有{{}},否则hexo无法见解析，会报错 运行 123hexo init blogcd bloghexo server 访问 localhost:4000 即可看到网页 在 sources/posts 文件夹下新建一个 test.md 文件，再次访问页面，可看到新加的文章。 安装 hexo-admin123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin 安装 next 主题好的主题推荐链接 next主题不在维护~~，不推荐使用 在根目录运行 1git clone https://github.com/theme-next/hexo-theme-next themes/next 会在 themes 目录下创建 next 文件夹 (需运行多次才能顺利下载) 在根目录的_config.yml 里配置 themes: next 发布到 github需先安装插件 1npm install hexo-deployer-git --save 在根目录_config.yml 里配置 deploy。根据 github 配置提示，branch 只能是 master，其他分支不生效(实测)。repo 项目名一定要是用户名.github.io 12345deploy: type: git repo: git@github.com:believezjp/believezjp.github.io.git branch: master 配置完成运行 12hexo cleanhexo d -g 发布出去。访问 believezjp.github.io，即可看到主页。 如果没有权限，需要将本地的 id_rsa.pub 里的 key 加到 github 的 SSH key 中查看本地的 key 1less ~/.ssh/id_rsa.pub githubSSH keys 地址快捷地址, 添加 SSH key 值 打赏设置将二维码图片放到主题 source/images 下面打开主题目录下面的配置文件_config.yml这里的配置项可能每个主题不一样。根据每个主题自己配置。 12345678## 打赏文字提示reward_comment: '扫码送礼, 走起~~~'## 微信收款图片wechatpay: /images/wechatpay.jpeg## 支付宝收款图片alipay: /images/alipay.jpeg## 比特币收款#bitcoin: /images/bitcoin.png 新建文章1hexo new &quot;标题&quot; 在 _posts 目录下会生成文件标题.md, 如下: 1234567title: '标题'date: 2018-11-04 10:17:16 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写 编辑完后保存，hexo server，浏览器输入 localhost:4000 预览 添加阅读全文隔断默认文章列表页是全部展示, 只展示部分的话，可以在文章中加入 123&lt;!-- more --&gt; 会自动隔断，添加阅读全文按钮。(注意, 是在文章列表页有阅读全文按钮) 展示摘要字数统计和阅读时长 安装 hexo-wordcount 1npm install hexo-symbols-count-time --save 文件配置在根目录的_config.yml 中添加如下配置(注意格式一定要准确无误): 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 在 next 主题的配置文件中查看如下配置是否启用 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 重启服务, 刷新页面, 可以看到效果。这个只针对文章详情页才会展示。列表页不会展示。 展示总访问量不蒜子 - 极简网页计数器 在 themes/next/layout/_partials/footer.swig 中添加如下代码 12345678&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; &gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 即可在首页末尾看到总数，因为本地是 localhost:4000,所以数量有误 修改 footer 内容next 主题默认会有由 next 强力驱动等文字。不喜欢可以去掉, 配置方法:在目录 themes/next/_config.yml 中搜 footer:, 将 copyright 中的 powered, 如下配置。即可去掉。 12345678copyright:powered: enable: false version: falsetheme: enable: false version: false 网站运行时间添加根据目录 themes/next/layout/_partials/footer.swig, 找到页脚配置文件。在末尾添加 12345678910111213141516171819&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(&quot;02/14/2018 12:49:00&quot;);//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; }setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; leancloud 阅读统计功能 注册 leancloud 登录后创建应用,点击设置-应用 key, 查看 app ID 和 app Key 在 next/_config.yml 中搜索leancloud_visitors配置 ID 和 Key 1234leancloud_visitors: enable: true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 创建 Class在左侧点击存储，创建一个名为 Counter 的 Class 文件，这里的名称一定为 Counter 不能随意取！！！权限设置要选无限制, 否则在第二次访问会报错。设置完后，回到我的博客，随便点击一篇博文，刷新几次 就可以在 leancloud–》存储–》Counter 看到我们的浏览记录了，在我们的博文副标题也可以看到浏览记录。 hexo 新建目录，page, 标签, 分类, 关于在主题的_config.yml 中打开配置 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap 可以看到左上角新增关于, 标签, 分类 标签运行 hexo new page tags访问标签页, 新页面可以正常访问在 source/tags/index.md 中如下设置, 即可看到标签分类(前提:在文章中需添加 tags) 123456---title: tagsdate: 2018-11-06 16:55:49type: &quot;tags&quot;layout: &quot;tags&quot;--- 分类1hexo new page categories 在 source/categories/index.md 中添加如下 123456---title: categoriesdate: 2018-11-06 17:11:29type: &quot;categories&quot;layout: &quot;categories&quot;--- 文章中多个 tag 时，如下配置 123tags: - http - 网络 单个 1tags: 网络 关于1hexo new page about 在 source/about/index.md 写个人信息 添加社交链接在主题配置文件中搜索 social: 1234social: GitHub: https://github.com/believeZJP || github 微博: https://weibo.com/u/6021664425 || weibo QQ: tencent://message/?uin=421790588&amp;Site=www&amp;Menu=yes || qq 图标配置： 123456social_icons: enable: true icons_only: true transition: false 微博: weibo QQ: qq 在左侧即可看到链接。需要注意, 图标的配置是根据 font-awesome.min.css 中的 css 属性样式, 想添加对应的可以在文件中搜索。 默认显示文字和图标, 如果只显示图标可设置icons_only: true 站内搜索1npm install hexo-generator-searchdb --save 在主题 next/_config.yml 中配置 12local_search: enable: true 在全局配置中_config.yml 添加 12345search: path: search.xml field: post format: html limit: 10000 ———–正常情况到这就可以使用搜索功能了——— 复盘: 点击首页搜索,发现弹框弹出, loading 一直加载。没有显示搜索界面. 检查 network, 发现 search.xml 请求成功, 状态 200. 用链接直接访问 search.xml localhost:4000/search.xml提示报错, 有错误字符 可以拉到最后看哪篇文章被截断 也可以审查元素, 点击每个 entry-content 查看最近为空的那个,找到后, 这篇文章中有错误字符不识别。 在 network 看 search.xml 中截断的文章中有两个字中间有个点的地方, 在文中找到这个地方光标移动发现会有一次没有移动, 删除即可。 实在找不到可以先剪切文章, 看是否能正常显示. 用 vim 编辑器查看特殊字符一目了然常见的特殊字符^H, .(灰色) 来必力评论https://www.livere.com/一定要用这个注册, 中文版(http://www.laibili.com.cn/)失效！！！！注册完成后, 填写相应信息, 即可获取到 data-uid.next/_config.yml 中搜索livere_uid, 填入对应 data-uid注意:格式如下:livere_uid: fsdfs343==一定不要加任何引号~~~~~~~(🕳🕳🕳🕳🕳) 本地图片添加 在_config.yml 中搜索post_asset_folder, 设为 true 在 source 文件夹下创建文件夹 img 在 img 中添加图片 在 md 中引用图片 12[记忆曲线](/img/clipboard.png)&lt;img src=&quot;/img/clipboard.png&quot; &gt; 注意: 这里一定要用绝对路径, 因为图片在根目录下 不用根目录的图片添加用hexo n '文章标题'创建文章后，会生成与文章标题相同的文件夹，可以把图片放到对应文件夹中在md中引用方式 12![添加自定义search](/posts/Alfred/addbaidu.png)![设置百度内容](/posts/Alfred/addbaidu-input.png) 部署命令简化在 package.json 中添加 1234&quot;scripts&quot;: { &quot;d&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;, &quot;s&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;}, 部署时，只需在终端运行npm run d即可发布文章 启动时，运行npm run s,即可在本地访问服务 好的链接 百度统计在 next/_config.yml 中搜索 baidu_analytics, 配置 id 在官网,新建应用，点击管理，复制 id 123456&lt;script&gt;var _hmt = _hmt || [];(function() { var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?60d1bc14f9ca17b7&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; 添加头像在 next/config.yml 里搜 avatar,如下配置, 图片链接可更换 12345avatar: url: /images/avatar.gif rounded: true opacity: 1 rotated: true 添加缓存hexo-offline 1npm i hexo-offline --save 修改默认的文章链接官方文档 默认文章链接是http://localhost:4000/2018/10/18/hello-world/ 有年月日层级太深，不利于 SEO 修改为http://localhost:4000/posts/hello-world/ 在_config.yml 中搜索permalink,修改如下 12## permalink: :year/:month/:day/:title/permalink: :category/:title/ 搜索default_category,修改如下 1default_category: posts 重启服务即可 绑定自己域名在阿里云控制台域名修改域名解析，记录类型 CNAME, 记录纸为 believezjp.github.io 在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。 1believezjp.oriht.com 注意，这个要写自己的域名，不是 github 的域名 在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages 的 Custom domain 设置里填上购买的域名。 详见:参考链接 替换 jquery 资源库地址在主题目录下找到 after-footer.ejs 文件，PS：主题目录指的是 themes 下 next 目录 找到下面一段代码 1&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt; 修改为：（将 jquery 的在线地址修改为百度的静态资源库地址） 1&lt;script src=&quot;http://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; 项目添加 changelog❌123npm install --save conventional-changelogconventional-changelog -p angular -i CHANGELOG.md -w -r 0 项目添加git commit 规范插件链接 12345678910111213npm install --save-dev @commitlint/{cli,config-conventional}echo &quot;module.exports = {extends: ['@commitlint/config-conventional']};&quot; &gt; commitlint.config.jsnpm install --save-dev husky## 在package.json中配置## package.json{ &quot;husky&quot;: { &quot;hooks&quot;: { &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot; } }} 提交方式： 格式： type(scope?): subject ## scope 可选 subject是 commit 目的的简短描述，不超过50个字符，且结尾不加句号（.） eg: 12345chore: run tests on travis cifix(server): send cors headersfeat(blog): add comment section build: 主要目的是修改项目构建系统(例如 gulp，webpack，rollup 的配置等)的提交 ci: 主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交 docs：文档（documentation） feat：新功能（feature） merge: 合并分支 fix：修复bug perf: (performance) 优化相关，比如提升性能、体验 refactor：重构（即不是新增功能，也不是修改bug的代码变动） revert: 回滚到上一个版本 style： 格式（不影响代码运行的变动） test：增加测试 wip：移除文件或者代码 chore：不属于以上类型的其他类型 生成changelogChange log 就可以用脚本自动生成。生成的文档包括以下三个部分： New features Bug fixes Breaking changes. onventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。用到的是其中的cli工具 12npm install -g conventional-changelog-cliconventional-changelog -p angular -i CHANGELOG.md -s -w -r 0 为了方便使用，可以将其写入 package.json 的 scripts 字段： 12345{ &quot;scripts&quot;: { &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -w -r 0&quot; }} 以后，直接运行下面的命令即可： 1npm run changelog 新建草稿草稿相当于很多博客都有的“私密文章”功能。hexo new draft &quot;new draft&quot;会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。如果你希望强行预览草稿，更改配置文件_config.yml：render_drafts: true或者，如下方式启动server：hexo server --drafts下面这条命令可以把草稿变成文章，或者页面：hexo publish [layout] &lt;filename&gt;或hexo P &lt;filename&gt;filename为不包含md后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。 若日后想将正式文章转为为草稿，只需手动将文章从 source/_posts 目录移动到 source/_drafts 目录即可。 hexo 命令常用命令 12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，'Ctrl+C'关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy git push以后自动发布到gitHub上使用Travis 自动化部署Hexo Blog 添加.travis.yml 配置token Hexo博客收录百度和谷歌-基于Next主题参考链接 参考文章Hexo 进阶高级教程Hexo+Github: 个人博客网站搭建完全教程","link":"/posts/hexo%E7%AC%94%E8%AE%B0/"},{"title":"js 代码片段","text":"js比较版本号123456789101112131415161718192021222324252627282930313233/** * 版本比较 versionCompare * @param {String} currVer 当前版本. * @param {String} promoteVer 比较版本. * @return {Boolean} false 当前版本小于比较版本返回 true. * * 使用 * versionCompare(&quot;6.3&quot;,&quot;5.2.5&quot;); // false. * versionCompare(&quot;6.1&quot;, &quot;6.1&quot;); // false. * versionCompare(&quot;6.1.5&quot;, &quot;6.2&quot;); // true. */function versionCompare(currVer = '0.0.0', promoteVer = '0.0.0') { if (currVer === promoteVer) { return false; } const currVerArr = currVer.split('.'); const promoteVerArr = promoteVer.split('.'); const len = Math.max(currVerArr.length, promoteVerArr.length); // ~是按位取反的意思，计算机里面处理二进制数据时候的非， // ~~利用两个按位取反的符号，进行类型的转换，转换成数字 for (let i = 0; i &lt; len; i++) { // 将比较对象转成数字 const proVal = ~~promoteVerArr[i]; const curVal = ~~currVerArr[i]; if (proVal &lt; curVal) { return false; } else if (proVal &gt; curVal) { return true; } } return false;} bindbind 返回的是一个新的函数，你必须调用它才会被执行 function() {}.bind(thisArg [, arg1 [, arg2, …]]); bind函数传参会先于新函数调用时的参数传入 1234567891011121314151617181920212223var fn = function(){ setTimeout(function(){ console.log(this.name) }.bind({name: 2}), 100)}var obj1 = {name:1}fn.call(obj1) //输出2 ，因为bind的参数先于其他参数。自己实现bindif (!function() {}.bind) { Function.prototype.bind = function(context) { var self = this , args = Array.prototype.slice.call(arguments); return function() { return self.apply(context, args.slice(1)); } };} 把queryString转换成js对象123456789101112131415function getQueryObject(url){ url=url==null?window.location.href:url; var search=url.substring(url.lastIndexOf(&quot;?&quot;)+1); var obj={}; var reg=/([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg,function(rs,$1,$2){ var name=decodeURIComponent($1); var val=decodeURIComponent($2); obj[name]=String(val); return rs; }) return obj;}getQueryObject(&quot;http://www.cnblogs.com/zichi/p/4359786.html?aa=111&amp;bb=3dadsads&amp;43=43a&quot;); 实现一个异步缓存器，第一次调用，发送请求，第二次调用，直接取结果用发布订阅者模式 不管谁调用都是拿的同一个Promise， Promise 写法12345678910111213141516171819202122232425262728293031323334353637383940// 标准写法：var promise = new Promise(function(resolve, reject) { // ... some code if ( /* 异步操作成功 */ ) { resolve(value); } else { reject(error); }});promise.then(function(value) { // success}, function(error) { // failure});new Promise(function (resolve, reject) {// 一、这里是Promise要执行的代码 log('start new Promise...'); var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () { if (timeOut &lt; 1) { log('call resolve()...'); // 二、这里才是异步执行后调用的步骤 resolve('200 OK'); } else { log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); } }, timeOut * 1000);}).then(function (r) { log('Done: ' + r);}).catch(function (reason) { log('Failed: ' + reason);}); 自己实现promise.all思路，用一个数组将所有要请求的存起来，循环发送执行后，根据数组长度判断是否执行完成。 1、接收一个 Promise 实例的数组或具有 Iterator 接口的对象， 2、如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象 3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调 4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象 123456789101112131415161718192021222324function promiseAll(promises) { return new Promise(function(resolve, reject) { if (!isArray(promises)) { return reject(new TypeError('arguments must be an array')); } var resolvedCounter = 0; var promiseNum = promises.length; var resolvedValues = new Array(promiseNum); for (var i = 0; i &lt; promiseNum; i++) { (function(i) { Promise.resolve(promises[i]).then(function(value) { resolvedCounter++ resolvedValues[i] = value if (resolvedCounter == promiseNum) { return resolve(resolvedValues) } }, function(reason) { return reject(reason) }) })(i) } })} 手动写多次异步调用回调场景一：先调用getData1，再调用getData2，再调用getData3 … 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//创建一个Promise实例，获取数据。并把数据传递给处理函数resolve和reject。需要注意的是Promise在声明的时候就执行了。var getData1=new Promise(function(resolve,reject){ $.ajax({ type:&quot;get&quot;, url:&quot;index.aspx&quot;, success:function(data){ if(data.Status==&quot;1&quot;){ resolve(data.ResultJson)//在异步操作成功时调用 }else{ reject(data.ErrMsg);//在异步操作失败时调用 } } });})var getData2= new Promise(function(resolve,reject){ $.ajax({ type:&quot;get&quot;, url:&quot;index.aspx&quot;, success:function(data){ if(data.Status==&quot;1&quot;){ resolve(data.ResultJson)//在异步操作成功时调用 }else{ reject(data.ErrMsg);//在异步操作失败时调用 } } });})var getData3=new Promise(function(resolve,reject){ $.ajax({ type:&quot;get&quot;, url:&quot;index.aspx&quot;, success:function(data){ if(data.Status==&quot;1&quot;){ resolve(data.ResultJson)//在异步操作成功时调用 }else{ reject(data.ErrMsg);//在异步操作失败时调用 } } });})getData1.then(function(res){ return getData2(res)}).then(function(res){ return getData3(res)}).then(function(res){ console.log(res)}).cache(function(error){ console.log(error)})场景二：getData3的执行依赖getData1和getData2//Promise的all方法，等数组中的所有promise对象都完成执行Promise.all([getData1,getData2]).then(function([ResultJson1,ResultJson2]){ //这里写等这两个ajax都成功返回数据才执行的业务逻辑 getData3()}) Object.defineProperty(obj, prop, descriptor)value属性对应的值,可以使任意类型的值，默认为undefined writable属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false enumerable此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。 configurable是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。 这个属性起到两个作用： 目标属性是否可以使用delete删除 目标属性是否可以再次设置特性 //第一种情况：configurable设置为false，不能被删除。//第二种情况：configurable设置为true，可以被删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//对象新添加的属性的特性描述Object.defineProperty(obj,&quot;newKey&quot;,{ configurable:true | false, enumerable:true | false, value:任意类型的值, writable:true | false});存取器描述当使用存取器描述属性的特性的时候，允许设置以下特性属性：var obj = {};Object.defineProperty(obj,&quot;newKey&quot;,{ get:function (){} | undefined, set:function (value){} | undefined configurable: true | false enumerable: true | false});属性对应的值,可以使任意类型的值，默认为undefinedgetter 是一种获得属性值的方法setter是一种设置属性值的方法。var obj = {};var initValue = 'hello';Object.defineProperty(obj,&quot;newKey&quot;,{ get:function (){ //当获取值的时候触发的函数 return initValue; }, set:function (value){ //当设置值的时候触发的函数,设置的新值通过参数value拿到 initValue = value; }});//获取值console.log( obj.newKey ); //hello//设置值obj.newKey = 'change value';console.log( obj.newKey ); //change value 字符串重复123'x'.repeat(3) // &quot;xxx&quot;264 'hello'.repeat(2) // &quot;hellohello&quot;265 'na'.repeat(0) // &quot;&quot; 数组重复12345678910Array.prototype.cp = function(n){ var arr = []; while(n&gt;0){ console.log(this); n--; arr= arr.concat(this); console.log(arr); }} js复制数组一、 slice slice 方法返回一个 Array 对象，其中包含了 arrayObj 的指定部分。 如果省略 end ，那么 slice 方法将一直复制到 arrayObj 的结尾。如果 end 出现在 start 之前，不复制任何元素到新数组中。 12345678var arr = [&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;];var arrtoo = arr.slice(0);arrtoo[1] = &quot;set Map&quot;;// arr One,Two,Three// arrtoo One,set Map,Three 二、concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 12var arrtooo = arr.concat();arrtooo[1] = &quot;set Map To&quot;; 三、虽然说assgin也是深拷贝，但是他只是第一层深拷贝，第二层之后还是进行浅拷贝 模拟链式调用12345678910var obj={};obj.a=function(){ console.log(&quot;a&quot;) return this}obj.b=function(){ console.log(&quot;n&quot;) return this}obj.a().b(); 参数链式调用12345678910const functionFunction = (s) =&gt; { const func = (str) =&gt; { s += ',' + str; return func; } func.toString = func.valueOf = () =&gt; s; return func;}alert(functionFunction(2)(3)(4)) // 2,3,4 Promise异步链式写法123456789101112131415161718192021222324function fn_a(num) { return new Promise(function (resolve, reject) { if(num!= undefined){ num=num+1; setTimeout(resolve(num), 500); }else{//错误 reject(&quot;num未定义&quot;); } });}function fn_b(num,parm) { return new Promise(function (resolve, reject) { num=num*parm; setTimeout(resolve(num), 1000); });}fn_a(1).then(num=&gt;{ return fn_b(num,5);},error=&gt;{ console.log(error);}).then(num=&gt;{ console.log(num);//在1.5秒回返回10}) map，forEach， filter， reduce1234567891011121314151617181920212223242526272829303132333435363738394041var a=new Array(1,2,3,3,2,1);Array.isArray(a)); //truea.indexOf(2)); //1a.lastIndexOf(2); //4a.forEach(function(e,i,array){ array[i]=e+1;});a.every(function(e,i,arr){ console.log(i+' : '+e); return e&lt;5;});a.map(function(e){ return e*e;});a.filter(function(e){ return e%2==0;})a.reduce(function(v1,v2){ return v1+v2;})// 数组 arr = [1,2,3,4] 求数组的和forEach 实现var arr = [1,2,3,4],sum = 0;arr.forEach(function(e){sum += e;}); // sum = 10map 实现var arr = [1,2,3,4],sum = 0;arr.map(function(obj){sum += obj});//return undefined array. sum = 10reduce实现var arr = [1,2,3,4];arr.reduce(function(pre,cur){return pre + cur}); // return 10 写一个方法clone; 实现js五种数据类型(string, number, boolean, array, object)的复制number , string , boolean 直接赋值 object , array 遍历后赋值 方法中用到的apply方法 1234567891011121314151617181920212223242526272829303132333435363738394041function clone(obj) { var copy; switch(typeof obj){ case 'number': case 'string': case 'boolean': copy = obj; break; case 'object': if (obj == null) { copy = null } else if (toString.apply(obj) === '[object Array]') { copy = []; for (var i in obj) { copy.push(clone(obj[i])) }; } else { copy = {}; for (var j in obj) { copy[j] = clone(obj[j]); } } } return copy;} //各种类型的返回值; call 和 apply 返回值相同; 只是参数不同 console.log(&quot;string&quot; +toString.apply(str)) // string[object String] console.log(&quot;number&quot; +toString.apply(num)) // number[object Number] console.log(&quot;object&quot; +toString.apply(obj)) // object[object Object] console.log(&quot;array&quot; + toString.apply(arr)) // array[object Array] console.log(&quot;boolean&quot; + toString.apply(bool)) // boolean[object Boolean] console.log(&quot;undefined&quot; + toString.apply(undefined)) //undefined[object Undefined] console.log(&quot;null&quot; + toString.apply(null)) // null[object Null] 纯js的ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 得到ajax对象 */function getajaxHttp() { var xmlHttp; try { // Firefox, Opera 8.0+, Safari xmlHttp = new XMLHttpRequest(); } catch (e) { // Internet Explorer try { xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } catch (e) { try { xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } catch (e) { alert(&quot;您的浏览器不支持AJAX！&quot;); return false; } } } return xmlHttp;}/** * 发送ajax请求 * url--url * methodtype(post/get) * con (true(异步)|false(同步)) * parameter(参数) * functionName(回调方法名，不需要引号,这里只有成功的时候才调用) * (注意：这方法有二个参数，一个就是xmlhttp,一个就是要处理的对象) * obj需要到回调方法中处理的对象 */function ajaxrequest(url,methodtype,con,parameter,functionName,obj){ var xmlhttp=getajaxHttp(); xmlhttp.onreadystatechange=function(){ if(xmlhttp.readyState==4){ //HTTP响应已经完全接收才调用 functionName(xmlhttp,obj); } }; xmlhttp.open(methodtype,url,con); xmlhttp.send(parameter);}//这就是参数function createxml(){ var xml=&quot;&lt;user&gt;&lt;userid&gt;haorooms 纯js ajax请求&lt;\\/userid&gt;&lt;\\/user&gt;&quot;;//&quot;\\/&quot;这不是大写V而是转义是左斜杠和右斜杠 return xml;}//这就是参数function createjson(){ var json={id:0,username:&quot;haorooms&quot;}; return json;}function c(){ alert(&quot;&quot;);}//测试ajaxrequest(&quot;http://www.haorooms.com&quot;,&quot;post&quot;,true,createxml(),c,document); reduce用法将数组所有项相加1234var total = [0, 1, 2, 3].reduce(function(a, b) { return a + b;});// total == 6 数组扁平化 有多种解决办法1234567891011121314151617181920var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) { return a.concat(b);});// flattened is [0, 1, 2, 3, 4, 5]使用递归实现function flattenDepth(array, depth=1) { let result = []; array.forEach (item =&gt; { let d = depth; if(Array.isArray(item) &amp;&amp; d &gt; 0){ result.push(...(flattenDepth(item, --d))) } else { result.push(item); } }) return result;}console.log(flattenDepth([1,[2,[3,[4]],5]])) 数组去重多种方法123456789101112131415161718192021222324252627282930313233343536373839404142扩展运算符（…）内部使用for…of循环[...new Set([1,2,3,1,'a',1,'a'])]Array.from(new Set(array));// 原理：利用forEach的三个参数和indexOf()的第二个参数(从哪里开始查找)，在数组中检测该元素后方是否有与该元素相同的元素。distinct = (arr) =&gt;{ let _arr = []; arr.forEach((item, index, arr) =&gt; { var bool = arr.indexOf(item,index+1); if(bool === -1){ _arr.push(item); } }) return _arr;}let arr = [2,1,3,5,1,2,4];distinct(arr);=&gt; [3, 5, 1, 2, 4] //1是后面的1，2也是后出现的2.// 原理：splice()删除元素，会改变原数组。distinct = (arr) =&gt;{ let len = arr.length; for(let i = 0; i &lt; len; i++) { for(let j = i + 1; j &lt; len; j++) { if(arr[i] === arr[j]) { arr.splice(j,1); len--; j--; } } } return arr;}let arr = [2,1,3,5,1,2,4];distinct(arr);=&gt;[2, 1, 3, 5, 4] 获取数组最大最小值12345678910111213141516171819202122232425262728293031Array.max = function( array ){return Math.max.apply( Math, array );};Array.min = function( array ){return Math.min.apply( Math, array );};Array.prototype.max = function(){return Math.max.apply({},this)}Array.prototype.min = function(){return Math.min.apply({},this)}[1,2,3].max()// =&gt; 3[1,2,3].min()// =&gt; 1var a=[1,2,3,[5,6],[1,4,8]];var ta=a.join(&quot;,&quot;).split(&quot;,&quot;);//转化为一维数组alert(Math.max.apply(null,ta));//最大值alert(Math.min.apply(null,ta));//最小值//sort()排序默认为升序，reverse()将数组掉个var max3 = arr.sort().reverse()[0];console.log(max3)使用ES6的扩展运算符 var arr = [22,13,6,55,30]; console.log(Math.max(...arr)); // 55 防抖（debounce）函数防抖和节流都能控制一段时间内函数执行的次数. 函数防抖: 将本来短时间内爆发的一组事件组合成单个事件来触发。等电梯就是一个非常形象的比喻，电梯不会立即上行，而是等待一段时间内没有人再上电梯了才上行，换句话说此时函数执行时一阵一阵的，如果一直有人上电梯，电梯就永远不会上行。 使用场合：用户输入关键词实时搜索，如果用户每输入一个字符就发请求搜索一次，就太浪费网络，页面性能也差；再比如缩放浏览器窗口事件；再再比如页面滚动埋点 函数节流: 控制持续快速触发的一系列事件每隔’X’毫秒执行一次,就像Magic把瓢泼大雨编程了绵绵细雨。 使用场合：页面滚动过程中不断统计离底部距离以便懒加载。作用是在短时间内多次触发同一个函数，只执行最后一次，或者只在开始时执行。 1234567891011121314151617181920212223242526// debounce 函数接受一个函数和延迟执行的时间作为参数function debounce(fn, delay){ // 维护一个 timer let timer = null; // 返回的函数并没有使用箭头函数，目的是在事件执行时确定上下文 return function() { // 获取函数的作用域和变量 let context = this; let args = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function(){ fn.apply(context, args); }, delay) }}function foo() { console.log('trigger');}// 在 debounce 中包装我们的函数，过 2 秒触发一次window.addEventListener('resize', debounce(foo, 2000));每一次事件被触发，都会清除当前的 timer 然后重新设置超时调用。只有在最后一次触发事件，才能在 delay 时间后执行。 节流（throttle）节流是在一段时间内只允许函数执行一次。 时间戳实现： 123456789101112131415161718function throttle(func, wait = 100) { let timerId let start = Date.now() return function(...args) { const now = Date.now() clearTimeout(timerId) if (now - start &gt;= wait) {// 可以保证func一定会被执行 func.apply(this, args) start = now } else { timerId = setTimeout(() =&gt; { func.apply(this, args) }, wait) } }} 使用时间戳实现的节流函数会在第一次触发事件时立即执行，以后每过 delay 秒之后才执行一次，并且最后一次触发事件不会被执行；而定时器实现的节流函数在第一次触发时不会执行，而是在 delay 秒之后才执行，当最后一次停止触发后，还会再执行一次函数。 柯里化参数够了就执行，参数不够就返回一个函数，之前的参数存起来，直到够了为止。 3个常见作用：1. 参数复用；2. 提前返回；3. 延迟计算/运行。 123456789101112131415161718192021function curry(func) { var l = func.length; return function curried() { var args = [].slice.call(arguments); if(args.length &lt; l) { return function() { var argsInner = [].slice.call(arguments) return curried.apply(this, args.concat(argsInner)) } } else { return func.apply(this, args) } }}var f = function(a,b,c) { return console.log([a,b,c])}var curried = curry(f);curried(1)(2)(3) 浅拷贝123456789101112 function extendCopy(p) { var c = {}; for (var i in p) { c[i] = p[i]; } c.uber = p; return c; } 深拷贝123456789101112131415161718192021function deepCopy(p, c) { var c = c || {}; for (var i in p) { if (typeof p[i] === 'object') { c[i] = (p[i].constructor === Array) ? [] : {}; deepCopy(p[i], c[i]); } else { c[i] = p[i]; } } return c;} 自己实现bind方法123456Function.prototype.bind=Function.prototype.bind||function(context){ var self=this; return function(){ return self.apply(contex,arguments); };}","link":"/posts/js-%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"},{"title":"js前端小知识","text":"前端替换字符串中的特殊字符 比如回车，换行，等。在window中，换行有可能是\\r\\n连起来的。 12345678910str.replace(/\\\\n/g, &quot;\\\\n&quot;) .replace(/\\n/g, &quot;\\\\n&quot;) .replace(/\\\\'/g, &quot;\\\\'&quot;) .replace(/&quot; &quot;/g, &quot;&quot;) .replace(/\\\\&quot;/g, &quot;\\\\\\&quot;&quot;) .replace(/\\\\&amp;/g, &quot;\\\\&amp;&quot;) .replace(/\\\\r/g, &quot;\\\\r&quot;) .replace(/\\\\t/g, &quot;\\\\t&quot;) .replace(/\\\\b/g, &quot;\\\\b&quot;) .replace(/\\\\f/g, &quot;\\\\f&quot;); js获取options的列表和每个的文本和值var opts=document.getElementById(&quot;option&quot;).options;opts[0].value得到第一个value的值opts[0].text得到显示的文本值 js获取时间戳var nowTimestamp = new Date().getTime();获取3个小时前的时间戳var threeHourAgo = nowTimestamp - 3 *60 * 60* 1000; js获取select选中的值1234567891011$(&quot;#s option:selected&quot;).text(); //获取选中的option的文本值// 获取select中option的被选中的value值，$(&quot;#s&quot;).val();$(&quot;#s option:selected&quot;).val();// js获取select选中的值var sel=document.getElementById(&quot;select1&quot;);var index = sel.selectedIndex; // 选中索引albumid= sel.options[index].value;//要的值 获取文本为{}的元素$(“table tr td:contains(‘{}’)”) 在当前元素上添加一个父元素12//给table添加一个div.table-responsive的父元素，可以使table变成响应式的。$('table').addClass('table').wrap('&lt;div class=&quot;table-responsive&quot;/&gt;'); js 触发resizejQuery: $(selector).resize() eg: $(window).resize(); js的暂未找到！！！！！！ js设置时间为标准时间格式 普通 new Date(); var a = new Date(‘2016-10-12 12:12:11’); 这种情况在safari下不能用会返回Invalid Date 可以用a == ‘Invalid Date’ 判断new Date(‘2016/10/12 12:12:11’) 这种可以在sarafi和chrome下使用 于是， var a = ‘2016-10-12 12:12:11’ a = a.replace(/-/g,”/“) var a = new Date(a) setTimeout1234567891011function a(){ console.log('a'); setTimeout(function(){ console.log('aaa'); },0);}function b(){ console.log('b');}a();b(); 调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间所以即使，时间设置为0，也是会照样先执行函数b js replace 替换空格var a = ‘{“string”:” “,”hex”:”20”,””:” “}’a.replace(/“ “/g, “”) 输出结果：”{“string”:,”hex”:”20”,””:}”解决办法： a.replace(/“ “/g, ‘“”‘) a.replace(/“ “/g, “&quot; &quot;“) css去除所有边框 border: none; cellpadding=”0” cellspacing=”0” css 换行word-break: break-word;在火狐下不支持，解决方案：所有的浏览器都支持 123overflow: hidden;word-wrap: break-word;word-break: break-all; 1、对已有对象进行扩充方法和属性 1234567var object = new Object(); object.name = &quot;zhangsan&quot;;//每个对象需要写这些语句 object.sayName = function(name){//每个对象需要写这些语句 this.name = name; }; object.sayName(&quot;lisi&quot;); alert(object.name); 2、工厂方式创建对象 123456789101112131415161718192021222324252627282930313233343536373839404142function createObject() { var object = new Object(); object.username = &quot;zhangsan&quot;; object.password = &quot;123456&quot;; object.get = function(){ alert(this.username + &quot;,&quot; + this.password); } return object; } var object1 = createObject(); var object2 = createObject(); object1.get(); object2.get(); // 带参数的构造方法 function createObject(username, password){ var object = new Object(); object.username = username; object.password = password; object.get = function(){//缺点是，多少个对象则方法就有多少个 alert(this.username + &quot;, &quot; + this.password); } return object; } var object1 = createObject(&quot;zhangsan&quot;,123456); object1.get(); // 最佳改进方式 function get(){//使该函数被多个对象共享 alert(this.username + &quot;, &quot; + this.password); } function createObject(username, password){//创建对象 var object = new Object(); object.username = username; object.password = password; object.get = get; return object; } var object1 = createObject(&quot;zhangsan&quot;, &quot;123456&quot;); var object2 = createObject(&quot;wangwu&quot;, &quot;654321&quot;); object1.get(); object2.get(); 3、构造函数方式创建对象 12345678910111213141516171819202122function Person(){ //在执行第一行代码欠，js引擎会为我们生成一个对象 this.username = &quot;zhangsan&quot;; this.password = &quot;123&quot;; this.getInfo = function(){ alert(this.username + &quot;, &quot; + this.password); } //此处有一个隐藏的return语句，用于将之前生成对象返回。 } var p1 = new Person(); p1.getInfo(); //带参数 function Person(username, password){ this.username = username; this.password = password; this.getInfo = function(){ alert(this.username + &quot;, &quot; + this.password); } } var p1 = new Person(&quot;zhangsan&quot;,&quot;1234546&quot;); p1.getInfo(); 4、原型（“prototype”）方式 12345678910111213141516171819202122232425262728293031function Person(){} Person.prototype.username = &quot;zhangsan&quot;; Person.prototype.password = &quot;123456&quot;; Person.prototype.getInfo = function(){ alert(this.username + &quot;, &quot; + this.password); } var person = new Person(); var person2 = new Person(); person.username = &quot;haha&quot;; person.getInfo(); person2.getInfo(); //单纯使用原型方式定义对象无法在构造函数中为属性赋值，只能在对象生成后再去改变属性值 function Person(){} Person.prototype.username = new Array(); Person.prototype.password = &quot;123456&quot;; Person.prototype.getInfo = function(){ alert(this.username + &quot;, &quot; + this.password); } var person = new Person(); var person2 = new Person(); person.username.push(&quot;zhangsan&quot;); person.username.push(&quot;lisi&quot;); person.password = &quot;321&quot;; person.getInfo(); person2.getInfo(); 5、综合方式（原型+构造函数方式搭配） 12345678910111213141516function Person(){ this.username = new Array();//不被多个对象共享 this.password = &quot;123&quot;; } Person.prototype.getInfo = function()//被多个对象共享 { alert(this.username + &quot;,&quot; + this.password); } var p1 = new Person(); var p2 = new Person(); p1.username.push(&quot;zhangsan&quot;); p2.username.push(&quot;lisi&quot;); p1.getInfo(); p2.getInfo(); 6、动态原型方式 123456789101112131415161718function Person(){ this.username = &quot;zhangsan&quot;; this.password = &quot;123&quot;; //通过标志量让所有的对象共享方法 if(typeof Person.flag == &quot;undefined&quot;){ alert(&quot;prototype&quot;); Person.prototype.getInfo = function() { alert(this.username + &quot;, &quot; + this.password); } Person.flag = true; }}var p = new Person();var p2 = new Person();p.getInfo();p2.getInfo(); 一道容易做错的JavaScript面试题 http://caibaojian.com/toutiao/5446?fid=0#0-tsina-1-81079-397232819ff9a47a7b7e80a40613cfe1 js获取字符串字节数方法小结 方法一： 123//原理：把中文字符替换成2个英文字母，那么字节数就是2，//\\u0000这个表示的是unicode编码alert('a你好'.replace(/[^\\u0000-\\u00ff]/g,&quot;aa&quot;).length); 方法二： 1234567891011121314151617//结果是6//原理也很简单，用正则判断是不是中文，如果是的话，字节数就加1。var str='我我我';var bytesCount;for (var i = 0; i &lt; str.length; i++){ var c = str.charAt(i); if (/^[\\u0000-\\u00ff]$/.test(c)) //匹配双字节 { bytesCount += 1; } else { bytesCount += 2; }}alert(bytesCount); 关键匹配中文字符的正则表达式： [\\u4e00-\\u9fa5] 匹配双字节字符(包括汉字在内)：[^\\u0000-\\u00ff] 过滤特殊字符123456789101112131415161718// /[&quot;'&lt;&gt;%;)(&amp;+]/if (/['&quot;)-&gt;&lt;&amp;\\\\\\/\\.]/.test(value)) { alert('包含特殊字符，不允许提交!');}IllegalString = &quot;\\`~!#$%^&amp;*()+{}|\\\\:\\&quot;&lt;&gt;?-=/,\\'&quot;;var pattern = new RegExp(&quot;[%--`~!@#$^&amp;*()=|{}':;',\\\\\\\\\\[\\\\].&lt;&gt;/?~！@#￥……&amp;*（）——|{}【】‘；：”“'。，、？]&quot;);if (/[ ,\\\\`,\\\\~,\\\\!,\\\\@,\\#,\\\\$,\\\\%,\\\\^,\\\\+,\\\\*,\\\\&amp;,\\\\\\\\,\\\\/,\\\\?,\\\\|,\\\\:,\\\\.,\\\\&lt;,\\\\&gt;,\\\\{,\\},\\\\(,\\\\),\\\\'',\\\\;,\\\\=,\\&quot;]/.test(key)) {if (/['&quot;)-&gt;&lt;&amp;\\\\\\/\\.]/.test(key)) { alert('包含特殊字符，不允许提交!'); return;} 1.如何通过css使div 实现全屏效果–全屏要素： 1.全屏的元素及其父元素都要设置为height:100%, 2.将html,body标签设置为height100%,注：height:100%是跟随其父元素高度变化而变化的 jQuery插件的封装123(function($){ // do something})(jQuery); 闭包的作用 –避免全局依赖 –避免第三方破坏 –兼容jQuery操作符‘$’和jQuery 开发方式类级别组件开发 -即给jQuery命名空间下添加新的全局函数，也称静态方法。 123jQuery.myPlugin = function(){ //do something}; 例如： $.ajax,$.extend() 对象级别组件开发-即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法， 也称动态方法。 1234$.fn.myPlugin = function(){ //do something};这里$.fn===$.prototype 例如：addClass()、attr()等，需要创建实例来调用 链式调用123456eg: $(&quot;div&quot;).next().addClass().... $.fn.myPlugin = function(){ return this.each(function(){ //do something }); }; 代码说明： return this 返回当前对象，来维护插件的链式调用 each 循环实现每个元素的访问 单例模式1234567$.fn.myPlugin = function(){ var me = $(this), instance = me.data(&quot;myPlugin&quot;); if(!instance){ me.data(&quot;myPlugin&quot;,(instance= new Plugin())); }}; 代码说明： -如果实例存在则不再重新创建实例 -利用data()来存放插件对象的实例 es6 从数组中查找一个元素1234let users = data.usersresult = users.find(ele =&gt; { return ele.username === username &amp;&amp; ele.password === password}) 从数组中删除某个元素 1splice(index, 1) 数组比较12345678const arr1 =['a', 'b', 'c'];const arr2 =['b', 'c', 'a'];console.log( arr1.sort() === arr1, arr2.sort() === arr2, arr1.sort() === arr2.sort());// true, true, false 解析: arr.sort方法对原始数组进行排序，并返回该数组的引用，调用.sort(), 对数组内对象进行排序 当比较对象时，数组的排序顺序并不重要。由于arr1.sort()和arr1指向内存中的同一对象，因此第一个和第二个返回true. arr1.sort()和arr2.sort()排序顺序相同；但他们指向内存中的不同对象，所以返回false 前端实现即时通讯的方式有哪些，并介绍对应的优缺点短轮询短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。 优点：兼容性强，实现非常简单缺点：延迟性高，非常消耗请求资源，影响性能 cometcomet有两种主要实现手段， 一种是基于AJAX的长轮询(1ong-polling) 方式， 另一种是基于Iframe及html file的流(streaming) 方式，通常被叫做长连接。 a.长轮询优缺点：优点：兼容性好，资源浪费较小缺点：服务器hold连接会消耗资源， 返回数据顺序无保证，难于管理维护 b.长连接优缺点：优点：兼容性好，消息即时到达，不发无用请求缺点：服务器维护长连接消耗资源 SSESSE(Server-Sent Event， 服务端推送事件) 是一种允许服务端向客户端推送新数据的HTML 5技术。 a.优点：基于HTTP而生， 因此不需要太多改造就能使用， 使用方便， 而websocket非常复杂， 必须借助成熟的库或框架b.缺点：基于文本传输效率没有websocket高， 不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求 Web socketWeb socket是一个全新的、独立的协议， 基于TCP协议，与http协议兼容、却不会融入http协议， 仅仅作为htmL 5的一部分， 其作用就是在服务器和客户端之间建立实时的双向通信。a.优点：真正意义上的实时双向通信，性能好，低延迟b.缺点：独立与http的协议， 因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器 Service workersService Worker从英文翻译过来就是一个服务工人， (服务于前端页面的后台线程， 基于Web Worker实现。有着独立的js运行环境，分担、协助前端页面完成前端开发者分配的需要在后台悄悄执行的任务。基于它可以实现拦截和处理网络请求、消息推送、静默更新、事件同步等服务。 优势及使用场景： ①离线缓存：可以将H5应用中不变化的资源或者很少变化的资源长久的存储在用户端，提升加载速度降低流量消耗、降低服务器压力。如中重度的H5游戏、框架数据独立的web资讯客户端、web邮件客户端等 ②消息推送：激活沉睡的用户，推送即时消息、公告通知，激发更新等。如web资讯客户端、web即时通讯工具、h5游戏等运营产品。 ③事件同步：确保web端产生的任务即使在用户关闭了web页面也可以顺利完成。如web邮件客户端、web即时通讯工具等。 ④定时同步：周期性的触发Service Worker脚中的定时同事件，可借助它提前刷新缓存内容。如web资讯客户端。 数组push123456function addToList(item, list) { return list.push(item);}const result = addToList('abc', ['de']);console.log(result);// 结果是2 push方法返回新数组的长度push方法修改原始数组，如果想从函数返回数组而不是数组长度，应该先push，后返回 12list.push(item);return list; Script放在底部会影响DOM的解析和渲染吗Script放在底部影响DOM渲染。不会影响解析。 Script内的代码执行会会等待CSS加载完成么Script内的代码执行会等待CSS加载 CSS加载会影响DOMContentLoaded么CSS代码下若无Script代码段，就不会影响DOMContentLoaded 也可以借助控制台的Performance详细的查看HTML的整体渲染流程，这是成为高级前端的第一步。 实现Promise.all思路 接收一个Promise实例的数组或具有Iterator接口的对象作为参数 这个方法返回一个新的promise对象 遍历传入的参数，用promise.resolve()将参数包一层，使其变成一个promise对象 参数所有回调成功才是成功，返回值数组与参数顺序一致 参数数组其中一个失败，则触发失败状态，第一个触发失败的Promise错误信息作为Promise.all的错误信息 扩展 一般来说，Promise.all用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来。不过如果其中一个借口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了。 123456789101112131415161718192021222324252627282930313233343536373839404142function promiseAll(promises) { return new Promise((resolve, reject) =&gt; { if (!Array.isArray(promises)) { throw new TypeError('argument must be a array') } let resolvedCounter = 0; let promiseNum = promises.length; let resolvedResult = []; for(let i=0;i&lt;promiseNum;i++) { Promise.resolve(promises[i]).then(value =&gt; { resolvedCounter++; resolvedResult[i] = value; if (resolvedCounter === promiseNum) { return resolve(resolvedResult) } }, error =&gt; { return reject(error) }) } })}// testlet p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1) }, 1000)})let p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2) }, 2000)})let p3 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(3) }, 3000)})promiseAll([p3, p1, p2]).then(res =&gt; { console.log(res)});","link":"/posts/js%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"title":"Linux学习","text":"window远程连接工具：secure CRT配置：选项-会话选项-仿真 终端：x-term ansi颜色 外观：颜色方案：黄黑 光标 竖线 编码：回话选项-外观-字符编码-UTF-8 git 定时任务crontab链接 在centos执行git pull报错Peer reports incompatible or unsupported protocol version. 解决办法： yum update -y nss curl libcurl 执行后，可以正常运行。 ==++文件与目录管理++==新建文件夹mkdir eg:mkdir test mkdir -p test/123/abc -p 递归创建目录，即使上级目录不存在。还有一种情况就是如果你想要创建的目录存在的话，会提示报错，然后你加上-p参数后，就不会报错了。 命令详情 man rm, man ls 复制文件cp eg: cp a b cp copy的简写，即拷贝。格式为 cp [选项] [ 来源文件 ] [目的文件] ，例如我想把test1 拷贝成test2 ，这样即可 cp test1 test2， -d 这里涉及到一个“连接”的概念。连接分为软连接和硬连接 如果不加这个-d 则拷贝软连接时会把软连接的目标文件拷贝过去，而加上后，其实只是拷贝了一个连接文件（即快捷方式）。 -r 如果你要拷贝一个目录，必须要加-r选项，否则你是拷贝不了目录的。 omitting directory ‘d’ -i 如果遇到一个存在的文件，会问是否覆盖。 -u 该选项仅当目标文件存在时才会生效，如果源文件比目标文件新才会拷贝，否则不做任何动作 移动文件mv 移动的意思，是move的简写。格式为 mv [ 选项 ] [源文件] [目标文件]。 -i 和cp的-i 一样，当目标文件存在时会问用户是否要覆盖。 -u 和上边cp 命令的-u选项一个作用，当目标文件存在时才会生效，如果源文件比目标文件新才会移动，否则不做任何动作。 - windows下的重命名，在linux下用mv就可以搞定。 删除文件夹 rm -rf eg:rm -rf testCLI rmdir 只能删除目录但不能删除文件，要想删除一个文件，则要用rm命令了。 -f 强制的意思，如果不加这个选项，当删除一个不存在的文件时会报错。 -i 这个选项的作用是，当用户删除一个文件时会提示用户是否真的删除。 -r 当删除目录时，加该选项，如果不加这个选项会报错。rm是可以删除不为空的目录的。 新建文件touch a a.txt 可以创建一个文件a也是一个文件vi a vi a /vim a 可以查看文件内容 输入i，进入编辑模式 按esc，退出编辑模式 输入:wq退出查看文件 进入linux的主目录cd /home pwd 这个命令打印出当前所在目录./ 指的是当前目录 ../ 指的是当前目录的上一级目录。cd wwwroot/ls 绝对路径：路径的写法一定由根目录”/”写起，例如/usr/local/mysql 这就是绝对路径。 相对路径：路径的写法不是由根目录”/”写起，例如，首先用户进入到/ 然后再进入到 home ，命令为 cd /home 然后 cd test 此时用户所在的路径为 /home/test 。第一个cd命令后跟 /home 第二个 cd 命令后跟 test ，并没有斜杠，这个test是相对于/home 目录来讲的，所以叫做相对路径。 输出echo 变量echo ‘abc’&gt;111 将字符输出到一个文件中大于号”&gt;” 在linux中这叫做重定向，即把前面产生的输出写入到后面的文件中。”&gt;&gt;”是追加的意思，而用”&gt;”，如果文件中有内容则会删除文件中内容，而”&gt;&gt;”则不会。 查看文件 cat 比较常用的一个命令，即查看一个文件的内容并显示在屏幕上 -n 查看文件时，把行号也显示到屏幕上。 -A 显示所有东西出来，包括特殊字符 tac 其实是cat的反写，同样的功能也是反向打印文件的内容到屏幕上。 more也是用来查看一个文件的内容。当文件内容太多，一屏幕不能占下，而你用cat肯定是看不前面的内容的，那么使用more就可以解决这个问题了。当看完一屏后按空格键继续看下一屏。但看完所有内容后就会退出。如果你想提前退出，只需按q键即可。 less作用跟more一样，但比more好在可以上翻，下翻。空格键同样可以翻页，而按”j”键可以向下移动（按一下就向下移动一行），按”k”键向上移动。在使用more和less查看某个文件时，你可以按一下”/” 键，然后输入一个word回车，这样就可以查找这个word了。如果是多个该word可以按”n”键显示下一个。另外你也可以不按”/”而是按”?”后边同样跟word来搜索这个word，唯一不同的是，”/”是在当前行向下搜索，而”?”是在当前行向上搜索。 按n向上，按N向下显示–老罗 vim head head后直接跟文件名，则显示文件的前十行。如果加 –n 选项则显示文件前n行。 tail 和head一样，后面直接跟文件名，则显示文件最后十行。如果加-n 选项则显示文件最后n行。 -f 动态显示文件的最后十行，如果文件是不断增加的，则用-f 选项。如：tail -f /var/log/messages - 实时查看文件内容 tail -f catalina.out ！！！！！！！！ 文件的所属主以及所属组所属组”就派上用场了。即，创建一个群组users，让user0和user1同属于users组，然后建立一个文件test2，且其所属组为users，那么user0和user1都可以访问test2文件。 查看文件列表listlsls -l-a 全部的档案都列出，包括隐藏的。 -l 详细列出文件的属性信息，包括大小、创建日期、所属主所属组等等。ll 这个命令等同于ls –l 。 -d 后边跟目录，如果不加这个选项则列出目录下的文件，加上后只列车目录本身。 linux 文件属性用ls –l 查看当前目录下的文件时，共显示了9列内容（用空格划分列），都代表了什么含义呢？ 第1列，包含的东西有该文件类型和所属主、所属组以及其他用户对该文件的权限。第一列共10位。其中第一位用来描述该文件的类型。上例中，我们看到的类型有”d”, “-“ ，其实除了这两种外还有”l”, “b”, “c”,”s”等。 d 表示该文件为目录； 表示该文件为普通文件； l 表示该文件为连接文件（linux file），上边提到的软连接即为该类型； b 表示该文件为块设备文件，比如磁盘分区 c 表示该文件为串行端口设备，例如键盘、鼠标。 s 表示该文件为套接字文件（socket），用于进程间通信。 后边的9位，每三个为一组。均为rwx 三个参数的组合。其中r 代表可读，w代表可写，x代表可执行。前三位为所属主（user）的权限，中间三位为所属组（group）的权限，最后三位为其他非本群组（others）的权限。下面拿一个具体的例子来述说一下。 一个文件的属性为-rwxr-xr– ，它代表的意思是，该文件为普通文件，文件拥有者可读可写可执行，文件所属组对其可读不可写可执行，其他用户对其只可读。 对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个目录必须要有x权限才能打开并查看该目录。例如一个目录的属性为 drwxr–r– 其所属主为root，那么除了root外的其他用户是不能打开这个目录的。 第2列，表示为连接占用的节点（inode），若为目录时，通常与该目录地下还有多少目录有关系，关于连接（link）在以后章节详细介绍。 第3列，表示该文件的所属主。 第4列，表示该文件的所属组。 第5列，表示该文件的大小。 第6列、第7列和第8列为该文件的创建日期或者最近的修改日期，分别为月份日期以及时间。 第9列，文件名。如果前面有一个. 则表示该文件为隐藏文件。 更改文件的权限==？？？太多了？？？以后再学== 在 linux 下搜索一个文件 which 用来查找可执行文件的绝对路径 which只能用来查找PATH环境变量中出现的路径下的可执行文件。不知道某个命令的绝对路径，which一下就知道了。 whereis 通过预先生成的一个文件列表库去查找跟给出的文件名相关的文件。 语法： whereis [-bmsu] [文件名称] -b：只找binary 文件 -m：只找在说明文件manual路径下的文件 -s：只找source来源文件 -u：没有说明档的文件 locate 类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里。后边直接跟文件名。 find 用的最多，务必要熟悉。 语法： find [路径] [参数] 下面介绍几个笔者经常用的参数 -atime +n ：访问或执行时间大于n天的文件 -ctime +n ：写入、更改inode属性（例如更改所有者、权限或者连接）时间大于n天的文件 -mtime +n ：写入时间大于n天的文件 -name filename 直接查找该文件名的文件，这个使用最多了。 -type type ：通过文件类型查找。type 包含了 f, b, c, d, l, s 等等。后续的内容还会介绍文件类型的。 你对这三个time是不是有些晕了，那笔者就先给你介绍一下这三个time属性。 文件的 Access time，atime 是在读取文件或者执行文件时更改的。文件的 Modified time，mtime 是在写入文件时随文件内容的更改而更改的。文件的 Create time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。因此，更改文件的内容即会更改 mtime 和 ctime，但是文件的 ctime 可能会在 mtime 未发生任何变化时更改，例如，更改了文件的权限，但是文件内容没有变化。 如何获得一个文件的atime mtime 以及ctime ？ ls -l 命令可用来列出文件的 atime、ctime 和 mtime。 ls -lc filename 列出文件的 ctime ls -lu filename 列出文件的 atime ls -l filename 列出文件的 mtime atime不一定在访问文件之后被修改，因为：使用ext3文件系统的时候，如果在mount的时候使用了noatime参数那么就不会更新atime的信息。而这是加了 noatime 取消了, 不代表真实情況。反正, 這三個 time stamp 都放在 inode 中。若 mtime, atime 修改inode 就一定會改, 既然 inode 改了, 那 ctime 也就跟著要改了。 linux 文件类型1）正规文件（regular file）：就是一般类型的文件，当用ls –l 查看某个目录时，第一个属性为”-“的文件就是正规文件，或者叫普通文件。正规文件又可分成纯文字文件（ascii）和二进制文件（binary）。纯文本文件是可以通过cat, more, less等工具直接查看内容的，而二进制文件并不能。例如我们用的命令/bin/ls 这就是一个二进制文件。 2）目录（directory）即文件夹,ls –l 查看第一个属性为”d”。 3）连接档（link）：ls –l 查看第一个属性为 “l”，类似windows下的快捷方式。 4）设备档（device）：与系统周边相关的一些档案，通常都集中在 /dev 这个目录之下！通常又分为两种： 区块 (block) 设备档：说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的档案啦！第一个属性为 “ b “； 字符 (character) 设备档：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为 “ c “。 linux 文件后缀名1.sh代表它是一个shell script2.tar.gz 代表它是一个压缩包，3.my.cnf 代表它是一个配置文件，4.test.zip 代表它是一个压缩文件。早期Unix系统文件名最多允许14个字符，而新的Unix或者linux系统中，文件名最长可以到达 256 个字符！ 压缩 解压缩tar 解包：tar zxvf filename.tar 打包：tar czvf filename.tar dirname zip命令 解压：unzip filename.zip 压缩：zip filename.zip dirname ln 建立连接档ln 语法： ln [-s] [来源文件] [目的文件]ln 常用的选项就一个-s ，如果不加就是建立硬连接，加上就建立软连接。 Hard Link 的限制太多了，包括无法做目录的 link ，所以在用途上面是比较受限的！反而是 Symbolic Link 的使用方向较广！在建立硬连接前后，空间大小不改变。不能创建目录的硬连接。目录是可以软连接的。删除软连接对源文件没有任何影响。 环境变量 PATH有两个方法。 一种方法是直接将 /root 的路径加入 PATH 当中！如何增加？可以使用： PATH=”$PATH”:/root 另一种方式则是使用完整档名，亦即直接使用相对或绝对路径来执行，例如： /root/ls ./ls ==== vim查看版本vim 设置vim编码vim ~/.vimrc vimvim 编辑 按i ,进入编辑模式， 编辑完成后，按esc退出编辑模式 退出保存 :wq 退出不保存 :q会提示: No write since last change (add ! to override)再输入一次 :q!即可 将以下复制到其中 syntax onset nu!set encoding=utf-8set fenc=utf-8set fileencodings=ucs-bom,utf-8,cp936,gb2312,gb18030 查看系统的编码echo $LANG 乱码解决方案 系统编码 vim的编码 连接服务器的终端。 SecureCRT设置字条编码Option–Session Option–Appearance设置字符编码 命令行远程登录服务器ssh root@192.168.1.25 用户名@ip 服务器上安装公钥键入以下命令，在服务器上安装公钥： [root@host ~]$ cd .ssh [root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys 将本地的key复制到authorized_keys文件中 从gitbash中获ssh key clip &lt; ~/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOmNk1rDPVPv+DTpe/ynM9dLDj/FjG/3xkAvjz8EoxSM/QBXNLj69m0SXA4jI6LOIwuS3Pdn011qWGa14zHPDI0wY9cGzlC+AvcuAZ0s+ndppAVk5PktYM0zCfBhlpLyHCgCVNxDxv1shd1A+gG3Lbi+tJ75oOnvJ5uSWC6x6wJgwJy/zUdQHTA3od4Mfkbz/6hr1sWqnCJE3r4H9Na6XtYMbjyl+O+JnePxH4PDwT/0MVxPpojyEqAv/FE9Gb7WjqmLsT5TWEoRhb4V0pm75moh6QObgqQ+RfJLS6Cz+NIvep980qVrYaRQGQG+7bEwy3fNDZlSGXRUALgELceVP/ HP@HP-PC 查看版本号 uname -r 查看系统uname 查看当前正在进行的进程 jobs 启一个服务，在后台执行，并将日志输出到log node . &gt;log 2&gt;&amp;1 &amp; tail -f log 查找某个进程(eg:node) ps -ef|grep node 在历史命令中查找某个命令 history|grep cd 写了脚本以后执行一个脚本./control.sh linux 查找文件find / -name nginx.conf find / -name php.ini find / -name my.cnf find / -name httpd.conf php 相关 查看php运行目录命令：which php which 用来查找一个命令的绝对路径 /usr/bin/php查看php-fpm进程数： ps aux | grep -c php-fpm 查看运行内存/usr/bin/php -i|grep mem 关闭PHP killall php-fpm php重启 /usr/local/php/sbin/php-fpm &amp; php 配置 端口 httpd.conf listen 80 2. 查看linux IP公网IPcurl members.3322.org/dyndns/getip 47.94.93.83 内网IPifconfig inet addr:192.168.42.128 NGINX启动：/usr/local/nginx/sbin/nginx service nginx start关闭：/usr/local/nginx/sbin/nginx -s stop service nginx stop 重启：/usr/local/nginx/sbin/nginx -s reload 查看nginx状态 service nginx status 查看当前nginx目录ps -ef | grep nginx可以在conf目录下的nginx.conf中找到对应的配置。 查看一个服务是否已经启动： ps -A | grep nginx 如果返回结果的话，说明有nginx在运行，服务已经启动 nginx -V 查看nginx安装目录 cd /usr/local/etc/nginx 里有nginx.conf sudo nginx -s reloadSudo nginx -s stop openresty/nginx/coupon ./sbin/nginx -s reload Nginx 命令service nginx stop/start/status/reload 2、查看nginx.conf配置文件目录 输入命令 nginx -t返回结果包含配置文件目录nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 检查下80端口是否被其他进程占用了。lsof -i:80 Nginx 配置实现CORS123456789101112131415161718192021222324252627location ^~ /api/v1 { add_header 'Access-Control-Allow-Origin' &quot;$http_origin&quot;; add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type '; add_header 'Access-Control-Allow-Credentials' 'true'; if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' &quot;$http_origin&quot;; add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type '; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Max-Age' 1728000; # 20 天 add_header 'Content-Type' 'text/html charset=UTF-8'; add_header 'Content-Length' 0; return 200; } # 这下面是要被代理的后端服务器，它们就不需要修改代码来支持跨域了 proxy_pass http://127.0.0.1:8085; proxy_set_header Host $host; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_connect_timeout 60; proxy_read_timeout 60; proxy_send_timeout 60;} telnet 80 d端口ping不通12curl &lt;http://127.0.0.1&gt;curl http:oriht.com 查看实例安全组规则 端口范围是否有80端口 允许自定义 TCP 12345680/80 地址段访问0.0.0.0/0-1 2017-09-25 11:03:54--- 如果新配置nginx一直403 禁止访问的话 修改/etc/selinux/config将SELINUX=enforcing 改为SELINUX=disabled 跟着吴博学linuxls -lh sudo sh updata_www.sh less update_www.sh ls -l sudo su root git branch -r !/bin/bashrm www-oldmv ./www ./www-oldln -s ./ac-www-releases/ac-www-2016-10-17/ wwwsh git.pull.sh exit sudo sh update_www.sh 找不到httpd.confhttpd.conf的位置一般位于/etc/httpd/conf/httpd.conf 如果没执行命令yum install httpd重新安装一下， 根据nginx配置，查找文件目录原本nginx配置好后，目录应该在 1root /data/www/hosts; 但如果有 12345location ^~ / { proxy_buffering off; proxy_pass http://127.0.0.1:3001/; proxy_set_header Host $host;} 则应根据3001端口来找具体进程对应的进程 执行 如下命令找到对应进程的pid 1sudo netstat -nplt | grep 3001 根据pid来找到目录，执行以下命令 1ps -aux | grep 37098 出现如下结果，则为对应的目录 1501 37098 0.0 0.2 1209696 42828 ? Ssl Aug08 8:37 node /home/nodeProjects/express/dist/index.js 跟着立斌学命令行dashzsh/oh-my-zshoh-my-zsh sh -c “$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;需要提前装zsh， yum install zsh 切换到zshchsh -s /usr/local/bin/zsh 修改主题，目录/root/.oh-my-zsh/templates/zshrc.zsh-template zsh-autosuggestions 安装方法：git clone git://github.com/zsh-users/zsh-autosuggestions /.zsh/zsh-autosuggestionssource/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 看一下自己目前使用的终端是什么： echo $SHELL 查看当前主题 echo $ZSH_THEME 我用的主题robbyrussell 主题修改文件路径:sudo vim ~/.zshrc linux 用命令启动服务不掉线创建control.sh 运行./control.sh 1234#!/bin/bashnohup npm start ./ 1&gt;&gt;log 2&gt;&amp;1 &amp; cat access.log | cut -d’ ‘ -f7 | sort | uniq -c | sort -nr | head -n30","link":"/posts/linux%E5%AD%A6%E4%B9%A0/"},{"title":"业务?! 业务与技术之争","text":"以前确实不重视业务，读了接下来这篇文章，发现了自己的误区。将好的观点抄下来，以便领会吸收。 原文链接前言 作为一个业务前端，完成业务需求的同时，还要处理各种线上问题，加班辛苦忙碌了一年，还要被老板说“思考是不够的”、“没有业务 sence”，出去面试，被问项目，也说不出什么有亮点或者有挑战的东西，想做点牛逼的东西，也没有发现什么有价值的方向，好不容易找到一些方向，还要被老板一顿质问，业务价值是什么？ROI 怎样？最终可能就只是做了一点性能优化工作，抽离了一些可复用的组件……不禁让人感叹，业务难、前端难、做业务的前端更难！ 1. 业务前端的困境1.1 业务前端“好忙”业务前端，顾名思义，做业务的前端，直接与业务的 PD、运营接触，对产品的用户直接负责。在实际的工作中，业务前端经常忙于业务的各种会议、项目和答疑，即便一条业务线上有多个前端同学支持，面对成山的需求，可能依然感到吃力，这其中的原因可能有： 用户侧产品往往需要快速上线，大部分需求都需要倒排工期，开发时间尤其紧张 对业务不熟悉，在项目需求已确定的时候才去参加视觉评审，没有办法判断需求背后的业务逻辑跟业务大节奏是否匹配、需求本身是否能够达成业务目标、有没有更好的实现方式，只能接下需求，然后排期 维护成本高，每天还要忙于解决各种线上问题，比如这里样式有点问题，那里怎么没有显示……各种琐碎问题让你过的非常“充实” 需求响应速度较慢，比如业务的技术栈较老，或者定制逻辑过多，边写代码还要边查文档，查不到可能还要查源码，效率大幅降低。又或者跟别的业务技术体系不同，难以复用和沉淀，如果要用，可能还要重写一遍…… 1.2 业务前端是“资源”前端岗位的特点就是有视觉稿就可以完成工作，不需要理解业务全貌，所以在繁忙期很容易让前端忽视了业务思考，加上之前描述的各种原因，业务前端经常沦落为“资源”，当你沦落为“资源”的时候，其实就已经失去了和业务平等对话的资格，他们只会把你当成莫得感情的开发机器，跟你输入需求，让你吐出页面，而你在这样的关系中，本来写着还算工整的代码，为了快速实现业务需求，也开始写起乱糟糟的代码，对于你所创造的产品也没有话语权，久而久之也失去了激情和耐心。 失去激情，写的不开心也就算了，因为你没有做出什么特别的东西，老板也不会特别认可你的辛苦，还会觉得你思考不够、没有业务 sence，对业务没有助力，没有让业务因为你的存在而有所不同…… 1.3 业务前端想突破好吧，那我决定做点什么改变一下，于是跟老板提出了一系列想法： 这里技术体系太老了，为了进一步提升开发效率，我们想要搞技术重构 前后端联调有点费劲，我们想搞个联调数据中台，提升联调效率 那里展现速度太慢了，我们要搞性能优化 …… 老板往往会来一系列灵魂提问： 为什么要做？（有什么业务价值？有什么技术价值？） 为什么是现在做？ 为什么是你做？ ROI（投入产出比）怎么样？ 还没有开始，躁动的心就被老板的一系列“质疑”浇了一盆冷水。 如果没有回答好这些问题、说服老板，自然也争取不到什么资源，只能一个人搞搞，一个人搞的往往质量不行、也没有人用，久而久之自己也不维护了，只能又开始埋头在需求中。 干的不开心，也没有成长，最后只能暗淡离职，但换了一个公司就会好吗，很可能又是类似的过程…… 这真的堪称是业务前端的“困境”，那么如何突破这种困境呢？首先我们就要摆正心态，从了解业务开始。 2. 了解业务2.1 业务和需求在了解业务之前，首先我们要知道，业务跟需求是不一样的。理解需求并不等于理解业务，需求是业务经过产品消化后的产物，可能已经经过演绎或者拆解，因此需求并不是业务本身，当然了解的需求越多，对业务的全貌也会更加了解。 那么什么是业务呢？业界对”业务”有多种定义，但是其主要思想基本不变，业务就是一系列人通过一系列活动完成某一任务的过程，因此，业务可大可小，可以无限拆分。 我们本文涉及的业务泛指商业业务，就是与该 BU 或者公司商业模式直接关联的业务或其组成部分。 2.2 前端为什么要学习业务前端即使不学习业务，其实也不影响做需求，毕竟你只要告诉我交互是什么样的，前端就可以帮你实现，而且已经有产品经理的角色了，大家各司其职不就好了，为什么一个做技术的，要狗拿耗子、或者是越俎代庖呢？这就要说到： 只有了解业务，才能从技术的角度想到业务方不曾想到的地方；不了解业务，你可能听不懂业务方要什么，甚至连需求的业务逻辑都搞不清，这种情况的合作模式只有一种，需求下来了，你接住，然后给排期。也许，这个需求的设计不合理，你不知道；这个需求有更好的实现方案，你不知道；这个需求可以通过现成的关联产品方案解决，省时省人力，你也不知道。 只有了解到业务背后的原因，才能从全局的视角去规划技术的未来。不了解业务，会让你离用户的真实需求很远，你越难发现其中的一些痛点和挑战，没法真正提出你的思考和解决方案，去解决用户的难题。 作为一名产品研发工程师，自然是希望亲手打磨一款解决用户问题、体验友好的产品，如果产品能得到用户认可，产生影响力、自然会特别有成就感。 阿里作为一家商业科技公司，对技术人的要求就是技术与业务相结合，在满足业务需求的基础上，成为技术与业务的桥梁，主动走进业务，思考如何通过技术手段帮助业务做赢、满足市场和用户需求，先一步技术规划、人才储备、技术架构和技术预研。 2.3 你了解业务吗那么目前你了解你对接的业务吗？不妨尝试回答下以下问题： 业务做的是什么？产品大图有吗？ 业务的核心指标是什么？KPI目标是什么，这些数字背后的含义是什么？要达成这些目标，业务策略是什么？ 业务的用户是谁？流量怎么分层？占比多少？分别在业务中是怎样的定位？ 业务的商业模式？靠什么吸引流量，盈利模式是怎样的？ 我们做的页面是什么东西？为业务带来什么价值？要创造更多的价值，我们可以做什么？ 2.4 如何学习业务2.4.1 业务领域知识的阅读找到该领域相关的评分较好的书籍集中阅读，快速形成知识框架。 2.4.2 了解业务背景和规划刚刚接手新的业务，可以邀请业务方老板或者资深的运营/产品同学，给你讲讲这块业务的过去、现在、未来、愿景、财年规划，以及对技术同学的期望； 花时间读合作方（运营、产品、研发）的周报，了解现在在发生什么，是不是离目标越来越近了； 了解业务目标、落地策略、衡量目标的数据口径，关注数据，关注目前做的项目是否为了达成目标而战，如果不是，提出你的想法和建议； 多参会，建立产品 sense。收集信息最好的方式就是参加所处业务老大的 KO 会，各种 KO 会会把战略上的拆解和背后的思考整体梳理之后宣讲传达给 BU 或部门的同学， 2.4.3 多交流与服务端同学聊天，与 PM 聊天，与用户聊天，多角度看业务，但要注意的是，针对专业型比较强的业务，需要先做功课，至少一些英文的缩写要清楚的明白意思。 2.4.4 谨记数字如果前面还需要花比较长的时间，那这一个可以现在就做起来，那就是把业务相关的数字记得越精细约好，越具体越好，越全面越多越好。这样做有两个好处： 所记的数字指标本身，很大程度已经涵盖了这个业务价值方向，你便知道了这个业务重点关注的是哪个维度的东西 这些数字可以作为和业务方以及产品“平等对话”的源头，否则连最基本的对话基础都没有 2.4.5 从日常需求入手对于项目中的需求，我们要尝试分析背后的目的和价值，做了之后有什么预期的收益，为什么这么做就可以达到这个收益，跟总体目标是否契合，还要判断业务方提到的点是不是有效的方案或者说成本太大的方案，看能不能给出替代方案，用现有的方案或者小成本的方式来满足业务方。而在项目提测上线后，还要仔细分析以及多关注上线之后的业务数据和效果，会有如下好处： 提高自己对业务的理解能力，你在关注业务数据的同时，也就会更多的从业务的角度来看到这个功能所带来的价值是否符合预期，当出现不符合预期的时候，可以和业务方一起进行数据漏斗的分析从而找到问题所在，避免我们的劳动成果成为一次性的工作。 总结的同时可以帮助自己梳理这个项目中自己哪些地方做的不足，或者相关推进中存在什么问题，以及后面怎么改进，提高了下次项目中的迭代效率和质量。比如这个项目是否存在需求理解不到位存在返工，或者沟通 &amp; 联调低效，环境不稳定，自己设计的方案是否合理等问题，后续要怎么解决。 也可以从数据和总结中判断出什么样的需求是靠谱的 &amp; 什么的样业务方是靠谱的，频繁争取资源上线效果又不好的业务方，下次再有需求过来则需要多增加一个心眼和思考的过程。 2.4.6 坚持业务思考力，没有个至少半年是不会见效的 3. 助力业务3.1 思考尽管平时的业务很忙，但再忙，也要抽时间思考，那么思考哪些内容呢？以下举一些例子： 养成每天记工作内容的习惯，分析一下自己的时间到底耗在哪了 在业务开发中，有遇到让你特别想吐槽的点吗？想下问题背后的原因，有什么方法可以避免下次不犯，能不能提炼为更加通用的解决方案，其他同学怎么解决的，我可以怎么解决？ 不断地输入、观察，业务的真实需求是什么？站在业务方的角度思考，业务遇到的痛点、挑战在哪里？ 3.2 沟通和老板、团队同学、业务方对焦，确认“我想做的”是不是“大家想要的”？你可能会提出很多意见，但一般会遭到老板或者业务方无情的拒绝，而且问得你一脸懵逼，就比如： 当前业务背景下，为什么要做？（有什么业务价值？有什么技术价值？） 现在必须做么？ 为什么是你做？ 怎么做？（体系化、全链路、单点技术挑战） 有什么业务和技术结果？能否被复用？ 未来规划（能否跟BU或集团的方案联动、共建） 而这往往是因为你提出要做的事情，有价值但不是必须做的，没有结合目前业务需要什么。也就是说，你想做的技术是个人和纯技术角度思考的，没有基于业务的现状和痛点去考虑技术方案，不接地气，投入产出比不高。所以给技术产出先找好业务的阵地，看看有没有可以借力的地方，不要重复造轮子。快速验证这个方向的正确性后，再逐渐多加投入、丰满技术设计。不要自己YY、默默地做完，这样做出来的东西没有业务场景埋单。 3.3 技术规划业务赋能其实是需要我们紧贴业务规划，制定技术规划和方案。在了解业务方今年的 KPI 重点是什么，预计的拆解和实现路径是什么后，再结合自己的和团队情况，想想自己能做哪些事情来帮助业务实现其 KPI，这里有两点需要注意下： 抓住本质从点及面，通盘考虑: 很多时候，我们收到的痛点和业务需求都是单点的，这时我们不能着眼于眼前的单点问题，而需要通盘来考虑，比如SEO的页面对性能非常敏感，经常可能会收到一些业务方来反馈，说目前我们的SEO有这个地方，那个地方需要优化下，而单点解决这些问题可能对业务带来的收益并不大，对自己的技能也没有什么成长。这时候如果通盘考虑这个命题，其实会发现做SEO页面的优化，其实目的是为了提升SEO页面的收录和排名。而提升SEO页面的收录和排名其实不仅有前端性能优化这一个路径，而是还有一些其他的路径：比如优化关键词&amp;长尾词，采用Google的AMP技术改造SEO页面，优化爬虫爬取页面的耗时提升爬取率等等。这样就能吧点的问题转化为面的问题，才能制定更有效和全面的抓手来赋能业务。 既要解决眼前痛点，也要长远谋划: 很多时候我们不能仅满足于眼前的KPI，还需要了解业务方长远的想法和可以预见的规划。就比如试点的新业务，一层规划是保证业务项目的按时上线，考虑到未来，另一层规划可能就是如何做到技术方案的可以复制性。 3.4 站在巨人的肩膀上当你需要制定一个产品化的方案或者工具和框架的时候，最好先放眼集团内部和行业进行一番调研，看看业界和其他同事是怎么解决这个问题的。尽量站在别人的肩膀上做出创新或者参与共建，避免小团队内造出重复和质量低的轮子 4. 技术深度4.1 技术知识与技术能力“技术”不能是一个笼统的词汇，我想它至少可以分为“技术知识”和“技术能力”两大部分。什么是“技术知识”？知识就是 I KNOW 《TypeScript 从入门到放弃》 《React 从入门到放弃》 《Webpack 从入门到放弃》 …… 什么是“技术能力”？能力就是 I CAN 我用 TypeScript 重构了一个大型系统，代码健壮性及研发效率大幅提升。 我用 React Hooks 给全栈同学进行前端培训，培训效果大幅提升。 我深入研究了 Webpack，优化配置，使得系统构建速度大幅提升。….. 4.2 培养技术视野 关注日常业界新技术。不一定要深入了解，但对新技术保持好奇心，大概了解它是做什么的，如果在工作中遇到匹配的落地环境，可以考虑写个 demo 看看是不是有价值 关注集团和业界的解决方案。在业务中发现问题，做解决方案的时候，我们很容易陷入自己的设计中，一脑子地想把所有东西都自己做出来，但投入会非常大，产出的价值是否一样大呢？不知道。大部分情况下，你想做的，在ATA能搜到，前人踩的坑，或者已有的成熟的解决方案，只要你去沟通去接触，就可以轻松地接进来，为什么要花大量的时间去造轮子呢？可以借力的地方，就去借力吧，把时间剩下来，做你的解决方案中更核心更有价值的事情。 4.3 技术深度一聊到“技术深度”，可能很自然地会认为是在某项技术上挖得很深，或者解决了一个业界公认难度很高的技术难题，但这只是“技术深度”的其中一部分： 体系化 / 系统化体系化思维是认识事物的一种方式，在面对问题的时候，能够针对复杂的问题，列出关键的要素和解决方法，将散乱无序的问题，变得逻辑清晰，有章可循。在问题的定位和解决的体现，从表象到本质，拆解出造成问题背后的原因，针对性地去解决本质的原因，而非治标不治本，有解决方案有节奏地解决。 全链路除了前端的部分，向前向后的技术栈，还能挖多深。 单点技术挑战在某个技术挑战上，你的思考和解决方案是怎样的。 4.4 技术与业务共赢真正有突破性的、带来重大价值的业务成果必然伴随着技术上的深入乃至创新，所以在做业务成果的时候，一定会有让我们增加技术深度的场景。 5. 给你更多体感培养业务感确实是一件非常有难度的事情，他要求你以业务而非技术为第一视角，这可能违背了很多人内心的“技术坚持”，但如果一直做技术，其实是很难有非常大的突破的，在工作中，如果能实现技术与业务共赢，将会助力你到达更高的高度。 改变的确很难，但结果值得冒险。","link":"/posts/%E4%B8%9A%E5%8A%A1-%E4%B8%9A%E5%8A%A1%E4%B8%8E%E6%8A%80%E6%9C%AF%E4%B9%8B%E4%BA%89/"},{"title":"正则","text":"[TOC]参考链接面试官！让我们聊聊正则 正则表达式 - 元字符!!!一直以来正则都靠搜索，复制粘贴。今天开始学习，以后就可以自己写啦~~~ 正则表达式是什么正则表达式(Regular Expression)是一个描述字符模式的对象，使用正则表达式可以进行强大的模式匹配和文本检索与替换功能。在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 正则表达式是处理字符串的利器，并提高工作效率，一个好的正则能够帮我们省去几十甚至上百行代码。 入门学习正则表达式最好方法是从例子开始，理解例子之后再对例子进行修改，实验。 常用正则表达式 姓名 2-9位中文昵称： ^[\\u4e00-\\u9fa5]{2,9}$ 验证密码 只能是数字、字母、下划线，长度不限制: ^\\w+$ 允许 小写字母 a-z、大写字母 A-Z、数字 0-9、下划线 _、 连接符 -，且长度在 6-18 位数：/^[a-zA-Z0-9_-]{6,18}$/ 必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 验证 Email 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-+.] + @ + 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-.] + . + 允许有一个字符符合 [A-Za-z0-9_] 之后可以有 [A-Za-z0-9_-.] 的邮箱：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ 验证身份证 18 位身份证号，尾数是数字或者字母 X：^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$ 15 或者 18 位身份证号，尾数可以是数字及 X 或者 x：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 验证手机号 以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：^1[3,4,5,7,8,9]\\d{9}$ 移动号码：^134[0-8]\\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\\d{7,8}$ 电信号码：^(?:133|153|1700|1701|1702|177|173|18[019])\\d{7,8}$ 联通号码：^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])\\d{7,8}|$ JavaScript 创建正则表达式两种方式： 用/正则表达式/两个斜杠来包裹要写的正则表达式 构造函数创建(不推荐)var reg = new RegExp('\\\\d+', 'img')第一个参数是元字符并且\\d这种特殊字符在这里面是普通字符，所以需要用\\转义为特殊字符，第二个参数是修饰符 这两种的用途有区别，一般需要动态创建正则元字符采用构造函数创建，因为里面元字符是字符串拼接，常规固定写死正则采用字面量创建，例子如下： var reg = /^[a-z0-9_-]{6,12}$/ 这就是一条规则。 如何匹配一个字符串。这里用test方法 1234var str = 'abc-cba_abc';var reg = /^[a-z0-9_-]{6,12}$/;console.log(reg.test(str)); // true reg 通过 test() 方法去测试 str 是否符合 reg的规则，如果符合则返回 true，如果不符合则返回 false。这里返回的是 true，因为我们的 str 是符合 reg 规则的。 基础要想玩转正则首先要明白三大元素：修饰符 元字符 量词例：var reg = /^\\d$/g 这是一个简单点正则，下面我们来对三大元素一探究竟 1. 修饰符 g - global 全局匹配（只要有匹配成功的结果一直匹配直到没有为止） i - ignoreCase 忽略大小写 m - multiline 多行匹配 2. 元字符元字符分为特殊元字符和普通元字符普通元字符就是列入数组，字母等元素常用特殊元字符如下： \\ 转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义的字符转变为普通字符） . 除了\\n（换行符）以外的任意字符 \\d 匹配一个0~9之间的数字 \\D 匹配一个非0~9之间的数字（大写与小写字母组合正好是相反含义 \\w 匹配一个0~9或字母或_之间的一个字符 \\s 匹配一个任意空白字符 \\b 匹配一个边界符 x|y 匹配x或者y中的一个 [a-z] 匹配a-z中的任意一个字符 [^a-z] 匹配非a-z中的任意一个字符 [x- yz] 匹配x或y或z中的一个字符 [^xyz 和上方相反 () 整的小分组，匹配一个小分组（可以理解为大正则中的一个小正则） ^ 以某一个元字符开始。例：var reg = /^2/; 表示开头必须是2，如果开始元字符放在[]里面 例：[^]表示非中括号种情况 相反含义 $ 以某一个元字符结束。例： var reg = /2$/; 表示结尾必须是2，如果是 var reg = /^2$/; 表示只能为2，因为2只代表一个元字符。 ?: 只匹配不捕获 ?= 正向肯定预查 ?! 正向否定预查 使用解析1. () 小分组 匹配子项匹配子项，就是小括号()，也叫分组操作。|表达式| 释义| 用法||—–|——-|——||(子表达式)|标记一个子表达式的开始和结束位置。| (\\w)\\1 能匹配 deep 中的 ee| 123456789var reg = /^18|19$/// 这个例子很多同学能够了解是18或者19开头 但是结尾呢？真的只匹配19么？ 其实并不是// 正确的匹配除了18 19 还有181、189、819 这时候小分组就起到了作用如下var reg = /^(18|19)$/// 这里将18或19用()包裹起来，起到小分组的作用// 这样这个正则只匹配18开头结尾或者19而不是181和189 var re = /(\\d+)(-)/g; 分析这个正则： /(\\d+)/ 表示任意 1 个及以上的数字 /(-)/ 表示匹配字符 - g 表示匹配一次以上 所以这段正则的意思就是匹配一次及以上的 数字- 形式的字符串。 12345678910111213var str = &quot;2018-11-28&quot;;var re = /(\\d+)(-)/g;str = str.replace(re, function($0, $1, $2){ // 第一个参数：$0（母亲) // 第二个参数：$1（第一个孩子） // 第三个参数：$2 (第二个孩子) console.log(&quot;$0：&quot; + $0); console.log(&quot;$1：&quot; + $1); console.log(&quot;$2：&quot; + $2); return $1 + '.';});console.log(str); // 2018.11.28 console结果： 1234567$0：2018-$1：2018$2：-$0：11-$1：11$2：-2018.11.28 这里使用了 replace() 方法。观察 Console 打印出来的结果，可以看出$0 即是我们的正则 var re = /(\\d+)(-)/g 去匹配 var str = “2018-11-28” 所得到的结果，这里我们匹配成功了两次，即 2018- 及 11-；$1 即是我们的一个小括号 (\\d+) 的匹配结果，所以结果为 2018 以及 11；$2 即是我们的第二个小括号 (-) 的匹配结果，所以结果为 - 以及 -。 最后，我们做的事情就是，将 $1 加上 .，并返回最终结果给 str，最终结果：2018.11.28。 另一个例子： 123var str = &quot;abc&quot;;var re = /(a)(b)(c)/;console.log(str.match(re)); console结果： 1[&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;, groups: undefined] 2. 分组引用\\n分组引用的概念就是可以引用大正则中指定的小正则规则，例如： 12var reg = /^([a-z])([a-z])\\2([a-z])$/// 符合的字符串：book week http ...​ 具体上面的例子理解为\\2代表着第二个小正则规则的完全引用，就是和第二个小正则([a-z])一样，可以减少正则的复杂度和处理多次重复规则 4. 匹配字符 [][] 这样的中括号的整体，代表一个字符。字符串包含中括号中任一字符即满足条件 12345678var reg = /^[a-zA_Z0-9_]$/// 这个正则和等价于\\w 就是匹配一个0~9或字母或_之间的一个字符// 而正则[xyz]中的xyz分别代表a-z、A_Z、0-9,xyz只是一个代表标识，// 可以有xyzhw各种组合// 就像这个例子中有下划线_一样四个的匹配// 有一个重点补充，在[]中的特殊元字符一般都代表本身含义，如下var reg = /^[.?+&amp;]$/// 代表着匹配. .? ?+ ...等等 1234567891011var str1 = &quot;abcd&quot;;var re1 = /a[bcd]c/;console.log(re1.test(str1)); // truevar str2 = &quot;abc&quot;;var re2 = /a[^bcd]c/;console.log(re2.test(str2)); // falsevar str3 = &quot;a.c&quot;;var re3 = /a[a-z0-9A-Z]c/;console.log(re3.test(str3)); // false 解析： /a/：匹配字母 a /[bcd]/：匹配字母 bcd 中的一位 /[d]：匹配字母 d ^ 如果写在 [] 里面的话，就代表排除的意思。在这里就代表着 a 和 c 中间不能是 bcd 中的任意一个 /[a-z0-9A-Z]/：匹配小写字母 a-z，或者数字 0-9，或者大写字母 A-Z。即 a 与 c 之间只能是上面匹配地上的字符。 5. 边界符\\b匹配一个单词边界，也就是指单词和空格间的位置（边界主要是单词的左右两边） 例如： 12345var reg = /er\\b/// 可以匹配never中的er，但是不能匹配verb中的ervar reg = /\\b\\w+\\b/g// 能匹配字母数字和下划线与单词边界 'my blog is www.ngaiwe.com'// 能匹配 'my'、'blog'、'is'、'www'、'ngaiwe'、'com' 6. 只匹配不捕获 ?下面举一个例子，但是涉及到捕获内容，如果同学们不太明白，可以先跳过此处，看完下面捕获，再返回来看 123456789var reg = /^(\\d{6})(\\d{4})(\\d{2})(\\d{2})\\d{2}(\\d)(\\d|X)$/gvar str = '110105199001220613'console.log(reg.exec(str))// 打印结果为 &quot;110105199001220613&quot;, &quot;110105&quot;, &quot;1990&quot;, &quot;01&quot;, &quot;22&quot;, &quot;1&quot;, &quot;3&quot;var reg = /^(\\d{6})(?:\\d{4})(\\d{2})(\\d{2})\\d{2}(\\d)(\\d|X)$/g// 打印结果为 &quot;110105199001220613&quot;, &quot;110105&quot;, &quot;01&quot;, &quot;22&quot;, &quot;1&quot;, &quot;3&quot;// 会将第二个小分组只匹配，不捕获 7. 正向肯定预查 ?=这个概念比较难理解，用于就是为了匹配一个元素后面是的元素是否符合相应规则，但是并不消耗这个规则，例子1： 1234567891011121314151617181920212223242526var reg = /windows(?=95|98|NT|2000)/var str1 = 'windows2000'var str2 = 'windowsxp'console.log(reg.test(str1))console.log(reg.test(str2))// str1 为true str2 为falseconsole.log(reg.exec(str1))console.log(reg.exec(str2))// 能捕获到str1 并且捕获结果时windows 并没有将2000也同时捕获// 说明正向预查只负责匹配相应规则//-------例子2-----------var reg1 = /win(?=d)dows/var reg2 = /win(d)dows/var str = 'windows'console.log(reg1.test(str))console.log(reg2.test(str))// reg1 返回true reg2返回 false// 原因是正向预查只负责匹配，不消耗字符，也就是并不会匹配为里面规则的字符// reg1 相当于匹配windows并且符合win后面第一个出现的是d// reg2 相当于匹配winddows 8. 正想否定预查 ?!和正向肯定预查相反，匹配不符合规则的正则 9. \\ 转义字符 将特殊元字符转换为普通字符，例：var reg = /^2.3$/ 正常理解为匹配启示为2 结束为3中间是.的正则，但是在这里面.属于特殊元字符，意义是除了\\n（换行符）以外的任意字符，所以不论是2.3/2+3/2s.3等等，只要是不·\\n都匹配成功，所以为了这种需求就用到了转义字符\\ 如下： var reg = /^2\\.3$/ 将特殊元字符.转义为真正的.元素，再次匹配只有2.3才能匹配成功 如下思考： 1234var reg1 = /^\\d$/var reg2 = /^\\\\d$/var reg3 = /^\\\\\\d$/var reg4 = /^\\\\\\\\d$/ 首先reg1 表示0-9之间的数字 所以0-9都能匹配成功 reg2出现两个\\ 不论是0-9 d \\d都匹配失败，只有\\d才匹配成功，原因在于第一个转义字符把第二个\\转义为普通\\，此时第一个\\也表示普通字符，所以只有匹配到\\\\d才生效 reg3出现三个\\，此时大家一定会认为\\\\\\d才是正确答案，非也，此时的正确答案是\\[0-9]意思是\\和0-9中任意一个数字，原因在于第一个\\将第二个转义，所以变为\\\\ \\d分为了两部分，\\为普通字符，而\\d表示一个0~9之间的数字，所以正确答案是\\\\[0-9] reg4出现四个\\ 很多同学会认为正确答案一定是\\[0-9], 很可惜，正确的是\\\\\\\\d，原因是当第一个把第二个转义为普通字符时，第三个又把第四个转义为普通字符，所以最后匹配为\\\\\\\\d 看到这里相信有一部分小伙伴已经晕了，虽然在工作我们不会玩这种操作，但是要深刻理解转义字符，在正则中如果你直接写 var reg = /\\/ 会报错，因为正则中不能单独一个\\出现，因为它是一个特殊元字符，需要写至少两个, 例如： var reg = /^\\\\$/正确的匹配结果为\\\\，所以牢记两个\\代表真正的\\，到这里能搞明白的同学，相信转义字符已经完全掌握。 3. 量词量词主要的作用是用来描述元字符出现的次数 如下： + 让前面的元字符出现一到多次 ? 出现零到一次 * 出现零到多次 {n} 出现n次 {n,} 出现n到多次 {n,m} 出现n到m次 常用方法JavaScript 正则默认： 正则匹配成功就会结束，不会继续匹配。如果想查找全部，就要加标识 g（全局匹配） 1. test()规则：匹配字符串，匹配成功返回true，匹配失败返回false语法：正则.test(字符串)案例： 1234567var str = &quot;123abc&quot;;var re = /\\D/; // 匹配非数字if(re.test(str)) { console.log(&quot;不全是数字！&quot;);} else { console.log(&quot;全是数字！&quot;);} 当test匹配到结尾或者匹配不到时，返回false，成功则向数组添加当前小分组匹配第一个元素内容。在RegExp的constructor中存在$1-$9，他们的具体指的是当前本次匹配小分组第一到第九捕获的内容 123456789var reg = /\\{([a-z]+)\\}/gvar str = 'my name is {weiran}. I am from {china}'var result = []while (reg.test(str)) { result.push(RegExp.$1)}console.log(result)// ['weiran', 'china'] 手动实现一个函数匹配到全部内容并且都能捕获到 这个方法当正则reg加了修饰符g 则返回大正则匹配到结果，如果没加g则返回exec捕获结果 123456789101112131415161718192021var reg = /^(\\d{6})(\\d{4})(\\d{2})(\\d{2})\\d{2}(\\d)(\\d|X)$/gvar str = '110105199001220613'RegExp.prototype.myExec = function myExec() { var str = arguments[0] || '' var result = [] // 首先this指向的是RegExp，所以判断this是否加了全局修饰符g // 如果没有，防止执行死循环，我们只执行一次exec并将其返回即可 if(!this.global) { return this.exec(str) } var arrs = this.exec(str) while(arrs) { result.push(arrs[0]) // 此时lastIndex的值已经变为上一次的结尾 arrs = this.exec(str) } return result} 2. search()规则：匹配成功，返回成功的位置，失败返回-1用法：字符串.search(正则)案例： 12345var str = &quot;abcdef&quot;;var re1 = /d/i;var re2 = /h/i;console.log(str.search(re1)); // 3console.log(str.search(re2)); // -1 3. match()规则：匹配成功，返回匹配成功的数组，匹配不成功，返回 null用法：字符串.match(正则)案例： 123var str = &quot;123fadf321dfadf4fadf1&quot;;var re = /\\d+/g;console.log(str.match(re)); //(4) [&quot;123&quot;, &quot;321&quot;, &quot;4&quot;, &quot;1&quot;] 当加了修饰符g，返回的是大正则匹配结果组成的数组，不加修饰符g则返回大正则和每个小分组返回结果组成的数组，但是他也有局限性，就想上面说的在加了修饰符g的时候，会忽略小分组捕获内容，只捕获大正则捕获内容，解决办法就向上面myExec一样，将arrs[0]改为arrs，在每次匹配到结果时，将每个小分组也保存下来。 4. replace()规则：匹配陈宫的字符串替换成新的字符串。用法：字符串.replace(正则, 新的字符串)案例： 1234var str = 'aaa';var re = /a+/g;str = str.replace(re, &quot;b&quot;);console.log(str); // b 敏感词替换 12345var s1 = '非诚勿扰在中国船的监视之下寸步难行';var re = /非诚|中国船|监视之下/g;s1.replace(re, function(str) { return '*'.repeat(str.length);}) 替换大括号里的内容 123456789var str = 'my name is {lalala}, I\\'m from {haia}'var reg = /\\{([a-z]+)\\}/str = str.replace(reg, '123')console.log(str)// 打印出 my name is 123, I'm from {ngaiwe}// 同学们会发现和exec的懒惰性很相似，不加修饰符g 只匹配第一个lastIndex没有改变var reg = /\\{([a-z]+)\\}/g// 打印出 my name is 123, I'm from 123 replace不会修改原始字符串 123456var str = 'my name is {weiran}, my blog is {ngaiwe}'var reg = /\\{([a-z]+)\\}/gstr = str.replace(reg, function () { console.log(arguments)})// 打印出当前匹配的小分组，如果函数中没有return出替换值，则返回undefined 5. split()按照正则规则拆分数组 1234var str = 'weiRanNgaiWe'var reg = /[A-Z]/console.log(str.split(reg))// [&quot;wei&quot;, &quot;an&quot;, &quot;gai&quot;, &quot;e&quot;]按照大写拆分成数组 正则原型方法RegExp.prototype正则原型对象上一共就三个方法,exec test和toString exec用于捕获组而设计，实参是要匹配的字符串12345678910111213var str = '234ewqe2r3562';var reg = /\\d+/;reg.exec(str);// [&quot;234&quot;, index: 0, input: &quot;234ewqe2r3562&quot;, groups: undefined]// 0: &quot;234&quot;// groups: undefined// index: 0// input: &quot;234ewqe2r3562&quot;// length: 1// __proto__: Array(0)str = '文字';reg.exec(str);// null 捕获原理 在捕获的时候先验证当前字符串和正则是否匹配，不匹配返回null（没有捕获到任何内容） 如果匹配从字符串最左边开始，向右查找到匹配内容，并把匹配的内容返回 捕获结果 结果是一个数组 第一项0 是当前本次大正则中匹配的结果 index是匹配到的结果在字符串中的索引位置 input当前正则操作的原始字符串 如果大正则中有分组()，获取的数组中从第二项开始都是每个小分组的捕获结果下面举一个身份证正则的例子 便于参考，具体里面匹配规则下面会单独介绍，这里只学习字段意义 12345678910111213141516var reg = /^(\\d{6})(\\d{4})(\\d{2})(\\d{2})\\d{2}(\\d)(\\d|X)$/;var str = '110010199301032345'reg.exec(str)// 执行结果：// [&quot;110010199301032345&quot;, &quot;110010&quot;, &quot;1993&quot;, &quot;01&quot;, &quot;03&quot;, &quot;4&quot;, &quot;5&quot;, index: 0, input: &quot;110010199301032345&quot;, groups: undefined]// 0: &quot;110010199301032345&quot;// 1: &quot;110010&quot;// 2: &quot;1993&quot;// 3: &quot;01&quot;// 4: &quot;03&quot;// 5: &quot;4&quot;// 6: &quot;5&quot;// groups: undefined// index: 0// input: &quot;110010199301032345&quot;// length: 7 懒惰性正则捕获存在懒惰性，在上面执行exec只捕获到第一个符合规则的内容，第二次执行也是捕获到第一个内容，后面的内容无论执行多少次都无法捕获到。 解决办法：在正则末尾加修饰符g(全局匹配) 原理正则本身有lastIndex属性, 下一次正则在字符串中匹配查找的开始索引默认值是0， 从字符串第一个位置开始查找，由此可见当执行完exec后lastIndex并没有变，并且就算手动修改lastIndex也不会起作用 12345678var str = '1w2q3e'var reg = /\\d+/console.log(reg.lastIndex)reg.exec(str)console.log(reg.lastIndex)reg.exec(str)// 0// 0 在正则表达式末尾加g后，每次执行exec后，浏览器默认会修改lastIndex。下次从上一次结束的位置开始查找 12345reg = /\\d+/gconsole.log(reg.lastIndex) // 0reg.exec(str)console.log(reg.lastIndex) // 1reg.exec(str) reg.global 可以判断正则是否是全局匹配 toString将正则表达式转化为字符串 test如上 正则解析看一个简单的正则：^[a-z0-9_-]{6,12}$ ^表示匹配字符串的开始位置 [a-z0-9_-]表示字符串的开头可以为a-z的字母, 0-9的数字, _下划线, -连接符 [a-z] 表示匹配 a-z 中任意单个字母； [0-9] 表示匹配 0-9 中任意单个数字； [_] 表示匹配下划线； [-] 表示匹配连接符 -。所以，将前面的连起来，[a-z0-9_-] 表示字符串可以包含数字、字母、_、- 这四种形式的字符串。 {6, 12} 表示该字符串的长度为 6-12 位。 $表示结束标志，^ 表示开始 ^ 与 $ 同时使用，表示精确匹配。 综上：这个正则表达式的用途校验字符串只能包含小写字母，数字，下划线，连接字符，并且最长12位，最短6位。 小栗子🌰🌰🌰1234567var str = &quot;Cheer for yourself&quot;;var reg1 = /^Cheer/;var reg2 = /yourself$/;var reg3 = /for/;console.log(reg1.test(str));console.log(reg2.test(str));console.log(reg3.test(str)); 第一个判断该字符串是否以 Cheer 开头； 第二个判断该字符串是否以 yourself 结尾； 第三个判断该字符串是否包含 for。 身份证号 前6位是数字地区区号组成，然后四位是年，两位月，两位日和四位随机，倒数第二位单数男性，双数女性， 最后一位可能是大写X,所以根据这个规则的正则是 12345var str = '110105199109214237'var reg = /^(\\d{6})(\\d{4})(\\d{2})(\\d{2})\\d{2}(\\d)(\\d|X)$/console.log(reg.exec(str))// [&quot;110105199109214237&quot;, &quot;110105&quot;, &quot;1991&quot;, &quot;09&quot;, &quot;21&quot;, &quot;3&quot;, &quot;7&quot;, index: 0, input: &quot;110105199109214237&quot;, groups: undefined] 邮箱 规则： @前面可能是数字、字母、下划线、-、. -和.不能相连在一起 /^\\w+((-|\\w+)|(.\\w+))*/ 开头一定是数字，字母或下划线组成，后面的内容可能是-与数字字母下划线 或者.和数字字母下划线组成的0到多个字符 @后面部分首先一定是数字字母组成的多位字符然后可能存在是.组成的邮箱后缀或者链接前方字符的.和-最后肯定是.组成的邮箱后缀 12345var reg = /^\\w+((-|\\w+)|(\\.\\w+))*@[a-zA-Z0-9]+((\\.|-)[a-zA-Z0-9]+)*\\.[a-zA-Z0-9]+$/var str = 'aaa@hotmail.com.cn'console.log(reg.test(str))// true URL截取 获取url后的搜索参数 参数转化键值对和哈希值{key: ‘value’} 需要分为两部分捕获，首先第一次捕获?后面的参数，第二次捕获#后面的hash值首先匹配第一个，他的规则是匹配等号两边所以是/()=()/，并且匹配的是非?&amp;=#的特殊字符，将他们保存在obj对象中其次匹配hash，方法和第一个类似只是匹配#后面的部分 1234567891011String.prototype.myQueryURLParameter = function myQueryURLParameter () { var obj = {} this.replace(/([^?&amp;=#]+)=([^?&amp;=#]+)/g, function () { obj[arguments[1]] = arguments[2] }) this.replace(/#([^?&amp;=#]+)/g, function () { obj['HASH'] = arguments[1] }) return obj} 编写验证规则最流行和最简单的方法就是正则表达式了，但唯一的一个问题是正则表达式的语法太隐晦了，让人蛋疼无比。很多开发者为了在项目中应用复杂的验证，经常要使用一些小抄来记住正则式的复杂语法和各种常用命令。 在这篇文章中，我将试图让大家明白什么是正则表达式，以及如何更轻松地学习正则表达式。 也许你是初学者，那以防万一，我先来讲讲什么是正则表达式吧： 正则表达式可以帮助我们更好的描述复杂的文本格式。一旦你描述清楚了这些格式，那你就可以利用它们对文本数据进行检索、替换、提取和修改操作。 下面有一个正则表达式的简单例子。第一步先要引入有关正则式的命名空间：using System.Text.RegularExpressions;第二步就是用指定的正则式构建一个正则表达式对象,下面的正则式是用来搜索长度为10的a-z的英文字母：Regex obj = new Regex(“[a-z]{10}”);最后，根据正则式在指定数据中检索匹配项,如果匹配IsMatch方法就会返回true。MessageBox.Show(obj.IsMatch(“shivkoirala”).ToString());3个重要的正则式命令 记住正则语法最好的办法就是记住这三样东西：Bracket（括号）, caret（插入符号）和Dollars（美元符号）。 B 在正则表达式中有3种类型的括号 方括号 “[“和花括号“{“ 。 方括号”[“内是需要匹配的字符，花括号”{“内是指定匹配字符的数量。 圆括号“(“ 则是用来分组的。 C插入符号 “^” 表示正则式的开始。 D美元符号“$” 表示正则式的结束。现在你知道上面的3个语法后，你就可以写世界上任何一条验证规则了。比如下面的例子就很好的说明了上面3条正则语法是如何协调运作的。 注：上图有个错误，”()”应为”{}” 上面的这条正则式只能匹配a-z的英文字母，同样是在中括号中标明匹配范围。 花括号中则是标明匹配字符串的最小长度和最大长度。 最后为了让表达式更规则，分别在开头和结尾加上了插入符号”^”和美元符号”$”。 好了，现在我们就用上面的3条语法来实现一些正则表达式的验证规则吧。 检查用户是否输入了shivkoirala？shivkoirala让我们开始第一个验证，输入的字符在a-g之间？[a-g]输入的字符在a-g之间并且长度为3？[a-g]{3}输入的字符在a-g之间并且最大长度为3最小长度为1？[a-g]{1,3}我如何在匹配像91230456, 01237648那样的固定8位数？^[0-9]{8}$如何验证最小长度为3最大长度为7的数字，如：123, 1274667, 87654？^[0-9]{3,7}$如何验证像LJI1020那样的发票编号，前3个是字母剩余为8位长度的数字？ 前三个是字母：^[a-z]{3}后面是8位长度的数字：[0-9]{8}所以整个表达式为：^[a-z]{3}[0-9]{7}$验证像INV190203 或 inv820830那样的前3位是不区分大小写的英文字母，剩余8位是数字。 在前面的表达式中只能匹配前3个是小写英文字母的发票编号，如果我们输入大写字母那就不能匹配了。所以为了确保前3个字母是不区分大小写的，我们就要用表达式^[a-zA-Z]{3}。^[a-zA-Z]{3}[0-9]{7}$我们可以验证简单的网址URL格式吗？ 第一步：检查是否存在www：^www.第二步：域名必须是长度在1-15的英文字母：. [a-z]{1,15}第三步：以.com或者.org结束：. (com|org)$完整的表达式如下：^www[.][a-z]{1,15}.$让我们在来看看BCD（其实也就是上面说的3条基本语法）如何验证email格式。 第一步：email开始是长度在1-10的英文字母，最后跟一个”@”：^[a-zA-Z0-9]{1,10}@第二步：@后面是长度在1-10的英文字母，后面跟一个”.”：[a-zA-Z]{1,10}.第三步：最后以.com或.org结束：.(com|org)$最后完整的表达式如下：^[a-zA-Z0-9]{1,10}@[a-zA-Z]{1,10}.(com|org)$验证值在0-25的数字：^(([0-9])|([0-1][0-9])|([0-2][0-5]))$验证格式为MM/DD/YYYY, YYYY/MM/DD and DD/MM/YYYY的日期：步骤 正则式 描述说明 先来检查 DD. 首先DD的长度为1-29 ( 2月份) , 1-30 (月小) , 1-31 (月大) . 所以 DD 就是 1-9 或 01-09 [1-9]|0[1-9] 允许用户输入1-9或者01-09. 再为DD添加匹配10-19 [1-9]|1[0-9] 允许用户输入01-19. 再为DD添加匹配20-29 [1-9]|1[0-9]|2[0-9] 允许用户输入01-29. i再为DD添加匹配30-31 [1-9]|1[0-9]|2[0-9]|3[0-1] 最后用户可以输入01-31. 再来匹配日期间的分隔符”/“，”-“ [/ . -] 允许用户输入日期分隔符. MM也是类似的操作 [1-9]|0[1-9]|1[0-2] 让用户输入月份值01-12. 最后就是YY的操作 1[9][0-9][0-9]|2[0][0-9][0-9] 允许用户输入年份1900-2099.最后DD/MM/YYYY格式的日期的正则表达式为：^([1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])- / .- / .$MM/DD/YYYY格式的日期：^([1-9]|0[1-9]|1[0-2])- / .- / .$YYYY/MM/DD格式的日期：^(1[9][0-9][0-9]|2[0][0-9][0-9])- / .- / .$快捷命令 你也可以用以下的快捷命令来简化你的正则表达式：实际命令快捷命令 [0-9]d [a-z][0-9][_]w 0次或多次发生* 至少一次发生+ 0次或1次发生?","link":"/posts/%E6%AD%A3%E5%88%99/"},{"title":"HTTP积累","text":"[TOC] http 方法，每个方法分别什么情况下用put和get有什么相同点链接 trace是用来干嘛的， options是用来干嘛的 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 HTTP2 与 HTTP1.1 区别 http2 使用二进制传送，http1.x 使用文本(字符串)传送 二进制传送单位是帧和流，帧组成了流，同时流还有流 ID 标识 http2 支持多路复用 有流 ID，通过同一个 HTTP 请求实现多个 http 请求传输变成了可能，可以通过流 ID 来标示究竟是哪个流从而定位到是哪个 http 请求 http2 头部压缩 http2 通过 gzip 和 compress 压缩头部再发送，同时客户端和服务端同时维护一张头信息表，所有字段都记录在这张表中，以后每次传输只需要传输表里面的索引 id，通过索引 id 可以知道表头的值 http2 支持服务器推送 支持在客户端未经请求许可的情况下，主动向客户端推送内容 http 方法，每个方法分别什么情况下用put 和 get 有什么相同点链接 trace 是用来干嘛的， options 是用来干嘛的 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 GET：获取资源 POST:传输实体主体 PUT:传输文件 HEAD:获取报文首部 DELETE：删除文件 OPTIONS：查询支持方法 TRACK：追踪路径 CONNECT：要求用隧道协议连接代理 ajax 状态值123450 代表未初始化。 还没有调用 open 方法1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用2 代表已加载完毕。send 已被调用。请求已经开始3 代表交互中。服务器正在发送响应4 代表完成。响应发送完毕 7 层模型7 应用层6 表示层 定义数据格式及加密示例：加密，ASII 5 会话层定义了如何开始、控制和结束一个会话，包括对多个双向小时的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的， 示例：RPC，SQL 等。 4 传输层功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。 示例：TCP，UDP，SPX。 3 网络层为建立网络连接和为上层提供服务, 示例：IP,IPX 2 数据链路层为网络层提供数据传送服务的。示例：ATM，FDDI等。 1 物理层连接头、针、针的使用、电流、电流、编码及光调制等都属于各种物理层规范中的内容。 OSI 分层的优点（1）人们可以很容易的讨论和学习协议的规范细节。 （2）层间的标准接口方便了工程模块化。 （3）创建了一个更好的互连环境。 （4）降低了复杂度，使程序更容易修改，产品开发的速度更快。 （5）每层利用紧邻的下层服务，更容易记住个层的功能。 get 和 post 区别最直观的区别1).GET 把参数包含在 URL 中，POST 通过 request body 传递参数; 2).GET 在浏览器回退时是无害的，而 POST 会再次提交请求; 3).GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以; 4).GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置; 5). GET 请求只能进行 url 编码，而 POST 支持多种编码方式; 6).GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留; 7).GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制; 8). 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制; 9).GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息; 本质区别首先 GET 和 POST 请求都是 HTTP 协议中的两种发送请求的方法,而 HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议,HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。 1).虽然理论上 GET 和 POST 请求在使用上可以没有区别,但是不同的浏览器(发起 http 请求)和服务器(接受 http 请求)会限制单次传送数据了来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制 url 长度在 2K 个字节，而(大多数)服务器最多处理 64K 大小的 url。超过的部分，恕不处理。如果你用 GET 服务，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然 GET 可以带 request body，也不能保证一定能被接收到. 2).GET 产生一个 TCP 数据包;POST 产生两个 TCP 数据包;对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200(返回数据);而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok(返回数据)。因为 ==POST 需要两步，时间上消耗的要多一点，看起来 GET 比 POST 更有效。== 因此 Yahoo 团队有推荐用 GET 替换 POST 来优化网站性能。 HTTPS 和 HTTP 的区别 https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 浏览器缓存协商缓存Last-Modify/If-Modify-Since ETag/If-None-Match 强缓存Expires 或者 Cache-Control 因为 http1.1&gt;http1.0， 所以 Cache-Control&gt;Expires，ETag&gt;Last-Modified。 依照就近原则，先找本地缓存，没有再向服务器发请求， 所以 Expires&gt;Last-Modified,Cache-Control&gt;ETag， 缓存类型 获取资源形式 状态码 发送请求到服务器 强缓存 从缓存取 200（from cache） 否，直接从缓存取 协商缓存 从缓存取 304（Not Modified） 否，通过服务器来告知缓存是否可用 200 from memory cache 不访问服务器，直接读缓存，==从内存中读取缓存==。此时的数据时缓存到内存中的，当 kill 进程后，也就是浏览器关闭以后，数据将不存在。但是这种方式只能缓存派生资源 200 from disk cache 不访问服务器，直接读缓存，==从磁盘中读取缓存==，当 kill 进程时，数据还是存在。这种方式也只能缓存派生资源 304 Not Modified 访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。 三级缓存原理先去内存看，如果有，直接加载 如果内存没有，择取硬盘获取，如果有直接加载 如果硬盘也没有，那么就进行网络请求 加载到的资源缓存到硬盘和内存 application cache 和上面缓存有点区别，是离线缓存，就是资源可以从硬盘上读取而不用联网，即使断网，用户也可以浏览。 解决缓存文件没有及时更新思路用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。 Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。 Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高 Cache-ControlCache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。 must-revalidate: 一旦缓存过期，必须向源服务器进行校验，不得使用过期内容。如果无法连接必须返回 504。没有值 proxy-revalidate与 must-revalidate 相同，但仅对公共缓存生效。没有值 max-stale如果有值，客户端可以接受过期时间不超过指定值的缓存如果没有值，客户端愿意接受过期缓存而无论过期过久。 min-fresh客户端愿意接受一个新鲜度不小于当前 age 加上指定时间的响应。简单说在指定的后续一段时间内不会过期的响应。总是有值 public 指示响应数据可以被任何客户端缓存 private 指示响应数据可以被非共享缓存所缓存。这表明响应的数据可以被发送请求的浏览器缓存，而不能被中介所缓存 no-cache 指示响应数据不能被任何接受响应的客户端所缓存 no-store 指示所传送的响应数据除了不能被缓存，也不能存入磁盘。一般用于敏感数据，以免数据被复制。 must-revalidate 指示所有的缓存都必须重新验证，在这个过程中，浏览器会发送一个 If-Modified-Since 头。如果服务器程序验证得出当前的响应数据为最新的数 据，那么服务器应当返回一个 304 Not Modified 响应给客户端，否则响应数据将再次被发送到客户端。 proxy-revalidate 与 must-revalidate 相似，不同的是用来指示共享缓存。 max-age 数据经过 max-age 设置的秒数后就会失效，相当于 HTTP/1.0 中的 Expires 头。如果在一次响应中同时设置了 max-age 和 Expires，那么 max-age 将具有较高的优先级。 s-maxage 与 max-age 相似，不同的是用来指示共享缓存。 三次握手主机 A 向主机 B 发出连接请求数据包： “我想给你发数据，可以吗？”，这是第一次对话； 主机 B 向主机 A 发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机 A 再发出一个数据包确认主机 B 的要求同步： “我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机 A 才向主机 B 正式发送数据。 首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。 四次握手Client 端发起中断连接请求，也就是发送 FIN 报文。 意思是说”我 Client 端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。 所以服务端先发送 ACK，告诉 Client 端: “你的请求我收到了，但是我还没准备好，请继续你等我的消息”。 这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。 当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，告诉 Client 端: “好了，我这边数据发完了，准备好关闭连接了”。 Client 端收到 FIN 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。 Server 端收到 ACK 后，”就知道可以断开连接了”。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！ 长连接，短链接，长轮询，websocket 长连接在 HTTP 1.1，客户端发出请求，服务端接收请求，双方建立连接，在服务端没有返回之前保持连接，当客户端再发送请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。 优势：省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。 劣势：可能会影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间随着客户端连接越来越多，server 会保持过多连接 server 端采取策略： 关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致 server 端服务受损 如果条件允许则可以限制每个客户端的最大长连接数，避免恶意的客户端拖垮整体后端服务 短连接在 HTTP1.0 中，客户端发送请求，服务器接收请求，双方建立连接，服务器响应资源，请求结束。劣势： 请求频繁，在 TCP 的建立和关闭操作上浪费较多时间和带宽。 长轮询客户端像传统轮询一样从服务器请求数据。然而，如果服务器没有可以立即返回给客户端的数据，则不会立刻返回一个空结果，而是保持这个请求等待数据到来（或者恰当的超时），之后将数据作为结果返回给客户端。 WebSocket是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助 HTTP 请求完成。 客户端发送一次 http websocket 请求，服务器响应请求，双方建立持久连接，并进行双向数据传输，后面不进行 HTTP 连接，而是使用 TCP 连接。 是独立的、创建在 TCP 上的协议。通过 HTTP/1.1 协议的 101 状态码进行握手。使用 ws 或 wss 的统一资源标志符，类似于 HTTPS，其中 wss 表示在 TLS 之上的 Websocket。ws://example.com/wsapiwss://secure.example.com/ 使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket 协议使用 80 端口；运行在 TLS 之上时，默认使用 443 端口。数据格式比较轻量，性能开销较小，通信高效可以发送文本和二进制数据。没有同源限制，可以任意服务器通信 websocket 协议解析wensocket 协议包含两部分:一部分是“握手”，一部分是“数据传输”。 优势：较少的控制开销。更强的实时性。保持连接状态。更好的二进制支持。可以支持扩展。更好的压缩效果。 数据传输试用的是一系列数据帧， 基本的数据帧为一个opcode、一个payload长度和发送的应用数据， 根据ABNF的定义， Websocket 协议解决了服务器与客户端全双工通信的问题。 注:什么是单工、半双工、全工通信？信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。 - HTTP/1.0 中默认使用短连接。 从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。 使用长连接的 HTTP 协议，会在响应头加入这行代码： ==Connection:keep-alive== Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。 1234567891011121314151617客户端请求GET / HTTP/1.1Upgrade: websocketConnection: UpgradeHost: example.comOrigin: http://example.comSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==Sec-WebSocket-Version: 13服务器回应HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Location: ws://example.com/ WebSocket 与 HTTP 的关系相同点 都是一样基于 TCP 的，都是可靠性传输协议。 都是应用层协议。 不同点 WebSocket 是双向通信协议，模拟 Socket 协议，可以双向发送或接受信息。HTTP 是单向的。 WebSocket 是需要握手进行建立连接的。 联系WebSocket 在建立握手时，数据是通过 HTTP 传输的。但是建立之后，在真正传输时候是不需要 HTTP 协议的。 WebSocket 与 Socket 的关系Socket 其实并不是一个协议，而是为了方便使用 TCP 或 UDP 而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。 Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。 当两台主机通信时，必须通过 Socket 连接，Socket 则利用 TCP/IP 协议建立 TCP 连接。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。 WebSocket 则是一个典型的应用层协议。 区别Socket 是传输控制层协议，WebSocket 是应用层协议。 缓存一、资源内容不变 + 设置长时间 max-age// 设置缓存时间为 1 年Cache-Control: max-age=31536000 二、对于经常修改的内容，始终需要进行服务器认证Cache-Control: no-cache Cache-Control 比 Expires 可以控制的多一些，而且 Cache-Control 会重写 Expires 的规则，Cache-Control 是关于浏览器缓存的最重要的设置，因为它覆盖其他设置，比如 Expires 和 Last-Modified Mainfest 可以缓存一个应用，pwa 中有 Mainfest 和 Service Worker 可以实现缓存 HTTP request 报文结构是怎样的123456789101112131415161718192021222324252627282930313233343536373839rfc2616中进行了定义：首行是Request-Line包括： 请求方法，请求URI，协议版本，CRLF首行之后是若干行请求头，包括 general-header， request-header或者 entity-header， 每个一行以CRLF结束请求头和消息实体之间有一个CRLF分隔根据实际请求需要可能包含一个消息实体User-Agent：产生请求的浏览器类型。Accept：客户端可识别的内容类型列表。Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。一个请求报文例子如下：GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1Host: www.w3.orgConnection: keep-aliveCache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36Referer: https://www.google.com.hk/Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: authorstyle=yesIf-None-Match: &quot;2cc8-3e3073913b100&quot;If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMTname=qiu&amp;age=25 HTTP response 报文结构是怎样的123456789101112131415161718192021222324252627rfc2616中进行了定义：首行是状态行包括： HTTP版本，状态码， 状态描述，后面跟一个CRLF首行之后是若干行响应头，包括： 通用头部，响应头部，实体头部响应头部和响应实体之间用一个CRLF空行分隔最后是一个可能的消息实体响应报文例子如下：HTTP/1.1 200 OKDate: Tue, 08 Jul 2014 05:28:43 GMTServer: Apache/2Last-Modified: Wed, 01 Sep 2004 13:24:52 GMTETag: &quot;40d7-3e3073913b100&quot;Accept-Ranges: bytesContent-Length: 16599Cache-Control: max-age=21600Expires: Tue, 08 Jul 2014 11:28:43 GMTP3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;Content-Type: text/html; charset=iso-8859-1{&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25} Promise 封装 Ajax123456789101112131415161718192021222324252627function getJSON(url){ return new Promise((resolve, reject) =&gt;{ var xhr = new XMLHttpRequest() // get xhr.open('GET', url, true) // post // xhr.open('POST', url, true) // xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded') xhr.onreadystatechange = function(){ if(this.readyState === 4){ if(this.status === 200){ resolve(this.responseText, this) }else{ var resJson = {code: this.status, response: this.response} reject(resJson, this) } } } xhr.send() // post // xhr.send(JSON.stringify(data)) })} URL 详解链接 123456789101112131415161718192021URL(Uniform Resource Locator) 地址用于描述一个网络上的资源， 基本格式如下schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] scheme 指定低层使用的协议(例如：http, https, ftp) host HTTP服务器的IP地址或者域名 port# HTTP服务器的默认端口是80， https是443 这种情况下端口号可以省略。如果使用了别的端口， 必须指明，例如 http://www.cnblogs.com:8080/ path 访问资源的路径 url-params query-string 发送给http服务器的数据 anchor- 锚URL 的一个例子：http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/testURL params: id=8079Query String: name=sviergn&amp;x=trueAnchor: stuff http 常见状态码有哪些12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861XX：信息状态码-表示请求已接收，继续处理。100 Continue：客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。101 Switching Protocols：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。一: 2开头状态码2xx (成功)表示成功处理了请求的状态代码200 (成功) 服务器已成功处理了请求200 from cache： 表示该资源已经被缓存过，并且在有效期内，所以不再向浏览器发出请求，直接使用本地缓存。201 Created：202 Accepted：203 Non-Authoritative Information：204 No Content：205 Reset Content：206 Partial Content：二: 3开头状态码3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。300 Multiple Choices：301 Moved Permanently：永久性转移(Permanently Moved),302 Found：重定向表示临时性转移(Temporarily Moved )， 当一个网页URL需要短期变化时使用。303 See Other：304 Not Modified： 表示浏览器虽然发现了本地有该资源的缓存，但是不确定是否是最新的， 于是向服务器询问，若服务器认为浏览器的缓存版本还可用（即还未更新）， 那么便会返回304，继续使用本地的缓存。305 Use Proxy：306 （unused）：307 Temporary Redirect：301重定向与302重定向的区别 301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。 302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。三: 4开头状态码4xx(请求错误) 客户端错误--请求有语法错误或请求无法实现。1:400 (错误请求) 服务器不理解请求的语法。2:403 (禁止) 服务器拒绝请求。3:404 (未找到) 服务器找不到请求的网页。400 Bad Request:客户端请求有语法错误，不能被服务器所理解401 Unauthorized:请求未经授权， 这个状态代码必须和WWW-Authenticate报头域一起使用。402 Payment Required:403 Forbidden:服务器收到请求，但是拒绝提供服务。404 Not Found:请求资源不存在405 Method Not Allowed:406 Not Acceptable:407 Proxy Authentication Required:408 Request Timeout:409 Conflict:410 Gone:411 Length Required:412 Precondition Failed:413 Request Entity Too Large:414 Request-URI Too Long:415 Unsupported Media Type:416 Requested Range Not Satisfiable:417 Expectation Failed:四: 5开头状态码5xx服务器端错误--服务器未能实现合法的请求。500 (服务器内部错误) 服务器遇到错误，无法完成请求。501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 十四、http 的状态响应码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374751**(信息类)：表示接收到请求并且继续处理100——客户必须继续发出请求101——客户要求服务器根据请求转换HTTP协议版本2**(响应成功)：表示动作被成功接收、理解和接受200——表明该请求被成功地完成，所请求的资源发送回客户端201——提示知道新文件的URL202——接受和处理、但处理未完成203——返回信息不确定或不完整204——请求收到，但返回信息为空205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件206——服务器已经完成了部分用户的GET请求3**(重定向类)：为了完成指定的动作，必须接受进一步处理300——请求的资源可在多处得到301——本网页被永久性转移到另一个URL302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。303——建议客户访问其他URL或访问方式304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用305——请求的资源必须从服务器指定的地址得到306——前一版本HTTP中使用的代码，现行版本中不再使用307——申明请求的资源临时性删除4**(客户端错误类)：请求包含错误语法或不能正确执行400——客户端请求有语法错误，不能被服务器所理解401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用HTTP 401.1 - 未授权：登录失败HTTP 401.2 - 未授权：服务器配置问题导致登录失败HTTP 401.3 - ACL 禁止访问资源HTTP 401.4 - 未授权：授权被筛选器拒绝HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败402——保留有效ChargeTo头响应403——禁止访问，服务器收到请求，但是拒绝提供服务HTTP 403.1 禁止访问：禁止可执行访问HTTP 403.2 - 禁止访问：禁止读访问HTTP 403.3 - 禁止访问：禁止写访问HTTP 403.4 - 禁止访问：要求 SSLHTTP 403.5 - 禁止访问：要求 SSL 128HTTP 403.6 - 禁止访问：IP 地址被拒绝HTTP 403.7 - 禁止访问：要求客户证书HTTP 403.8 - 禁止访问：禁止站点访问HTTP 403.9 - 禁止访问：连接的用户过多HTTP 403.10 - 禁止访问：配置无效HTTP 403.11 - 禁止访问：密码更改HTTP 403.12 - 禁止访问：映射器拒绝访问HTTP 403.13 - 禁止访问：客户证书已被吊销HTTP 403.15 - 禁止访问：客户访问许可过多HTTP 403.16 - 禁止访问：客户证书不可信或者无效HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL405——用户在Request-Line字段定义的方法不允许406——根据用户发送的Accept拖，请求资源不可访问407——类似401，用户必须首先在代理服务器上得到授权408——客户端没有在用户指定的饿时间内完成请求409——对当前资源状态，请求不能完成410——服务器上不再有此资源且无进一步的参考地址411——服务器拒绝用户定义的Content-Length属性请求412——一个或多个请求头字段在当前请求中错误413——请求的资源大于服务器允许的大小414——请求的资源URL长于服务器允许的长度415——请求资源不支持请求项目格式416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。5**(服务端错误类)：服务器不能正确执行一个正确的请求HTTP500 - 服务器遇到错误，无法完成请求HTTP 500.100 - 内部服务器错误 - ASP 错误HTTP 500-11 服务器关闭HTTP 500-12 应用程序重新启动HTTP 500-13 - 服务器太忙HTTP 500-14 - 应用程序无效HTTP 500-15 - 不允许请求 global.asa Error501 - 未实现HTTP502 - 网关错误HTTP503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常 HTML5 离线缓存典型的 manifest 文件代码结构: 基本格式为三段： CACHE，NETWORK，FALLBACK， CACHE:（必须）标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。 NETWORK:（可选）这一部分是要绕过缓存直接读取的文件，可以使用通配符＊。 FALLBACK:（可选）指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI 第一个表示资源， 第二个表示后备页面。 三种方式，可以更新缓存一、更新 manifest 文件：给 manifest 添加或删除文件，都可更新缓存，如果我们更改了 js，而没有新增或删除，前面例子中注释中的版本号、时间戳或者 md5 码等进行修改，都可以很好的用来更新 manifest 文件 二、通过 javascript 操作：html5 中引入了 js 操作离线缓存的方法，下面的 js 可以手动更新本地缓存。 window.applicationCache.update();三、清除浏览器缓存：如果用户清除了浏览器缓存（手动或用其他一些工具）都会重新下载文件。 注意事项1、浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。 2、如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。 3、引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。 4、FALLBACK 中的资源必须和 manifest 文件同源。 5、当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。 6、站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。 7、当 manifest 文件发生改变时，资源请求本身也会触发更新。 1234567891011121314151617CACHE MANIFEST#version 1.2.2CACHE:#csshttp://www.haorooms.com/theme/assets/style.css#jshttp://www.haorooms.com/theme/assets/js/main.js#imghttp://static.hyb.dev.ipo.com/css/wifi/pc/images/logo-fk1.pnghttp://static.hyb.dev.ipo.com/css/wifi/images/favicon.icoNETWORK: *FALLBACK: /404.html Service Worker 与缓存及离线缓存网络请求首先到达的是 SW 脚本中，如果未命中再转发给 HTTP 缓存。 网络请求首先到达的是 SW 脚本中，如果未命中再转发给 HTTP 缓存。 一个标配版的 sw 缓存工代代码应该有以下的片段： 123456789101112131415161718const version = '2';self.addEventListener('install', event =&gt; { event.waitUntil( caches.open(`static-${version}`) .then(cache =&gt; cache.addAll([ '/styles.css', '/script.js' ])) );});self.addEventListener('fetch', event =&gt; { event.respondWith( caches.match(event.request) .then(response =&gt; response || fetch(event.request)) );}); 在 SW 的 install 阶段我们将 script.js 和 styles.css 放入缓存中；而在请求发起的 fetch 阶段，通过资源的 URL 去缓存内查找匹配，成功后立刻返回，否则走正常的网络请求流程。 PageCache 与 Ajax 可缓存PageCache 其实是 facebook 提出的，解决 ajax 缓存的一种方案！简单的说，就是将访问过的页面缓存在客户端。 更新思路： 1、增量更新：只要页面来自于缓存，即更新所有预定义的需增量更新的模块。 2、用户复写：通过 HistoryManager 记录用户操作并在 cache 页面读取后重放所有被标记为“replayable”的操作。 3、跨页更新：通过服务端 Database API 发送信号至客户端将过期缓存标识为 invalid（不清楚如何实现。也许是 DB 端提供一个开放的 webservice，客户端通过 Ajax 持续访问此 API 来获得此信息）。获得了缓存过期信号后，通过 Ajax 更新需要更新的信息。","link":"/http/%E7%BD%91%E7%BB%9C/HTTP%E7%A7%AF%E7%B4%AF/"},{"title":"React 高阶组件","text":"[TOC] 高阶组件高阶组件（ higher-order component ，HOC ）是 React 中复用组件逻辑的一种进阶技巧。它本身并不是 React 的 API，而是一种 React 组件的设计理念，众多的 React 库已经证明了它的价值，例如耳熟能详的 react-redux。 高阶函数是把函数作为参数传入到函数中并返回一个新的函数。把函数替换成组件，就是高阶组件。高阶组件就是一个函数，用来封装重复的逻辑。传进去一个老组件，返回一个新组件 const EnhancedComponent = higherOrderComponent(WrappedComponent); 高阶组件可以抽离公共逻辑，像洋葱一样层层叠加给组件，每一层职能分明，可以方便地抽离与增添。在优化代码或解耦组件时，可以考虑使用高阶组件模式。 实现高阶组件的两种方式： 属性代理(Props Proxy): 高阶组件操控传递给 WrappedComponent 的 props， 反向继承（Inheritance Inversion）：高阶组件继承（extends）WrappedComponent。 可以用高阶组件做什么？ 代码复用，逻辑抽象，抽离底层准备（bootstrap）代码 渲染劫持 State 抽象和更改 Props 更改 实例例如，假设你有一个接受外部数据源渲染评论列表的CommentList组件： 12345678910111213141516171819202122232425262728293031323334353637class CommentList extends React.Component { constructor() { super(); this.handleChange = this.handleChange.bind(this); this.state = { // &quot;DataSource&quot; is some global data source comments: DataSource.getComments() }; } componentDidMount() { // Subscribe to changes DataSource.addChangeListener(this.handleChange); } componentWillUnmount() { // Clean up listener DataSource.removeChangeListener(this.handleChange); } handleChange() { // Update component state whenever the data source changes this.setState({ comments: DataSource.getComments() }); } render() { return ( &lt;div&gt; {this.state.comments.map((comment) =&gt; ( &lt;Comment comment={comment} key={comment.id} /&gt; ))} &lt;/div&gt; ); }} 随后，你编写一个订阅单个博文的组件，其遵循类似的模式: 12345678910111213141516171819202122232425262728class BlogPost extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = { blogPost: DataSource.getBlogPost(props.id) }; } componentDidMount() { DataSource.addChangeListener(this.handleChange); } componentWillUnmount() { DataSource.removeChangeListener(this.handleChange); } handleChange() { this.setState({ blogPost: DataSource.getBlogPost(this.props.id) }); } render() { return &lt;TextBlock text={this.state.blogPost} /&gt;; }} CommentList和BlogPost是等价的，除了它们调用DataSource的不同方法，有不同的输出。但它们大部分的实现是类似的: 组件mount结束后，都添加DataSource的change监听 除了监听函数，无论什么时候datasource改变之后，都会调用setState 组件unmount之后，都会移除监听。 以上两个组件在大型项目中订阅及setState的方法会一次次出现。 我们需要将其抽象出来，使得我们能够在一个地方定义逻辑并且在组件中共享。这就是高阶组件的优点 写一个函数，能够创建类似于CommentList和BlogPost这类订阅DataSource的新的组件。这个函数接受一个子组件作为参数，这个子组件接受订阅数据源作为props，调用withSubscription如下： 123456789const CommentListWithSubscription = withSubscription( CommentList, (DataSource) =&gt; DataSource.getComments());const BlogPostWithSubscription = withSubscription( BlogPost, (DataSource, props) =&gt; DataSource.getBlogPost(props.id)}); 第一个参数是被包含的组件，第二个参数根据给定的DataSource和当前的props取回我们需要的数据。 当CommentListWithSubscription和CommentListWithSubscription被渲染时，CommentList和BlogPost将会被传递data属性，其中包含从DataSource取回的最新数据。 12345678910111213141516171819202122232425262728293031323334// This function takes a component...function withSubscription(WrappedComponent, selectData) { // ...and returns another component... return class extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.state = { data: selectData(DataSource, props) }; } componentDidMount() { // ... that takes care of the subscription... DataSource.addChangeListener(this.handleChange); } componentWillUnmount() { DataSource.removeChangeListener(this.handleChange); } handleChange() { this.setState({ data: selectData(DataSource, this.props) }); } render() { // ... and renders the wrapped component with the fresh data! // Notice that we pass through any additional props return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;; } };} 高阶组件既不会修改输入组件，也不会通过继承来复制行为。相反，通过包裹的形式，高阶组件将原先的组件组合在container组件中。高阶组件是纯函数，没有副作用。 被包裹的元素接受 container 的所有props和新的props，并使用其渲染输出。高阶组件并不关心数据将会如何或者为什么使用，并且被包裹的元素并不关心数据的源头。 因为withSubscription只是一个普通函数，你可以按照你的意愿添加很多或者很少的参数。例如，你可能希望data的名字是可以配置的，为了进一步隔离高阶组件和被包裹组件。或者你可以接受一个参数，它可以配置shouldComponentUpdate,或者是可以配置数据的来源。这都是可行的，因为高阶组件可以完全自己控制组件该如何定义。 和组件相类似，withSubscription和被包裹组件的联系是基于props的。只要为被包裹元素提供相同的属性，那么很容易将一个高阶组件组件转化成不同的高阶组件。例如，如果你想要改变数据获取的库，这将非常有用。 一个简单的高阶组件1234567891011121314import React, {Component} from 'react';import simpleHoc from './simpleHoc';class Usual extends Component { render() { console.log(this.props, 'props); return ( &lt;div&gt; Usual &lt;/div&gt; ) }}export default simpleHoc(Usual); simpleHoc.js 1234567891011import React, { Component } from 'react';const simpleHoc = wrappedComponent =&gt; { console.log('simpleHoc'); return class extends Component { render() { return &lt;wrappedComponent {...this.props} /&gt; } }}export default simpleHoc; 例二: 123456789101112export default function withHeader(WrappedComponent) { return class HOC extends Component { render() { return &lt;div&gt; &lt;div className=&quot;demo-header&quot;&gt; 我是标题 &lt;/div&gt; &lt;WrappedComponent {...this.props}/&gt; &lt;/div&gt; } }} 在其他组件中引用 12345678910@withHeaderexport default class Demo extends Component { render() { return ( &lt;div&gt; 我是一个普通组件 &lt;/div&gt; ); }} 装饰器模式高阶组件可以看做是装饰器模式(Decorator Pattern) 在React的实现。即允许向一个现有对象添加新功能，同时不改变其结构，属于包装模式(Wrapper Pattern)的一种 上面例子可以改写为 12345678910111213import React, { Component } from 'react';import simpleHoc from './simple-hoc';@simpleHocexport default class Usual extends Component { render() { return ( &lt;div&gt; Usual &lt;/div&gt; ) }} 两种形式属性代理属性代理本质上是返回了一个全新的 Component，此时原组件的静态属性、生命周期等一系列内容都被屏蔽，导致上层的高阶组件、对组件的操作都拿不到应有的内容。 一个简单例子中用的就是属性代理(Props Proxy)的形式。本来传给Usual的props在hoc中接收到，就是props proxy. 这里可以做一些操作 12345678function ppHOC(WrappedComponent) { return class PP extends React.Component { render() { return &lt;WrappedComponent {...this.props}/&gt; } }} 这里高阶组件的 render 方法返回了一个 type 为 WrappedComponent 的 React Element（也就是被包装的那个组件），我们把高阶组件收到的 props 传递给它，因此得名 Props Proxy。 注意： 123&lt;WrappedComponent {...this.props}/&gt;// is equivalent toReact.createElement(WrappedComponent, this.props, null) Props Proxy 可以做什么 操作 props 通过 refs 获取组件实例 抽象 state 把 WrappedComponent 与其它 elements 包装在一起 操作props接收到props可以做任何读取，编辑，删除等自定义操作。都可以通过props再传下去 12345678910111213141516import React, { Component } from 'react';const propsProxyHoc = WrappedComponent =&gt; class extends Component { handleClick() { console.log('click'); } render() { return (&lt;WrappedComponent {...this.props} handleClick={this.handleClick} /&gt;); }};export default propsProxyHoc; 在Usual组件中会接收到handleClick属性 在修改或删除重要 props 的时候要小心，你可能应该给高阶组件的 props 指定命名空间（namespace），以防破坏从外传递给 WrappedComponent 的 props。 例子：添加新 props。这个currentLoggedInUser可以在 WrappedComponent 通过 this.props.user 获取 12345678910function ppHOC(WrappedComponent) { return class PP extends React.Component { render() { const newProps = { user: currentLoggedInUser } return &lt;WrappedComponent {...this.props} {...newProps}/&gt; } }} 通过refs获取组件实例尽管惯例是高阶组件会给被包裹组件传递所有的属性(props)，但是不会传递refs。因为ref不是一个属性，就像key一样，它是由React特殊处理的。如果你给高阶组件产生的组件的元素添加ref,ref引用的是外层的容器组件的实例，而不是被包裹的组件。 如果你遇到这个问题，最好的解决方法是避免使用ref。有时候，React新手用户依赖于refs，这时候props是更好的选择。 也就是说，也就是说refs有时候是必要的，否则React也不会提供refs。 选中输入框(focusing an input field)是一个你可能希望强制控制组件的例子。在这种例子中，一个解决办法是通过起一个别名，将ref作为一个普通的props传递： 1234567891011121314151617function Field({ inputRef, ...rest }) { return &lt;input ref={inputRef} {...rest} /&gt;;}// Wrap Field in a higher-order componentconst EnhancedField = enhance(Field);// Inside a class component's render method...&lt;EnhancedField inputRef={(inputEl) =&gt; { // This callback gets passed through as a regular prop this.inputEl = inputEl }}/&gt;// Now you can call imperative methodsthis.inputEl.focus(); 无论如何，这都是一个完美的解决方案。我们倾向于refs是由库去处理，而不是要求你手动地处理。我们正在寻找解决这个问题的办法，以便在使用高阶组件时不需要注意这个问题。 抽象state这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件（文档），即把input都做成受控的，改变value的时候，用onChange事件同步到state中。 可以通过向 WrappedComponent 传递 props 和 callbacks（回调函数）来抽象 state，这和 React 中另外一个组件构成思想 Presentational and Container Components 很相似。 1234567891011121314151617181920// 普通组件Loginimport React, { Component } from 'react';import formCreate from './form-create';@formCreateexport default class Login extends Component { render() { return ( &lt;div&gt; &lt;div&gt; &lt;label id=&quot;username&quot;&gt; 账户 &lt;/label&gt; &lt;input name=&quot;username&quot; {...this.props.getField('username')}/&gt; &lt;/div&gt; &lt;div onClick={this.props.handleSubmit}&gt;提交&lt;/div&gt; &lt;/div&gt; ) }} form-create.js 1234567891011121314151617181920212223242526272829303132333435363738//HOCimport React, { Component } from 'react';const formCreate = WrappedComponent =&gt; class extends Component { constructor() { super(); this.state = { fields: {}, } } onChange = key =&gt; e =&gt; { const { fields } = this.state; fields[key] = e.target.value; this.setState({ fields, }) } handleSubmit = () =&gt; { console.log(this.state.fields); } getField = fieldName =&gt; { return { onChange: this.onChange(fieldName), } } render() { const props = { ...this.props, handleSubmit: this.handleSubmit, getField: this.getField, } return (&lt;WrappedComponent {...props} /&gt;); }};export default formCreate; 这里我们把state，onChange等方法都放到HOC里，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。 把 WrappedComponent 与其它 elements 包装在一起出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起。一些基本的用法也可以使用正常的父组件来实现（附录 B），但是就像之前所描述的，使用高阶组件你可以获得更多的灵活性。 123456789101112function ppHOC(WrappedComponent) { return class PP extends React.Component { render() { return ( &lt;div style={{display: 'block'}}&gt; &lt;WrappedComponent {...this.props}/&gt; &lt;/div&gt; ) } }} 反向继承反向继承(Inheritance Inversion), 简称II， 简单的实现： 1234567891011function iiHOC(WrappedComponent) { return class Enhancer extends WrappedComponent { componentDidMount() { // 可以方便地得到state，做一些更深入的修改。 console.log(this.state); } render() { return super.render() } }} 返回的高阶组件类（Enhancer）继承了 WrappedComponent。这被叫做反向继承是因为 WrappedComponent 被动地被 Enhancer 继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。 反向继承允许高阶组件通过 this 关键词获取 WrappedComponent，意味着它可以获取到 state，props，组件生命周期（component lifecycle）钩子，以及渲染方法（render）。 可以用反向继承高阶组件做什么？ 渲染劫持（Render Highjacking） 操作 state 渲染劫持被叫做渲染劫持是因为高阶组件控制了 WrappedComponent 生成的渲染结果，并且可以做各种操作。 通过渲染劫持你可以： 『读取、添加、修改、删除』任何一个将被渲染的 React Element 的 props 在渲染方法中读取或更改 React Elements tree，也就是 WrappedComponent 的 children 根据条件不同，选择性的渲染子树 给子树里的元素变更样式 *渲染 指的是 WrappedComponent.render 方法 你无法更改或创建 props 给 WrappedComponent 实例，因为 React 不允许变更一个组件收到的 props，但是你可以在 render 方法里更改子元素/子组件们的 props。 就像之前所说的，反向继承的高阶组件不能保证一定渲染整个子元素树，这同时也给渲染劫持增添了一些限制。通过反向继承，你只能劫持 WrappedComponent 渲染的元素，这意味着如果 WrappedComponent 的子元素里有 Function 类型的 React Element，你不能劫持这个元素里面的子元素树的渲染。 例子1：条件性渲染。如果 this.props.loggedIn 是 true，这个高阶组件会原封不动地渲染 WrappedComponent，如果不是 true 则不渲染（假设此组件会收到 loggedIn 的 prop） 1234567891011function iiHOC(WrappedComponent) { return class Enhancer extends WrappedComponent { render() { if (this.props.loggedIn) { return super.render() } else { return null } } }} 例子2：通过 render 来变成 React Elements tree 的结果 1234567891011121314function iiHOC(WrappedComponent) { return class Enhancer extends WrappedComponent { render() { const elementsTree = super.render() let newProps = {}; if (elementsTree &amp;&amp; elementsTree.type === 'input') { newProps = {value: 'may the force be with you'} } const props = Object.assign({}, elementsTree.props, newProps) const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children) return newElementsTree } }} 在这个例子中，如果 WrappedComponent 的顶层元素是一个 input，则改变它的值为 “may the force be with you”。这里你可以做任何操作，比如你可以遍历整个 element tree 然后变更某些元素的 props。这恰好就是 Radium 的工作方式。 注意：你不能通过 Props Proxy 来做渲染劫持即使你可以通过 WrappedComponent.prototype.render 获取它的 render 方法，你需要自己手动模拟整个实例以及生命周期方法，而不是依靠 React，这是不值当的，应该使用反向继承来做到渲染劫持。要记住 React 在内部处理组件的实例，而你只通过 this 或 refs 来处理实例。 操作 state高阶组件可以 『读取、修改、删除』WrappedComponent 实例的 state，如果需要也可以添加新的 state。需要记住的是，你在弄乱 WrappedComponent 的 state，可能会导致破坏一些东西。通常不建议使用高阶组件来读取或添加 state，添加 state 需要使用命名空间来防止与 WrappedComponent 的 state 冲突。 例子：通过显示 WrappedComponent 的 props 和 state 来 debug 1234567891011121314export function IIHOCDEBUGGER(WrappedComponent) { return class II extends WrappedComponent { render() { return ( &lt;div&gt; &lt;h2&gt;HOC Debugger Component&lt;/h2&gt; &lt;p&gt;Props&lt;/p&gt; &lt;pre&gt;{JSON.stringify(this.props, null, 2)}&lt;/pre&gt; &lt;p&gt;State&lt;/p&gt;&lt;pre&gt;{JSON.stringify(this.state, null, 2)}&lt;/pre&gt; {super.render()} &lt;/div&gt; ) } }} HOC和Mixin的比较 高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。 作者：请叫我王磊同学链接：https://juejin.im/post/5914fb4a0ce4630069d1f3f6来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 应用场景 用高阶组件优化之前老项目写的不好的地方，比如两个页面UI几乎一样，功能几乎相同，仅仅几个操作不太一样，却写了两个耦合很多的页面级组件。当我去维护它的时候，由于它的耦合性过多，经常会添加一个功能(这两个组件都要添加)，我要去改完第一个的时候，还要改第二个。而且有时候由于记性不好，会忘掉第二个… 就会出现bug再返工。所以加新功能时，写一个高阶组件，往HOC里添加方法，把那两个组件包装一下，也就是属性代理。这样新代码就不会再出现耦合，旧的逻辑并不会改变 另一种情况是之前写过一个组件A，做完上线，之后产品加了一个新需求，很奇怪要做的组件B跟A几乎一模一样，但稍微有区别。那我可能就通过II的方式去继承之前的组件A，比如它在didMount去fetch请求，需要的数据是一样的。不同的地方我就会放到HOC里，存储新的state这样，再通过劫持渲染，把不同的地方，添加的地方进行处理。但其实这算Hack的一种方式，能快速解决问题，也反映了组件设计规划之初有所不足(原因比较多)。 Container解决不了的时候甚至不太优雅的时候。其实大部分时候包一层Container组件也能做到差不多的效果，比如操作props，渲染劫持。但其实还是有很大区别的。比如我们现在有两个功能的container，添加样式和添加处理函数的，对Usual进行包装。栗子： 123456789101112//usualclass Usual extends Component { render() { console.log(this.props, 'props'); return &lt;div&gt; Usual &lt;/div&gt; }};export default Usual;//console - Object {handleClick: function} &quot;props&quot; 1234567891011121314import React, { Component } from 'react';import Usual from './usual';class StyleContainer extends Component { render() { return (&lt;div style={{ color: '#76d0a3' }}&gt; &lt;div&gt;container&lt;/div&gt; &lt;Usual {...this.props} /&gt; &lt;/div&gt;); }}export default StyleContainer; 123456789101112131415161718import React, { Component } from 'react';import StyleContainer from './container-add-style';class FuncContainer extends Component { handleClick() { console.log('click'); } render() { const props = { ...this.props, handleClick: this.handleClick, }; return (&lt;StyleContainer {...props} /&gt;); }}export default FuncContainer; 外层Container必须要引入内层Container，进行包装，还有props的传递，同样要注意包装的顺序。当然你可以把所有的处理都放到一个Container里。那用HOC怎么处理呢，相信大家有清晰的答案了。 12345678910111213const addFunc = WrappedComponent =&gt; class extends Component { handleClick() { console.log('click'); } render() { const props = { ...this.props, handleClick: this.handleClick, }; return &lt;WrappedComponent {...props} /&gt;; }}; 12345678const addStyle = WrappedComponent =&gt; class extends Component { render() { return (&lt;div style={{ color: '#76d0a3' }}&gt; &lt;WrappedComponent {...this.props} /&gt; &lt;/div&gt;); }}; 1234567891011const WrappenComponent = addStyle(addFunc(Usual));class WrappedUsual extends Component { render() { console.log(this.props, 'props'); return (&lt;div&gt; &lt;WrappedComponent /&gt; &lt;/div&gt;); }} 显然HOC是更优雅一些的，每个HOC都定义自己独有的处理逻辑，需要的时候只需要去包装你的组件。相较于Container的方式，HOC耦合性更低，灵活性更高，可以自由组合，更适合应付复杂的业务。每个HOC负责独立的功能，比如可能只是一个Loading的效果，很多列表页都需要，用HOC只需要包装一下就可以了，不需要在每个组件里再重写这部分逻辑了。当然当你的需求很简单的时候，还是用Container去自由组合，应用场景需要你清楚。 案例学习React-ReduxReact-Redux 是 Redux 官方的对于 React 的绑定。 其中一个方法 connect 处理了所有关于监听 store 的 bootstrap 代码 以及清理工作，这是通过 Props Proxy 来实现的。 如果你曾经使用过 Flux 你会知道 React 组件需要和一个或多个 store 连接，并且添加/删除对 store 的监听，从中选择需要的那部分 state。而 React-Redux 帮你把它们实现了，自己就不用再去写这些了。 RadiumRadium 是一个增强了行内（inline）css 能力的库，它允许了在 inline css 使用 CSS 伪选择器。点此了解关于使用 inline css 的好处. 那么，Radium 是怎么允许 inline css 来实现 CSS 伪选择器的呢（比如 hover）？它实现了一个反向继承来使用渲染劫持，添加适当的事件监听来模拟 CSS 伪选择器。这要求 Radium 读取整个 WrappedComponent 将要渲染的元素树，每当找个某个元素带有 style prop，它就添加对应的时间监听 props。简单地说，Radium 修改了原先元素树的 props（实际上会更复杂，但这么说你可以理解到要点所在）。 Radium 只暴露了一个非常简单的 API 给开发者。这非常惊艳，因为开发者几乎不会注意到它的存在和它是怎么发挥作用的，而实现了想要的功能。这揭露了高阶组件的能力。 附录附录A: 高阶组件和参数有时，在高阶组件中使用参数是很有用的。这个在以上所有例子中都不是很明显，但是对于中等的 JavaScript 开发者是比较自然的事情。让我们迅速的介绍一下。 例子：一个简单的 Props Proxy 高阶组件搭配参数。重点是这个 HOCFactoryFactory 方法。 12345678910function HOCFactoryFactory(...params) { // do something with params return function HOCFactory(WrappedComponent) { return class HOC extends React.Component { render() { return &lt;WrappedComponent {...this.props}/&gt; } } }} 你可以这样使用它： 1234HOCFactoryFactory(params)(WrappedComponent)//or@HOCFatoryFactory(params)class WrappedComponent extends React.Component{} 例子： 123456789// 如果传入参数，则传入的参数将作为组件的标题呈现@withHeader('Demo')export default class Demo extends Component { render() { return ( //... ); }} withHead.js 接收参数，返回高阶组件 12345678910111213141516export default function (title) { return function (WrappedComponent) { return class HOC extends Component { render() { return &lt;div&gt; &lt;div className=&quot;demo-header&quot;&gt; {title ? title : '我是标题'} &lt;/div&gt; &lt;WrappedComponent {...this.props}/&gt; &lt;/div&gt; } } }} ES6写法 123456789101112export default(title) =&gt; (WrappedComponent) =&gt; class HOC extends Component { render() { return &lt;div&gt; &lt;div className=&quot;demo-header&quot;&gt; {title ? title : '我是标题'} &lt;/div&gt; &lt;WrappedComponent {...this.props}/&gt; &lt;/div&gt; }} 柯里化 Curry 概念：只传递函数的一部分参数来调用它，让它返回一个函数去处理剩下的参数。 函数签名：fun(params)(otherParams) 应用：在React里，通过柯里化，我们可以通过传入不同的参数来得到不同的高阶组件。 1 附录 B：和父组件的不同之处父组件就是单纯的 React 组件包含了一些子组件（children）。React 提供了获取和操作一个组件的 children 的 APIs。 例子：父组件获取它的 children 12345678910111213141516class Parent extends React.Component { render() { return ( &lt;div&gt; {this.props.children} &lt;/div&gt; ) }}render(( &lt;Parent&gt; {children} &lt;/Parent&gt;), mountNode) 现在来总结一下父组件能做和不能做的事情（与高阶组件对比）： 渲染劫持 操作内部 props 抽象 state。但是有缺点，不能再父组件外获取到它的 state，除非明确地实现了钩子。 与新的 React Element 包装。这似乎是唯一一点，使用父组件要比高阶组件强，但高阶组件也同样可以实现。 Children 的操控。如果 children 不是单一 root，则需要多添加一层来包括所有 children，可能会使你的 markup 变得有点笨重。使用高阶组件可以保证单一 root。 父组件可以在元素树立随意使用，它们不像高阶组件一样限制于一个组件。 通常来讲，能使用父组件达到的效果，尽量不要用高阶组件，因为高阶组件是一种更 hack 的方法，但同时也有更高的灵活性。 高阶组件作为一个函数，它可以更加纯粹地关注业务逻辑层面的代码，比如数据处理，数据校验，发送请求等，可以改善目前代码里业务逻辑和UI逻辑混杂在一起的现状。父组件则是UI层的东西，我们先前经常把一些业务逻辑处理放在父组件里，这样会造成父组件混乱的情况。为了代码进一步解耦，可以考虑使用高阶组件这种模式。 注意点原文链接 不要改变原始组件，而是使用组合要忍住在高阶组件修改组件原型(或者修改其他)的冲动。 123456789101112function logProps(InputComponent) { InputComponent.prototype.componentWillReceiveProps(nextProps) { console.log('Current props: ', this.props); console.log('Next props: ', nextProps); } // The fact that we're returning the original input is a hint that it has // been mutated. return InputComponent;}// EnhancedComponent will log whenever props are receivedconst EnhancedComponent = logProps(InputComponent); 这里存在一些问题，一个是输入组件(InputComponent)不能脱离增强组件分别重用。更重要的是，如果将另一个也修改componentWillReceiveProps的高阶组件应用于EnhancedComponent组件，第一个高阶组件的功能将会别覆盖。这个高阶组件对函数组件不会起作用，因为函数组件没有生命周期函数。 具有修改功能的高阶组件是一个漏洞的抽象过程：用户必须知道它是怎么实现的从而避免与其他高阶组件的冲突。 组合多个高阶组件12345@withHeader@withLoadingclass Demo extends Component{} 使用compose可以简化上述过程，也能体现函数式编程的思想。 12345const enhance = compose(withHeader,withLoading);@enhanceclass Demo extends Component{} 组合 Composecompose可以帮助我们组合任意个（包括0个）高阶函数，例如compose(a,b,c)返回一个新的函数d，函数d依然接受一个函数作为入参，只不过在内部会依次调用c,b,a，从表现层对使用者保持透明。基于这个特性，我们便可以非常便捷地为某个组件增强或减弱其特征，只需要去变更compose函数里的参数个数便可。compose函数实现方式有很多种，这里推荐其中一个recompact.compose，详情见下方参考类库。 相比于修改，高阶组件最好是通过将输入组件包裹在容器组件的方式来使用组合: 123456789101112function logProps(WrappedComponent) { return class extends React.Component { componentWillReceiveProps(nextProps) { console.log('Current props: ', this.props); console.log('Next props: ', nextProps); } render() { // Wraps the input component in a container, without mutating it. Good! return &lt;WrappedComponent {...this.props} /&gt;; } }} 这个高阶组件与之前的修改原型的版本有着相同的功能，但又避免了潜在的冲突可能。其在class类型和函数类型的组件都起作用。并且，因为是纯函数，它可以与其他高阶组件，甚至是自己组合。 你可能已经注意到高阶组件和被称为容器组件(container components)的模式有相同之处。容器组件是分离责任策略的一部分。这个分离策略是关于高层次和低层次关注点之间的责任分离。容器管理着类似订阅和状态这类东西，和给组件传递属性来处理类似渲染UI这类事情。高阶组件使用容器作为其实现的一部分。你可以将高阶组件视为定义参数化容器组件。 约定: 给包裹组件传递不相关的属性(Props)高阶组件可以向组件添加功能。他不应该大幅度地改变功能。期望地是高阶组件返回的组件和被包裹组件具有相似的界面。 高阶组件应该通过props传递那些与特定功能无关的特性。大多数的高阶组件包含如下的render函数: 1234567891011121314151617render() { // Filter out extra props that are specific to this HOC and shouldn't be // passed through const { extraProp, ...passThroughProps } = this.props; // Inject props into the wrapped component. These are usually state values or // instance methods. const injectedProp = someStateOrInstanceMethod; // Pass props to wrapped component return ( &lt;WrappedComponent injectedProp={injectedProp} {...passThroughProps} /&gt; );} 这个约定帮助确定高阶组件能够足够灵活和可以被重用。 约定: 最大化组合(Maximizing Composability)不是所有的高阶组件看起来都是一样的。有时候，它接受包裹组件作为单一参数： 1const NavbarWithRouter = withRouter(Navbar); 通常情况下，高阶组件接受其他的参数。在Relay这个例子中，配置对象用来指定组件的数据依赖关系： 1const CommentWithRelay = Relay.createContainer(Comment, config); 高阶组件最常见的签名如下： 12// React Redux's `connect`const ConnectedComment = connect(commentSelector, commentActions)(Comment); **什么?!**，如果你把它分开，就更容易看到发生了什么。 12345// connect is a function that returns another functionconst enhance = connect(commentListSelector, commentListActions);// The returned function is an HOC, which returns a component that is connected// to the Redux storeconst ConnectedComment = enhance(CommentList); 总的来说，connect是一个返回高阶组件的高阶函数！ 这种形式看起来是混乱的或者是没有必要的，但是它是一个有用的属性。单参数的高阶组件类似于connect函数所返回的函数，其签名为Component =&gt; Component。返回的函数的输出类型和输入类型是相同的，很容易相互组合。 1234567891011// Instead of doing this...const EnhancedComponent = connect(commentSelector)(withRouter(WrappedComponent))// ... you can use a function composition utility// compose(f, g, h) is the same as (...args) =&gt; f(g(h(...args)))const enhance = compose( // These are both single-argument HOCs connect(commentSelector), withRouter)const EnhancedComponent = enhance(WrappedComponent) (这个相同的属性还允许连接和其他增强型高阶属性作为装饰器(decorators),这是一个实验性的JavaScript提案)。 包括lodash(例如lodash.flowRight)、Redux和Ramda在内的许多第三方库都提供了组合函数。 约定:为了方便调试包装显示名称(display name)由高阶属性创建的容器组件在React开发者工具中显示同其他的组件相似。为了方便调试，选择一个显示名称(display name)，表示它是高阶组件的结果。 最常见的方法是给被包裹元素包裹一个显示名称(display name)。因此，如果你的高阶组件名字为withSubscription，被包裹的元素名称为CommentList，那就选择名称为WithSubscription(CommentList)。 123456789function withSubscription(WrappedComponent) { class WithSubscription extends React.Component {/* ... */} WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`; return WithSubscription;}function getDisplayName(WrappedComponent) { return WrappedComponent.displayName || WrappedComponent.name || 'Component';} 警告高阶组件有以下几个警告，如果你是刚接触React，这些警告可能不会立刻就被发现。 不要在render函数中使用高阶组件React的diff算法(又称为reconciliation)使用组件标识符(component identity)来决定是否应该更新已有的子树或者将其抛出并安装一个新的子树。如果从render返回的组件等同于(===)之前render函数返回的组件，React将会迭代地通过diff算法更新子树到新的子树。如果不相等，则先前的子树将会完全卸载。 通常情况下，你不需要考虑这些。但是这对高阶组件非常重要，因为这意味你在组件的render方法中不能通过高阶组件产生组件: 1234567render() { // A new version of EnhancedComponent is created on every render // EnhancedComponent1 !== EnhancedComponent2 const EnhancedComponent = enhance(MyComponent); // That causes the entire subtree to unmount/remount each time! return &lt;EnhancedComponent /&gt;;} 这个问题不仅仅关乎于性能，卸载组件会造成组件状态和其子元素全部丢失。 相反地，在组件定义外应用高阶组件，以便生成的组件只会被创建一次。然后，它的标识符在每次渲染中都是相同的。无论如何，这才是你想要的。 在一些极少的例子中你需要动态地引用高阶组件，你可以在组件的声明周期函数中使用或者在构造函数中使用。 静态方法必须复制有时候，在React组价中定义静态方法是非常有用的。例如，Relay容器对外暴露一个静态方法getFragment，来帮助组合GraphQL代码。 当你将一个组件应用于高阶组件式，虽然原有的组件被容器组件所包裹，但这以为这新的组件没有之前组件的静态函数。 1234567// Define a static methodWrappedComponent.staticMethod = function() {/*...*/}// Now apply an HOCconst EnhancedComponent = enhance(WrappedComponent);// The enhanced component has no static methodtypeof EnhancedComponent.staticMethod === 'undefined' // true 为了解决这个问题，在返回之前，可以向容器组件中复制原有的静态方法： 123456function enhance(WrappedComponent) { class Enhance extends React.Component {/*...*/} // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;} 然而，这需要你明确地知道哪些方法需要别复制。你可以使用hoist-non-react-statics来自动复制非React的静态方法。 123456import hoistNonReactStatic from 'hoist-non-react-statics';function enhance(WrappedComponent) { class Enhance extends React.Component {/*...*/} hoistNonReactStatic(Enhance, WrappedComponent); return Enhance;} 另一个有效的方法是将静态方法与组件本身相分离： 123456789// Instead of...MyComponent.someFunction = someFunction;export default MyComponent;// ...export the method separately...export { someFunction };// ...and in the consuming module, import bothimport MyComponent, { someFunction } from './MyComponent.js'; 使用compose组合HOC函数式编程的套路… 例如应用redux中的middleware以增强功能。redux-middleware解析 123456789101112const addFuncHOC = ...const addStyleHOC = ...//省略const compose = (...funcs) =&gt; component =&gt; { if (funcs.lenght === 0) { return component; } const last = funcs[funcs.length - 1]; return funcs.reduceRight((res, cur) =&gt; cur(res), last(component));};const WrappedComponent = compose(addFuncHOC, addStyleHOC)(Usual); 实战loading组件实现Loading组件时，发现需要去拦截它的渲染过程，故使用了反向继承的方式来完成。 12345678910111213141516171819202122232425import React, {Component} from 'react';import {Spin} from 'antd';export default function (loadingCheck) { return function (WrappedComponent) { return class extends WrappedComponent { componentWillUpdate(nextProps, nextState) { console.log('withLoading将会更新'); } render() { if (loadingCheck(this.props)) { return &lt;Spin tip=&quot;加载中&quot; size=&quot;large&quot;&gt; {super.render()} &lt;/Spin&gt; } else { return super.render(); } } } }}// 使用@withLoading(props =&gt; { return props.IndexStore.accountList.length == 0;}) 实现一个copy组件实现copy组件的时候，我们发现不需要去改变组件内部的展示方式，只是为其在外围增加一个功能，并不会侵入被传入的组件，故使用了属性代理的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import gotem from 'gotem';import React, {Component} from 'react';import ReactDom from 'react-dom';import {message} from 'antd';export default copy = (targetName) =&gt; { return (WrappedComponent) =&gt; { return class extends Component { componentDidMount() { const ctx = this; const dom = ReactDom.findDOMNode(ctx); const nodes = { trigger: dom, // targetName为DOM选择器，复制组件将会复制它的值 target: dom.querySelector(targetName) }; gotem(nodes.trigger, nodes.target, { success: function () { message.success('复制成功'); }, error: function () { message.error('复制失败，请手动输入'); } }); } render() { return &lt;WrappedComponent {...this.props}/&gt;; } }; };}// 使用// 传入 h3 ，让复制组件去获取它的值@copy('h3')class Info extends Component { render() { return ( &lt;div&gt; &lt;h3&gt; 阿里云,点击复制这段文字 &lt;/h3&gt; &lt;/div&gt; ); }} [参考链接]React 进阶之高阶组件 深入理解 React 高阶组件 精度React组件","link":"/posts/React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"},{"title":"React进阶读书笔记","text":"React 四大特点 声明式视图层 采用JSX语法来声明视图层, 可以在视图层中随意使用各种状态数据 简单的更新流程 从状态到UI单向数据流让React组件的更新流程更清晰 灵活的渲染实现 基于虚拟dom渲染 高效的DOM操作 React可以尽量减少虚拟dom到真实DOM的渲染次数, 以及每次渲染需要改变的真实DOM节点数。 React只是view层, 关注的是如何根据状态创建可复用的UI组件, 如何根据组件创建可组合的UI.应用复杂时, 需要结合其他库(Redux, MobX等). React组件名必须大写因为DOM标签的首字母都是小写; React组件类型的标签必须首字母大写。React正是通过首字母大小写判断渲染的是一个dom类型的标签还是React组件类型的标签。 JSX语法实际是什么JSX语法只是React.createElement(component, props, …children)的语法糖, 所有的JSX语法最终都会被转换成对这个方法的调用。 1const ele = &lt;div className='foo'&gt;Hello, React&lt;/div&gt; 转换后 1const ele = React.createElement('div', {className: 'foo', 'Hello, React'}) 组件定义方式有两种方式 ES6 class(类组件) 需满足条件: class继承自React.Component class内部必须定义render方法, render返回代表该组件UI的React元素. eg: 1234567891011import React, { Component } from &quot;react&quot;;export default class PostList extends Component { render() { return ( &lt;div&gt; 列表 &lt;/div&gt; ) }} 使用函数(函数组件) 函数组件接收props作为参数,返回这个组件UI的React元素结构. eg: 123function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;} React组件数据驱动UIReact组件是由props和state两种类型的数据驱动渲染出组件UI. props是组件对外的接口, 组件通过props接收外部传入的数据(包括方法);state是组件对内的接口, 组件内部状态的变化通过state来反映。props是只读的, 不能再组件内部修改props, 要修改props只能在父组件中修改;state是可变的, 组件状态的变化通过修改state来实现. 这也是state和props的区别 有状态组件 无状态组件 如果组件内部状态是不变的, 就不用state, 这样的组件称之为无状态组件。 无状态组件尽量定义成函数组件. 优点:无状态组件不关心状态变化, 只聚焦于UI展示, 更容易被复用。 组件内部状态会发生变化，需要使用state来保存变化，这样的组件称为有状态组件。 建议:开发React应用, 一定要先认真思考哪些组件应该设计成有状态组件, 哪些该设计成无状态组件.并且应尽可能多地使用无状态组件。无状态组件数据从父级获取, 组件解耦更彻底. React组件设计思路:通过定义少数的有状态组件管理整个应用的状态变化, 将状态通过props传递给其余的无状态组件, 由无状态组件完成页面绝大部分UI的渲染工作。有状态组件主要关注处理状态变化的业务逻辑, 无状态组件主要关注组件UI的渲染。 属性校验和默认值12345678910import PropTypes from 'prop-types';class PostItem extends React.Component { // ...}PostItem.propsTypes = { post: PropTypes.object, onVote: PropTypes.func} 如果属性是一个对象或数组,至于对象的结构或数组元素类型无法确定。这种情况下使用PropTypes.shape 或PropTypes.arrayOf 1234567891011style: PropTypes.shape({ color: PropTypes.string, fontSize: PropTypes.number}),// 必传属性 isRequiredsqeuence: PropTypes.arrayof(PropTypes.number).isRequired// 默认属性PostItem.defaultProps = { name: 'Lucy'} 组件与元素React元素是一个普通的Javascript对象, 通过DOM节点或React组件描述界面.JSX语法就是用来创建React元素的。 React组件是一个class或函数，它接收一些属性作为输入，返回一个React元素。React组件由若干React元素组件而成。 React生命周期1. 挂载阶段 constructor组件被创建时，会先调用组件的构造方法。构造方法接收一个props参数，props是从父组件中传入的属性对象，如果父组件中没有传入属性而组件自身定义了默认属性，props执行组件默认属性。必须在和这个方法中先调用super(props)才能保证props被传入组件中. constructor常用于初始化组件的state以及绑定时间处理方法等工作。 componentWillMount 组件被挂载到DOM前调用，只会调用一次。 调用this.state不会引发组件重新渲染 render 定义组件时唯一必要的方法(其他生命周期方法都可以省略) render并不负责组件的实际渲染工作，只返回UI的描述，渲染页面DOM的工作由React自身负责 不能在render调用this.setState会改变组件状态 componentDidMount 组件被挂载到DOM后调用, 且只会被调用一次。 可以获取到DOM结构, 依赖DOM节点的操作可以放到这个方法中 通常会用于向服务器请求数据, 调用this.setState会引起组件重新渲染 2. 更新阶段props引起组件更新时由渲染该组件的父组件引起的. 当父组件的render被调用时组件会发生更新过程，无论props是否改变，父组件render方法每调用一次，会导致组件更新。state组件更新是通过this.state修改组件state来触发的。 componentWillReceiveProps(nextProps) props引起组件更新过程才会调用 state引起的组件更新不会触发该方法执行。 需要比较nextProps与this.props来决定是否执行props发生变化后的逻辑 tips: - componentWillReceiveProps中调用setState，只有在最近render及其之后的方法中，this.state指向的才是更新后的state。 在render之前的方法shouldComponentUpdate、componentWillUpdate中，this.state依然指向的是更新前的state - 调用setState更新组件状态不会触发componentWillReceiveProps的调用，否则会进入死循环 componentWillReceiveProps-&gt;this.setState-&gt;componentWillReceiveProps shouldComponentUpdate 通过比较nextprops、nextState和组件当前的props、state决定这个方法的返回结果。 true： 继续更细过程 false： 组件停止更新，后续方法不执行。 可以减少组件不必要渲染，优化组件性能。 componentWillUpdate 一般很少用到 shouldComponentUpdate和componentWillUpdate都不能调用setState，否则会引起循环调用。 render componentDidUpdate(preProps, preState) 更新后调用可以操作更新后的DOM 两个参数代表调用前的props和state 3. 卸载阶段 componentWillUnmount 组件被卸载前调用 执行清理工作，如：取消定时器，手动创建DOM元素，取消http请求，以避免内存泄漏。 ==只有类组件才有生命周期方法，函数组件没有生命周期方法！！！！！！== 事件绑定12345678handleClick = (event) =&gt; { const number = ++this.state.number; this.setState({ number: number });}&lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt; 受控组件 非受控组件 受控组件：非表单元素只需根据组件的属性或状态进行渲染 如果一个表单元素的值是由React来管理的，那么它就是一个受控组件。 状态不受React控制的表单元素为非受控组件。input，textarea，select等 React中，装填的修改必须通过组件的state，非受控组件的行为有悖于这一原则。 为了让表单元素状态变更也能通过组件的state管理，React采用受控组件的技术达到这一目的。 受控组件保证了表单元素的状态也由React统一管理，但需为每个表单元素定义onChange事件的处理函数， 把表单状态同步到React组件的state。这一过程比较繁琐。 一种替代方案是使用非受控组件。表单元素的状态依然由表单元素自己管理，而不是交给React组件管理。使用非受控组件需要有一种方式可以获取到表单元素的值，React中提供了一种特殊的属性ref, 用来引用React组件或DOM实例。因此可以通过为表单元素定义ref属性获取元素的值。 看似简化了操作表单元素的过程，但破坏了React对组件状态管理的一致性，旺旺容易出现不容易排查的问题，非特殊情况，不建议使用。 React 16新特性 render新的返回类型 React156之前必须返回单个元素。现在支持两种新的返回类型：数组(由React元素组成)和字符串。 123456789101112131415class ListComponent extends Component { render() { return [ &lt;li key=&quot;A&quot;&gt;First item&lt;/li&gt;, &lt;li key=&quot;B&quot;&gt;Second item&lt;/li&gt;, &lt;li key=&quot;C&quot;&gt;Third item&lt;/li&gt; ]; }}class StringComponent extends Component { render() { return &quot;Just a strings&quot;; }} 错误处理 React16之前运行期执行出错，会阻塞整个应用的渲染。只能刷新页面才能恢复应用。 React16引入新的错误处理机制，默认情况下组件中抛出错误，组件会从组件树中卸载，避免整个应用崩溃。 还提供了错误边界(Error Boundaries),可以输出错误日志，显示错误提示.componentDidCatch(error, info) ————–我的点评————–项目中目前从后端返回的数据取值。eg: 1res.data.userInfo[0].nickName 任何一个节点没有数据都可能引发异常通常需要 1res &amp;&amp; res.data &amp;&amp; res.data.userInfo &amp;&amp; ... 解决办法：可以自己写个isEmpty 或引用lodash.isEmpty Portals可以把组件渲染到当前组件树以外的DOM节点上。典型应用场景是渲染应用的全局弹框。使用Portals后，任意组件都可以将弹框组件渲染到根节点上。 Portals的实现依赖ReactDOM的一个新API:ReactDOM.createPortal(child, container)第一个参数child是可以被渲染的React节点。container是一个DOM元素，child将被挂载到这个DOM节点。 eg: 123456789101112131415161718192021222324252627class Modal extends Component { constructor(props) { super(props); // 根节点下创建一个div节点 this.container = document.createElement(&quot;div&quot;); document.body.appendChild(this.container); } componentWillUnmount() { document.body.removeChild(this.container); } render() { // 创建的DOM树挂载到this.container指向的div节点下面 return ReactDOM.createPortal( &lt;div className=&quot;modal&quot;&gt; &lt;span className=&quot;close&quot; onClick= {this.props.onClose}&gt; &amp;times; &lt;/span&gt; &lt;div className=&quot;content&quot;&gt; {this.props.children} &lt;/div&gt; &lt;/div&gt;, this.container ); }} App中使用Modal 1234567891011121314151617181920class App extends Component { constructor(props) { super(props); this.state = { showModal: true }; } // 关闭 closeModal = () =&gt; { this.setState({ showModal: false }); }; render() { return ( &lt;div&gt; &lt;h2&gt;Dashboard&lt;/h2&gt; {this.state.showModal &amp;&amp; ( &lt;Modal onClose={this.closeModal}&gt;Modal Dialog&lt;/Modal&gt; )} &lt;/div&gt;); }}export default App; 自定义DOM属性 React16可以识别自定义属性, 传递给DOM元素 &lt;div custom-attribute=&quot;something&quot; /&gt; 还有其他特性 setState传入null时不会再触发组件更新 更高效的服务器端渲染方式 设计合适的statestate必须能代表一个组件UI呈现的完整状态集。组件的任何UI改变都可以从state的变化中反映出来; 同时state还必须代表一个组件UI呈现的最小状态集，即state中的所有状态都用于反映组件UI的变化，没有任何多余状态，也不应该存在通过其他状态计算而来的中间状态。 eg:错误的state 1234{ purchaseList: [], totalCost: 0} 包含无用的状态totalCost，totalCost可以根据购买的每一项物品的价格和数量计算得出。totalCost属于中间状态，可以省略。 state可以分为两类数据： 用作渲染组件时使用到的数据来源 用作组件UI展现形式的判断依据 state与组件的普通属性 定义：除了state，props以外的组件属性成为组件的普通属性。 在ES6中，可以使用this.{属性名}定义一个class的属性，可以说属性是直接挂载到this下的变量。因此state， props也是组件的属性，只不过它们是React为我们Component Class中预定义好的属性。 123456789class Hello extends React.Component { constructor(props) { super(props); this.timer = null; // 普通属性 this.state = { date: new Date() } }} 使用场景：当组件中需要用到一个变量，并且它与组件的渲染无关时，就应该把这个变量定义为组件的普通属性，直接挂载到this下，而不是作为组件state。更直观的判断方法，看组件render方法中有没有用到这个变量，没有，就是普通属性。 总结：判断一个变量是不是应该作为state可以通过以下4条依据判断： 是否通过props从父组件中获取？是，不是state 是否在组件整个生命周期中保持不变？是，不是state 是否可以通过其他state或props计算得到？是，不是state 是否在组件render方法中使用？是，不是state，定义为普通属性更合适 state的修改 不能直接修改 this.state.title = 'react' //错误 state更新是异步的 state的更新时一个合并的过程 state与不可变对象React官方建议把state当做不可变对象： 直接修改this.state, 组件不会重新render state中包含的所有状态都应该是不可变对象 state中的某个状态发生变化，应该重新创建这个状态对象，而不是直接修改原来的状态。 如何创建新的状态呢？三种情况 不可变类型(数字，字符串，布尔值，null，undefined)—直接赋值 12345this.setState({ count: 1, title: 'React', success: true}) 数组—concat, 扩展语法(spread syntax) 1234567this.setState(preState =&gt; ({ books: preState.books.concat(['React Guide'])}))this.setState(preState =&gt; ({ books: [...preState.books, 'React Guide']})) 截取部分元素作为新状态123this.setState(preState =&gt; ({ books: preState.books.slice(1,3)})) 过滤部分元素作为新状态12345this.setState(preState =&gt; ({ books: preState.books.filter(item =&gt; { return item !== 'React'; })})) 注意：不要使用push,pop,shift,unshift,splice等方法修改数组类型状态。因为这些方法都是在原数组基础上修改，而从concat,slice,filter会返回一个新数组。 普通对象(不包含字符串，数组)—Object.assign,对象扩展语法(object spread properties)1234567this.setState(preState =&gt; ({ owner: Object.assign({}, preState.owner, {name: 'James Bond'})}))this.setState(preState =&gt; ({ owner: {...preState.owner, name: 'James Bond'}})) 总结： 创建新状态对象的关键，避免使用会直接修改原对象的方法，而使用可以返回一个新对象的方法。 也可用一些Immutable的JS库，(如Immutable.js) 为什么组件的状态是不可变对象？ 对不可变兑现的修改会返回一个新对象，不用但系原有对象在不小心情况下修改导致的错误，方便管理和调试 出于性能考虑，当对象组件状态都是不可变对象时，在shouldComponentUpdate方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，避免不必要的render调用。 componentDidMount执行请求最佳，原因两个 在componentDidMount中执行请求可以保证获取到数据时，组件已处于挂载状态。即使操作DOM也是安全的。 componentWillMount无法保证 组件在服务端渲染时componentWillMount会调用两次，一次在服务端，一次在浏览器端。 而componentDidMount能保证在任何情况下只调用一次。不会发送多余的请求。 组件更新阶段也可以发送请求，获取服务最新数据。例如：组件需要以props中某个属性作为与服务器通信时请求参数，当这个值发生更新，需要重新发起请求。在componentWillReceiveProps阶段处理。 12345678class ListContainer extends React.Component { // ... componentWillReceiveProps(nextProps) { fetch('url').then(res=&gt;{ // ... }) }} fetch之前需要对nextProps判断，如果不一致再发起请求 组件通信父子组件通信–通过props父向子是通过父组件向子组件的props传递数据完成 子向父：父组件通过子组件的props传递给子组件一个回调函数，子组件在需要改变父组件时，调用这个回调函数 1234567// 父&lt;UserList users={this.state.users}/&gt;// 父&lt;UserList users={this.state.users} onAddUser={this.handleAddUser}/&gt;// 子&lt;button onClick={this.props.onAddUser}&gt; 兄弟组件通信兄弟组件：有相同父组件，不是父子组件的组件。 兄弟组件不能直接互传数据，需要通过状态提升的方式实现兄弟组件的通信。把组件之间需要共享的状态保存到距离它们最近的共同父组件内，任一兄弟组件都可以通过父组件传递的回调函数来修改共享状态，父组件中的共享状态的变化也会通过props向下传递给所有兄弟组件，完成兄弟组件之间的通信 Context–实验性API,不建议使用，会让数据流变得混乱组件层级太深，props传递层级繁琐。context让任意层级的子组件都可以获取父组件的状态和方法 其他通信方式 消息队列 改变数据的组件发起消息，使用数据的组件监听，在响应函数中触发setState改变组件状态。–观察者模式 (EventEmitter或Postal.js等消息队列库) Redux, MobX状态管理库。 ref优点： 获取表单元素，获取其他任意DOM元素，获取React组件实例用处：控制元素焦点，文本选择，第三方操作DOM库集成 缺点：避免使用ref,破坏了React中以props为数据传递介质的典型数据流ref接收一个回调函数作为值，在组件被挂载或卸载时，回调函数会被调用。组件被挂载时，回调函数会接收当前DOM元素作为参数；组件被卸载时回调函数会接收null作为参数 在DOM 上使用ref让input自动获取焦点 12345678910111213141516class AutoFocusInput extends React.Component { componentDidMount() { // 通过ref让input自动获取焦点 this.textInput.focus(); } blur= () =&gt; { this.textInput.blur(); } render() { return ( &lt;div&gt; &lt;input type='text' ref={(input) =&gt; {this.textInput = input}}/&gt; &lt;/div&gt; ) }} 组件上使用refref的回调函数接收的参数是当前组件的实例。提供了一种在组件外部操作组件的方式。 123// 通过ref调用AutoFocusInput组件的方法this.inputInstance.blur();&lt;AutoFocusInput ref={input =&gt; {this.inputInstance = input}}/&gt; 注意：只能为累组件定义ref属性，不能为函数组件定义ref属性。但可以在函数组件内部使用ref引用其他DOM元素或组件。 1234567891011121314function MyFuncitonCom() { let textInput = null; function handleClick() { textInput.focus(); } return( &lt;div&gt; &lt;input ref={(input) =&gt; {textInput = input;}} /&gt; &lt;button onClick={handleClick}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; )} 父组件访问子组件的DOM节点因为ref只能访问子组件的实例对象，而不能获取子组件中的某个DOM元素。 可以采用一种间接方式获取子组件的DOM元素：在子组件的DOM元素上定义ref, ref的值是父组件传递给子组件的一个回调函数，回调函数可以通过一个自定义的属性传递，例如inputRef,这样父组件的回调函数中就能获取到这个DOM元素。 123456789101112131415161718function Children(props) { // 子组件使用父组件传递的inputRef， 为input的ref赋值 return ( &lt;div&gt; &lt;input ref={props.inputRef}/&gt; &lt;/div&gt; );}class Parent extends React.Component { render() { // 自定义一个属性inputRef, 值是一个函数 return ( &lt;Children inputRef={el =&gt; this.inputElement = el} /&gt; ); }} 可以看到即使子组件是函数组件，这种方式同样有效。 虚拟DOM虚拟DOM是用来描述真实DOM的JavaScript对象。 1234567891011121314151617&lt;div className='foo'&gt; &lt;h1&gt;Hello React&lt;/h1&gt;&lt;/div&gt;对应的JavaScript对象{ type: 'div', props: { className: 'foo', children: { type: 'h1', props: { children: 'Hello React' } } }} 虚拟DOM是普通的JavaScript对象，访问JavaScript对象当然比访问真实DOM快得多 Diff算法React采用声明式API描述UI结构，每次组件的状态或属性更新，render方法都会返回一个新的虚拟DOM对象，用来标书新的UI结构。如果每次render都直接使用新的虚拟DOM来生成真实DOM结构，会带来大量对真实DOM操作，影响效率。React通过比较两次虚拟DOM结构的变化找出差异部分，更新到真实DOM上，从而减少最终要在真实DOM上的操作，提高效率。这就是React的调和过程(Reconciliation).其中的关键是比较两个树形结构的Diff算法。基于两种假设, 算法复杂度从O(N^3)–&gt; O(N) 两个元素类型不同，它们将生成两棵不同的树 为列表元素设置key属性，用key标识对应元素在多次render过程中是否发生变化 React如何比较两棵树的差异从根节点开始比较，根节点类型不同，React执行的操作也不同 根节点不同类型React认为新树和旧树完全不同，不再继续比较其他属性和子节点。把整棵树拆掉重建(包括虚拟DOM和真实DOM) 虚拟DOM节点分为两类：DOM元素，div,p等；react组件类型，自定义组件等。拆除过程中，旧的DOM元素类型节点被销毁，旧的react组件实例的componentWillUnmount会被调用重建过程中，新的DOM元素被插入DOM树，新的组件实例的componentWillMount和componentDidMount会被调用 更新效率最低 根节点是相同DOM元素类型两个根节点相同类型的DOM元素，React会保留根节点，比较根节点的属性，然后只更新那些变化了的属性 根节点是相同的组件类型两个根节点是相同类型的组件，对应的组件实例不会被销毁，只是会执行更新操作。同步变化的属性到虚拟DOM树上，组件的componentWillReceiveProps和componentWillUpdate会被调用 需在组件更新并且render方法执行完成后，根据render返回的虚拟DOM结构决定如何更新真实DOM树 如此递归比较，直到比较完两棵树上所有节点，计算得到最终差异，更新到DOM树上。 key的重要性对多个li这种情况，React提供了key属性。key帮助React提高diff算法效率。当一组子节点定义了key，React会根据key来匹配子节点，在每次渲染之后，只要子节点的key值没有变化，React就认为这是同一个节点。尽量不要使用元素在列表中的索引值作为key，因为列表中的元素顺序发生变化，可能导致大量的key失效，进而引起大量的修改操作。 123&lt;ul&gt; {list.map((item, index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;)}&lt;/ul&gt; key的使用，减少了DOM操作，提高了DOM更新效率，当列表元素数量很多时，key的使用更显得重要 React性能优化 使用生产环境版本的库 避免不必要的组件渲染–shouldComponentUpdate， pureComponent 使用key 性能检测工具 React Developer Tools for Chrome背景是黑色表示用生产环境版本的React，红色表示开发环境版本 Chrome Performance Tab why-did-you-update 高阶组件主要用来实现组件逻辑的抽象和服用本质：也是一个函数，并不是一个组件 装饰器设计模式 基本概念JavaScript中，高阶组件是以函数为参数，并且返回值也是函数的函数。类似的高阶组件(简称HOC), 接收React组件作为参数，并且返回一个新的React组件 形式：const EnhancedComponent = higherOrderComponent(WrappedComponent); 主要功能封装并分离组件的通用逻辑，让通用逻辑在组件间更好的被复用。 使用场景 操纵props 通过ref访问组件实例 组件状态提升 用其他元素包装组件 React Router—-划分组件原则划分页面组件需要根据页面结构、组件的复用性、组件的复杂度等因素综合考虑 划分组件两个极端，组件粒度过大或过小。过大，组件逻辑过于复杂，可维护性和复用性变差；过小，组件数量激增，一个简单功能需引入大量组件，增加开发成本，过多也不利于查找。 一种观点是一个组件只负责一个功能。建议辩证看待。如果几个功能都很简单，且每一个功能都没有复用需求，那么把这几个功能放到一个组件也可，提高开发效率。 代码分片实现代码按需加载，提高应用加载速度 借助bundle-loader来实现按需加载。1import ListContainer from 'bundle-loader?lazy&amp;name=app-[name]!./app/list.js'; 动态import ReduxRedux 通过reducer解析action reducer是一个普通的JavaScript函数，接收action为参数，然后返回一个新的应用状态state。 主要思想：描述应用的状态如何根据action进行更新，Redux通过提供一系列API将这一主要思想的落地实施进行标准化和规范化。 三大原则 唯一数据源Redux只维护一个全局的状态对象，存储在Redux的store中。唯一数据源是一种集中式管理应用状态的方式，便于监控任意时刻应用的状态和调试应用，减少出错可能性。 保持应用状态只读任何时刻都不能直接修改应用状态。需要修改，必须发送一个action，由这个action描述如何修改应用状态。保证了大型应用中状态管理的有序进行。 应用状态的改变通过纯函数完成action表明修改应用状态的意图，真正对应用状态做修改的是reducer reducer必须是纯函数，所以reducer在接收action时，不能直接修改原来的状态对象，而要创建一个新的状态对象返回。 纯函数必须满足两个条件 对于同样的参数值，函数的返回结果总是相同的。函数结果不依赖任何在程序执行过程中可能改变的变量。 函数的执行不会产生副作用，例如修改外部对象或输出到I/O设备。 主要组成action, reducer, store actionaction是Redux中信息的载体， 是store唯一的信息来源。action发送给store必须通过store的dispatch。 action是普通的JavaScript对象，但每个action必须有一个type属性描述action的类型，一般被定义为字符串常量。除了type属性之外，action的结构完全由自己决定，但应该能确保action的结构能清晰的描述实际业务场景。 一般通过action creator创建action， action creator是返回action的函数。如下： 123456function addTodo(text) { return { type: 'ADD_TODO', text }} reduceraction用于描述应用发生了什么操作， reducer则根据action做出响应，决定如何修改state. state既可以包含服务器端获取的数据，也可以包含UI状态。 最基本的reducer, eg: 123456789101112import { VisibilityFilters } from './acitons'const initialState = { todos: [], visibilityFilter: VisibilityFilters.SHOW_ALL}// reducerfunction todoApp(state = initialState, action) { return state} storestore是action和reducer之间的桥梁。负责以下工作： 保存应用状态 通过getState访问应用状态 通过dispatch(action)发送更新状态的意图 通过subscribe(listener)注册监听函数、监听应用状态的改变。 一个Redux应用中只有一个store，store保存了唯一数据源。store通过createStore()创建，创建时需要传递reducer作为参数，创建store。 12345import { createStore } from 'redux'import todoApp from './reducers'let store = createStore(todoApp) 总结redux数据流过程 调用store.dispatch(action)。可以在任何地方调用。包括组件，XHR回调，定时器等。 store调用reducer。store传递两个参数给reducer：当前应用的状态和action。 根reducer会把多个子reducer的返回结果组合成最终的应用状态。redux提供了combineReducer方便组合。 store保存根reducer返回的完整应用状态。此时应用状态才完成更新。 react-redux展示组件和容器组件根据组件意图的不同，可以将组件划分为两类：展示组件(presentational components)和容器组件(container components). 展示组件负责应用的UI展示(how things look), 展示组件不关心渲染时使用的数据是如何获取的，数据如何获取是容器组件负责的事情。 容器组件负责应用逻辑的处理(how things work), 如发送请求，处理返回数据，将处理过的数据传递给展示组件等。还提供修改源数据的方法，通过展示组件的props传递给展示组件，当展示组件的状态变更引起源数据变化时，展示组件通过调用容器组件提供的方法同步这些变化。 展示组件和容器组件可以自由嵌套。这样的分工可以使与UI渲染无直接关系的业务逻辑由容器组件集中负责，展示组件只关注UI的渲染逻辑，从而使展示组件更容易被复用。 展示组件和容器组件与无状态组件和有状态组件区别：划分依据：展示组件和容器组件是根据组件的意图划分组件无状态组件和有状态组件是根据组件内部是否使用state划分组件。 通常展示组件是通过无状态组件实现，容器组件通过有状态组件实现。但展示组件也可以是有状态组件，容器组件也可以是无状态组件。 connectreact-redux提供了connect函数，用于把react组件和redux的store连接起来，生成一个容器组件，负责管理数据管理和业务逻辑。 12345import { connect } from 'react-redux'import TodoList from './TodoList'const VisibleTodoList = connect()(TodoList); 根据Redux的数据流过程，VisibleTodoList需要承担两个工作： 从Redux的store中获取展示组件所需的应用状态 把展示组件的状态同步到Redux的store中 通过两个参数实现 1234567import { connect } from 'react-redux'import TodoList from './TodoList'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList); mapStateToProps 和 mapDsipatchToProps 的类型都是函数，前者负责从全局应用状态state中取出所需数据，映射到展示组件的props，后者负责把需要用到的action映射到展示组件的props上 mapStateToPropsmapStateToProps作用是把state转换成props。state是store中保存的应用状态，会作为参数传递给mapStateToProps，props是被连接的展示组件的props。 每当store中的state更新时，mapStateToProps会重新执行，重新计算传递给展示组件的props，从而触发组件的重新渲染。 store中的state更新一定会导致mapStateToProps重新执行，但不一定会触发组件render方法的重新执行。如果mapStateToProps新返回的对象和之前的对象浅比较(shallow comparison)相等，组件的shouldComponentUpdate会返回false，render不再触发。 connect可以省略mapStateToProps参数，这样state的更新就不会引起组件的重新渲染。 mapStateToProps除了接收state参数外，还可以使用第二个参数，代表容器组件的props对象 12345// ownProps 是组件的props对象function mapStateToProps(state, ownProps) { //...} mapDispatchToProps！！！！容器组件除了可以从state中读取数据外，还可以发送action更新state，这依赖于connect的第二个参数 mapDispatchToProps. mapDispatchToProps 接收 store.dispatch 方法作为参数返回展示组件用来修改state的函数。 12345678910111213// toggleTodo(id) 返回一个actionfunction toggleTodo(id) { return {type: 'TOGGLE_TODO', id}}function mapDispatchToProps(dispatch) { return { onTodoClick: funciton(id) { dispatch(toggleTodo(id)) } }} 这样展示组件内就可以调用 this.props.onTodoClick(id) 的action。与mapStateToProps相同，mapDispatchToProps也支持第二个参数，代表容器组件的props。 Provider组件通过connect函数创建出容器组件，但这个容器组件如何获取到Redux的store？react-redux提供了Provider组件，示意代码如下： 12345678910111213141516class Provider extends Component { getChildContext() { return { store: this.props.store }; } render() { return this.props.children; }}Provider.childContextTypes = { store: React.PropTypes.object} Provider组件需要接收一个store属性，然后把store保存到context。Provider组件正是通过context把store传递给子组件，所以使用Provider组件时，一般把它作为根组件，这样内层的任意组件才可以从context中获取store对象。 1234567891011121314import {createStore} from 'redux'import {Provider} from 'react-redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 中间件与异步操作中间件redux的action类比web框架收到的请求，reducer类比web框架的业务逻辑层，因此redux的中间件代表action在到达reducer前经过的处理程序。 实际上，一个redux中间件就是一个函数。redux中间件增强了store的功能，可以利用中间件为action添加一些通用功能，如日志输出，异常捕获等。 通过改造 store.dispatch 增加日志输出功能： 123456789let next = store.dispatchstore.dispatch = function dispatchAndLog(action) { console.log('dispatching', action) let result = next(action) console.log('next state', store.getState()) return result} 通过重新定义store.dispatch，在发送action前后都添加了日志输出，这就是中间件的雏形。 对store.dispatch方法进行搞糟，在发出action和执行 reducer 这两步之间添加其他功能。 实际项目中通常使用别人直接写好的中间件。如redux-logger. 在应用中会用到applyMiddleware。通过applyMiddleware将中间件logger传给createStore, 完成store.dispatch功能的加强。 applyMiddleware把接收到的中间件放入数组chain中，通过compose(…chain)(store.dispatch)定义加强版的dispatch。 compose是工具函数，compose(f, g, h)等价于 (…args)=&gt;f(g(h(args))). 每个中间件都接收一个包含getState和dispatch的参数对象，在利用中间件执行异步操作时，会用到这两个方法。 异步操作redux中的异步操作必须借助中间件完成。 redux-thunk是处理异步操作最常用的中间件。 store.dispatch 只能接收普通JavaScript对象代表的action，使用redux-thunk，store.dispatch 就能接收函数作为参数了。异步action先经过redux-thunk的处理，当请求返回后，再发送一个action: dispatch({type: ‘RECEIVE_DATA’, json}), 把返回的数据发送出去，这时的action就是一个普通的JavaScript对象了，处理流程和不使用中间件流程一样。 常用中间件 redux-promise, redux-sage等。 小结本章详细介绍了redux架构以及Redux各组成部分(action, reducer, store)，在react项目中使用redux需要借助react-redux，可以方便的将react组件和redux的store连接。中间件是redux的一大利器，redux中执行异步操作就是通过引入中间件实现的。 redux实战经验设计state设计state容易犯的两个错误： 以API作为设计state的依据以API作为设计state的依据往往是一个API对应全局state中的一部分结构，且这部分结构同API返回的数据结构保持一致或接近一致。 因为API是基于服务端逻辑设计的，而不是基于应用状态设计的。 以页面UI为设计state的依据基于页面UI设计state 。页面UI需要什么样的数据和数据结构，state就设计成什么样。 合理设计state最重要一句话：像设计数据库一样设计state。 把state看做一个数据库，state中的每一部分状态看做数据库中的一张表，状态中每个字段对应表的一个字段。 设计数据库遵循三个原则： 数据按照领域(Domain)分类存储在不同的表中，不同表中存储的列数据不能重复 表中每一列的数据都依赖于这张表的主键 表中除了主键以外其他列互相之间不能有直接依赖关系 对照以上三个原则，设计state原则： 整个应用的状态按照领域分成若干子状态，子状态之间不能保存重复的数据 state以键值对的结构存储数据，以记录的key活ID作为记录索引，记录中的其他字段都依赖于索引 state中不能保存可以通过state中的已有字段计算而来的数据，即state中的字段不互相依赖。 有开发者习惯把UI状态数据保存在组件state中，由组件自己管理，而不是交给Redux管理。但将UI状态数据也交给redux统一管理有利于应用UI状态的追溯。 设计模块定义模块不能只被UI组件使用，各个模块之间也可以互相调用 action和reducer之间并不存在一对一的关系。一个action可以被多个模块的reducer处理，尤其是多个模块之间存在关联关系时。 良好的模块设计对外暴露的应该是模块的接口，而不是模块的具体结构 性能优化","link":"/posts/React%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"十大经典排序算法总结（JavaScript描述）","text":"======================== ss前言 这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript….当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，JavaScript可谓风头无两，已经坐上了头把交椅。 在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（十大排序算法或是和十大排序算法同等难度的），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。 算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。 正文排序算法说明（1）排序的定义：对一序列对象根据某个关键字进行排序； 输入：n个数：a1,a2,a3,…,an 输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’&lt;=a2’&lt;=a3’&lt;=…&lt;=an’。 再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。 （3）对于评述算法优劣术语的说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度: 一个算法执行所耗费的时间。 空间复杂度: 运行完一个程序所需内存的大小。 关于时间空间复杂度的更多了解请戳这里，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。 （4）排序算法图片总结(图片来源于网络): 排序对比： 图片名词解释： n: 数据规模 k:“桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存 排序分类： 1.冒泡排序（Bubble Sort） 好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。 (1)算法描述 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 (2)算法描述和实现具体算法描述如下： &lt;1&gt;.比较相邻的元素。如果第一个比第二个大，就交换它们两个； &lt;2&gt;.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； &lt;3&gt;.针对所有的元素重复以上的步骤，除了最后一个； &lt;4&gt;.重复步骤1~3，直到排序完成。 JavaScript代码实现： function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len; i++) { for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 **改进冒泡排序： **设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 改进后算法如下: function bubbleSort2(arr) { console.time('改进后冒泡排序耗时'); var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) { var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++) if (arr[j]&gt; arr[j+1]) { pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; } i= pos; //为下一趟排序作准备 } console.timeEnd('改进后冒泡排序耗时'); return arr; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 改进后的算法实现为: function bubbleSort3(arr3) { var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time('2.改进后冒泡排序耗时'); while (low &lt; high) { for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) { tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; } --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) { tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; } ++low; //修改low值,后移一位 } console.timeEnd('2.改进后冒泡排序耗时'); return arr3; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 三种方法耗时对比： 由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~ 冒泡排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢….） 最差情况：T(n) = O(n2) 当输入的数据是反序时(卧槽，我直接反序不就完了….) 平均情况：T(n) = O(n2) 2.选择排序（Selection Sort） 表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度…..所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 (1)算法简介 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 (2)算法描述和实现n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： &lt;1&gt;.初始状态：无序区为R[1..n]，有序区为空； &lt;2&gt;.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； &lt;3&gt;.n-1趟结束，数组有序化了。 Javascript代码实现: function selectionSort(arr) { var len = arr.length; var minIndex, temp; console.time('选择排序耗时'); for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { //寻找最小的数 minIndex = j; //将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } console.timeEnd('选择排序耗时'); return arr; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 选择排序动图演示： (3)算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 3.插入排序（Insertion Sort） 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了….. (1)算法简介 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 (2)算法描述和实现一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： &lt;1&gt;.从第一个元素开始，该元素可以认为已经被排序； &lt;2&gt;.取出下一个元素，在已经排序的元素序列中从后向前扫描； &lt;3&gt;.如果该元素（已排序）大于新元素，将该元素移到下一位置； &lt;4&gt;.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； &lt;5&gt;.将新元素插入到该位置后； &lt;6&gt;.重复步骤2~5。 Javascript代码实现: function insertionSort(array) { if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') { console.time('插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) { var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } console.timeEnd('插入排序耗时：'); return array; } else { return 'array is not an Array!'; } } 复制代码 改进插入排序： 查找插入位置时使用二分查找的方式 function binaryInsertionSort(array) { if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') { console.time('二分插入排序耗时：'); for (var i = 1; i &lt; array.length; i++) { var key = array[i], left = 0, right = i - 1; while (left &lt;= right) { var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) { right = middle - 1; } else { left = middle + 1; } } for (var j = i - 1; j &gt;= left; j--) { array[j + 1] = array[j]; } array[left] = key; } console.timeEnd('二分插入排序耗时：'); return array; } else { return 'array is not an Array!'; } } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 改进前后对比： 插入排序动图演示: (3)算法分析 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n2) 平均情况：T(n) = O(n2) 4.希尔排序（Shell Sort） 1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 (1)算法简介 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。 (2)算法描述和实现先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： &lt;1&gt;. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； &lt;2&gt;.按增量序列个数k，对序列进行k 趟排序； &lt;3&gt;.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Javascript代码实现： function shellSort(arr) { var len = arr.length, temp, gap = 1; console.time('希尔排序耗时:'); while(gap &lt; len/5) { //动态定义间隔序列 gap =gap*5+1; } for (gap; gap &gt; 0; gap = Math.floor(gap/5)) { for (var i = gap; i &lt; len; i++) { temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } console.timeEnd('希尔排序耗时:'); return arr; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 希尔排序图示（图片来源网络）： （3）算法分析 最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog n) 5.归并排序（Merge Sort） 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 (1)算法简介 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 (2)算法描述和实现具体算法描述如下： &lt;1&gt;.把长度为n的输入序列分成两个长度为n/2的子序列； &lt;2&gt;.对这两个子序列分别采用归并排序； &lt;3&gt;.将两个排序好的子序列合并成一个最终的排序序列。 Javscript代码实现: function mergeSort(arr) { //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { var result = []; console.time('归并排序耗时'); while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd('归并排序耗时'); return result; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(mergeSort(arr)); 复制代码 归并排序动图演示: (3)算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 6.快速排序（Quick Sort） 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。 (1)算法简介 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 (2)算法描述和实现快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： &lt;1&gt;.从数列中挑出一个元素，称为 “基准”（pivot）； &lt;2&gt;.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； &lt;3&gt;.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 Javascript代码实现： /*方法说明：快速排序 @param array 待排序数组*/ //方法一 function quickSort(array, left, right) { console.time('1.快速排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' &amp;&amp; typeof left === 'number' &amp;&amp; typeof right === 'number') { if (left &lt; right) { var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) { if (array[j] &lt;= x) { i++; temp = array[i]; array[i] = array[j]; array[j] = temp; } } quickSort(array, left, i - 1); quickSort(array, i + 1, right); } console.timeEnd('1.快速排序耗时'); return array; } else { return 'array is not an Array or left or right is not a number!'; } } //方法二 var quickSort2 = function(arr) { console.time('2.快速排序耗时'); &amp;emsp;&amp;emsp;if (arr.length &lt;= 1) { return arr; } &amp;emsp;&amp;emsp;var pivotIndex = Math.floor(arr.length / 2); &amp;emsp;&amp;emsp;var pivot = arr.splice(pivotIndex, 1)[0]; &amp;emsp;&amp;emsp;var left = []; &amp;emsp;&amp;emsp;var right = []; &amp;emsp;&amp;emsp;for (var i = 0; i &lt; arr.length; i++){ &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;if (arr[i] &lt; pivot) { &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;left.push(arr[i]); &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;} else { &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;right.push(arr[i]); &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;} &amp;emsp;&amp;emsp;} console.timeEnd('2.快速排序耗时'); &amp;emsp;&amp;emsp;return quickSort2(left).concat([pivot], quickSort2(right)); }; var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 快速排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) 7.堆排序（Heap Sort） 堆排序可以说是一种利用堆的概念来排序的选择排序。 (1)算法简介 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 (2)算法描述和实现具体算法描述如下： &lt;1&gt;.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； &lt;2&gt;.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； &lt;3&gt;.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 Javascript代码实现： /*方法说明：堆排序 @param array 待排序数组*/ function heapSort(array) { console.time('堆排序耗时'); if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') { //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) { heapify(array, i, heapSize); } //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) { temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); } console.timeEnd('堆排序耗时'); return array; } else { return 'array is not an Array!'; } } /*方法说明：维护堆的性质 @param arr 数组 @param x 数组下标 @param len 堆大小*/ function heapify(arr, x, len) { if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' &amp;&amp; typeof x === 'number') { var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) { largest = l; } if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) { largest = r; } if (largest != x) { temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); } } else { return 'arr is not an Array or x is not a number!'; } } var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22]; console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] 复制代码 堆排序动图演示： (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn) 8.计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 (1)算法简介 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 (2)算法描述和实现具体算法描述如下： &lt;1&gt;. 找出待排序的数组中最大和最小的元素； &lt;2&gt;. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； &lt;3&gt;. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； &lt;4&gt;. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 Javascript代码实现： function countingSort(array) { var len = array.length, B = [], C = [], min = max = array[0]; console.time('计数排序耗时'); for (var i = 0; i &lt; len; i++) { min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; } for (var j = min; j &lt; max; j++) { C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); } for (var k = len - 1; k &gt;= 0; k--) { B[C[array[k]] - 1] = array[k]; C[array[k]]--; } console.timeEnd('计数排序耗时'); return B; } var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2]; console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9] 复制代码 JavaScript动图演示：、 (3)算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k) 9.桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 (1)算法简介 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 (2)算法描述和实现具体算法描述如下： &lt;1&gt;.设置一个定量的数组当作空桶； &lt;2&gt;.遍历输入数据，并且把数据一个一个放到对应的桶里去； &lt;3&gt;.对每个不是空的桶进行排序； &lt;4&gt;.从不是空的桶里把排好序的数据拼接起来。 Javascript代码实现: /*方法说明：桶排序 @param array 数组 @param num 桶的数量*/ function bucketSort(array, num) { if (array.length &lt;= 1) { return array; } var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time('桶排序耗时'); for (var i = 1; i &lt; len; i++) { min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; } space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) { var index = Math.floor((array[j] - min) / space); if (buckets[index]) { // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) { buckets[index][k + 1] = buckets[index][k]; k--; } buckets[index][k + 1] = array[j]; } else { //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); } } while (n &lt; num) { result = result.concat(buckets[n]); n++; } console.timeEnd('桶排序耗时'); return result; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 桶排序图示（图片来源网络）： 关于桶排序更多 (3)算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2) 10.基数排序（Radix Sort） 基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数； (1)算法简介 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 (2)算法描述和实现具体算法描述如下： &lt;1&gt;.取得数组中的最大数，并取得位数； &lt;2&gt;.arr为原始数组，从最低位开始取每个位组成radix数组； &lt;3&gt;.对radix进行计数排序（利用计数排序适用于小范围数的特点）； Javascript代码实现： /** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数 */ //LSD Radix Sort function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; var counter = []; console.time('基数排序耗时'); for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) { for(var j = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]== null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } var pos = 0; for(var j = 0; j &lt; counter.length; j++) { var value = null; if(counter[j]!=null) { while ((value = counter[j].shift()) != null) { arr[pos++] = value; } } } } console.timeEnd('基数排序耗时'); return arr; } var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]; console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 复制代码 基数排序LSD动图演示： (3)算法分析 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 ![https://user-gold-cdn.xitu.io/2020/2/3/1700919fb9a285de?w=450&amp;h=359&amp;f=png&amp;s=66765](https://juejin.cn/post/data:image/svg+xml;utf8) 后记 十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。 .markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}","link":"/posts/s/"},{"title":"精读你不知道的JavaScript上卷","text":"[TOC] I-第1章作用域是什么编译原理JavaScript是一门编译语言 传统的编译语言在代码执行前会经历三个步骤(编译) 分词/词法分析(Tokenizing/Lexing) 将由字符组成的字符串分解成(对编程语言来说)有意义的代码块(词法单元token) 解析/语法分析(Parsing) 将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树(抽象语法树Abstract Syntax Tree，AST)。 代码生成 将 AST 转换为可执行代码 JavaScript引擎编译过程比普通编译语言更复杂在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。用尽了各种办法(比如 JIT，可以延迟编译甚至实施重编译)来保证性能最佳。 理解作用域(建议多读几遍)当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。 可以将 RHS 理解成 retrieve his source value(取到它的源值)，这意味着“得到某某的值”。在概念上最好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”。 如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。 赋值操作符会导致 LHS 查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 作用域作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。 遍历嵌套作用域链的规则: 从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 编码经验：减少无意义的变量查找次数和未定义变量的查找，可以提升效率 异常RHS 查询遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。 非严格模式：引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。 如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。 ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 案例12345function foo(a) { var b = a; return a + b;}var c = foo( 2 ); 找出所有的LHS查询(这里有3处!) c = ..;、a = 2(隐式变量分配)、b = .. 找出所有的RHS查询(这里有4处!) foo(2..、= a;、a ..、.. b I-第2章 词法作用域词法作用域就是定义在词法阶段的作用域。 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。 全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问window.a，通过这种方式可以访问那些被同名变量所遮蔽的全局变量。 但非全局的变量如果被遮蔽了，无论如何都无法被访问到。 欺骗语法JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。 前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。 后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。会导致性能下降。不要使用它们。 I-第3章 函数作用域和块作用域 开发中，函数写的太多了。怎样才是个好的函数？我们常讲封装。封装函数，封装常用的方法，通过这章内容可以学习到为什么要封装，封装的好处和一些封装的方法。 函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(在嵌套的作用域中也可以使用)。这种设计方案能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。 利用函数作用域隐藏内部实现正确的代码应该考虑到如何选择作用域来包含变量和函数。遵循最小授权原则。 最小授权或最小暴露原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。 示例： 123456789function doSomething(a) { b = a + doSomethingElse( a * 2 ); console.log( b * 3 );}function doSomethingElse(a) { return a - 1;}var b;doSomething( 2 ); // 15 变量 b 和函数 doSomethingElse(..) 是 doSomething(..) 内部具体实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内容隐藏在 doSomething(..) 内部。 123456789function doSomething(a) { function doSomethingElse(a) { return a - 1; } var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );}doSomething( 2 ); // 15 功能和效果都没受影响，设计上将具体内容私有化，设计良好的软件都会依此进行实现。 规避冲突隐藏作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突， 1234567891011function foo() { function bar(a) { i = 3; // 修改for循环所属作用域中的i console.log( a + i ); } for (var i=0; i&lt;10; i++) { bar( i * 2 ); // 糟糕，无限循环了! }}foo(); 这里用var i = 3;和 j = 3;都可以解决这个问题，但使用作用域来“隐藏”内部声明是唯一的最佳选择。 解决方案 全局命名空间 在jQuery时代，引用各种第三方库尤为明显。如果组件没有很好的将内部私有函数和变量隐藏起来会引起很多问题。 最佳实践：声明一个名字足够独特的变量，通常是一个对象。所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。 示例 123456789var MyReallyCoolLibrary = { awesome: &quot;stuff&quot;, doSomething: function() { // ... }, doAnotherThing: function() { // ... }}; 模块管理 从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。 函数作用域优化函数作用域需要显示声明函数名和调用该函数 采用包装函数来解决，将函数声明转成表达式 123456var a = 2;(function foo(){ // &lt;-- 添加这一行 var a = 3; console.log( a ); // 3 })(); // &lt;-- 以及这一行console.log( a ); // 2 1如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 匿名和具名函数匿名函数表达式123setTimeout( function() { console.log(&quot;I waited 1 second!&quot;);}, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数缺点： 匿名函数在栈追踪中不会显示函数名，调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践 123setTimeout( function timeoutHandler() { // &lt;-- 快看，我有名字了! console.log( &quot;I waited 1 second!&quot; );}, 1000 ); 立即执行函数表达式(IIFE Immediately Invoked Function Expression)将函数包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数。比如 (function foo(){ .. })(), 另一种形式(function(){ .. }())。两种形式在功能上是一致的。 IIFE进阶用法，把它们当作函数调用并传递参数进去。 1234567var a = 2;(function IIFE( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2})( window );console.log( a ); // 2 将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。这对于改进代码风格是非常有帮助的。 IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD(Universal Module Definition)项目中被广泛使用。 123456789var a = 2;(function IIFE( def ) { def( window );})(function def( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2}); 块作用域{}, for, if, with, try/catch, let, const都是声明块级作用域。 12345678if (foo) { { // &lt;-- 显式的块 let bar = foo * 2; bar = something( bar ); console.log( bar ); }}console.log( bar ); // ReferenceError 本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 I-第4章 提升 编译器在编译代码时是从上到下一行行编译的吗？ 引擎会在执行 JavaScript 代码之前先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。 变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。 注意：函数声明会被提升，包括函数表达式的赋值在内的赋值操作并不会提升。 函数会首先被提升，然后才是变量。 后面的函数声明可以覆盖前面的，如下输出3 12345678910111213foo(); // 1var foo;function foo() { console.log( 1 );}// 函数表达式不会提升foo = function() { console.log( 2 );};function foo() { console.log( 3 );} 这个代码被引擎解析如下: 1234567891011function foo() { console.log( 1 );}function foo() { console.log( 3 );}foo(); // 3foo = function() { console.log( 2 );}; 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题! 用let和const可以解决重复声明的问题。 I-第5章 作用域闭包闭包当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 经典示例： 123456789function foo() { var a = 2; function bar() { console.log( a ); } return bar;}var baz = foo();baz(); // 2 —— 这就是闭包的效果。 bar() 在自己定义的词法作用域以外的地方执行。 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。 而闭包的“神奇”之处正是可以阻止这件事情的发生。由于 bar() 所声明的位置在foo内部，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 循环经典案例： 123456for (var i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); // 以每秒一次的频率输出五次 6 }, i*1000 );} 根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。 改进，为每次迭代生成新的作用域 1234567for (var i=1; i&lt;=5; i++) { (function(j) { setTimeout( function timer() { console.log( j ); }, j*1000 ); })( i );} 用let解决。let变量在循环过程中不止被声明一次，每次迭代都会声明。 123456for (let i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 );} 模块模块模式需要具备两个必要条件。 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 示例： 1234567891011121314151617181920var foo = (function CoolModule() { var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( &quot; ! &quot; ) ); } return { doSomething: doSomething, doAnother: doAnother };})();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 12345678910111213141516171819202122232425var foo = (function CoolModule(id) { function change() { // modifying the public API publicAPI.identify = identify2; } function identify1() { console.log( id ); } function identify2() { console.log( id.toUpperCase() ); } var publicAPI = { change: change, identify: identify1 }; return publicAPI;})( &quot;foo module&quot; );foo.identify(); // foo modulefoo.change();foo.identify(); // FOO MODULE 通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。 现代的模块机制12345678910111213141516171819var MyModules = (function Manager() { var modules = {}; function define(name, deps, impl) { for (var i=0; i&lt;deps.length; i++) { deps[i] = modules[deps[i]]; } modules[name] = impl.apply( impl, deps ); } function get(name) { return modules[name]; } return { define: define, get: get };})(); 核心代码是这行modules[name] = impl.apply( impl, deps );为了模块的定义引入了包装函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。 看看怎么使用 12345678910111213141516171819202122232425262728293031MyModules.define( &quot;bar&quot;, [], function(){ function hello(who) { return &quot;Let me introduce: &quot; + who; } return { hello: hello };} );MyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar){ var hungry = &quot;hippo&quot;; function awesome() { console.log( bar.hello( hungry ).toUpperCase() ); } return { awesome: awesome };} );var bar = MyModules.get( &quot;bar&quot; );var foo = MyModules.get( &quot;foo&quot; );console.log( bar.hello( &quot;hippo&quot; )); // Let me introduce: hippofoo.awesome(); // LET ME INTRODUCE: HIPPO 多花一点时间来研究这些示例代码并完全理解闭包的作用吧。最重要的是要理解模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个特点:为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。 未来的模块机制ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。 ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。 import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在我们的例子里是 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。 bar.js 12345function hello(who) { return &quot;Let me introduce: &quot; + who;}export hello; baz.js 12import bar from &quot;bar&quot;;console.log(bar.hello( &quot;rhino&quot; )); // Let II-第1章 关于thisthis 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。 this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。 this既不指向函数自身也不指向函数的词法作用域 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 II-第2章 this全面解析从上一章知道理解this，就是要理解函数被调用的位置。但实践起来有点复杂。 1重要的是分析调用栈，在当前正在执行函数前一个调用中。在函数第一行设置`debugger`,开发者工具调用栈的第二个元素就是真正的调用位置。 四条绑定规则1. 独立调用独立函数调用，即使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象;严格模式下与 foo() 的调用位置无关: 123456function foo() { &quot;use strict&quot;; console.log( this.a );}var a = 2;foo(); // TypeError: this is undefined 12345function foo() { console.log( this.a );}var a = 2;foo(); // 2 2. 隐式绑定当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。 如下： 123456789101112function foo() { console.log( this.a );}var obj2 = { a: 42, foo: foo};var obj1 = { a: 2, obj2: obj2};obj1.obj2.foo(); // 42 隐式丢失一个最常见的 this 绑定问题是被隐式绑定的函数会丢失绑定对象，它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。 123456789function foo() { console.log( this.a );}var obj = { a: 2, foo: foo};var bar = obj.foo; // 函数别名!var a = &quot;oops, global&quot;; // a 是全局对象的属性 bar(); // &quot;oops, global&quot; 回调函数里也会有this丢失现象 3. 显式绑定call和apply可以直接指定 this 的绑定对象，称之为显式绑定。 1234567function foo() { console.log(this.a);}var obj = { a:2};foo.call(obj); // 2 硬绑定12345678910111213function foo() { console.log( this.a );}var obj = { a:2};var bar = function() { foo.call( obj );};bar(); // 2setTimeout( bar, 10 ); // 2// 硬绑定的 bar 不可能再修改它的 thisbar.call( window ); // 2 在bar中强制把foo的this绑定到obj上，无论之后怎么调用bar，都不会修改this。这种显示强绑定，称为硬绑定。 ES5 中提供了内置的方法Function.prototype.bind也是强绑定。 API调用的“上下文”(context)12[1, 2, 3].forEach( foo, obj );// 1 awesome 2 awesome 3 awesome 这种也是通过call和apply实现的显示绑定。 4. new绑定js通过new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建(构造)一个全新的对象。 这个新对象会被执行原型连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 优先级四条绑定原则的优先级 由new调用? 绑定到新创建的对象。 由call或者apply(或者bind)调用? 绑定到指定的对象。 由上下文对象调用? 绑定到那个上下文对象。 默认:在严格模式下绑定到undefined，否则绑定到全局对象。 绑定例外把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 函数的间接引用，会导致应用默认绑定。 软绑定硬绑定可以强制绑定到指定对象(除new时)，降低了函数的灵活性。采用软绑定方式可以实现和硬绑定相同的效果，同时保留隐式绑定修改this的能力。 12345678910111213141516if (!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有 curried 参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this curried.concat.apply( curried, arguments ) ); }; bound.prototype = Object.create( fn.prototype ); return bound; };} this语法箭头函数() =&gt; {}无法使用上述四种规则。而是根据外层（函数或者全局）作用域来决定this。箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，它用更常见的词法作用域取代了传统的 this 机制。 没有箭头函数之前我们习惯采用的方式 12345678910function foo() { var self = this; // lexical capture of this setTimeout( function(){ console.log( self.a ); }, 100 );}var obj = { a: 2};foo.call( obj ); // 2 self = this 和箭头函数看起来都可以取代bind(..)，但是从本质上来说，它们想替代的是 this 机制。 小结this全面解析学习本章了解this绑定的方式，通过4条准则定位函数运行时this到底指向什么。 在箭头函数出来之后，用() =&gt; {}和bind可以解决大多数问题了。 ES5出来之后，很多js的问题被新语法取代了，但我们可以抽时间多了解新语法背后的历史，能更深入的了解js本身的魅力。 II-第3章 对象对象是JavaScript的基础。 ECMAScript 标准定义了 8 种数据类型: 7 种原始类型:UndefinedNullNumberBooleanBigIntStringSymbol和 Object 记忆口诀：欧呦(O)你(U)俩(2个)牛(N)逼(B)啥(S) 定义对象两种形式：声明形式和构造形式。 123456789// 声明var myObj = { key: value // ...};// 构造var myObj = new Object();myObj.key = value; 可计算属性ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名: 123456var prefix = &quot;foo&quot;;var myObject = { [prefix + &quot;bar&quot;]:&quot;hello&quot;, [prefix + &quot;baz&quot;]: &quot;world&quot;};myObject[&quot;foobar&quot;]; // hello 属性与方法js中函数不会属于一个对象，因为this是在运行时根据调用位置动态绑定的。 所以方法这个称呼不太成立。但这只是个称呼，不必太纠结。 复制对象浅复制 对于JSON安全(可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象)的对象可以用JSON.parse复制 var newObj = JSON.parse(JSON.stringify(someObj)); ES6中可以用Object.assign({}, obj)复制 属性描述符属性描述符writable(可写), configurable(可配置), enumerable(可枚举) 可以使用Object.defineProperty定义属性 1234567Object.defineProperty(obj, 'KEY', { value: 12, writable: false, configurable: false}); 如果把 enumerable 设置成 false，这个属性不会出现在枚举中（比如for..in）。但可以正常访问这个属性。 结合writable: false和configurable: false可以创建一个真正的常量属性(不可修改、重定义或删除) 禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(obj) 密封：Object.seal(..)调用Object.preventExtensions(obj)把所有现有属性标记为configurable: false。密封后不能添加，重新配置和删除现有属性。可以修改属性的值。 冻结：Object.freeze(..)调用Object.seal(..)把所有数据访问属性标记为writable: false。这样就无法修改属性值。 get, setget: 属性访问先在对象中查找是否有名称相同的属性，没找到就遍历可能存在的原型链，找不到的话返回undefined。 set: 先判断属性是否是访问描述符，存在setter就调用setter。 writable是否为false。是，非严格模式下静默失败，严格模式抛出TypeError异常。 都不是，设置属性值。 1234567891011var myObject = {// 给 a 定义一个 getter get a() { return this._a_; },// 给 a 定义一个 setter set a(val) { this._a_ = val * 2; }};myObject.a = 2; myObject.a; // 4 存在性判断对象是否有某个属性 1234567var myObject = { a:2};(&quot;a&quot; in myObject); // true(&quot;b&quot; in myObject); // falsemyObject.hasOwnProperty( &quot;a&quot; ); // truemyObject.hasOwnProperty( &quot;b&quot; ); // false in操作符会检查属性是否在对象及其原型链中 hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查链。 所有的普通对象都可以通过对于 Object.prototype 的委托来访问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype(通过 Object. create(null) 来创建)。在这种情况下，形如myObejct.hasOwnProperty(..)就会失败。 可以采用Object.prototype.hasOwnProperty. call(myObject,&quot;a&quot;)判断 在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。 1234567// 判断是否可枚举myObject.propertyIsEnumerable( &quot;a&quot; ); // truemyObject.propertyIsEnumerable( &quot;b&quot; ); // false// 所有可枚举属性的数组Object.keys( myObject ); // [&quot;a&quot;]// 所有属性，无论它们是否可枚举Object.getOwnPropertyNames( myObject ); // [&quot;a&quot;, &quot;b&quot;] 遍历for..in无法直接获取属性值，因为它遍历的是对象中的所有可枚举属性，需要手动获取属性值。for..of循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值。 小结 第3章对象了解对象是什么，怎么定义，一些常用方法和特性，遍历对象。 工作中对象的使用是非常频繁的，熟练掌握各种API是提升技术的必备条件。 最佳实践12345678910111213141516171819202122// goodconst newObj = { a: 12, b: 23};// badconst newObj = {};newObj.a = 12;newObj.b = 23;newObj['a'] = 12;// goodthis.setState({ ...newObj});// badthis.setState({ a: newObj.a, b: newObj.b}); II-第4章 混合对象”类“ 我的理解类也是一种对象而已，没那么复杂。 类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。 类意味着复制。传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的是复制的结果。 JavaScript 并不会(像类那样)自动创建对象的副本。 混入模式用来模拟类的复制行为。Vue中也提供了类似的API,mixin II-第5章 原型（还需多读几遍）1这篇文章是JS的重中之重，要用心研读~~ 能学到的知识： 对象查找和设置属性背后发生了什么 原型链形成的机制和特点 前面说到在对象里查找属性时，如果在对象本身找不到，会继续访问对象的prototype链。如果都没有的话返回undefined 1234567var anotherObject = { a:2};// 创建一个关联到 anotherObject 的对象var myObject = Object.create( anotherObject );console.log(myObject); // {}myObject.a; // 2 现在myObject的prototype关联到anotherObject，myObject.a并不存在，但myObject.a结果为2 for..in遍历对象时原理和查找原型链类似。任何可通过原型链访问到(并且是enumerable)的属性都会被枚举 当你通过各种语法进行属性查找时都会查找原型链，直到找到属性或者查找完整条原型链。 原型链的尽头是Object.prototypetoString()、valueOf()和其他一些通用的功能 都存在于Object.prototype对象上，因此语言中所有的对象都可以使用它们。 属性设置和屏蔽给一个对象设置属性的过程并不简单。通过例子来看myObject.foo = &quot;bar&quot;; 一、 如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属性值。 二、 如果 foo 不是直接存在于 myObject 中，原型链就会被遍历。如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。 三、 如果 foo 存在于原型链上层，赋值语句 myObject.foo = &quot;bar&quot; 的行为就会有些不同。 如果属性名 foo 既出现在 myObject 中也出现在 myObject 的原型链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。 屏蔽：在当前作用域添加属性，以隔绝访问原型链上层的同样属性 发生屏蔽的三种情况： 如果在原型链上层存在名为foo的普通数据访问属性并且没有被标记为只读，那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。 如果在原型链上层存在foo，但是它被标记为只读，那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 如果在原型链上层存在foo并且它是一个setter，那就一定会调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这个 setter。 向原型链上层已经存在的属性赋值，不一定会触发屏蔽(第二三种)。如果希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 = 操作符来赋值，而是使用 Object.defineProperty(..)来向 myObject 添加 foo。 只读属性会阻止原型链下层屏蔽同名属性。这样做主要是为了模拟类属性的继承。你可以把原型链上层的 foo 看作是父类中的属性，它会被 myObject 继承(复制)，这样一来 myObject 中的 foo 属性也是只读，所以无法创建。但是一定要注意，实际上并不会发生类似的继承复制。这看起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不能包含 foo 属性。更奇怪的是，这个限制只存在于 = 赋值中，使用 Object. defineProperty(..) 并不会受到影响。 有些情况下会隐式产生屏蔽，如下： 1234567891011var anotherObject = { a:2};var myObject = Object.create( anotherObject );anotherObject.a; // 2myObject.a; // 2myObject.a++; // 隐式屏蔽!anotherObject.a; // 2myObject.a; // 3myObject.hasOwnProperty( &quot;a&quot; ); // true ++ 操作相当于 myObject.a = myObject.a + 1。因此 ++ 操作首先会通过原型链查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着将值 3 赋给 myObject 中新建的屏蔽属性 a。 修改委托属性时一定要小心。如果想让 anotherObject.a 的值增加，唯一的办法是 anotherObject.a++。 类函数函数的一种特殊特性:所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象: Foo的原型。我们通过名为 Foo.prototype 的属性引用来访问它。 1234567function Foo() { // ...}Foo.prototype; // { }var a = new Foo();Object.getPrototypeOf( a ) === Foo.prototype; // true 调用 new Foo() 时会创建 a，其中的一步就是给 a 一个内部的原型链，关联到 Foo.prototype 指向的那个对象。 在 JavaScript 中，不能创建一个类的多个实例，只能创建多个对象，它们的原型链关联的是同一个对象。在默认情况下多次实例化一个类不会进行复制， 因此这些对象之间并不会完全失去联系，它们是互相关联的。 通过new Foo()得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联。 实际上，绝大多数 JavaScript 开发者不知道的秘密是，new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。new Foo() 只是间接完成了我们的目标:一个关联到其他对象的新对象。 通过Object.create(..)可以直接做到这一点。 通常我们讲原型继承。继承意味着复制操作。JS默认不会复制对象属性。会在两个对象之间创建关联，这样一个对象可以通过委托访问另一个对象的属性和函数。 差异继承？ 构造函数在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。 函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。 123456function Foo() { // ...}Foo.prototype.constructor === Foo; // truevar a = new Foo();a.constructor === Foo; // true Foo.prototype 默认(在代码中第一行声明时)有一个公有并且不可枚举的属性.constructor，这个属性引用的是对象关联的函数(本例中是 Foo)。此外，我们可以看到通过“构造函数”调用 new Foo() 创建的对象也有一个 .constructor 属性，指向 “创建这个对象的函数”。 a.constructor 只是通过默认的原型委托指向 Foo，这和构造毫无关系。 12345function Foo() { /* .. */ }Foo.prototype = { /* .. */ }; // 创建一个新原型对象var a1 = new Foo();a1.constructor === Foo; // false!a1.constructor === Object; // true! Object(..) 并没有“构造”a1，看起来应该是 Foo()“构造”了它。大部分开发者 都认为是 Foo() 执行了构造工作，但是问题在于，如果你认为constructor表示“由…… 构造”的话，a1.constructor 应该是 Foo，但是它并不是 Foo ! a1 并没有 .constructor 属性，所以它会委托原型链上的 Foo. prototype。但是这个对象也没有 .constructor 属性(不过默认的 Foo.prototype 对象有这 个属性!)，所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象 有 .constructor 属性，指向内置的 Object(..) 函数。 对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用。 constructor 并不表示被构造.constructor 并不是一个不可变属性。它是不可枚举的，但是它的值是可写的。此外，你可以给任意原型链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。 原型继承Bar.prototype = Object.create()Object.create(..) 会凭空创建一个“新”对象并把新对象内部的原型链关联到指定的对象(本例中是 Foo.prototype)。换句话说，这条语句的意思是:“创建一个新的 Bar.prototype 对象并把它关联到 Foo. prototype”。 1234// 和你想要的机制不一样!Bar.prototype = Foo.prototype;// 基本上满足你的需求，但是可能会产生一些副作用 :(Bar.prototype = new Foo(); Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。因此当你执行类似Bar.prototype. myLabel = ...的赋值语句时会直接修改 Foo.prototype 对象本身。显然这不是你想要的结果，否则你根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会更简单一些。 Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象。但是它使用了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些副作用(比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等)的话，就会影响到 Bar() 的“后代”，后果 不堪设想。 对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法: 1234// ES6 之前需要抛弃默认的 Bar.prototypeBar.ptototype = Object.create( Foo.prototype );// ES6 开始可以直接修改现有的Bar.prototype Object.setPrototypeOf( Bar.prototype, Foo.prototype ); 如果忽略掉 Object.create(..) 方法带来的轻微性能损失(抛弃的对象需要进行垃圾回收)，它实际上比 ES6 及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法。 检查类关系instanceof 操作符的左操作数是一个普通的对象，右操作数是一个函数。 在 a 的整条原型链中是否有指向 Foo.prototype 的对象? 这个方法只能处理对象(a)和函数(带 .prototype 引用的 Foo)之间的关系。如果你想判断两个对象(比如 a 和 b)之间是否通过原型链关联，只用 instanceof 无法实现。 第二种判断反射的方法： Foo.prototype.isPrototypeOf( a ); // true b 是否出现在 c 的原型链中?b.isPrototypeOf( c ); 直接获取一个对象原型链的方法Object.getPrototypeOf(a) Object.getPrototypeOf( a ) === Foo.prototype; // true 非标准的方法a.__proto__ === Foo.prototype; // true .constructor和.__proto__一样，并不存在于你正在使用的对象中 (本例中是 a)。它和其他的常用函数(.toString()、.isPrototypeOf(..)，等等)一样，存在于内置的 Object.prototype 中。是不可枚举的。 .proto 的实现大致上是这样的 123456789Object.defineProperty( Object.prototype, &quot;__proto__&quot;, { get: function() { return Object.getPrototypeOf( this ); }, set: function(o) { // ES6 中的 setPrototypeOf(..) Object.setPrototypeOf( this, o ); return o; }}); 对象关联Object.create(..) 会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，这样我们就可以充分发挥原型链机制的威力(委托)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。 Object.create()的polyfill代码 12345678if (!Object.create) { Object.create = function(o) { function F(){} F.prototype = o; return new F(); };} II-第6章 行为委托委托行为意味着某些对象(XYZ)在找不到属性或者方法引用时会把这个请求委托给另一个对象(Task)。 1234567891011121314Task = { setID: function(ID) { this.id = ID; }, outputID: function() { console.log( this.id ); }};// 让XYZ委托TaskXYZ = Object.create( Task );XYZ.prepareTask = function(ID,Label) { this.setID(ID); this.label = Label;};XYZ.outputTaskDetails = function() { this.outputID(); console.log(this.label);}; 这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。 写不下去了~~ 学不精，所以讲不通 待我理解透彻再来更新吧","link":"/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%B2%BE%E8%AF%BB%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E5%8D%B7/"},{"title":"精读你不知道的JavaScript中卷","text":"[TOC] I-第1章 类型一个人身上的特异性和一个人身上的特异性与惊奇性并不会对另一人产生压制。你身上的天才，会激发我身上的天才。 内置类型ECMAScript 标准定义了 8 种数据类型: 7 种原始类型:UndefinedNullNumberBooleanBigIntStringSymbol和 Object(基本类型) 记忆口诀：欧呦(O)你(U)俩(2个)牛(N)逼(B)啥(S) 用typeof来查看值的类型，返回的是字符串。但类型和它们的字符串值不一一对应 123456789101112131415161718192021typeof undefined === 'undefined' // truetypeof true === 'boolean' // truetypeof 12 === 'number' // truetypeof '12' === 'string' // truetypeof { life: 12 } === 'object' // truetypeof Symbol() === 'symbol' // truetypeof BigInt('1') === 'bigint' // truetypeof Object(BigInt('2')) === 'object' // true// 不一样的typeof null === 'object' // true// 检测null值的类型需要复合条件const a = null;(!a &amp;&amp; typeof a === 'object'); // true// function也是JS的内置类型，实际是object的子类型typeof function a() {/**/} === 'function'; // true// 数组也是object的子类型typeof [1,2,3] === 'object' // true 值和类型JS中变量没有类型，值才有。变量可以随时持有任何类型的值。 typeof得到的结果不是该变量的类型，而是该变量持有值的类型。返回的总是字符串。 1234567let a = 12;typeof a; // 'number'a = true;typeof a; // 'boolean'typeof typeof 12; // 'string' typeof Undeclared123456let a;a; // undefinedb; // ReferenceError: b is not definedtypeof a; // 'undefined'typeof b; // 'undefined' typeof对未定义的变量也返回undefined。且没有报错。 这是因为typeof有一个特殊的安全防范机制。 多个脚本会在共享的全局命名空间中加载变量。 12345678910111213// 这样会抛出错误if (DEBUG) { console.log( 'Debugging is starting' );}// 这样是安全的if (typeof DEBUG !== 'undefined') { console.log( 'Debugging is starting' );}// 对内建API也有帮助if (typeof atob === 'undefined') { atob = function() { /*..*/ };} typeof安全机制也可以用来判断非全局变量 123456789101112(function(){ function FeatureXYZ() { /*.. my XYZ feature ..*/ } // 包含doSomethingCool(..) function doSomethingCool() { var helper = (typeof FeatureXYZ !== 'undefined') ? FeatureXYZ : function() { /*.. default feature ..*/ }; var val = helper(); // .. } doSomethingCool();})(); 这里FeatureXYZ不是全局变量，也可以用typeof安全防范机制来做检查 也可以用依赖注入方式 123456function doSomethingCool(FeatureXYZ) { var helper = FeatureXYZ || function() { /*.. default feature ..*/ }; var val = helper(); // ..} 类型小结 了解JS内置类型 根据typeof判断类型 typeof的安全机制应用场景 I-第2章 值1通过这章的学习，可以了解，数组，字符串，特殊数值，值传递和值引用的区别 数组JS的数组可容纳任何类型的值，数组声明后即可添加值，不用预设大小。 123456let a = [1, '2', [3]];a.length; // 3a[2][0] === 3; // truea[4] = 5;a[3]; // undefined a[3]为undefined，称作”稀疏数组”（sparse array）。这里的undefined与显示赋值为undefined不同。 数组也是对象。可以自定义属性(不计算在数组长度内)。 1234let a = [1];a['foo'] = 2;a.length; // 1a['foo']; // 2 类数组类数组转数组常用方法 1234// slice() 返回参数列表的一个数组复本。var arr = Array.prototype.slice.call( arguments );var arr = Array.from( arguments ); 字符串字符串和数组相似，都有length属性，indexOf, concat方法 123456789101112131415161718let a = 'foo';let b = ['f', 'o', 'o'];a.length; // 3b.length; // 3a.indexOf('o'); // 1b.indexOf('o'); // 1var c = a.concat( 'bar' );// 'foobar'var d = b.concat( ['b','a','r'] );// ['f','o','o','b','a','r']a === c;// falseb === d;// falsea; // 'foo'b; // ['f','o','o'] 字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。 借助数组方法来处理字符串 12345678910a.join; // undefineda.map; // undefinedvar c = Array.prototype.join.call( a, '-' );var d = Array.prototype.map.call( a, function(v){ return v.toUpperCase() + '.';} ).join( '' );c; // 'f-o-o'd; // 'F.O.O.' 字符串反转 字符串没有reverse方法 12345678var c = a// 将a的值转换为字符数组.split( &quot;&quot; )// 将数组中的字符进行倒转.reverse()// 将数组中的字符拼接回字符串.join( &quot;&quot; );c; // &quot;oof&quot; 如果经常以字符数组方式处理字符串的话，倒不如直接用数组。在需要时使用join()将数组转成字符串。 数字toFixed()返回的是字符串toPrecision(..) 方法用来指定有效数位的显示位数 12345678910111213var a = 42.59;a.toFixed( 0 ); // &quot;43&quot;a.toFixed( 1 ); // &quot;42.6&quot;a.toFixed( 2 ); // &quot;42.59&quot;a.toFixed( 3 ); // &quot;42.590&quot;var a = 42.59;a.toPrecision( 1 ); // &quot;4e+1&quot;a.toPrecision( 2 ); // &quot;43&quot;a.toPrecision( 3 ); // &quot;42.6&quot;a.toPrecision( 4 ); // &quot;42.59&quot;a.toPrecision( 5 ); // &quot;42.590&quot; 不过对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。 42.tofixed(3) 是无效语法，因为 . 被视为常量 42. 的一部分(如前所述)，所以没有 . 属 性访问运算符来调用 tofixed 方法。42..tofixed(3) 则没有问题，因为第一个 . 被视为 number 的一部分，第二个 . 是属性访问运算符。 123456789// invalid syntax:42.toFixed( 3 ); // SyntaxError// these are all valid:(42).toFixed( 3 ); // &quot;42.000&quot;0.42.toFixed( 3 ); // &quot;0.420&quot;42..toFixed( 3 ); // &quot;42.000&quot;42 .toFixed(3); // &quot;42.000&quot; 怎样判断0.1+0.2 === 0.3 最常见的方法是设置一个误差范围值，通常称为“机器精度”(machine epsilon)，对JavaScript的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前的版本写 polyfill: 123if (!Number.EPSILON) { Number.EPSILON = Math.pow(2,-52);} 可以使用 Number.EPSILON 来比较两个数字是否相等(在指定的误差范围内): 1234567function numbersCloseEnoughToEqual(n1,n2) { return Math.abs( n1 - n2 ) &lt; Number.EPSILON;}var a = 0.1 + 0.2;var b = 0.3;numbersCloseEnoughToEqual( a, b ); // truenumbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false 数字“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为 Number.MAX_SAFE_INTEGER。最小整数是 -9007199254740991， 在 ES6 中 被 定 义 为 Number. MIN_SAFE_INTEGER。 整数检测Number.isInteger(..) 12345678910Number.isInteger( 42 ); // trueNumber.isInteger( 42.000 ); // trueNumber.isInteger( 42.3 ); // false// polyfillif (!Number.isInteger) { Number.isInteger = function(num) { return typeof num == &quot;number&quot; &amp;&amp; num % 1 == 0; };} 检测安全的整数Number.isSafeInteger(..) 1234567891011Number.isSafeInteger( Number.MAX_SAFE_INTEGER );// trueNumber.isSafeInteger( Math.pow( 2, 53 ) );// trueNumber.isSafeInteger( Math.pow( 2, 53 ) - 1 );// false// polyfillif (!Number.isSafeInteger) { Number.isSafeInteger = function(num) { return Number.isInteger( num ) &amp;&amp; Math.abs( num ) &lt;= Number.MAX_SAFE_INTEGER; };} 特殊数值undefined和nullundefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名称既是类型也是值。 null 指空值(empty value)，曾赋过值，但是目前没有值 undefined 指没有值(missing value)，从未赋值 null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而undefined 却是一个标识符，可以被当作变量来使用和赋值。（不要给undefined赋值！） void运算符表达式void ___没有返回值，因此返回结果是undefined。void并不改变表达式的结果， 只是让表达式不返回值: 123var a = 42;console.log( void a, a ); // undefined 42 如果要将代码中的值(如表达式的返回值)设为 undefined，就可以使用 void。 特殊的数字NaN 意指“不是一个数字”(not a number)，不是数字的数字，但仍然是数字类型 NaN是一个特殊值，它和自身不相等，是唯一一个非自反(自反，reflexive，即x === x不成立)的值。而 NaN != NaN 为 true， 123456var a = 2 / &quot;foo&quot;; // NaNtypeof a === &quot;number&quot;; // truevar a = 2 / &quot;foo&quot;;a == NaN; // falsea === NaN; // false ES6以后，可以用Number.isNaN()判断 12345678910111213141516if (!Number.isNaN) { Number.isNaN = function(n) { return (typeof n === &quot;number&quot; &amp;&amp; window.isNaN( n )); }};var a = 2 / &quot;foo&quot;;var b = &quot;foo&quot;;Number.isNaN( a ); // trueNumber.isNaN( b );// false——好!// 另一种更简单的方法if (!Number.isNaN) { Number.isNaN = function(n) { return n !== n; };} JavaScript 中Infinity(即 Number.POSITIVE_INfiNITY)表示无穷数 12var a = 1 / 0; // Infinityvar b = -1 / 0; // -Infinity 负零（-0） 加法和减法运算不会得到负零(negative zero)。 判断是否是负零 1234567function isNegZero(n) { n = Number( n ); return (n === 0) &amp;&amp; (1 / n === -Infinity);}isNegZero( -0 );// trueisNegZero( 0 / -3 );// trueisNegZero( 0 );// false 有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度)，数字的符号位 (sign)用来代表其他信息(比如移动的方向)。此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。 特殊等式ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等。仅用来判断NaN和-0等情况，能用===就不用这个 1234567var a = 2 / &quot;foo&quot;;var b = -3 * 0;Object.is( a, NaN ); // trueObject.is( b, -0 ); // trueObject.is( b, 0 ); // false polyfill 1234567891011121314if (!Object.is) { Object.is = function(v1, v2) { // test for `-0` if (v1 === 0 &amp;&amp; v2 === 0) { return 1 / v1 === 1 / v2; } // test for `NaN` if (v1 !== v1) { return v2 !== v2; } // everything else return v1 === v2; };} 值和引用JS中，值复制还是引用复制，一切由值的类型来决定。 简单类型（null、undefined、字符串、数字、布尔和 ES6 中的 symbol）总是通过值复制方式来赋值/传递。 复合值(compound value)——对象(包括数组和封装对象)和函数，则总是通过引用复制的方式来赋值/传递。 1234567891011var a = 2;var b = a; // `b` is always a copy of the value in `a`b++;a; // 2b; // 3var c = [1,2,3];var d = c; // `d` is a reference to the shared `[1,2,3]` valued.push( 4 );c; // [1,2,3,4]d; // [1,2,3,4] 函数传参的问题 1234567891011function foo(x) { x.push( 4 ); x; // [1,2,3,4] // 这里x变成了一个新数组，a还是原来的 x = [4,5,6]; x.push( 7 ); x; // [4,5,6,7]}var a = [1,2,3];foo( a );a; // [1,2,3,4] not [4,5,6,7] 将 a 的值变为 [4,5,6,7]，必须更改 x 指向的数组，而不是为 x 赋值一个新的数组。 123456789101112131415function foo(x) { x.push( 4 ); x; // [1,2,3,4] // 这样做不会创建新数组 x.length = 0; // empty existing array in-place x.push( 4, 5, 6, 7 ); x; // [4,5,6,7]}var a = [1,2,3];foo( a );a; // [4,5,6,7] not [1,2,3,4] 如果通过值复制的方式来传递复合值(如数组)，就需要为其创建一个复本，这样传递的就不再是原始值。foo( a.slice() ); a.slice()返回的是数组的浅复本，foo的操作不会影响a指向的数组。相反，如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值(对象、数组等)中，然后通过引用复制的方式传递。 1234567891011function foo(wrapper) { wrapper.a = 42;}var obj = { a: 2};foo( obj );obj.a; // 42 I-第3章 原生函数1学习原生函数，封装对象包装，拆分。 常用的原生函数• String()• Number()• Boolean()• Array()• Object()• Function()• RegExp()• Date()• Error()• Symbol() 原生函数可以被当作构造函数来使用。通过构造函数(如new String(“abc”))创建出来的是封装了基本类型值(如”abc”)的封装对象。 1234var a = new String( &quot;abc&quot; );typeof a; // 是&quot;object&quot;，不是&quot;String&quot;a instanceof String; // trueObject.prototype.toString.call( a ); // &quot;[object String]&quot; 内部属性class所有 typeof 返回值为 “object” 的对象(如数组)都包含一个内部属性Class。这个属性无法直接访问，通过 Object.prototype.toString(..) 来查看。 1234567Object.prototype.toString.call( [1,2,3] ); // &quot;[object Array]&quot;Object.prototype.toString.call( /regex-literal/i ); // &quot;[object RegExp]&quot;Object.prototype.toString.call( null ); // &quot;[object Null]&quot;Object.prototype.toString.call( undefined ); // &quot;[object Undefined]&quot;Object.prototype.toString.call( &quot;abc&quot; ); // &quot;[object String]&quot;Object.prototype.toString.call( 42 ); // &quot;[object Number]&quot;Object.prototype.toString.call( true ); // &quot;[object Boolean]&quot; 封装对象包装由于基本类型值没有.length和.toString()这样的属性和方法，需要通过封装对象才能访问。JS会自动为基本类型包装一个封装对象。 123var a = &quot;abc&quot;;a.length; // 3a.toUpperCase(); // &quot;ABC&quot; 一般情况下，不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什么时候应该使用封装对象。 如果要自行封装基本类型值，可以用Object()函数(不带new关键字) 12345678910111213var a = &quot;abc&quot;;var b = new String( a );var c = Object( a );typeof a; // &quot;string&quot;typeof b; // &quot;object&quot;typeof c; // &quot;object&quot;b instanceof String; // truec instanceof String; // trueObject.prototype.toString.call( b ); // &quot;[object String]&quot;Object.prototype.toString.call( c ); // &quot;[object String]&quot; 拆封要拆封封装对象中的基本类型值，可以用valuesOf()函数。 1234567var a = new String( &quot;abc&quot; );var b = new Number( 42 );var c = new Boolean( true );a.valueOf(); // &quot;abc&quot;b.valueOf(); // 42c.valueOf(); // true 在需要用到封装对象中的基本类型值的地方会发生隐式拆封。 12345var a = new String( &quot;abc&quot; );var b = a + &quot;&quot;; // b拥有了拆封后的值abctypeof a; // &quot;object&quot;typeof b; // &quot;string&quot; 原生函数作为构造函数 数组 永远不要创建和使用空单元数组。 1234var a = new Array( 3 );var b = [ undefined, undefined, undefined ];var c = [];c.length = 3; Object(..)、Function(..) 和 RegExp(..) 不建议使用Object和Function 强烈建议使用常量形式(如 /^a*b+/g)来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。 与前面的构造函数不同，RegExp(..) 有时还是很有用的，比如动态定义正则表达式时: 123var name = &quot;Kyle&quot;;var namePattern = new RegExp( &quot;\\\\b(?:&quot; + name + &quot;)+\\\\b&quot;, &quot;ig&quot; );var matches = someText.match( namePattern ); 上述情况在JavaScript编程中时有发生，这时new RegExp(“pattern”,”flags”)就能派上用场。 Date(..) 和 Error(..) 创建日期必须使用 new Date()。 Date(..) 主要用来获得当前的 Unix 时间戳(从 1970 年 1 月 1 日开始计算，以秒为单位)。 该值可以通过日期对象中的 getTime() 来获得。 用Date.now()即可获取 创建错误对象(error object)主要是为了获得当前运行栈的上下文(大部分 JavaScript 引擎通过只读属性 .stack 来访问)。 栈上下文信息包括函数调用栈信息和产生错误的代码行号， 以便于调试(debug)。 123456function foo(x) { if (!x) { throw new Error( &quot;x wasn’t provided&quot; ); } // ..} 通常错误对象至少包含一个 message 属性，有时也不乏其他属性(必须作为只读属性访问)，如 type。 除了访问 stack 属性以外，最好的办法是调用toString() 来获得经过格式化的便于阅读的错误信息。 Symbol 可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键 字，否则会出错: 12345678910var mysym = Symbol( &quot;my own symbol&quot; );mysym; // Symbol(my own symbol)mysym.toString(); // &quot;Symbol(my own symbol)&quot;typeof mysym; // &quot;symbol&quot;var a = { };a[mysym] = &quot;foobar&quot;;Object.getOwnPropertySymbols( a );// [ Symbol(my own symbol) ] 原生原型 原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。 这些对象包含其对应子类型所特有的行为特征。 Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式(无任何匹配)，而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。 12345678910111213function isThisCool(vals = Array.prototype,fn = Function.prototype,rx = RegExp.prototype) { return rx.test( vals.map( fn ).join( &quot;&quot; ) );}isThisCool(); // trueisThisCool( [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], function(v){ return v.toUpperCase(); }, /D/); 这种方法的一个好处是 .prototype 已被创建并且仅创建一次。相反，如果将 []、function(){} 和 /(?:)/ 作为默认值， 则每次调用 isThisCool(..) 时它们都会被创建一次 (具体创建与否取决于 JavaScript 引擎，稍后它们可能会被垃圾回收)，这样无疑会造成内存和 CPU 资源的浪费。 I-第4章 强制类型转换值从一个类型转换为另一种类型，称为类型转换(type casting)。这是显示的情况，隐式的情况称为强制类型转换(coercion)。 类型转换发生在静态语言的编译阶段，强制类型转换发生在动态类型语言的运行时 在JS中统称为强制类型转换。可以通过隐式强制类型和强制类型转换来区分。 隐式类型转换不明显，通常是某些操作产生的副作用。 123var a = 42;var b = a + &quot;&quot;; // 隐式强制类型转换var c = String(a); // 显式强制类型转换 抽象值操作ToString 非字符串到字符串强制类型转换基本类型值的字符串化规则为:null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。数字极大极小值用指数形式。数组的toString默认将所有单元字符串化后用,连接。 12var a = [1,2,3]a.toString(); // '1,2,3,' JSON.stringify(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。 JSON字符串化用stringify,遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null。 12345JSON.stringify( undefined ); // undefinedJSON.stringify( function(){} ); // undefinedJSON.stringify( [1,undefined,function(){},4] ); // &quot;[1,null,null,4]&quot;JSON.stringify( { a:2, b:function(){} } ); // &quot;{&quot;a&quot;:2}&quot; 包含循环引用的对象执行 JSON.stringify(..) 会出错。 如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，需要定义 toJSON() 方法来返回一个能够被字符串化的安全的 JSON 值。 123456789101112131415161718192021var o = { };var a = { b: 42, c: o, d: function(){}};// a被循环引用o.e = a;// 由于循环引用，会抛出异常// JSON.stringify( a );// define a custom JSON value serializationa.toJSON = function() { // only include the `b` property for serialization return { b: this.b };};JSON.stringify( a ); // &quot;{&quot;b&quot;:42}&quot; 向 JSON.stringify(..) 传递一个可选参数 replacer，可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined，否则返回指定的值。 123456789101112var a = { b: 42, c: &quot;42&quot;, d: [1,2,3]};JSON.stringify( a, [&quot;b&quot;,&quot;c&quot;] ); // &quot;{&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;}&quot;JSON.stringify( a, function(k,v){ if (k !== &quot;c&quot;) return v;});// &quot;{&quot;b&quot;:42,&quot;d&quot;:[1,2,3]}&quot; ToNumbertrue 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。 对象(包括数组)会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。 ToBoolean 假值(false value) 可以被强制类型转换为 false 的值。 undefined null false +0, -0, NaN ‘’ 假值对象 123var a = new Boolean( false );var b = new Number( 0 );var c = new String( &quot;&quot; ); a, b, c都为true 真值 1234567891011var a = &quot;false&quot;;var b = &quot;0&quot;;var c = &quot;''&quot;;var d = Boolean( a &amp;&amp; b &amp;&amp; c );d; // 字符串不为空所以为truevar a = [];var b = {};var c = function(){};var d = Boolean( a &amp;&amp; b &amp;&amp; c );d; // [], {}, function(){} 不为空，为true 显式强制类型转换代码转换清晰，可读性高，更容易理解，推荐使用。 字符串数字互转 1234567891011var a = 42;var b = String( a );b; // &quot;42&quot;var c = &quot;3.14&quot;;var d = Number( c );d; // 3.14var c = &quot;3.14&quot;;var d = +c; // 最常用~~~d; // 3.14 奇特的~运算符 字位运算符(如 | 和 ~)和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字。 在 -(x+1) 中唯一能够得到 0(或者严格说是 -0)的 x 值是 -1。也就是说如果 x 为 -1 时，~和一些数字值在一起会返回假值 0，其他情况则返回真值。 indexOf搜索到指定字符串返回字符串所在位置(从0开始)，否则返回-1。 12345678910111213141516171819202122232425262728var a = &quot;Hello World&quot;;if (a.indexOf( &quot;lo&quot; ) &gt;= 0) { // true // found it!}if (a.indexOf( &quot;lo&quot; ) != -1) { // true // found it}if (a.indexOf( &quot;ol&quot; ) &lt; 0) { // true // not found!}if (a.indexOf( &quot;ol&quot; ) == -1) { // true // not found!}~a.indexOf( &quot;lo&quot; ); // -4 &lt;-- truthy!if (~a.indexOf( &quot;lo&quot; )) { // true // found it!}~a.indexOf( &quot;ol&quot; ); // 0 &lt;-- falsy!!~a.indexOf( &quot;ol&quot; ); // trueif (!~a.indexOf( &quot;ol&quot; )) { // true // not found!} &gt;= 0和== -1这样的写法不是很好，称为“抽象渗漏”，在代码中暴露了底层的实现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉。~ 和 indexOf() 一起可以将结果强制类型转换(实际上仅仅是转换)为真 / 假值 这种写法看起来逼格也高，哈哈 ~~中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。 只适用于 32 位数字，更重要的是它对负数的处理与 Math. floor(..) 不同。 12Math.floor( -49.6 ); // -50~~-49.6; // -49 显式解析数字字符串解析(parseInt)允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。字符串转数字(Number)不允许出现非数字字符，否则会失败并返回 NaN。 12345678var a = &quot;42&quot;;var b = &quot;42px&quot;;Number( a ); // 42parseInt( a ); // 42Number( b ); // NaNparseInt( b ); // 42 parseInt(..) 针对的是字符串值。向 parseInt(..) 传递其他类型的参数，比如 true、function(){...} 和 [1,2,3]。会首先被强制类型转换为字符串，依赖这样的隐式强制类型转换并非上策，应该避免向 parseInt(..) 传递非字符串参数。 parseInt(..) 先将参数强制类型转换为字符串再进行解析。 1parseInt( 1/0, 19 ); // 18 怎么来处理 Infinity(1/0 的结果)最合理呢?有两个选择:”Infinity” 和 “∞”，JavaScript选择的是 “Infinity”。 parseInt(1/0, 19) 实际上是 parseInt(“Infinity”, 19)。第一个字符是 “I”，以 19 为基数 时值为 18。第二个字符 “n” 不是一个有效的数字字符，解析到此为止，和 “42px” 中的 “p” 一样。 最后的结果是 18，而非 Infinity 或者报错。所以理解其中的工作原理对于我们学习 JavaScript 是非常重要的。 1234567parseInt( 0.000008 ); // 0 (&quot;0&quot; from &quot;0.000008&quot;)parseInt( 0.0000008 ); // 8 (&quot;8&quot; from &quot;8e-7&quot;)parseInt( false, 16 ); // 250 (&quot;fa&quot; from &quot;false&quot;)parseInt( parseInt, 16 ); // 15 (&quot;f&quot; from &quot;function..&quot;)parseInt( &quot;0x10&quot; ); // 16parseInt( &quot;103&quot;, 2 ); // 2 显示转换为布尔值显式强制类型转换为布尔值最常用的方法!!，第二个!会把结果反转回原值 1234567891011121314151617181920212223242526var a = &quot;0&quot;;var b = [];var c = {};var d = &quot;&quot;;var e = 0;var f = null;var g;Boolean( a ); // trueBoolean( b ); // trueBoolean( c ); // trueBoolean( d ); // falseBoolean( e ); // falseBoolean( f ); // falseBoolean( g ); // false!!a; // true!!b; // true!!c; // true!!d; // false!!e; // false!!f; // false!!g; // false 三元运算符 ? : 判断 a 是否为真，如果是则将变量 b 赋值为 true，否则赋值为 false。 表面上这是一个显式的 ToBoolean 强制类型转换，因为返回结果是 true 或者 false。然而这里涉及隐式强制类型转换，因为 a 要首先被强制类型转换为布尔值才能进行条件判断。这种情况称为“显式的隐式”，有百害而无一益，我们应彻底杜绝。建议使用 Boolean(a) 和 !!a 来进行显式强制类型转换。 隐式强制类型转换不够明显的强制类型转换都可以算作隐式强制类型转换。 隐式强制类型转换的作用是减少冗余，让代码更简洁。可能会让代码晦涩难懂。 +既能用于字符串也能用于数字。怎么判断要执行哪个操作？ 1234567891011121314151617var a = &quot;42&quot;;var b = &quot;0&quot;;var c = 42;var d = 0;a + b; // &quot;420&quot;c + d; // 42var a = [1,2];var b = [3,4];a + b; // &quot;1,23,4&quot;// 将数字转成字符串var a = 42;var b = a + &quot;&quot;;b; // &quot;42&quot; 如果其中一个操作数是对象(包括数组)，则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用DefaultValue，以数字作为上下文。数组的 valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()。因此上例中的两个数组变成了 “1,2” 和 “3,4”。+ 将它们拼接后返回 “1,23,4”。 如果 + 的其中一个操作数是字符串(或者通过以上步骤可以得到字符串)， 则执行字符串拼接;否则执行数字加法。 a + “”(隐式)和前面的String(a)(显式)之间有一个细微的差别需要注意。根据 ToPrimitive抽象操作规则，a + “”会对a调用valueOf()方法，然后通过ToString抽象 操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。 如果a是对象，结果会不一样。 12345678var a = { valueOf: function() { return 42; }, toString: function() { return 4; }};a + &quot;&quot;; // &quot;42&quot;String( a ); // &quot;4 在定制 valueOf() 和 toString() 方法时需要特别小心，因为这会影响强制类型转换的结果。 -减法运算符，会先转换为字符串，再转换为数字 12345678var a = &quot;3.14&quot;;var b = a - 0;b; // 3.14var a = [3];var b = [1];a - b; // 2 布尔值到数字的隐式强制类型转换12345var sum = 0arr = [true, false, true]arr.reduce(item=&gt; { sum +=item}, sum) 在控制台显示是NaN？？？和书里不一样 隐式强制类型转换为布尔值(1)if (..)语句中的条件判断表达式。(2)for ( .. ; .. ; .. )语句中的条件判断表达式(第二个)。(3) while (..) 和 do..while(..) 循环中的条件判断表达式。(4)? :中的条件判断表达式。(5) 逻辑运算符 ||(逻辑或)和 &amp;&amp;(逻辑与)左边的操作数(作为条件判断表达式)。 以上情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的 ToBoolean 抽象操作规则。 12345678910111213141516171819var a = 42;var b = &quot;abc&quot;;var c;var d = null;if (a) { console.log( &quot;yep&quot; ); // yep}while (c) { console.log( &quot;nope, never runs&quot; );}c = d ? a : b;c; // &quot;abc&quot;if ((a &amp;&amp; d) || c) { console.log( &quot;yep&quot; ); // yep} || 和 &amp;&amp;JS中返回的不一定布尔值。而是两个操作数中的一个的值。 123456789var a = 42;var b = &quot;abc&quot;;var c = null;a || b; // 42a &amp;&amp; b; // &quot;abc&quot;c || b; // &quot;abc&quot;c &amp;&amp; b; // null || 和 &amp;&amp; 首先会对第一个操作数(a 和 c)执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数(a 和 c)的值，如果为 false 就返回第二个操作数(b)的值。&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数(b)的值，如果为 false 就返回第一个操作数(a 和 c)的值。 换个角度理解 123456789a || b;// 相当于a ? a : b;a &amp;&amp; b;// 相当于a ? b : a;// 同三元表达式不同的是, 如果a是表达式，可能会执行两次。 常见用法设置默认值 123456789function foo(a,b) { a = a || &quot;hello&quot;; b = b || &quot;world&quot;; console.log( a + &quot; &quot; + b );}foo(); // &quot;hello world&quot;foo( &quot;yeah&quot;, &quot;yeah!&quot; ); // &quot;yeah yeah!&quot; 短路机制 a为false时，foo不会执行。比if (a) { foo() }简洁明了 1234567function foo() { console.log( a );}var a = 42;a &amp;&amp; foo(); // 42 宽松相等和严格相等==允许在相等比较中进行强制类型转换，而===不允许。 人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级 (百万分之一秒)的差别而已。如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎 实现上的细微差别之外，它们之间并没有什么不同。 抽象相等规定如果两个值的类型相同，就仅比较它们是否相等。例如，42 等于 42，”abc” 等于 “abc”。 特殊情况 NaN 不等于 NaN，+0 等于 -0。 以 x 和 y 为值进行 x == y 比较会产生的结果可为 true 或 false。比较的执行步骤如下： 若 Type(x) 与 Type(y) 相同， 则 若 Type(x) 为 Undefined， 返回 true。 若 Type(x)为 Null， 返回 true。 若 Type(x)为 Number，则 若 x 为 NaN，返回 false。 若 y 为 NaN，返回 false。 若 x 与 y 为相等数值，返回 true。 若 x 为 +0 且 y 为 −0，返回 true。 若 x 为 −0 且 y 为 +0，返回 true。 返回 false。 若 Type(x) 为 String，则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。否则，返回 false。 若 Type(x) 为 Boolean，当 x 和 y 为同为 true 或者同为 false 时返回 true。否则，返回 false。 当 x 和 y 为引用同一对象时返回 true。否则，返回 false。 若 x 为 null 且 y 为 undefined，返回 true。 若 x 为 undefined 且 y 为 null，返回 true。 若 Type(x) 为 Number 且 Type(y) 为 String，返回 x == ToNumber(y) 的结果。 若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。 若 Type(x) 为 Boolean，返回比较 ToNumber(x) == y 的结果。 若 Type(y) 为 Boolean，返回比较 x == ToNumber(y) 的结果。 若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。 若 Type(x) 为 Object 且 Type(y) 为 String 或 Number，返回比较 ToPrimitive(x) == y 的结果。 返回 false。 123456789101112131415161718192021222324252627282930313233var a = 42;var b = &quot;42&quot;;a === b; // falsea == b; // truevar a = &quot;42&quot;;var b = true;a == b; // false 1==42var x = &quot;42&quot;;var y = false;x == y; // false 42==0var a = 42;var b = [ 42 ];a == b; // true 42==42var a = &quot;abc&quot;;var b = Object( a ); // same as `new String( a )`a === b; // falsea == b; // truevar a = null;var b = Object( a ); // same as `Object()`a == b; // falsevar c = undefined;var d = Object( c ); // same as `Object()`c == d; // falsevar e = NaN;var f = Object( e ); // same as `new Number( e )`e == f; // false 无论什么情况下都不要使用 == true 和 == false。 1234567891011121314151617181920212223242526var a = &quot;42&quot;;// 会失败if (a == true) { // ..}// 也会失败if (a === true) { // ..}// 没问题if (a) { // ..}// 更好if (!!a) { // ..}// 也很好if (Boolean( a )) { // ..} 其他情况更改内置原生原型会导致奇怪效果 12345678910111213141516171819202122Number.prototype.valueOf = function() { return 3;};new Number( 2 ) == 3; // true，因为valueOf返回3// 这种情况也会发生，如下if (a == 2 &amp;&amp; a == 3) { // ..}var i = 2;// 让 a.valueOf() 每次调用都产生副作用，第一次返回 2，第二次返回 3Number.prototype.valueOf = function() { return i++;};var a = new Number( 42 );if (a == 2 &amp;&amp; a == 3) { console.log( &quot;Yep, this happened.&quot; );} 123456789101112131415161718192021222324252627&quot;0&quot; == null; // false&quot;0&quot; == undefined; // false&quot;0&quot; == false; // true -- UH OH!&quot;0&quot; == NaN; // false&quot;0&quot; == 0; // true&quot;0&quot; == &quot;&quot;; // falsefalse == null; // falsefalse == undefined; // falsefalse == NaN; // falsefalse == 0; // true -- UH OH!false == &quot;&quot;; // true -- UH OH!false == []; // true -- UH OH!false == {}; // false&quot;&quot; == null; // false&quot;&quot; == undefined; // false&quot;&quot; == NaN; // false&quot;&quot; == 0; // true -- UH OH!&quot;&quot; == []; // true -- UH OH!&quot;&quot; == {}; // false0 == null; // false0 == undefined; // false0 == NaN; // false0 == []; // true -- UH OH!0 == {}; // false 有 7 种注释了“UH OH!”，因为它们属于假阳(false positive)的情况，里面坑很多。 “” 和 0 明显是两个不同的值，它们之间的强制类型转换很容易搞错。 12345[] == ![] // true,根据toBoolean变成[]==false2 == [2]; // true&quot;&quot; == [null]; // true0 == &quot;\\n&quot;; // true ，== 右边的值 [2] 和 [null] 会进行 ToPrimitive 强制类型转换， 以便能够和左边的基本类型值(2 和 “”)进行比较。因为数组的 valueOf() 返回数组本身， 所以强制类型转换过程中数组会进行字符串化。第一行中的 [2] 会转换为 &quot;2&quot;，然后通过 ToNumber 转换为 2。第二行中的 [null] 会直接转 换为 “”。所以最后的结果就是 2 == 2 和 &quot;&quot; == &quot;&quot;。 安全运用隐式强制转换，遵循以下两个原则： 如果两边的值中有 true 或者 false，千万不要使用 ==。 如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。 最好用 === 来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。 抽象关系比较比较双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。 如果比较双方都是字符串，则按字母顺序来进行比较: 123456789101112131415161718192021222324252627282930var a = [ 42 ];var b = [ &quot;43&quot; ];a &lt; b; // true 42&lt;43b &lt; a; // falsevar a = [ &quot;42&quot; ];var b = [ &quot;043&quot; ];a &lt; b; // false 字符串，&quot;42&quot; &lt; &quot;043&quot; 4&gt;0var a = [ 4, 2 ];var b = [ 0, 4, 3 ];a &lt; b; // false '4,2' &lt; '0,4,3'var a = { b: 42 };var b = { b: 43 };a &lt; b; // false '[object Object]' &lt; '[object Object]'// 以下很奇怪var a = { b: 42 };var b = { b: 43 };a &lt; b; // falsea == b; // falsea &gt; b; // falsea &lt;= b; // truea &gt;= b; // true JS中 &lt;= 是“不大于”的意思(即 !(a &gt; b)，处理为 !(b &lt; a))。同理 a &gt;= b 处理为 !(a&lt;b)。 要避免a &lt; b中发生隐式强制类型转换，我们只能确保a和b为相同的类型， 除此之外别无他法。 为了保证安全，应该对关系比较中的值进行显式强制类型转换 12345var a = [ 42 ];var b = &quot;043&quot;;a &lt; b; // false -- string comparison!Number( a ) &lt; Number( b ); // true -- number comparison! 小结类型转换了解显示隐式转换 一般编码规范的项目都会要求强制类型转换 再加上用了TS之后，要求更高了。 不过还是要知其然，更要知其所以然。","link":"/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%B2%BE%E8%AF%BB%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E5%8D%B7/"},{"title":"React和Vue","text":"在jsx文件中为什么一定要引用react1234567891011121314151617181920212223242526JSX 语法就是用React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。React.createElement( type, [props], [...children])React.cloneElement()React.cloneElement()与React.createElement()相似，不同的是它传入的第一个参数是一个 React元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。React.cloneElement( element, [props], [...children]) React 组件React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。 React.createClass()React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。 12345var Greeting = React.createClass({ render: function() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; }}); ES6 classES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。 12345class Greeting extemds React.Component{ render: function() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; }}; 无状态函数无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。 123function Greeting (props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;} React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。 元素与组件的区别组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。 1234function Greeting (props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;} componentWillReceiveProps应用场景如果子组件需要的数据是直接由父组件通过props传递过来就不需要在componentwillreceiveprops中setState，但是如果子组件有自己的状态，同时这个状态依赖于父组件的数据，那么就需要子组件单独进行setState操作，否则无法完成子组件的更新。同时有一点，在componentwillreceiveprops中写setState不会再次触发子组件的render。解释一下：父组件setState时会触发子组件的render，此时如果在子组件的componentwillreceiveprops里setState，给人的感觉是会再一次触发子组件的render（加上前面的一次就是两次），实际情况是不会的 vuex和redux使用有什么不同Vuex 其实是一个针对 Vue 特化的 Flux，主要是为了配合 Vue 本身的响应式机制。当然吸取了一些 Redux 的特点，比如单状态树和便于测试和热重载的 API，但是也选择性的放弃了一些在 Vue 的场景下并不契合的特性，比如强制的 immutability（在保证了每一次状态变化都能追踪的情况下强制的 immutability 带来的收益就很有限了）、为了同构而设计得较为繁琐的 API、必须依赖第三方库才能相对高效率地获得状态树的局部状态等等（相比之下 Vuex 直接用 Vue 本身的计算属性就可以）所以 Vue + Vuex 会更简洁，也不需要考虑性能问题，代价就是 Vuex 只能和 Vue 配合。Vue + Redux 也不是不可以，但是 Redux 作为一个泛用的实现和 Vue 的契合度肯定不如 Vuex。 nextTick的作用，原理，用api的场景$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM 也许有人会问，我在 Vue 实例方法中修改了数据，然后再在 $nextTick 回调中获取该数据在相应 DOM 元素所绑定的内容（或属性）殊无必要，我为什么需要这样的 API 呢？ 考虑这样一种场景，你有一个 jQuery 插件，希望在 DOM 元素中某些属性发生变化之后重新应用该插件，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。 当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 12345678910111213141516new Vue({ // ... methods: { // ... example: function () { // modify data this.message = 'changed' // DOM is not updated yet this.$nextTick(function () { // DOM is now updated // `this` is bound to the current instance this.doSomethingElse() }) } }}) 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中 vue的props，state, compute区别data: Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。 props: 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。 两个的区别就是data是响应式的？ 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。 计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。 react native 和原生的怎么通信pure componentReact15.3中新加了一个 PureComponent 类， 也就是纯组件，取代其前身 PureRenderMixin , PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可， 可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。 React Native 与 原生交互链接 vue.js 和vue.runtime.js区别vue.js 完整版：同时包含编译器和运行时的版本。 runtime.js 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 高阶组件？？ 解决了什么问题链接 适配器模式， 高阶函数的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。 对于高阶组件，它描述的便是接受React组件作为输入，输出一个新的React组件的组件。 高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的React组件，供其他组件调用。 高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用。 setState源码剖析，多次调用解密setState流程还是很复杂的，设计也很精巧，避免了重复无谓的刷新组件。它的主要流程如下 enqueueSetState将state放入队列中，并调用enqueueUpdate处理要更新的Component 如果组件当前正处于update事务中，则先将Component存入dirtyComponent中。否则调用batchedUpdates处理。 batchedUpdates发起一次transaction.perform()事务开始执行事务初始化，运行，结束三个阶段 1 初始化：事务初始化阶段没有注册方法，故无方法要执行 2 运行：执行setSate时传入的callback方法，一般不会传callback参数 3 结束：更新isBatchingUpdates为false，并执行FLUSH_BATCHED_UPDATES这个wrapper中的close方法FLUSH_BATCHED_UPDATES在close阶段，会循环遍历所有的dirtyComponents，调用updateComponent刷新组件，并执行它的pendingCallbacks, 也就是setState中设置的callback。 会调用到batchedUpdates进行批处理更新，React以事务的方式处理组件update，事务处理完后会调用wrapper.close(), react diff链接 三大要点 tree diff 两棵树只会对同一层次的节点进行比较。 component diff 判断是否是同一类型组件 element diff 同一节点 插入，删除，移动属性 在reactjs中我们需要更新时都是调用的setState setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。 就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新。 会合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了。 本质上还是递归调用receiveComponent的过程。 这里注意两个函数： inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。 _shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。 ==简单回顾下reactjs的差异算法：== 首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。 react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。 每个类型的元素都要处理好自己的更新： 自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。 text节点的更新很简单，直接更新文案。 浏览器基本元素的更新，分为两块： 先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。 然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。整个reactjs的差异算法就是这个样子。 最核心的两个_shouldUpdateReactComponent以及diff,patch算法。 //_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。 _patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。 链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556总结React 通过制定大胆的 diff 策略，将 O(n3)复杂度的问题转换成 O(n) 复杂度的问题；React 通过分层求异的策略，对 tree diff 进行算法优化；React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；React 通过设置唯一 key的策略，对 element diff 进行算法优化；建议，在开发组件时，保持稳定的 DOM结构会有助于性能的提升；建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。tree diffReact 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。component diff如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。对于同一类型的组件，有可能其 Virtual DOM没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过shouldComponentUpdate() 来判断该组件是否需要进行 diff。element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！ 设计组件组件尽量只做渲染，逻辑处理放到reducer中 redux 中的actionAction Creator 的唯一功能就是返回一个Action供 dispatch 进行调用。 在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件： 是一个纯文本对象 只具备 type 、payload、error 和 meta 中的一个或者多个属性。 type 字段不可缺省，其它字段可缺省 若 Action 报错，error 字段不可缺省，切必须为 true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869在 redux 全家桶中，可以利用 redux-actions 来创建符合 FSA 规范的Action：import {creatAction} from 'redux-actions';let addTodo = creatAction(ADD_TODO)//same aslet addTodo = creatAction(ADD_TODO,data=&gt;data)Redux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件：redux-thunkredux-promise用connect将组件绑定到reduxexport const ButtonContainer = connect( mapStateToProps, mapDispatchToProps)(Buttons);容器组件实现 mapStateToProps()（用于将状态映射到数据）和 mapDispatchToProps()（用于将状态映射到行为）同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。操作发起时的 Action操作成功时的 Action操作失败时的 Action操作开始时，送出一个 Action，触发 State 更新为&quot;正在操作&quot;状态，View 重新渲染用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数。这时，就要使用中间件redux-thunk。const fetchPosts = postTitle =&gt; (dispatch, getState) =&gt; { dispatch(requestPosts(postTitle)); return fetch(`/some/API/${postTitle}.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(postTitle, json))); };};// 使用方法一store.dispatch(fetchPosts('reactjs'));// 使用方法二store.dispatch(fetchPosts('reactjs')).then(() =&gt; console.log(store.getState()));看这里，返回的是Promise， ==用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。== store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。 Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法， Redux的单向数据流是同步操作，驱动Redux流程的是action对象，每一个action对象被派发到Store上之后，同步地被分配给所有的reducer函数，每个reducer都是纯函数，纯函数不产生任何副作用，自然是完成数据操作之后立刻同步返回，reducer返回的结果又被同步地拿去更新Store上的状态数据，更新状态数据的操作会立刻被同步给监听Store状态改变的函数，从而引发作为视图的React组件更新过程。 这个过程从头到尾，Redux马不停蹄地一路同步执行，根本没有执行异步操作的机会，那应该在哪里插入访问服务器的异步操作呢？ Redux创立之初就意识到了这种问题，所以提供了thunk这种解决方法，但是thunk并没有作为Redux的一部分一起发布，而是存在一个独立的redux-thunk发布包中， redux-thunk只是Redux中异步操作的解决方法之一 在Redux架构下，一个action对象在通过store.dispatch派发，在调用reducer函数之前，会先经过一个中间件的环节，这就是产生异步操作的机会，实际上redux-thunk提供的就是一个Redux中间件，我们需要在创建Store时用上这个中间件。 异步action对象非常好的讲解当我们想要让Redux帮忙处理一个异步操作的时候，代码一样也要派发一个action对象，毕竟Redux单向数据流就是由action对象驱动的。但是这个引发异步操作的action对象比较特殊，我们叫它们“异步action对象”。 前面例子中的action构造函数返回的都是一个普通的对象，这个对象包含若干字段，其中必不可少的字段是type，但是“异步action对象”不是一个普通JavaScript对象，而是一个函数。 如果没有redux-thunk中间件的存在，这样一个函数类型的action对象被派发出来会一路发送到各个reducer函数，reducer函数从这些实际上是函数的action对象上是无法获得type字段的，所以也做不了什么实质的处理。 不过，有了redux-thunk中间件之后，这些action对象根本没有机会触及到reducer函数，在中间件一层就被redux-thunk截获。 redux-thunk的工作是检查action对象是不是函数，如果不是函数就放行，完成普通action对象的生命周期，而如果发现action对象是函数，那就执行这个函数，并把Store的dispatch函数和getState函数作为参数传递到函数中去，处理过程到此为止，不会让这个异步action对象继续往前派发到reducer函数。 举一个并不涉及网络API访问的异步操作例子，在Counter组件中存在一个普通的同步增加计数的action构造函数increment，代码如下： 123const increment = () =&gt; ({ type: ActionTypes.INCREMENT,}); 派发increment执行返回的action对象，Redux会同步更新Store状态和视图，但是我们现在想要创造一个功能，能够发出一个“让Counter组件在1秒之后计数加一”的指令，这就需要定义一个新的异步action构造函数，代码如下： 1234567891011121314151617181920212223const incrementAsync = () =&gt; { return (dispatch) =&gt; { setTimeout(() =&gt; { dispatch(increment()); }, 1000); };};````异步action构造函数incrementAsync返回的是一个新的函数，这样一个函数被dispatch函数派发之后，会被redux-thunk中间件执行，于是setTimeout函数就会发生作用，在1秒之后利用参数dispatch函数派发出同步action构造函数increment的结果。这就是异步action的工作机理，这个例子虽然简单，但是可以看得出来，异步action最终还是要产生同步action派发才能对Redux系统产生影响。redux-thunk要做的工作也就不过如此，但因为引入了一次函数执行，而且这个函数还能够访问到dispatch和getState，就给异步操作带来了可能。action对象函数中完全可以通过fetch发起一个对服务器的异步请求，当得到服务器结果之后，通过参数dispatch，把成功或者失败的结果当做action对象再派发出去。这一次派发的是普通的action对象，就不会被redux-thunk截获，而是直接被派发到reducer，最终驱动Store上状态的改变。通常我们在组件的componentDidMount函数中做请求服务器的事情，因为当生命周期函数componentDidMount被调用的时候，表明装载过程已经完成，组件需要渲染的内容已经在DOM树上出现，对服务器的请求可能依赖于已经渲染的内容，在componentDidMount函数中发送对服务器请求是一个合适的时机。fetch函数执行会立刻返回，返回一个Promise类型的对象，所以后面会跟上一大串then和catch的语句。每个Promise成功的时候，对应的then中的回调函数会被调用；如果失败，对应catch中的回调函数也被调用。# vue声明组件 一、全局注册// 注册Vue.component(‘my-component’, { template: ‘A custom component!‘}) 操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染 用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？ // 创建根实例new Vue({ el: ‘#example’}) 二、局部注册var Child = { template: ‘A custom component!‘} new Vue({ // … components: { // 将只在父组件模板中可用 ‘my-component’: Child }}) 12345678910111213141516# 检测变化的注意事项Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：Vue.set(vm.someObject, 'b', 2)this.$set(this.someObject,'b',2)想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) 123456789# watch 深度监听==deep： true==一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 watch: { a: function (val, oldVal) { console.log(‘new: %s, old: %s’, val, oldVal) }, // 方法名 b: ‘someMethod’, // 深度 watcher c: { handler: function (val, oldVal) { /* … / }, deep: true }, // 该回调将会在侦听开始之后被立即调用 d: { handler: function (val, oldVal) { / … / }, immediate: true }, e: [ function handle1 (val, oldVal) { / … / }, function handle2 (val, oldVal) { / … / } ], // watch vm.e.f’s value: {g: 5} ‘e.f’: function (val, oldVal) { / … */ }} 123# 异步更新队列 this.$nextTick(function () { console.log(this.$el.textContent) // =&gt; ‘更新完成’ }) 1234567891011121314# 计算属性 computed对于任何复杂逻辑，你都应当使用计算属性。当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。==方法和计算属性：== 两种方式的最终结果确实是完全相同的。不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage计算属性会立即返回之前的计算结果，而不必再次执行函数。 computed: { // 计算属性的 getter reversedMessage: function () { // this 指向 vm 实例 return this.message.split(‘’).reverse().join(‘’) }} console.log(vm.reversedMessage) // =&gt; ‘olleH’vm.message = ‘Goodbye’console.log(vm.reversedMessage) // =&gt; ‘eybdooG’ // 在组件中methods: { reversedMessage: function () { return this.message.split(‘’).reverse().join(‘’) }} 123# 计算属性的 setter // …computed: { fullName: { // getter get: function () { return this.firstName + ‘ ‘ + this.lastName }, // setter set: function (newValue) { var names = newValue.split(‘ ‘) this.firstName = names[0] this.lastName = names[names.length - 1] } }} 1234567# watch 侦听器虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 watch: { // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = ‘Waiting for you to stop typing…’ this.getAnswer() }}, 12345678910111213# getters作用Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。this.$store.getters.doneTodosCount# mapGetters 辅助函数mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：# 提交 mutation 的另一种方式是直接使用包含 type 属性的对象 store.commit({ type: ‘increment’, amount: 10}) store.commit(‘increment’, { amount: 10})可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods映射为 store.commit 调用（需要在根节点注入 store）。 1234567891011121314151617181920212223242526272829303132333435363738394041# 分发 ActionAction 通过 store.dispatch 方法触发：store.dispatch('increment')# vue组件类型, 怎么定义一个组件# vue切换路由其他方式 不留痕迹```html一、router.push(location, onComplete?, onAbort?)&lt;router-link :to=&quot;...&quot;&gt; router.push(...)const userId = 123router.push({ name: 'user', params: { userId }}) // -&gt; /user/123router.push({ path: `/user/${userId}` }) // -&gt; /user/123// 字符串router.push('home')// 对象router.push({ path: 'home' })// 命名的路由router.push({ name: 'user', params: { userId: 123 }})// 带查询参数，变成 /register?plan=privaterouter.push({ path: 'register', query: { plan: 'private' }})二、 router.replace(location, onComplete?, onAbort?)跟 router.push 很像，唯一的不同就是，它不会向 history添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。三、router.go(n)在 history 记录中向前或者后退多少步，类似 window.history.go(n)。 vue-router传参方式12345678910111213141516171819query 和params { path: '/news/:id', component: NewsDetail }, &lt;span&gt;{{$route.params.id}}&lt;/span&gt;区别1、用法 query要用path来引入，params要用name来引入， 接收参数都是类似的， 分别是this.$route.query.name和this.$route.params.name。 接收参数时，已经是$route而不是$router了哦！！2、展示 query更加类似于我们ajax中get传参，params则类似于post， 说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示query:params: 受控组件 非受控组件没有任何嵌套关系的组件之间传值12345678910111213141516171819(1) Event Emitter/Target/Dispatcher// to subscribeotherObject.addEventListener(‘click’, function() { alert(‘click!’); });// to dispatchthis.dispatchEvent(‘click’);(2) Publish / Subscribe// to subscribeglobalBroadcaster.subscribe(‘click’, function() { alert(‘click!’); });// to dispatchglobalBroadcaster.publish(‘click’);(3) Signals// to subscribeotherObject.clicked.add(function() { alert(‘click’); });// to dispatchthis.clicked.dispatch(); this.setState()参数12345678910111213141516这个函数接受两个参数，第一个参数表示上一个状态值，第二参数表示当前的 props，第二个参数是 state 导致的页面变化完成后的回调，等价于componentDidUpdate。this.setState((prevState, props) =&gt; ({ counter: prevState.counter + props.increment}));setState的关键点:setState不会立刻改变React组件中state的值；setState通过引发一次组件的更新过程来引发重新绘制；多次setState函数调用产生的效果会合并。当setState被调用时，能驱动组件的更新过程，引发componentDidUpdate、render等一系列函数的调用。 React的生命周期主要分为三段，mount（挂载）、update（更新）、unmount（卸载） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667一、mount，即挂载阶段， 第一次让组件出现在页面中的过程，React会将render的返回值插入到页面中， 这个过程会暴露以下几个钩子（hook）： constructor() // 初始化props和state 初始化getDefaultProps()和getInitialState() getDefaultProps: 执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制getInitialState : 控件加载之前执行，返回值会被用于state的初始化值 初始化 componentWillMount() // 将要被插入 执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次 render() // 将return的内容插入到页面里 componentDidMount() // 插入完成后的动作 在组件被装配后立即调用。 初始化使得DOM节点应该进行到这里。 若你需要从远端加载数据， 这是一个适合实现网络请求的地方。 在该方法里设置状态将会触发重渲。二、update，即更新阶段，如果数据有任何变动就会来这一阶段，这个过程有5个钩子： componentWillReceiveProps( nextprops ) // 接受需要更新的props 在装配了的组件接收到新属性前调用。 若你需要更新状态响应属性改变（例如，重置它）， 你可能需对比this.props和nextProps 并在该方法中使用this.setState()处理状态改变。 注意即使属性未有任何改变，React可能也会调用该方法，因此若你想要处理改变，请确保比较当前和之后的值。这可能会发生在当父组件引起你的组件重渲。 shouldComponentUpdate( nextProps, nextState ) // 请问要不要更新组件 true/false 接收到新属性或状态时， shouldComponentUpdate() 在渲染前被调用。默认为true。 该方法并不会在初始化渲染或当使用forceUpdate()时被调用。 当他们状态改变时，返回false 并不能阻止子组件重渲。 若shouldComponentUpdate()返回false，componentWillUpdate()将不会被调用。 componentWillUpdate() // 准备更新组件啦 render() // 更新 componentDidUpdate() // 更新完成 该方法并不会在初始化渲染时调用。三、unmount，即卸载过程，当一个组件要从页面移除时，会进入这个过程，其中有一个钩子： componentWillUnmount() // 要卸载啦 可以在该方法里处理任何必要的清理工作， 例如解绑定时器，取消网络请求， 清理任何在componentDidMount环节创建的DOM元素。一般我们只在这几个钩子里setState：componentWillMount()componentDidMount()componentWillReceiveProps() Redux原理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Redux 和 React 没有直接关系，它瞄准的目标是应用状态管理。核心概念是 Map/Reduce 中的 Reduce。且 Reducer 的执行是同步，产生的 State 是 Immutable 的。改变 State 只能通过向 Reducer dispatch actions 来完成。State 的不同字段，可以通过不同的 Reducers 来分别维护。combineReducers 负责组合这些 Reducers，前提是每个 Reducer 只能维护自己关心的字段。Action 对象只能是 Javascript Plain Object，但是通过在 store 上装载 middleware，则可以任意定义 action 对象的形式，反正会有特定的 middleware 负责将此 action 对象变为 Javascript Plain Object。可以以middleware 链条为集中点实现很多控制逻辑，例如 Log，Undo, ErrorHandler 等。Redux 仅仅专注于应用状态的维护，reducer、dispatch/middleware 是两个常用扩展点、Higher-order Store 则仅针对需要扩展全部 Store 功能时使用。react-redux 是 Redux 针对 React/React-Native 的 Binding，connect/selector 是扩展点，负责将 store 中的状态添加到 React component 的 props 中。Redux 借用了很多函数式编程的思想，了解函数式编程会利于理解其实现原理，虽然使用它不需要了解很多函数式编程的概念。和 Flux 相比，Redux 的概念更精简、约定更严格、状态更确定、而是扩展却更灵活。通过 https://github.com/xgrommx/awesome-redux 可以获得大量参考。链接：https://www.jianshu.com/p/3334467e4b32redux有三大准则单一数据源整个应用状态，都应该被存储在单一store的对象树中。只读状态唯一可以修改状态的方式，就是发送（dispatch）一个动作（Action），通俗来讲，就是说只有getter，没有setter。使用纯函数去修改状态纯函数保障了状态的稳定性，不会因不同环境导致应用程序出现不同情况，听说是redux真正的精髓，日后可以深入了解。 谈谈MVVM模式1234567891011Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 2:mvvm和mvc区别12345mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到View 。 让CSS只在当前组件中起作用1将当前组件的&lt;style&gt;修改为&lt;style scoped&gt; Vue中使用插件的步骤12采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true }) 组件的使用和自己创建公用组件1234567第一步：在components目录新建你的组件文件（indexPage.vue）， script一定要export default {}第二步：在需要用的页面（组件）中导入： import indexPage from '@/components/indexPage.vue'第三步：注入到vue的子组件的components属性上面,components:{indexPage}第四步：在template视图view中使用，问题有indexPage命名，使用的时候则index-page。 vue如何实现按需加载配合webpack设置123webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。不进行页面按需加载引入方式：import home from '../../common/home.vue'进行页面按需加载的引入方式：const home = r =&gt; require.ensure( [], () =&gt; r (require('../../common/home.vue'))) 作用1&lt;keep-alive&gt;&lt;/keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。 vue-route模式12345678默认为hash，但是用hash模式的话，页面地址会加#所以一般采用 history模式````# vue阻止事件 .stop 阻止事件冒泡 .prevent 阻止默认事件 .capture 阻止事件捕获 .once 只触发一次 123# router传参数 routes: [ { path: ‘/linkParams/:name’, name:’linkParams’, component: linkParams }] 获取name let name = this.$route.params.name // 字符串,这里的字符串是路径path匹配噢，不是router配置里的namethis.$router.push(‘home’) // 对象this.$router.push({ path: ‘home’ }) // 命名的路由 这里会变成 /user/123this.$router.push({ name: ‘user’, params: { userId: 123 }}) // 带查询参数，变成 /register?plan=privatethis.$router.push({ path: ‘register’, query: { plan: ‘private’ }}) router.beforeEach((to, from, next)=&gt;{ //do something next();});router.afterEach((to, from, next) =&gt; { console.log(to.path);}); 每个钩子方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 123SSR实现原理 app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端。 Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的。 1234567# Vue实例初始化的过程中实现依赖管理的分析[链接](http://www.bslxx.com/a/vue/2018/0301/1795.html)大致的总结下就是： initState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。 当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤：第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 123# Vue声明组件的state是用data方法，那为什么data是通过一个function来返回一个对象，而不是直接写一个对象呢 答：从语法上说，如果不用function返回就会出现语法错误导致编译不通过。从原理上的话，大概就是组件可以被多次创建，如果不使用function就会使所有调用该组件的页面公用同一个数据域，这样就失去了组件的概念了 123# vuex State、 Getter、Mutation 、Action、 Module通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。应用级的状态集中放在store中；改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 一、Action 类似于 mutation，不同在于：二、Action 提交的是 mutation，而不是直接变更状态。三、Action 可以包含任意异步操作 一、getters 可以对State进行计算操作，它就是Store的计算属性二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用三、 如果一个状态只在一个组件内使用，是可以不用getters 二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中 123# 说下vue组件之间的通信 答：非父子组件间通信，Vue 有提供 Vuex，以状态共享方式来实现通信 prop 向下传递，事件向上传递。还可以通过$emit方法出发一个消息，然后$on接收这个消息 兄弟组件间的数据通讯，它们将会 寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法 。 var Event = new Vue()//父组件 Event.$on(“a-msg”, function (a) { this.a = a; }.bind(this)); // 子组件 Event.$emit(“a-msg”, this.a); 1234567# Vue 生命周期# 简单描述每个周期具体适合哪些场景Create Mount Update Destroy beforeCreate（创建前）,created（创建后）, beforeMount(载入前),mounted（载入后）, beforeUpdate（更新前）,updated（更新后）, beforeDestroy（销毁前）,destroyed（销毁后） 每个钩子函数都在啥时间触发 beforeCreate在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted挂载元素，获取到DOM节点el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。 destroyedVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 生命周期钩子的一些常见使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时需要执行的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted: 在这发起后端请求，拿回数据，配合路由钩子做一些事情 updated : 如果对数据统一处理，在这里写上相应函数beforeDestroy : 可以做一个确认停止事件的确认框 你确认删除XX吗？nextTick : 更新数据后立即操作domactivated::keep-alive组件激活时调用 123# v-show和v-if指令的共同点和不同点 v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果 v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 1.v-if 指令可以应用于template包装元素上，而v-show不支持template2.将v-show应用在组件上时，因为指令的优先级v-else 会出现问题，解决办法就是用另一个 v-show 替换 v-else // 错误 这可能也是一个组件 // 正确做法 这可能也是一个组件 123# vue 父子组件嵌套时，组件内部的各个生命周期钩子触发先后顺序 顺序是 先创建父组件(父组件beforeMount)，然后才创建子组件，当子组件创建完成并且实体dom挂载完成后(子组件先mounted)父组件才挂载完成(父组件mounted) 123# h函数 它来自单词 hyperscript， 这个单词通常用在 virtual-dom 的实现中。 Hyperscript 本身是指 生成HTML 结构的 script 脚本，因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言） 个人理解：createElement 函数是用来生成 HTML DOM元素的，也就是上文中的 generate HTMLstructures，也就是 Hyperscript，这样作者才把 createElement 简写成 h。 大概的翻译下：render: h =&gt; h(App) 是下面内容的缩写： render: function (createElement) { return createElement(App);}进一步缩写为(ES6 语法)： render (createElement) { return createElement(App);}再进一步缩写为： render (h){ return h(App);}按照 ES6 箭头函数的写法，就得到了： render: h =&gt; h(App); 12345# react-redux中connect函数[链接](https://segmentfault.com/a/1190000010188279) connect方法做的事情是将state和dispatch绑定到Connect组件的参数上，然后Connect组件将你当前的App组件封装起来，使得App组件可以通过props获取到父组件Connect传递的state和props。 Provider是顶层组件的作用，将store作为上下文提供给全局共享，而Connect组件是局部组件，将某个react组件包装起来，传递指定的state和props给该组件访问。 connect()返回值是Connect组件（请注意大小写的区别）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# Vue和React区别### 相同- 使用 Virtual DOM- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。都是JavaScript的UI框架，专注于创造前端的富应用。不同于早期的JavaScript框架“功能齐全”，### 区别- **性能** 计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。 Vue可以更快地计算出Virtual DOM的差异， 这是由于它在渲染过程中， 会跟踪每一个组件的依赖关系， 不需要重新渲染整个组件树。 而对于React而言，每当应用的状态被改变时， 全部子组件都会重新渲染。 当然，这可以通过shouldComponentUpdate 这个生命周期方法来进行控制， 但Vue将此视为默认的优化。- **JSX和Templates** React 中，所有的组件的渲染功能都依靠 JSX 可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。 模板比起 JSX 读写起来更自然。 基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。 可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。 vue的模板语法去除了往视图/组件中添加逻辑的诱惑，保持了关注点分离。 与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已。- **组件作用域内的 CSS** Vue 设置样式的默认方法是单文件组件里类似 style 的标签。 可选 scoped 属性会自动添加一个唯一的属性 CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的- **Props** JSX库中，数据通过props传到子组件中去。 在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态” 在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。- **构建工具** React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。- **配套框架** Vue的核心团队维护着vue-router和vuex， 它们由官方维护支持且与核心库同步更新的。 而React的react-router和react-redux则是由社区成员维护， 创建了一个更分散的生态系统- **向下扩展** React 学习曲线陡峭，学 React 前，你需要知道 JSX 和 ES2015，- **原生渲染** Weex 还在积极发展，成熟度也不能和 React Native 相抗衡。&lt;https://juejin.im/post/5a9b8417518825558251ce15&gt;# redux原理[链接](https://segmentfault.com/a/1190000004236064)# redux流程[Redux 入门教程](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html) // store// Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 import { createStore } from ‘redux’;const store = createStore(fn); //数据集合，就叫做 Stateconst state = store.getState(); // Action Creator定义一个函数来生成 Actionconst ADD_TODO = ‘添加 TODO’; function addTodo(text) { return { type: ADD_TODO, text }} const action = addTodo(‘Learn Redux’); //store.dispatch()是 View 发出 Action 的唯一方法。 import { createStore } from ‘redux’;const store = createStore(fn); store.dispatch({ type: ‘ADD_TODO’, payload: ‘Learn Redux’}); store.dispatch(addTodo(‘Learn Redux’)); //Reducer State 的计算过程就叫做 Reducer。接受 Action 和当前 State 作为参数，返回一个新的 State。 const reducer = function (state, action) { // … return new_state;}; const defaultState = 0;const reducer = (state = defaultState, action) =&gt; { switch (action.type) { case ‘ADD’: return state + action.payload; default: return state; }}; const state = reducer(1, { type: ‘ADD’, payload: 2}); Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。 import { createStore } from ‘redux’;const store = createStore(reducer); createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 reducer最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。 不得改写参数不能调用系统 I/O 的API不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 必须返回一个全新的对象// State 是一个对象function reducer(state, action) { return Object.assign({}, state, { thingToChange }); // 或者 return { …state, …newState };} // State 是一个数组function reducer(state, action) { return […state, newItem];}","link":"/posts/React%20%E5%92%8CVue/"},{"title":"Promise深度解析","text":"这一章节就是整理了45道Promise的笔试题让大家爽一爽 😁。 这篇文章是一篇比较纯的Promise笔试文章，是我自己在做题的时候，根据题目想要的考点来反敲知识点，然后再由这个知识点编写从浅到深的的题目。 本文的题目没有到特别深入，不过应该覆盖了大部分的考点，另外为了不把大家绕混，答案也没有考虑在Node的执行结果，执行结果全为浏览器环境下。 OK👌， 来看看通过阅读本篇文章你可以学到： Promise的几道基础题 Promise结合setTimeout Promise中的then、catch、finally Promise中的all和race async/await的几道题 async处理错误 综合题 几道大厂的面试题 前期准备在做下面👇的题目之前，我希望你能清楚几个知识点。 (如果你感觉一上来不想看这些列举的知识点的话，直接看后面的例子再来理解它们也可以) event loop它的执行顺序： 一开始整个脚本作为一个宏任务执行 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完 执行浏览器UI线程的渲染工作 检查是否有Web Worker任务，有则执行 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空 微任务包括：MutationObserver、Promise.then()或catch()、Promise为基础开发的其它技术，比如fetch API、V8的垃圾回收过程、Node独有的process.nextTick。 宏任务包括：script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering。 注意⚠️：在所有任务开始的时候，由于宏任务中包括了script，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如setTimeout)将被放到下一轮宏任务中来执行。 1. Promise的几道基础题1.1 题目一const promise1 = new Promise((resolve, reject) =&gt; { console.log('promise1') }) console.log('1', promise1); 复制代码 过程分析： 从上至下，先遇到new Promise，执行该构造函数中的代码promise1 然后执行同步代码1，此时promise1没有被resolve或者reject，因此状态还是pending 结果： 'promise1' '1' Promise{&lt;pending&gt;} 复制代码 1.2 题目二const promise = new Promise((resolve, reject) =&gt; { console.log(1); resolve('success') console.log(2); }); promise.then(() =&gt; { console.log(3); }); console.log(4); 复制代码 过程分析： 从上至下，先遇到new Promise，执行其中的同步代码1 再遇到resolve('success')， 将promise的状态改为了resolved并且将值保存下来 继续执行同步代码2 跳出promise，往下执行，碰到promise.then这个微任务，将其加入微任务队列 执行同步代码4 本轮宏任务全部执行完毕，检查微任务队列，发现promise.then这个微任务且状态为resolved，执行它。 结果： 1 2 4 3 复制代码 1.3 题目三const promise = new Promise((resolve, reject) =&gt; { console.log(1); console.log(2); }); promise.then(() =&gt; { console.log(3); }); console.log(4); 复制代码 过程分析 和题目二相似，只不过在promise中并没有resolve或者reject 因此promise.then并不会执行，它只有在被改变了状态之后才会执行。 结果： 1 2 4 复制代码 1.4 题目四const promise1 = new Promise((resolve, reject) =&gt; { console.log('promise1') resolve('resolve1') }) const promise2 = promise1.then(res =&gt; { console.log(res) }) console.log('1', promise1); console.log('2', promise2); 复制代码 过程分析： 从上至下，先遇到new Promise，执行该构造函数中的代码promise1 碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来 碰到promise1.then这个微任务，将它放入微任务队列 promise2是一个新的状态为pending的Promise 执行同步代码1， 同时打印出promise1的状态是resolved 执行同步代码2，同时打印出promise2的状态是pending 宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。 结果： 'promise1' '1' Promise{&lt;resolved&gt;: 'resolve1'} '2' Promise{&lt;pending&gt;} 'resolve1' 复制代码 1.5 题目五接下来看看这道题： const fn = () =&gt; (new Promise((resolve, reject) =&gt; { console.log(1); resolve('success') })) fn().then(res =&gt; { console.log(res) }) console.log('start') 复制代码 这道题里最先执行的是'start'吗 🤔️ ？ 请仔细看看哦，fn函数它是直接返回了一个new Promise的，而且fn函数的调用是在start之前，所以它里面的内容应该会先执行。 结果： 1 'start' 'success' 复制代码 1.6 题目六如果把fn的调用放到start之后呢？ const fn = () =&gt; new Promise((resolve, reject) =&gt; { console.log(1); resolve(&quot;success&quot;); }); console.log(&quot;start&quot;); fn().then(res =&gt; { console.log(res); }); 复制代码 是的，现在start就在1之前打印出来了，因为fn函数是之后执行的。 注意⚠️：之前我们很容易就以为看到new Promise()就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。 答案： &quot;start&quot; 1 &quot;success&quot; 复制代码 好嘞，学完了这几道基础题，让我们来用个表情包压压惊。 2. Promise结合setTimeout2.1 题目一console.log('start') setTimeout(() =&gt; { console.log('time') }) Promise.resolve().then(() =&gt; { console.log('resolve') }) console.log('end') 复制代码 过程分析： 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出start和end。 setTimout作为一个宏任务被放入宏任务队列(下一个) Promise.then作为一个微任务被放入微任务队列 本次宏任务执行完，检查微任务，发现Promise.then，执行它 接下来进入下一个宏任务，发现setTimeout，执行。 结果： 'start' 'end' 'resolve' 'time' 复制代码 2.2 题目二const promise = new Promise((resolve, reject) =&gt; { console.log(1); setTimeout(() =&gt; { console.log(&quot;timerStart&quot;); resolve(&quot;success&quot;); console.log(&quot;timerEnd&quot;); }, 0); console.log(2); }); promise.then((res) =&gt; { console.log(res); }); console.log(4); 复制代码 过程分析： 和题目1.2很像，不过在resolve的外层加了一层setTimeout定时器。 从上至下，先遇到new Promise，执行该构造函数中的代码1 然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行 执行同步代码2 跳出promise函数，遇到promise.then，但其状态还是为pending，这里理解为先不执行 执行同步代码4 一轮循环过后，进入第二次宏任务，发现延迟队列中有setTimeout定时器，执行它 首先执行timerStart，然后遇到了resolve，将promise的状态改为resolved且保存结果并将之前的promise.then推入微任务队列 继续执行同步代码timerEnd 宏任务全部执行完毕，查找微任务队列，发现promise.then这个微任务，执行它。 因此执行结果为： 1 2 4 &quot;timerStart&quot; &quot;timerEnd&quot; &quot;success&quot; 复制代码 2.3 题目三题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么： (1): setTimeout(() =&gt; { console.log('timer1'); setTimeout(() =&gt; { console.log('timer3') }, 0) }, 0) setTimeout(() =&gt; { console.log('timer2') }, 0) console.log('start') 复制代码 (2): setTimeout(() =&gt; { console.log('timer1'); Promise.resolve().then(() =&gt; { console.log('promise') }) }, 0) setTimeout(() =&gt; { console.log('timer2') }, 0) console.log('start') 复制代码 执行结果： 'start' 'timer1' 'timer2' 'timer3' 复制代码 'start' 'timer1' 'promise' 'timer2' 复制代码 这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。 一个是为定时器timer3，一个是为Promise.then 但是如果是定时器timer3的话，它会在timer2后执行，而Promise.then却是在timer2之前执行。 你可以这样理解，Promise.then是微任务，它会被加入到本轮中的微任务列表，而定时器timer3是宏任务，它会被加入到下一轮的宏任务中。 理解完这两个案例，可以来看看下面一道比较难的题目了。 2.3 题目三Promise.resolve().then(() =&gt; { console.log('promise1'); const timer2 = setTimeout(() =&gt; { console.log('timer2') }, 0) }); const timer1 = setTimeout(() =&gt; { console.log('timer1') Promise.resolve().then(() =&gt; { console.log('promise2') }) }, 0) console.log('start'); 复制代码 这道题稍微的难一些，在promise中执行定时器，又在定时器中执行promise； 并且要注意的是，这里的Promise是直接resolve的，而之前的new Promise不一样。 (偷偷告诉你，这道题往下一点有流程图) 因此过程分析为： 刚开始整个脚本作为第一次宏任务来执行，我们将它标记为宏1，从上至下执行 遇到Promise.resolve().then这个微任务，将then中的内容加入第一次的微任务队列标记为微1 遇到定时器timer1，将它加入下一次宏任务的延迟列表，标记为宏2，等待执行(先不管里面是什么内容) 执行宏1中的同步代码start 第一次宏任务(宏1)执行完毕，检查第一次的微任务队列(微1)，发现有一个promise.then这个微任务需要执行 执行打印出微1中同步代码promise1，然后发现定时器timer2，将它加入宏2的后面，标记为宏3 第一次微任务队列(微1)执行完毕，执行第二次宏任务(宏2)，首先执行同步代码timer1 然后遇到了promise2这个微任务，将它加入此次循环的微任务队列，标记为微2 宏2中没有同步代码可执行了，查找本次循环的微任务队列(微2)，发现了promise2，执行它 第二轮执行完毕，执行宏3，打印出timer2 所以结果为： 'start' 'promise1' 'timer1' 'promise2' 'timer2' 复制代码 如果感觉有点绕的话，可以看下面这张图，就一目了然了。 ![](https://juejin.im/post/data:image/svg+xml;utf8,) 2.4 题目四const promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('success') }, 1000) }) const promise2 = promise1.then(() =&gt; { throw new Error('error!!!') }) console.log('promise1', promise1) console.log('promise2', promise2) setTimeout(() =&gt; { console.log('promise1', promise1) console.log('promise2', promise2) }, 2000) 复制代码 过程分析： 从上至下，先执行第一个new Promise中的函数，碰到setTimeout将它加入下一个宏任务列表 跳出new Promise，碰到promise1.then这个微任务，但其状态还是为pending，这里理解为先不执行 promise2是一个新的状态为pending的Promise 执行同步代码console.log('promise1')，且打印出的promise1的状态为pending 执行同步代码console.log('promise2')，且打印出的promise2的状态为pending 碰到第二个定时器，将其放入下一个宏任务列表 第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务 先执行第一个定时器里的内容，将promise1的状态改为resolved且保存结果并将之前的promise1.then推入微任务队列 该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是promise1.then，它抛出了一个错误，且将promise2的状态设置为了rejected 第一个定时器执行完毕，开始执行第二个定时器中的内容 打印出'promise1'，且此时promise1的状态为resolved 打印出'promise2'，且此时promise2的状态为rejected 完整的结果为： 'promise1' Promise{&lt;pending&gt;} 'promise2' Promise{&lt;pending&gt;} test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102 'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;} 'promise2' Promise{&lt;rejected&gt;: Error: error!!!} 复制代码 2.5 题目五如果你上面这道题搞懂了之后，我们就可以来做做这道了，你应该能很快就给出答案： const promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;success&quot;); console.log(&quot;timer1&quot;); }, 1000); console.log(&quot;promise1里的内容&quot;); }); const promise2 = promise1.then(() =&gt; { throw new Error(&quot;error!!!&quot;); }); console.log(&quot;promise1&quot;, promise1); console.log(&quot;promise2&quot;, promise2); setTimeout(() =&gt; { console.log(&quot;timer2&quot;); console.log(&quot;promise1&quot;, promise1); console.log(&quot;promise2&quot;, promise2); }, 2000); 复制代码 结果： 'promise1里的内容' 'promise1' Promise{&lt;pending&gt;} 'promise2' Promise{&lt;pending&gt;} 'timer1' test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102 'timer2' 'promise1' Promise{&lt;resolved&gt;: &quot;success&quot;} 'promise2' Promise{&lt;rejected&gt;: Error: error!!!} 复制代码 3. Promise中的then、catch、finally额，可能你看到下面👇这么多的1，2，3脾气就上来了，不是说好了本篇文章没什么屁话嘛，怎么还是这么多一二三四。 😂，你要理解我的用心良苦啊，我这是帮你把知识点都列举出来，做个总结而已。当然，你也可以先不看，先去做后面的题，然后再回过头来看这些，你就觉得这些点都好好懂啊，甚至都不需要记。 总结： Promise的状态一经改变就不能再改变。(见3.1) .then和.catch都会返回一个新的Promise。(上面的👆1.4证明了) catch不管被连接到哪里，都能捕获上层未捕捉过的错误。(见3.2) 在Promise中，返回任意一个非 promise 的值都会被包裹成 promise 对象，例如return 2会被包装为return Promise.resolve(2)。 Promise 的 .then 或者 .catch 可以被调用多次, 但如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用.then或者.catch的时候都会直接拿到该值。(见3.5) .then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。(见3.6) .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。(见3.7) .then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。(见3.8) .then方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为catch是.then第二个参数的简便写法。(见3.9) .finally方法也是返回一个Promise，他在Promise结束的时候，无论结果为resolved还是rejected，都会执行里面的回调函数。 3.1 题目一const promise = new Promise((resolve, reject) =&gt; { resolve(&quot;success1&quot;); reject(&quot;error&quot;); resolve(&quot;success2&quot;); }); promise .then(res =&gt; { console.log(&quot;then: &quot;, res); }).catch(err =&gt; { console.log(&quot;catch: &quot;, err); }) 复制代码 结果： &quot;then: success1&quot; 复制代码 构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，Promise的状态一经改变就不能再改变。 3.2 题目二const promise = new Promise((resolve, reject) =&gt; { reject(&quot;error&quot;); resolve(&quot;success2&quot;); }); promise .then(res =&gt; { console.log(&quot;then1: &quot;, res); }).then(res =&gt; { console.log(&quot;then2: &quot;, res); }).catch(err =&gt; { console.log(&quot;catch: &quot;, err); }).then(res =&gt; { console.log(&quot;then3: &quot;, res); }) 复制代码 结果： &quot;catch: &quot; &quot;error&quot; &quot;then3: &quot; undefined 复制代码 验证了第三个结论，catch不管被连接到哪里，都能捕获上层未捕捉过的错误。 至于then3也会被执行，那是因为catch()也会返回一个Promise，且由于这个Promise没有返回值，所以打印出来的是undefined。 3.3 题目三Promise.resolve(1) .then(res =&gt; { console.log(res); return 2; }) .catch(err =&gt; { return 3; }) .then(res =&gt; { console.log(res); }); 复制代码 结果： 1 2 复制代码 Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。 上面的输出结果之所以依次打印出1和2，那是因为resolve(1)之后走的是第一个then方法，并没有走catch里，所以第二个then中的res得到的实际上是第一个then的返回值。 且return 2会被包装成resolve(2)。 3.4 题目四如果把3.3中的Promise.resolve(1)改为Promise.reject(1)又会怎么样呢？ Promise.reject(1) .then(res =&gt; { console.log(res); return 2; }) .catch(err =&gt; { console.log(err); return 3 }) .then(res =&gt; { console.log(res); }); 复制代码 结果： 1 3 复制代码 结果打印的当然是 1 和 3啦，因为reject(1)此时走的就是catch，且第二个then中的res得到的就是catch中的返回值。 3.5 题目五const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log('timer') resolve('success') }, 1000) }) const start = Date.now(); promise.then(res =&gt; { console.log(res, Date.now() - start) }) promise.then(res =&gt; { console.log(res, Date.now() - start) }) 复制代码 执行结果： 'timer' 'success' 1001 'success' 1002 复制代码 当然，如果你足够快的话，也可能两个都是1001。 Promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。 3.6 题目六Promise.resolve().then(() =&gt; { return new Error('error!!!') }).then(res =&gt; { console.log(&quot;then: &quot;, res) }).catch(err =&gt; { console.log(&quot;catch: &quot;, err) }) 复制代码 猜猜这里的结果输出的是什么 🤔️ ？ 你可能想到的是进入.catch然后被捕获了错误。 结果并不是这样的，它走的是.then里面： &quot;then: &quot; &quot;Error: error!!!&quot; 复制代码 这也验证了第4点和第6点，返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error('error!!!')也被包裹成了return Promise.resolve(new Error('error!!!'))。 当然如果你抛出一个错误的话，可以用下面👇两的任意一种： return Promise.reject(new Error('error!!!')); // or throw new Error('error!!!') 复制代码 3.7 题目七const promise = Promise.resolve().then(() =&gt; { return promise; }) promise.catch(console.err) 复制代码 .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。 因此结果会报错： Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt; 复制代码 3.8 题目八Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 复制代码 这道题看着好像很简单，又感觉很复杂的样子，怎么这么多个.then啊… 😅 其实你只要记住原则8：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传。 第一个then和第二个then中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个then里。 所以输出结果为： 1 复制代码 3.9 题目九下面来介绍一下.then函数中的两个参数。 第一个参数是用来处理Promise成功的函数，第二个则是处理失败的函数。 也就是说Promise.resolve('1')的值会进入成功的函数，Promise.reject('2')的值会进入失败的函数。 让我们来看看这个例子🌰： Promise.reject('err!!!') .then((res) =&gt; { console.log('success', res) }, (err) =&gt; { console.log('error', err) }).catch(err =&gt; { console.log('catch', err) }) 复制代码 这里的执行结果是： 'error' 'error!!!' 复制代码 它进入的是then()中的第二个参数里面，而如果把第二个参数去掉，就进入了catch()中： Promise.reject('err!!!') .then((res) =&gt; { console.log('success', res) }).catch(err =&gt; { console.log('catch', err) }) 复制代码 执行结果： 'catch' 'error!!!' 复制代码 但是有一个问题，如果是这个案例呢？ Promise.resolve() .then(function success (res) { throw new Error('error!!!') }, function fail1 (err) { console.log('fail1', err) }).catch(function fail2 (err) { console.log('fail2', err) }) 复制代码 由于Promise调用的是resolve()，因此.then()执行的应该是success()函数，可是success()函数抛出的是一个错误，它会被后面的catch()给捕获到，而不是被fail1函数捕获。 因此执行结果为： fail2 Error: error!!! at success 复制代码 3.10 题目十接着来看看.finally()，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。 其实你只要记住它三个很重要的知识点就可以了： .finally()方法不管Promise对象最后的状态如何都会执行 .finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是没法知道Promise最终的状态是resolved还是rejected的 它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。 来看看这个简单的例子🌰： Promise.resolve('1') .then(res =&gt; { console.log(res) }) .finally(() =&gt; { console.log('finally') }) Promise.resolve('2') .finally(() =&gt; { console.log('finally2') return '我是finally2返回的值' }) .then(res =&gt; { console.log('finally2后面的then函数', res) }) 复制代码 这两个Promise的.finally都会执行，且就算finally2返回了新的值，它后面的then()函数接收到的结果却还是'2'，因此打印结果为： '1' 'finally2' 'finally' 'finally2后面的then函数' '2' 复制代码 至于为什么finally2的打印要在finally前面，请看下一个例子中的解析。 不过在此之前让我们再来确认一下，finally中要是抛出的是一个异常是怎样的： Promise.resolve('1') .finally(() =&gt; { console.log('finally1') throw new Error('我是finally中抛出的异常') }) .then(res =&gt; { console.log('finally后面的then函数', res) }) .catch(err =&gt; { console.log('捕获错误', err) }) 复制代码 执行结果为： 'finally1' '捕获错误' Error: 我是finally中抛出的异常 复制代码 但是如果改为return new Error('我是finally中抛出的异常')，打印出来的就是'finally后面的then函数 1' OK，👌，让我们来看一个比较难的例子🌰： function promise1 () { let p = new Promise((resolve) =&gt; { console.log('promise1'); resolve('1') }) return p; } function promise2 () { return new Promise((resolve, reject) =&gt; { reject('error') }) } promise1() .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) .finally(() =&gt; console.log('finally1')) promise2() .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) .finally(() =&gt; console.log('finally2')) 复制代码 执行过程： 首先定义了两个函数promise1和promise2，先不管接着往下看。 promise1函数先被调用了，然后执行里面new Promise的同步代码打印出promise1 之后遇到了resolve(1)，将p的状态改为了resolved并将结果保存下来。 此时promise1内的函数内容已经执行完了，跳出该函数 碰到了promise1().then()，由于promise1的状态已经发生了改变且为resolved因此将promise1().then()这条微任务加入本轮的微任务列表(这是第一个微任务) 这时候要注意了，代码并不会接着往链式调用的下面走，也就是不会先将.finally加入微任务列表，那是因为.then本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管.finally() 再往下走碰到了promise2()函数，其中返回的new Promise中并没有同步代码需要执行，所以执行reject('error')的时候将promise2函数中的Promise的状态变为了rejected 跳出promise2函数，遇到了promise2().catch()，将其加入当前的微任务队列(这是第二个微任务)，且链式调用后面的内容得等该任务执行完后才执行，和.then()一样。 OK， 本轮的宏任务全部执行完了，来看看微任务列表，存在promise1().then()，执行它，打印出1，然后遇到了.finally()这个微任务将它加入微任务列表(这是第三个微任务)等待执行 再执行promise2().catch()打印出error，执行完后将finally2加入微任务加入微任务列表(这是第四个微任务) OK， 本轮又全部执行完了，但是微任务列表还有两个新的微任务没有执行完，因此依次执行finally1和finally2。 结果： 'promise1' '1' 'error' 'finally1' 'finally2' 复制代码 在这道题中其实能拓展的东西挺多的，之前没有提到，那就是你可以理解为链式调用后面的内容需要等前一个调用执行完才会执行。 就像是这里的finally()会等promise1().then()执行完才会将finally()加入微任务队列，其实如果这道题中你把finally()换成是then()也是这样的: function promise1 () { let p = new Promise((resolve) =&gt; { console.log('promise1'); resolve('1') }) return p; } function promise2 () { return new Promise((resolve, reject) =&gt; { reject('error') }) } promise1() .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) .then(() =&gt; console.log('finally1')) promise2() .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) .then(() =&gt; console.log('finally2')) 复制代码 4. Promise中的all和race在做下面👇的题目之前，让我们先来了解一下Promise.all()和Promise.race()的用法。 通俗来说，.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。 .race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。 来看看题目一。 4.1 题目一我们知道如果直接在脚本文件中定义一个Promise，它构造函数的第一个参数是会立即执行的，就像这样： const p1 = new Promise(r =&gt; console.log('立即打印')) 复制代码 控制台中会立即打印出 “立即打印”。 因此为了控制它什么时候执行，我们可以用一个函数包裹着它，在需要它执行的时候，调用这个函数就可以了： function runP1 () { const p1 = new Promise(r =&gt; console.log('立即打印')) return p1 } runP1() // 调用此函数时才执行 复制代码 OK 👌， 让我们回归正题。 现在来构建这么一个函数： function runAsync (x) { const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p } 复制代码 该函数传入一个值x，然后间隔一秒后打印出这个x。 如果我用.all()来执行它会怎样呢？ function runAsync (x) { const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p } Promise.all([runAsync(1), runAsync(2), runAsync(3)]) .then(res =&gt; console.log(res)) 复制代码 先来想想此段代码在浏览器中会如何执行？ 没错，当你打开页面的时候，在间隔一秒后，控制台会同时打印出1, 2, 3，还有一个数组[1, 2, 3]。 1 2 3 [1, 2, 3] 复制代码 所以你现在能理解这句话的意思了吗：有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。 .all()后面的.then()里的回调函数接收的就是所有异步操作的结果。 而且这个结果中数组的顺序和Promise.all()接收到的数组顺序一致！！！ 有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。 4.2 题目二我新增了一个runReject函数，它用来在1000 * x秒后reject一个错误。 同时.catch()函数能够捕获到.all()里最先的那个异常，并且只执行一次。 想想这道题会怎样执行呢 🤔️？ function runAsync (x) { const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p } function runReject (x) { const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x)) return p } Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)]) .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err)) 复制代码 不卖关子了 😁，让我来公布答案： // 1s后输出 1 3 // 2s后输出 2 Error: 2 // 4s后输出 4 复制代码 没错，就像我之前说的，.catch是会捕获最先的那个异常，在这道题目中最先的异常就是runReject(2)的结果。 另外，如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。 注意，为什么不说是不进入.then()中呢 🤔️？ 哈哈，大家别忘了.then()方法的第二个参数也是可以捕获错误的： Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)]) .then(res =&gt; console.log(res), err =&gt; console.log(err)) 复制代码 4.3 题目三接下来让我们看看另一个有趣的方法.race。 让我看看你们的英语水平如何？ 快！一秒钟告诉我race是什么意思？ ![](https://juejin.im/post/data:image/svg+xml;utf8,) 好吧…你们果然很强… race，比赛，赛跑的意思。 所以使用.race()方法，它只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，不过race已经不管那些任务的结果了。 来，改造一下4.1这道题： function runAsync (x) { const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000)) return p } Promise.race([runAsync(1), runAsync(2), runAsync(3)]) .then(res =&gt; console.log('result: ', res)) .catch(err =&gt; console.log(err)) 复制代码 执行结果为： 1 'result: ' 1 2 3 复制代码 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作 4.4 题目四改造一下题目4.2： function runAsync(x) { const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000) ); return p; } function runReject(x) { const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x) ); return p; } Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)]) .then(res =&gt; console.log(&quot;result: &quot;, res)) .catch(err =&gt; console.log(err)); 复制代码 遇到错误的话，也是一样的，在这道题中，runReject(0)最先执行完，所以进入了catch()中： 0 'Error: 0' 1 2 3 复制代码 总结好的，让我们来总结一下.then()和.race()吧，😄 Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。 .race()的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。 Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。 all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。 5. async/await的几道题既然谈到了Promise，那就肯定得再说说async/await，在很多时候async和Promise的解法差不多，又有些不一样。不信你来看看题目一。 5.1 题目一async function async1() { console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;); } async function async2() { console.log(&quot;async2&quot;); } async1(); console.log('start') 复制代码 这道基础题输出的是啥？ 答案： 'async1 start' 'async2' 'start' 'async1 end' 复制代码 过程分析： 首先一进来是创建了两个函数的，我们先不看函数的创建位置，而是看它的调用位置 发现async1函数被调用了，然后去看看调用的内容 执行函数中的同步代码async1 start，之后碰到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1 跳出async1函数后，执行同步代码start 在一轮宏任务全部执行完之后，再来执行刚刚await后面的内容async1 end。 在这里，你可以理解为「紧跟着await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中」。 让我们来看看将await转换为Promise.then的伪代码： async function async1() { console.log(&quot;async1 start&quot;); // 原来代码 // await async2(); // console.log(&quot;async1 end&quot;); // 转换后代码 new Promise(resolve =&gt; { console.log(&quot;async2&quot;) resolve() }).then(res =&gt; console.log(&quot;async1 end&quot;)) } async function async2() { console.log(&quot;async2&quot;); } async1(); console.log(&quot;start&quot;) 复制代码 转换后的伪代码和前面的执行结果是一样的。(感谢评论区Wing93和Jexxie小伙伴的指出) 另外关于await和Promise的区别，如果我们把await async2()换成一个new Promise呢？ async function async1() { console.log(&quot;async1 start&quot;); new Promise(resolve =&gt; { console.log('promise') }) console.log(&quot;async1 end&quot;); } async1(); console.log(&quot;start&quot;) 复制代码 此时的执行结果为： 'async start' 'promise' 'async1 end' 'start' 复制代码 可以看到new Promise()并不会阻塞后面的同步代码async1 end的执行。 5.2 题目二现在将async结合定时器看看。 给题目一中的 async2函数中加上一个定时器： async function async1() { console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;); } async function async2() { setTimeout(() =&gt; { console.log('timer') }, 0) console.log(&quot;async2&quot;); } async1(); console.log(&quot;start&quot;) 复制代码 没错，定时器始终还是最后执行的，它被放到下一条宏任务的延迟队列中。 答案： 'async1 start' 'async2' 'start' 'async1 end' 'timer' 复制代码 5.3 题目三来吧，小伙伴们，让我们多加几个定时器看看。😁 async function async1() { console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;); setTimeout(() =&gt; { console.log('timer1') }, 0) } async function async2() { setTimeout(() =&gt; { console.log('timer2') }, 0) console.log(&quot;async2&quot;); } async1(); setTimeout(() =&gt; { console.log('timer3') }, 0) console.log(&quot;start&quot;) 复制代码 思考一下🤔，执行结果会是什么？ 其实如果你能做到这里了，说明你前面的那些知识点也都掌握了，我就不需要太过详细的步骤分析了。 直接公布答案吧： 'async1 start' 'async2' 'start' 'async1 end' 'timer2' 'timer3' 'timer1' 复制代码 定时器谁先执行，你只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是0，所以只要关注谁先被调用的。。 5.4 题目四正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。 但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve() async function fn () { // return await 1234 // 等同于 return 123 } fn().then(res =&gt; console.log(res)) 复制代码 结果： 123 复制代码 5.5 题目五async function async1 () { console.log('async1 start'); await new Promise(resolve =&gt; { console.log('promise1') }) console.log('async1 success'); return 'async1 end' } console.log('srcipt start') async1().then(res =&gt; console.log(res)) console.log('srcipt end') 复制代码 这道题目比较有意思，大家要注意了。 在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，因此相当于一直在await，await，await却始终没有响应… ![](https://juejin.im/post/data:image/svg+xml;utf8,) 所以在await之后的内容是不会执行的，也包括async1后面的 .then。 答案为： 'script start' 'async1 start' 'promise1' 'script end' 复制代码 5.6 题目六让我们给5.5中的Promise加上resolve： async function async1 () { console.log('async1 start'); await new Promise(resolve =&gt; { console.log('promise1') resolve('promise1 resolve') }).then(res =&gt; console.log(res)) console.log('async1 success'); return 'async1 end' } console.log('srcipt start') async1().then(res =&gt; console.log(res)) console.log('srcipt end') 复制代码 现在Promise有了返回值了，因此await后面的内容将会被执行： 'script start' 'async1 start' 'promise1' 'script end' 'promise1 resolve' 'async1 success' 'async1 end' 复制代码 5.7 题目七async function async1 () { console.log('async1 start'); await new Promise(resolve =&gt; { console.log('promise1') resolve('promise resolve') }) console.log('async1 success'); return 'async1 end' } console.log('srcipt start') async1().then(res =&gt; { console.log(res) }) new Promise(resolve =&gt; { console.log('promise2') setTimeout(() =&gt; { console.log('timer') }) }) 复制代码 这道题应该也不难，不过有一点需要注意的，在async1中的new Promise它的resovle的值和async1().then()里的值是没有关系的，很多小伙伴可能看到resovle('promise resolve')就会误以为是async1().then()中的返回值。 因此这里的执行结果为： 'script start' 'async1 start' 'promise1' 'promise2' 'async1 success' 'async1 end' 'timer' 复制代码 5.8 题目八我们再来看一道头条曾经的面试题： async function async1() { console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;); } async function async2() { console.log(&quot;async2&quot;); } console.log(&quot;script start&quot;); setTimeout(function() { console.log(&quot;setTimeout&quot;); }, 0); async1(); new Promise(function(resolve) { console.log(&quot;promise1&quot;); resolve(); }).then(function() { console.log(&quot;promise2&quot;); }); console.log('script end') 复制代码 有了上面👆几题做基础，相信你很快也能答上来了。 ![](https://juejin.im/post/data:image/svg+xml;utf8,) 自信的写下你们的答案吧。 'script start' 'async1 start' 'async2' 'promise1' 'script end' 'async1 end' 'promise2' 'setTimeout' 复制代码 (这道题最后async1 end和promise2的顺序其实在网上饱受争议，我这里使用浏览器Chrome V80，Node v12.16.1的执行结果都是上面这个答案) 5.9 题目九好的👌，async/await大法已练成，咱们继续： async function testSometing() { console.log(&quot;执行testSometing&quot;); return &quot;testSometing&quot;; } async function testAsync() { console.log(&quot;执行testAsync&quot;); return Promise.resolve(&quot;hello async&quot;); } async function test() { console.log(&quot;test start...&quot;); const v1 = await testSometing(); console.log(v1); const v2 = await testAsync(); console.log(v2); console.log(v1, v2); } test(); var promise = new Promise(resolve =&gt; { console.log(&quot;promise start...&quot;); resolve(&quot;promise&quot;); }); promise.then(val =&gt; console.log(val)); console.log(&quot;test end...&quot;); 复制代码 答案： 'test start...' '执行testSometing' 'promise start...' 'test end...' 'testSometing' '执行testAsync' 'promise' 'hello async' 'testSometing' 'hello async' 复制代码 6. async处理错误6.1 题目一在async中，如果 await后面的内容是一个异常或者错误的话，会怎样呢？ async function async1 () { await async2(); console.log('async1'); return 'async1 success' } async function async2 () { return new Promise((resolve, reject) =&gt; { console.log('async2') reject('error') }) } async1().then(res =&gt; console.log(res)) 复制代码 例如这道题中，await后面跟着的是一个状态为rejected的promise。 如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。 所以答案为： 'async2' Uncaught (in promise) error 复制代码 如果改为throw new Error也是一样的： async function async1 () { console.log('async1'); throw new Error('error!!!') return 'async1 success' } async1().then(res =&gt; console.log(res)) 复制代码 结果为： 'async1' Uncaught (in promise) Error: error!!! 复制代码 6.2 题目二如果想要使得错误的地方不影响async函数后续的执行的话，可以使用try catch async function async1 () { try { await Promise.reject('error!!!') } catch(e) { console.log(e) } console.log('async1'); return Promise.resolve('async1 success') } async1().then(res =&gt; console.log(res)) console.log('script start') 复制代码 这里的结果为： 'script start' 'error!!!' 'async1' 'async1 success' 复制代码 或者你可以直接在Promise.reject后面跟着一个catch()方法： async function async1 () { // try { // await Promise.reject('error!!!') // } catch(e) { // console.log(e) // } await Promise.reject('error!!!') .catch(e =&gt; console.log(e)) console.log('async1'); return Promise.resolve('async1 success') } async1().then(res =&gt; console.log(res)) console.log('script start') 复制代码 运行结果是一样的。 7. 综合题上面👆的题目都是被我拆分着说一些功能点，现在让我们来做一些比较难的综合题吧。 7.1 题目一const first = () =&gt; (new Promise((resolve, reject) =&gt; { console.log(3); let p = new Promise((resolve, reject) =&gt; { console.log(7); setTimeout(() =&gt; { console.log(5); resolve(6); console.log(p) }, 0) resolve(1); }); resolve(2); p.then((arg) =&gt; { console.log(arg); }); })); first().then((arg) =&gt; { console.log(arg); }); console.log(4); 复制代码 过程分析： 第一段代码定义的是一个函数，所以我们得看看它是在哪执行的，发现它在4之前，所以可以来看看first函数里面的内容了。(这一步有点类似于题目1.5) 函数first返回的是一个new Promise()，因此先执行里面的同步代码3 接着又遇到了一个new Promise()，直接执行里面的同步代码7 执行完7之后，在p中，遇到了一个定时器，先将它放到下一个宏任务队列里不管它，接着向下走 碰到了resolve(1)，这里就把p的状态改为了resolved，且返回值为1，不过这里也先不执行 跳出p，碰到了resolve(2)，这里的resolve(2)，表示的是把first函数返回的那个Promise的状态改了，也先不管它。 然后碰到了p.then，将它加入本次循环的微任务列表，等待执行 跳出first函数，遇到了first().then()，将它加入本次循环的微任务列表(p.then的后面执行) 然后执行同步代码4 本轮的同步代码全部执行完毕，查找微任务列表，发现p.then和first().then()，依次执行，打印出1和2 本轮任务执行完毕了，发现还有一个定时器没有跑完，接着执行这个定时器里的内容，执行同步代码5 然后又遇到了一个resolve(6)，它是放在p里的，但是p的状态在之前已经发生过改变了，因此这里就不会再改变，也就是说resolve(6)相当于没任何用处，因此打印出来的p为Promise{&lt;resolved&gt;: 1}。(这一步类似于题目3.1) 结果： 3 7 4 1 2 5 Promise{&lt;resolved&gt;: 1} 复制代码 做对了的小伙伴奖励自己一朵小(大)红(嘴)花(巴)吧，😄 ![](https://juejin.im/post/data:image/svg+xml;utf8,) 7.2 题目二const async1 = async () =&gt; { console.log('async1'); setTimeout(() =&gt; { console.log('timer1') }, 2000) await new Promise(resolve =&gt; { console.log('promise1') }) console.log('async1 end') return 'async1 success' } console.log('script start'); async1().then(res =&gt; console.log(res)); console.log('script end'); Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .catch(4) .then(res =&gt; console.log(res)) setTimeout(() =&gt; { console.log('timer2') }, 1000) 复制代码 注意的知识点： async函数中await的new Promise要是没有返回值的话则不执行后面的内容(类似题5.5) .then函数中的参数期待的是函数，如果不是函数的话会发生透传(类似题3.8 ) 注意定时器的延迟时间 因此本题答案为： 'script start' 'async1' 'promise1' 'script end' 1 'timer2' 'timer1' 复制代码 7.3 题目三const p1 = new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('resolve3'); console.log('timer1') }, 0) resolve('resovle1'); resolve('resolve2'); }).then(res =&gt; { console.log(res) setTimeout(() =&gt; { console.log(p1) }, 1000) }).finally(res =&gt; { console.log('finally', res) }) 复制代码 注意的知识点： Promise的状态一旦改变就无法改变(类似题目3.5) finally不管Promise的状态是resolved还是rejected都会执行，且它的回调函数是接收不到Promise的结果的，所以finally()中的res是一个迷惑项(类似3.10)。 最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值(3.10中也有提到), 而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果你在定时器的下面加上一个return 1，则值就会变成1(感谢掘友JS丛中过的指出)。 答案： 'resolve1' 'finally' undefined 'timer1' Promise{&lt;resolved&gt;: undefined} 复制代码 8. 几道大厂的面试题8.1 使用Promise实现每隔1秒输出1,2,3这道题比较简单的一种做法是可以用Promise配合着reduce不停的在promise后面叠加.then，请看下面的代码： const arr = [1, 2, 3] arr.reduce((p, x) =&gt; { return p.then(() =&gt; { return new Promise(r =&gt; { setTimeout(() =&gt; r(console.log(x)), 1000) }) }) }, Promise.resolve()) 复制代码 或者你可以更简单一点写： const arr = [1, 2, 3] arr.reduce((p, x) =&gt; p.then(() =&gt; new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve()) 复制代码 参考链接：如何让异步操作顺序执行 拓展题 这道拓展题来自于“万物皆可爱的LINGLONG ”小姐姐，炒鸡棒 😁👍。 题目是这样的，她把我上面👆写的箭头函数版本改造了一下： const arr = [1, 2, 3]; const result = arr.reduce((p, x) =&gt; p.then(new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve()); 复制代码 眼尖的小伙伴看出区别了吗？😁 p.then里的代码由() =&gt; new Promise(...)变成了new Promise(...)。 现在执行结果就大不相同了。 在一秒后按顺序同时打印出1、2、3: 1 2 3 复制代码 咦 🤔️？为什么会这样呢 🤔️？ 只是一个小小的改变却有大大的区别。 其实刚开始看到的时候霖呆呆我也愣了那么几秒😂。不过等我们一步一步拆分并对想不通的地方写了几个案例来看就理解了。 评论区和小姐姐扯了一大堆，结果把她越弄越糊😂。后来我改变了一种思路来描述，觉得应该直接上伪代码： const arr = [1, 2, 3] arr.reduce((p, x) =&gt; p.then(() =&gt; new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve()) 复制代码 转换为伪代码就是这样： (相当于是用reduce不停的往后面叠加.then) Promise.resolve() .then(() =&gt; { return new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(1)) }, 1000) }) }) .then(r =&gt; { return new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(2)) }, 1000) }) }) .then(r =&gt; { return new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(3)) }, 1000) }) }) 复制代码 可以看到，每一个.then都是依赖于上一个new Promise何时被resolve了才会执行的，例如第二个.then()，它要等r(console.log(1)这段代码执行了，才会执行。 那么r(console.log(1))什么时候执行呢？就是在第一个定时器(也就是一秒后)触发的时候才执行。这样就保证了后面接着的.then()要等前一个定时器执行完才能执行，也就是隔一秒输出。 而如果是这样写的话： const arr = [1, 2, 3]; const result = arr.reduce((p, x) =&gt; p.then(new Promise(r =&gt; setTimeout(() =&gt; r(console.log(x)), 1000))), Promise.resolve()); 复制代码 它的伪代码就是这样： (每个then里面的第一个参数不是一个函数) Promise.resolve() .then(new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(1)) }, 1000) })) .then(new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(2)) }, 1000) })) .then(new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(3)) }, 1000) })) 复制代码 p.then()里面的参数如果不是函数的话，会发生透传，这个在3.8中已经提过了。但是发生透传，.then()里的代码就不执行了吗？ 并不是的，我们来看这个例子： const p = Promise.resolve(1).then(console.log('我不关心结果')) console.log(p) p.then((res) =&gt; console.log(res)) 复制代码 很明显这里也发生了透传，但是'我不关心结果'也还是被打印出来了，并且由于透传，p.then()里获取到的res就是1，因此会打印出： '我不关心结果' Promise{ [[PromiseStatus]]: &quot;resolved&quot; [[PromiseValue]]: 1 } 1 复制代码 (第二行打印出Promise{&lt;pending&gt;}的小伙伴请把这个对象展开来看) 这个例子表明，就算发生了透传，p.then()中的代码依旧也是会执行的。 所以回到 .then(new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(1)) }, 1000) })) 复制代码 中，现在.then()中就相当于是执行一段同步代码： new Promise(r =&gt; { setTimeout(() =&gt; { r(console.log(1)) }, 1000) }) 复制代码 而这段代码的作用是向延迟队列中push一个一秒后执行的定时器任务。 并且在push完定时器之后，代码就马上进入了下一个.then(因为既然第一个.then已经是透传的了就没有必要等它的执行结果了) 下一个.then竟然也是一个透传，OK，那我继续push这个定时器，然后再执行第三个.then。 三个.then已经执行完成了，现在我们的延迟队列中已经有了三个定时器等待执行，**并且三个定时器的延迟时间都是1000ms!!!**。 所以等到了时间之后，就会同时打印出来了1、2、3。（其实准确来说，不是同时打印的，不过中间相差的时间非常非常短，大可忽略它） 现在你是否理解了其中的区别呢 😝。 8.2 使用Promise实现红绿灯交替重复亮红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）三个亮灯函数已经存在： function red() { console.log('red'); } function green() { console.log('green'); } function yellow() { console.log('yellow'); } 复制代码 答案： function red() { console.log(&quot;red&quot;); } function green() { console.log(&quot;green&quot;); } function yellow() { console.log(&quot;yellow&quot;); } const light = function (timer, cb) { return new Promise(resolve =&gt; { setTimeout(() =&gt; { cb() resolve() }, timer) }) } const step = function () { Promise.resolve().then(() =&gt; { return light(3000, red) }).then(() =&gt; { return light(2000, green) }).then(() =&gt; { return light(1000, yellow) }).then(() =&gt; { return step() }) } step(); 复制代码 8.3 实现mergePromise函数实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。 const time = (timer) =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve() }, timer) }) } const ajax1 = () =&gt; time(2000).then(() =&gt; { console.log(1); return 1 }) const ajax2 = () =&gt; time(1000).then(() =&gt; { console.log(2); return 2 }) const ajax3 = () =&gt; time(1000).then(() =&gt; { console.log(3); return 3 }) function mergePromise () { // 在这里写代码 } mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; { console.log(&quot;done&quot;); console.log(data); // data 为 [1, 2, 3] }); // 要求分别输出 // 1 // 2 // 3 // done // [1, 2, 3] 复制代码 这道题有点类似于Promise.all()，不过.all()不需要管执行顺序，只需要并发执行就行了。但是这里需要等上一个执行完毕之后才能执行下一个。 解题思路： 定义一个数组data用于保存所有异步操作的结果 初始化一个const promise = Promise.resolve()，然后循环遍历数组，在promise后面添加执行ajax任务，同时要将添加的结果重新赋值到promise上。 答案： function mergePromise (ajaxArray) { // 存放每个ajax的结果 const data = []; let promise = Promise.resolve(); ajaxArray.forEach(ajax =&gt; { // 第一次的then为了用来调用ajax // 第二次的then是为了获取ajax的结果 promise = promise.then(ajax).then(res =&gt; { data.push(res); return data; // 把每次的结果返回 }) }) // 最后得到的promise它的值就是data return promise; } 复制代码 8.4 根据promiseA+实现一个自己的promise说真的，这道题被问到的概率还是挺高的，而且要说的内容也很多… 霖呆呆这里偷个懒，不想细说了… 不过哈，我保证，下下题我一定仔细说 😼. ![](https://juejin.im/post/data:image/svg+xml;utf8,) 来吧，给你们一些好的宝典： [《Promise不会？？看这里！！！史上最通俗易懂的Promise！！！》](https://juejin.im/post/5afe6d3bf265da0b9e654c4b rel=) 《写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise》 8.5 封装一个异步加载图片的方法这个相对简单一些，只需要在图片的onload函数中，使用resolve返回一下就可以了。 来看看具体代码： function loadImg(url) { return new Promise((resolve, reject) =&gt; { const img = new Image(); img.onload = function() { console.log(&quot;一张图片加载完成&quot;); resolve(img); }; img.onerror = function() { reject(new Error('Could not load image at' + url)); }; img.src = url; }); 复制代码 8.6 限制异步操作的并发个数并尽可能快的完成全部有8个图片资源的url，已经存储在数组urls中。 urls类似于['https://image1.png', 'https://image2.png', ....] 而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。 但有一个要求，任何时刻同时下载的链接数量不可以超过3个。 请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。 var urls = [ &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;, &quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;, ]; function loadImg(url) { return new Promise((resolve, reject) =&gt; { const img = new Image(); img.onload = function() { console.log(&quot;一张图片加载完成&quot;); resolve(img); }; img.onerror = function() { reject(new Error('Could not load image at' + url)); }; img.src = url; }); 复制代码 看到这道题时，我最开始的想法是： 拿到urls，然后将这个数组每3个url一组创建成一个二维数组 然后用Promise.all()每次加载一组url（也就是并发3个），这一组加载完再加载下一组。 这个想法从技术上说并不难实现，有点类似于第三题。不过缺点也明显，那就是每次都要等到上一组全部加载完之后，才加载下一组，那如果上一组有2个已经加载完了，还有1个特别慢，还在加载，要等这个慢的也加载完才能进入下一组。这明显会照常卡顿，影响加载效率。 但是开始没有考虑这么多，因此有了第一个版本。 如果你有兴趣可以看看想法一的代码，虽然对你没什么帮助，想直接知道比较好的做法的小伙伴请跳到想法二 ![](https://juejin.im/post/data:image/svg+xml;utf8,) 想法一💡： function limitLoad (urls, handler, limit) { const data = []; // 存储所有的加载结果 let p = Promise.resolve(); const handleUrls = (urls) =&gt; { // 这个函数是为了生成3个url为一组的二维数组 const doubleDim = []; const len = Math.ceil(urls.length / limit); // Math.ceil(8 / 3) = 3 console.log(len) // 3, 表示二维数组的长度为3 for (let i = 0; i &lt; len; i++) { doubleDim.push(urls.slice(i * limit, (i + 1) * limit)) } return doubleDim; } const ajaxImage = (urlCollect) =&gt; { // 将一组字符串url 转换为一个加载图片的数组 console.log(urlCollect) return urlCollect.map(url =&gt; handler(url)) } const doubleDim = handleUrls(urls); // 得到3个url为一组的二维数组 doubleDim.forEach(urlCollect =&gt; { p = p.then(() =&gt; Promise.all(ajaxImage(urlCollect))).then(res =&gt; { data.push(...res); // 将每次的结果展开，并存储到data中 (res为：[img, img, img]) return data; }) }) return p; } limitLoad(urls, loadImg, 3).then(res =&gt; { console.log(res); // 最终得到的是长度为8的img数组: [img, img, img, ...] res.forEach(img =&gt; { document.body.appendChild(img); }) }); 复制代码 想法二💡： 参考LHH大翰仔仔-Promise面试题 既然题目的要求是保证每次并发请求的数量为3，那么我们可以先请求urls中的前面三个(下标为0,1,2)，并且请求的时候使用Promise.race()来同时请求，三个中有一个先完成了(例如下标为1的图片)，我们就把这个当前数组中已经完成的那一项(第1项)换成还没有请求的那一项(urls中下标为3)。 直到urls已经遍历完了，然后将最后三个没有完成的请求(也就是状态没有改变的Promise)用Promise.all()来加载它们。 不多说，流程图都给你画好了，你可以结合流程图再来看代码。 为了方便你查看，我截了个图，不过代码在后面也有 (说真的，要我看这一大长串代码我也不愿意…) 代码： function limitLoad(urls, handler, limit) { let sequence = [].concat(urls); // 复制urls // 这一步是为了初始化 promises 这个&quot;容器&quot; let promises = sequence.splice(0, limit).map((url, index) =&gt; { return handler(url).then(() =&gt; { // 返回下标是为了知道数组中是哪一项最先完成 return index; }); }); // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用 return sequence .reduce((pCollect, url) =&gt; { return pCollect .then(() =&gt; { return Promise.race(promises); // 返回已经完成的下标 }) .then(fastestIndex =&gt; { // 获取到已经完成的下标 // 将&quot;容器&quot;内已经完成的那一项替换 promises[fastestIndex] = handler(url).then( () =&gt; { return fastestIndex; // 要继续将这个下标返回，以便下一次变量 } ); }) .catch(err =&gt; { console.error(err); }); }, Promise.resolve()) // 初始化传入 .then(() =&gt; { // 最后三个用.all来调用 return Promise.all(promises); }); } limitLoad(urls, loadImg, 3) .then(res =&gt; { console.log(&quot;图片全部加载完毕&quot;); console.log(res); }) .catch(err =&gt; { console.error(err); }); 复制代码 后语参考文章： 《ES6之Promise常见面试题》 《如何让异步操作顺序执行》 《大白话讲解Promise（一） 《LHH大翰仔仔-Promise面试题》 《今日头条async/await面试题执行顺序》 《(2.4w字,建议收藏)😇原生JS灵魂之问(下), 冲刺🚀进阶最后一公里(附个人成长经验分享)》","link":"/posts/Promise%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"},{"title":"Webpack 基础教程","text":"[TOC] 慢慢来 其实比较快 学习尽量做到知其然知其所以然 视频教程来源这篇笔记是jspang教程的学习笔记 第01节：认识WebPack的作用什么是WebPack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在4.0出现后，Webpack还肩负起了优化项目的责任。 重点 打包：可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。 转换：把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。 优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。 安装前提必须先安装node(node -v来查看node安装情况和版本) 全局安装webpack官方不推荐全局安装。这会将您项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 1npm install -g webpack 对项目目录进行安装 先对项目进行初始化 然后在项目目录中进行安装 用webpack -v 查看版本 –save 保存到package.json文件中 dev 保存到开发环境中而生产环境中不使用 123456npm initnpm install --save-dev webpack webpack-clinpm install --D webpack webpack-cli# 安装指定版本npm install webpack@4.16.5 查看webpack版本npx webpack -v npx解决的主要问题就是调用项目内部安装的模块,还能避免全局安装的模块 npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。 由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。 4.39.3 小知识开发环境and生产环境： 开发环境：在开发时需要的环境，这里指在开发时需要依赖的包。生产环境：程序开发完成，开始运行后的环境，这里指要使项目运行，所需要的依赖包。 第二节 快速上手一个Demo建立基本项目结构创建一个项目目录，进入后在根目录建立两个文件夹，分别是src文件夹和dist文件夹： src文件夹：用来存放我们编写的javascript代码(源代码)dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包成的文件。 在dist中新建index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;webpack tutorials&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;title&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在src中新建entry.js src/entery.js 1document.getElementById('title').innerHTML='Hello Webpack'; 这个文件的代码很简单，就是在&lt;div id=”title”&gt;&lt;/div&gt;标签里写入Hello Webpack这句话。 第一次Webpack打包在终端中用命令行打包。 语法： 1webpack {entry file} {destination for bundled file} 在这个项目中，执行 1webpack src/entry.js dist/bundle.js 执行成功后，会在dist文件夹中出现bundle.js,用浏览器查看index.html可以查看效果 总结-第2节从这个Demo中你会了解到webpack的基本用法和使用过程， 并学会了命令行打包的方法。 在这节文章的最后，还是要强调，你一定要把本节内容在自己的电脑上敲一遍，这样你才能深入了解。 在浏览器中用live-server访问文件用命令行 安装live-server 1npm install -g live-server 在该项目中用命令行 1live-server 即可在浏览器中访问文件 用webpack的scripts命令封装 在package.json的scripts中 123&quot;scripts&quot;: {&quot;server&quot;: &quot;live-server ./ --port=9090&quot;} 执行 1npm run server 第03节：配置文件：入口和出口这节课我们就学习配置文件的大体结构和入口出口文件的配置。 配置文件webpack.config.js123456789101112module.exports = { // 入口文件 entry: {}, // 出口文件的配置项 output: {}, // 模块,例如编译css,js,转换图片，压缩，合并 module: {}, // 插件，用于生产模板和各项功能 plugins: [], // 配置webpack开发服务功能 devServer: {}} entry：配置入口文件的地址，可以是单一入口，也可以是多入口。output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。module：配置模块，主要是解析CSS和图片转换压缩等功能。plugins：配置插件，根据你的需要配置不同功能的插件。devServer：配置开发服务功能。 entry选项（入口配置）配置要压缩的文件。一般是JavaScript，也可以是CSS文件。 12345// 入口文件配置entry: { // 里面的entry可以随便起名字，外面的是固定的 entry: './src/entry.js'} output(出口配置)配置webpack最后打包文件的地址和名称。 1234567// 出口文件配置output: { // 打包的文件位置 path: path.resolve(__dirname, 'dist'), // 打包的文件名称 filename: 'bundle.js'} 需要在webpack.config.js头部引入path 1const path = require('path'); path.resolve(__dirname, ‘dist’) 获取项目的绝对路径filename: 打包后的文件名称。 webpack单文件入口配置代码12345678910111213141516const path = require('path')module.exports = { // 入口文件 entry: './src/entry.js', // 出口文件的配置项 output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' }, // 模块,例如编译css,js,转换图片，压缩，合并 module: {}, // 插件，用于生产模板和各项功能 plugins: [], // 配置webpack开发服务功能 devServer: {}} 配置完成后，在终端直接输入webpack就会打包 多入口、多出口配置在entry配置多个文件， 在output处配置文件名为动态的 1234567891011121314151617181920212223const path = require('path')module.exports = { // 入口文件 entry: { entry: './src/entry.js', entry2: './src/entry2.js' }, // 出口文件的配置项 output: { // 输出的路径 path: path.resolve(__dirname, 'dist'), publicPath: 'http://www.cdn.com/assets/', // 输出文件的名称 filename: '[name].js' }, // 模块,例如编译css,js,转换图片，压缩，合并 module: {}, // 插件，用于生产模板和各项功能 plugins: [], // 配置webpack开发服务功能 devServer: {}, mode: 'production'} [mode]: webpack中新增的配置，分为开发，线上。可以在命令行后面添加如: webpack --mode=development[publicPath]: 自动将cdn路径添加到代码里的资源链接上[plugin]: 可以在webpack运行到某个时刻时，帮你做一些事情[name]： 根据入口文件的名称，打包成相同的名称，有几个入口文件，就打包成几个文件。 总结-第3节任何项目的webpack都要执行这些操作。需要牢记 小知识 调试js文件 在js中写console.log() 直接在命令行 node index.js， 即可在终端查看打印内容 第4节： 配置文件：服务和热更新热更新：所见即所得 设置webpack-dev-server 先安装webpack-dev-server 1npm install webpack-dev-server --save-dev 配置devServer webpack.config.js 123456789101112131415161718192021devServer: { // 设置基本目录结构 contentBase: path.resolve(__dirname, 'dist'), // 服务器的IP地址，可以是IP也可以是localhost host: 'localhost', // 服务端压缩是否开启 compress: true, // 配置服务端口 port: 8089, // 默认打开浏览器，可以用字符串代替用哪个浏览器打开. 'Google Chrome', 可以代替--open open: true, // 路由代理打到前端框架 historyApiFallback: true, // 开启hotModuleReplace hot: true, // 如果打包报错，直接在页面上展示错误，而不是在终端展示错误 overlay: true, proxy: { '/api': 'http://localhost:3000' }} 配置scripts package.json 123&quot;scripts&quot;: { &quot;server&quot;: &quot;webpack-dev-server --open&quot; }, 在这里直接设置 –open即可自动打开浏览器 在终端里输入npm run server 打开服务器，在浏览器中输入http://localhost:8089即可看到结果 historyApiFallbackwebpack不配置这个的话，正常的react请求会直接请求到服务端，不会走react内部的路由 historyApiFallback就是解决这个问题 TODO到了线上要配置NGINX，让路由打到项目里 支持热更新npm run server 启动后，有一种监控机制(watch), 监控修改源码，并立即在浏览器里更新。 注意：webpack 3.6版本以后内置热更新功能，不需要额外操作。 proxy设置 123456789101112131415proxy: { '/react/api': 'http://www.dell-lee.com', '/react/api': { target: 'http://www.dell-lee.com' // https接口需要配置这个 secure: false, // 解决某些网站对源限制 changeOrigin: true, // 在配置里请求转发，代码里请求header.json，实际去请求demo.json，省去修改代码里接口的麻烦 pathRewrite: { 'header.json': 'demo.json' } }} 第5节： 模块：CSS文件打包webpack在生产环境中的作用之一：减少http请求数，把多个文件打包到一个js文件中，请求数可以减少好多。 学习css文件打包之前，需要先对webpack.config.js里的Loaders配置项进行了解。 LoadersLoaders是Webpack最重要的功能之一，也是如此盛行的原因。 通过配置不同的Loaders，Webpack可以用脚本和工具对不同的文件格式进行特定的处理。 例子： 可以把less, sass转换成css,而不使用其他工具 写代码时，可以用ES6, ES7语法，转换成大多数浏览器兼容的代码 可以把React中的jsx转换成JavaScript代码 注意：所有Loaders都要在npm中单独安装，并在webpack.config.js中配置，下面对几种配置型简单梳理。 test: 用于匹配处理文件扩展名的表达式，【必须设置】； use: loader名称，【必须配置，否则报错】； include/exclude: 手动添加必须处理的文件/文件夹，或屏蔽不需要处理的文件/文件夹,【可选】； query: 为loaders提供额外的设置选项，【可选】。 打包CSS文件建立index.css文件在src/css 目录下，建一个index.css文件 1234body { background-color: red; color: white;} css 文件建立好后，需要引入到入口文件中，才可以打包到dist中。 这里引入到entry.js中 src/entry.js首行加入 1import css from './css/index.css'; 这里行末一定要加分号，没加就无法编译CSS文件报错CSS 引入后，需要使用loader来解析CSS文件，这里用到style-loader,css-loader. style-loader 官网用来处理css文件中的url()等。 安装 1npm install style-loader --save-dev css-loader 官网用来将css插入到页面的style标签。安装 1npm install css-loader --save-dev 两个都安装好后，开始配置loaders loaders配置修改webpack.config.js中的module属性，代码如下： webpack.config.js 12345678module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ]}, 1234567891011121314151617module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', { loader: 'css-loader', options: { importLoaders: 2, modules: true } } ] } ]}, modules: true 使用css模块化importLoaders: 在 css-loader 前应用的 loader 的数量， 用于在css文件中引入css文件，让loader也去处理引入文件中的样式 loader三种写法 直接用use 12345678module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ]} 把use换成loader 123456module: { rules: [ test: /\\.css$/, loader: ['style-loader', 'css-loader'] ]} 用use+loader 这种最常用，因为每个都有不同的配置项！！ 1234567891011module: { rules: [ { test: /\\.css$/, use: [ {loader: 'style-loader'}, {loader: 'css-loader'} ] } ]} 用哪种写法都可以，可以看出webpack的扩展和灵活性非常强最重要的是： 看见别人项目的其他写法也不要慌张，自己试试，有可能Get到新知识。 总结-第5节loader的使用决定了webpack水平的高低，一定要重视和练习。 第6节： 插件配置： 配置JS压缩压缩JS代码引入uglifyjs-webpack-plugin(js压缩插件，简称uglify) 注意： 虽然uglifyjs是插件，但webpack版本已默认集成，不需要再次安装。 引入在webpack.config.js中引入插件， 1const uglify = require('uglifyjs-webpack-plugin') 引入后，在plugins配置里new一个uglify对象。代码如下 123plugins: [ new uglify()] 这里执行webpack是可以打包成功的 但是执行npm run server时，报错,原因还待查 已找到 ***123456ERROR in entry.js from UglifyJsUnexpected token: name (urlParts) [entry.js:317,4]ERROR in entry2.js from UglifyJsUnexpected token: name (urlParts) [entry2.js:317,4]webpack: Failed to compile. 首先要先弄清楚什么是开发环境， 什么是生产环境。 开发环境基本不会对js进行压缩，在开发预览时，需要明确的报错行数和错误信息，所以没有必要压缩JavaScript代码。 生产环境才会压缩js代码，用于加快程序的工作效率。 devServer用于开发环境，而压缩js用于生产环境， 在开发环境中做生产环境的事情所以webpack设置冲突报错 第7节： 插件配置： HTML文件发布之前的index.html是直接放在dist文件夹中的，这是不对的。应该放在src目录中。 这节就学习如何把HTML文件打包到生产路径下。 打包HTML文件先将dist中的index.html剪切到src目录中，并去掉js引入代码(webpack会自动引入entry入口配置的js)， 因为这才是真实工作的目录结构。 npm安装html-webpack-plugin 官网htmlWebpackPlugin会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个HTML文件 1npm install --save-dev html-webpack-plugin 配置webpack.config.js引入html-webpack-plugin插件 1const htmlPlugin = require('html-webpack-plugin') 在plugins里进行插件的配置，代码如下123456789plugins: [ new htmlPlugin({ minify: { removeAttributeQuotes: true }, hash: true, template: './src/index.html' })], minify：是对html文件进行压缩，removeAttrubuteQuotes是去掉属性的双引号。 hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 template：是要打包的html模版路径和文件名称。 打包出错12ERROR in Error: Parse Error: &lt;!DOCTYPE&gt; &lt;html&gt; 原因，html页面的声明，必须是 12// &lt;!DOCTYPE&gt;&lt;!DOCTYPE html&gt; 总结html文件的打包可以有效的区分开发目录和生产目录，在webpack的配置中也要搞清楚哪些配置用于生产环境，哪些配置用于开发环境，避免两种环境的配置冲突。 第8节： 图片迈坑： css中的图片处理webpack打包时遇到css中的图片处理坑。 在开发环境中找得到图片，一打包后就找不到 不知道如何正确引入HTML或CSS中的图片 3节课彻底走出webpack图片的坑找张图片，在src目录新建一个images的文件夹。把图片放入images文件夹。 在index.html中增加一个div， 1&lt;div id=&quot;img&quot;&gt;&lt;/div&gt; css 12345#img{ background-image: url(../images/img.png); width:100px; height: 100px;} webpack 直接编译，报错 1234ERROR in ./src/images/img.pngModule parse failed: Unexpected character '�' (1:0)You may need an appropriate loader to handle this file type.(Source code omitted for this binary file) file-loader, url-loader1. 命令行安装1npm install --save-dev file-loader url-loader file-loader解决引用路径的问题，拿background样式用url引用背景图来说，webpack会将各个模块打包成一个文件，因此我们源代码样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在路径。这会导致图片引入失败。 这就是file-loader解决的。 file-loader可以解析项目中的url引入(不局限于css), 根据配置，将图片拷贝到相应的路径，再根据配置，打包后文件引用路径，使之指向正确的文件。 打包以后文件名保持不变，加hash值 123456789101112module: { rules: { test: /\\.(jpg|png|gif)/, use: { loader: 'file-loader', options: { name: '[name]_[hash].[ext]', outputPath: 'images/' } } }} url-loader如果图片较多，会发送很多http请求，降低页面性能。 可以用url-loader解决。 url-loader会将引入的图片编码，生成DataURL(把图片转成一串字符),再把这串字符打包到文件中，最终只要引入这个文件就能访问图片。 图片较大，编码会消耗性能。url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURL,大于limit的会使用file-loader进行copy 2. 配置url-loaderwebpack.config.js 12345678910111213141516171819module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, { test: /\\.(png|jpg|gif)/, use: [ { loader: 'url-loader', options: { limit: 500000 } } ] } ]}, test:/.(png|jpg|gif)/是匹配图片文件后缀名称。 use：是指定使用的loader和loader的配置参数。 limit：是把小于500000B的文件打成Base64的格式，写入JS。 现在就可以使用webpack打包了~~~~ 用npm run server ，可以在页面查看元素，查看图片的编码 为什么配置中只用了url-loader为什么在配置中只用了url-loader，依然打包成功？ 需要了解url-loader和file-loader关系 url-loader封装了file-loader，url-loader不依赖file-loader，即 使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。 url-loader工作分两种情况： 文件大小小于limit，url-loader将文件转为DataURL(Base64格式) 文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader 也就是说，安装一个url-loader即可，但是为了以后操作方便，顺便安装了file-loader。 总结-第8节本节学习了将小图打包成Base64格式， 对webpack图片打包有了基本的了解 第9节 图片迈坑： CSS分离与图片路径处理主要学习 把CSS从JavaScript代码中分离出来， 如何处理分离出来后的CSS中的图片路径不对的问题。 CSS分离： extract-text-webpack-plugin 官网之前的css是打包到JavaScript代码中的。 有些页面，JavaScript代码很少，而css很多，要求将css单独提取出来，方便以后更改，遇到这种需求， 解决办法就是extract-text-webpack-plugin 这个插件可以完美解决提取CSS的需求。但webpack官网不建议这样做，他们认为css就应该打包到JavaScript中以减少http请求数。 但现实中的需求我们无法控制，有些需求是我们不能控制的，分离css就是这样一个既合理又不合理的需求。 1. npm 安装1npm install --save-dev extract-text-webpack-plugin 2. 引入安装完成后，需要先require引入 1const extractTextPlugin = require('extract-text-webpack-plugin') 3. 设置Plugins引入成功后，需要在plugins属性中进行配置。这里只要new一下这个对象。 12345678910plugins: [ new htmlPlugin({ minify: { removeAttributeQuotes: true }, hash: true, template: './src/index.html' }), new extractTextPlugin('css/index.css')], 这里的/css/index.css是分离后的路径位置。注意： 这里路径前面不要加/,否则引用css的路径，会多一个/ 4. 修改原来的stye-loader, css-loader12345678910111213141516171819202122module: { rules: [ { test: /\\.css$/, use: extractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) }, { test: /\\.(png|jpg|gif)/, use: [ { loader: 'url-loader', options: { limit: 500000 } } ] } ]}, 完成4步操作后，可以用webpack打包。 打包结果 css被单独提取到css/index.css文件 图片也被Base64编码到index.css文件 index.html文件中引入了index.css 图片路径问题利用extract-text-wbpack-plugin 轻松的把css文件分离了出来，但css路径并不正确。 可以在这里先build一下看下效果。图片不会显示 最好的解决方案，使用publicPath解决 publicPath: 是在webpack.config.js文件中的output选项中，主要作用就是处理静态文件路径的。 1. 处理前，在webpack.config.js上方声明一个对象，叫website1234// 教程里这里写的是IP地址const website = { publicPath: 'http://localhost:8089/'} 这里的ip和端口是本机的IP或DevServer配置的ip和端口。 后面加/ 不加/，测试了一下不加/，可以查看css或图片路径，是不正确的1234// 错误的background-image: url(http://localhost:8089images/313455c00642024bfd21003ced8bf0e6.png);// 正确的background-image: url(http://localhost:8089/images/313455c00642024bfd21003ced8bf0e6.png); 2. 在output选项中引用这个对象的publicPath属性1234567output: { // 输出的路径 path: path.resolve(__dirname, 'dist'), // 输出文件的名称 filename: '[name].js', publicPath: website.publicPath}, 3. 用webpack打包可以看到，文件中的相对路径被替换成绝对路径。这样来讲速度更快。 总结-第9节实现了css分离，并处理了分离后图片路径不对的问题。 处理的方法要充分理解，在工作中经常用到。 更改webpack.config.js文件 不会热更新第10节： 图片迈坑： 处理HTML中的图片在webpack中不推荐使用img来引入图片，但我们通常都用这种写法。为此有人开发了：html-withimg-loader 官网 可以很好的处理在HTML中引入图片的问题。 1.安装1npm install html-withimg-loader --save 2. 配置loaderwebpack.config.js 1234{ test: /\\.(html|html)$/i, use: ['html-withimg-loader']} 3. 执行打包可以发现images被很好的打包了。并且路径也完全正确 总结-第10节三节课的时间，讲了webpack图片中的坑，所有问题应该都可以解决了. 小知识 npm run build没有打包npm run build，直接npm run server,无法看到最新结果只有项目安装了webpack，如何打包如果全局没有安装webpack的话，直接在命令行执行webpack会报错。 解决办法在package.json中配置scripts选项，增加一个build命令，进行打包项目使用。 1234&quot;scripts&quot;: { &quot;server&quot;: &quot;webpack-dev-server --open&quot;, &quot;build&quot;:&quot;webpack&quot; }, 配置完后，在终端输入npm run build 即可打包 如何把图片放到指定的文件夹下前面打包的图片并没有放到images文件夹下，要放到images里，需配置url-loader ==outputPath==选项。 1234567891011121314151617181920212223module: { rules: [ { test: /\\.css$/, use: extractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) }, { test: /\\.(png|jpg|gif)/, use: [ { loader: 'url-loader', options: { limit: 5000, outputPath: 'images/' } } ] } ]}, 这样再执行打包，图片都被打包到images文件里。 第11节： CSS 进阶： Less 文件的打包和分离第5节中已经讲了CSS打包，分离。这节讲Less文件如何打包和分离。 Less是一门CSS预处理语言，扩展了CSS语言，增加了变量，Mixin，函数等特性，使CSS更易维护和扩展。 打包Less文件1. 安装 官网安装less服务 1npm install --save-dev less 安装less-loader供打包使用 1npm install --save-dev less-loader 也可以一条命令安装 1npm install --save-dev less-loader less 2. loader配置12345678910{ test: /\\.less$/, use: [{ loader: &quot;style-loader&quot; // creates style nodes from JS strings }, { loader: &quot;css-loader&quot; // translates CSS into CommonJS }, { loader: &quot;less-loader&quot; // compiles Less to CSS }]} 3. 编写一个less文件css/black.less 123456@base: #000;#gogo{ width: 300px; height: 300px; background-color: @base;} 4. 引入到entry.js1import less from './css/black.less'; 可以打包看效果发现打包到了entry.js中，没有提取到css文件中 把Less文件分离之前讲了extract-text-webpack-plugin插件，分离Less也是用这个 配置less的loader123456789101112{ test: /\\.less$/, use: extractTextPlugin.extract({ use: [{ loader: &quot;css-loader&quot; }, { loader: &quot;less-loader&quot; }], // use style-loader in development fallback: &quot;style-loader&quot; })} 打包会看到less被打包到index.css文件中 此外，在官网看到了，修改后缀名的配置 1234const extractLess = new ExtractTextPlugin({ filename: &quot;[name].[contenthash].css&quot;, disable: process.env.NODE_ENV === &quot;development&quot;}); 总结-第11节通过这节课， 就可以很轻松的编写less文件啦 第12节： CSS进阶： SASS文件的打包和分离 官网上节学了less的打包，这节开始学习SASS打包 1. 安装两个包node-sass，sass-loader1npm install sass-loader node-sass webpack --save-dev 注意： npm安装时，这个loader很容易安装失败。多次安装失败，最好把node_modules文件夹删除，再重新安装。 2. 编写loader配置12345678910{ test: /\\.scss$/, use: [{ loader: &quot;style-loader&quot; // creates style nodes from JS strings }, { loader: &quot;css-loader&quot; // translates CSS into CommonJS }, { loader: &quot;sass-loader&quot; // compiles Sass to CSS }]} 注意loader的加载有先后顺序(从下到上，从右到左),可以直接从官网拷贝 3.SASS 文件的编写nav.scss,别忘了引入到entry.js中 1234567$nav-color: #FFF;#nav { $width:100%; width: $width; height: 30px; backround-color: $nav-color;} 1import sass from './css/nav.scss'; 此时，可以npm run server 查看效果。 4. 把SASS文件分离123456789101112{ test: /\\.scss$/, use: extractTextPlugin.extract({ use: [{ loader: &quot;css-loader&quot; }, { loader: &quot;sass-loader&quot; }], // use style-loader in development fallback: &quot;style-loader&quot; })} 至此，可以愉快的写sass代码了。 小知识-D-D 等于–save-dev 第13节：CSS进阶： 自动处理CSS3属性前缀css3属性不同浏览器对应的前缀名称不同，太多的话代码冗余工作繁杂。 这节学习如何用postcss-loader给css3属性自动添加前缀。 什么是属性前缀CSS 属性前的-webkit,-ms,-moz这些前缀。为了兼容各个浏览器版本。 PostCSScss的处理平台，可以实现css的很多功能，这里只介绍一个加前缀的功能。 1. 安装需要安装两个包postcss-loader， autoprefixer(自动添加前缀的插件) 1npm install --save-dev postcss-loader autoprefixer 2. postcss.config.jsPostCSS推荐在项目根目录(和webpack.config.js同级)，建一个postcss.config.js 12345module.exports = { plugins: [ require('autoprefixer') ]} 引入了autoprefixer插件，让postCSS拥有添加前缀的能力。 3. 编写loader123456789101112131415{ test: /\\.css$/, use: [ { loader: &quot;style-loader&quot; }, { loader: &quot;css-loader&quot;, options: { modules: true } }, { loader: &quot;postcss-loader&quot; } ]} 这里是提取css的loader配置webpack.config.js 12345678910{ test: /\\.css$/, use: extractTextPlugin.extract({ fallback: 'style-loader', use: [ { loader: 'css-loader', options: { importLoaders: 1 } }, 'postcss-loader' ] })}, 5. 在index.css中添加css样式123456789#img{ background-image: url(../images/img.png); width:100px; height: 100px; transform: rotate(45deg); box-shadow: 1px 1px 0 rgba(0,0,0,.25); border-radius: 50%; display: flex;} 打包，运行可以看到新加的样式都加上了前缀。 第14节： CSS进阶： 消除未使用的CSS 引用别的库如BootStrap这样的框架，会带很多CSS，但项目中只用了一部分。 随项目进展，CSS越来越多，开发时只考虑新增，造成CSS冗余 这节学习 用webpack消除未使用的CSS。 PurifyCSSPurifyCSS可以大大减少CSS冗余，比如我们经常使用的BootStrap(140KB)就可以减少到只有35KB大小。这在实际开发当中是非常有用的。 1. 安装PurifyCSS-webpack 官网1npm i -D purifycss-webpack purify-css -D 是–save-dev的缩写 2. 引入globnode的glob模块可以根据配置的规则，获取对应的文件。 在webpack.config.js引入glob。 12const glob = require('glob') 引入purifycss-webpack 1const purifyCSSPlugin = require('purifycss-webpack') 3.配置plugins在webpack.config.js的plugins里增加配置 1234567891011121314plugins: [ // new uglify() new htmlPlugin({ minify: { removeAttributeQuotes: true }, hash: true, template: './src/index.html' }), new extractTextPlugin('css/index.css'), new purifyCSSPlugin({ paths: glob.sync(path.join(__dirname, 'src/*.html')) })], 这里的paths主要是寻找HTML模板，purifycss会根据这个配置遍历文件，查找哪些css被使用了。 注意：使用这个插件必须配合extract-text-webpack-plugin插件。 4.在index.css中添加一些没用的css1234567891011/* 多余的css */.bu{ backface-visibility: hidden; background-color: green; color: #FFF;}.hefd{ width: 200px; height: 200px; background-color: green;} 执行打包，查看dist中的index.css内容，会发现没有多余的css. css文件代码分割把css单独打包到CSS文件中，webpack默认把css打包到js中。即css-in-js.MiniCssExtractPlugin 压缩打包出的css代码optimize-css-assets-webpack-plugin 不能与 总结-第14节工作中一定要用这个插件，决定你的代码质量，非常有用。 第15节： 给webpack增加babel配置虽然webpack4增加了ES6的语法支持，但实际效果并不好。所以还是要加babel-loader配置。 这节学习如何增加Babel配置。 babel是什么 官网Babel 是一个 JavaScript 编译器。用他可以 使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。 使用基于JavaScript进行了扩展的语言，比如React的JSX。 高级: 了解babel怎么把高级语法转换成浏览器能识别的代码 1. Babel安装先一次性安装所有依赖包 123npm install --save-dev babel-loader @babel/core @babel/preset-env# 避免polyfill 污染全局变量，会以闭包形式引入npm install -D @babel/plugin-transform-runtime 这些包分别是：核心包 babel-loader 8.x | babel 7.x 2.在webpack中配置Babel123456789101112131415161718{ test: /\\.(jsx|js)$/, use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env', // 用到哪个，加哪个polyfill ['@babel/preset-env', { useBuiltIns: 'usage' }] ], // 代码只是业务代码不用引入，如果是类库的代码，需要引入 plugins: ['@babel/plugin-transform-runtime'] } }, exclude: /node_modules/} presets: 渲染器 不能转换所有的js，去除掉node_modules， 3.在entry.js中修改代码1234567import css from './css/index.css';import less from './css/black.less';import sass from './css/nav.scss';{ let str = 'Hello Webpack' document.getElementById('title').innerHTML = str;} 现在打包可以看到let被转为var,做了兼容处理。如果不适用babel转换的话，不会处理。 .babelrc配置babel的配置通常单独写在.babelrc文件里 在项目根目录新建.babelrc文件，把配置写到文件里。 1234567891011{ &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, { &quot;loose&quot;: true, &quot;targets&quot;: { &quot;node&quot;: &quot;6.9&quot; } }], &quot;@babel/preset-react&quot; ]} 修改webpack.config.js的loader配置 1234567{ test: /\\.(jsx|js)$/, use: { loader: 'babel-loader' }, exclude: /node_modules/} ENV 官网 babel-preset-env 是一个新的 preset，可以根据配置的目标运行环境（environment）自动启用需要的 babel 插件。目前我们写 javascript 代码时，需要使用 N 个 preset，比如：babel-preset-es2015、babel-preset-es2016。es2015 可以把 ES6 代码编译为 ES5，es2016 可以把 ES2016 代码编译为 ES6。babel-preset-latest 可以编译 stage 4 进度的 ECMAScript 代码。 问题是我们几乎每个项目中都使用了非常多的 preset，包括不必要的。例如很多浏览器支持 ES6 的 generator，如果我们使用 babel-preset-es2015 的话，generator 函数就会被编译成 ES5 代码。 babel-preset-env 的工作方式类似 babel-preset-latest，唯一不同的就是 babel-preset-env 会根据配置的 env 只编译那些还不支持的特性。 安装babel1npm install --save-dev babel-preset-env 修改.babelrc里的配置文件，只要把es2015换成env就可以了。 12345{ &quot;presets&quot;: [ &quot;react&quot;, &quot;env&quot; ]} 总结-第15节这里学了怎么配置babel支持，并且动态支持最新配置。 第16节： 打包后如何调试webpack打包后，代码无法调试。怎么解决？ webpack支持生成sourceMap来方便调试使用webpack通过简单的devtool配置，webpack会自动生成source map文件，map文件是一种对应编译文件和源文件的方法，方便调试。 四种选项在配置devtool时，webpack提供了4种选项 source-map在一个单独的文件中生成一个完整且功能完全的文件。这个文件有最好的source map，但是它会减慢打包速度 出错信息–包括行，列 独立(每个文件对应一个map) cheap-module-source-map在一个单独的文件中产生一个不带映射列的map，不带映射列提高了打包速度，但也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列(符号)，会对调试造成不便。 出错信息–只有行，没有列 独立 eval-source-map使用eval打包源文件模块，在同一个文件中生产干净的完整版sourcemap，但对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段可以使用，生产阶段一定不要开启这个选项 出错信息– 行 列 不独立 cheap-module-eval-source-map这是在打包文件时最快生成sourcemap的方法，生成的sourcemap会和打包后的JavaScript同行显示，没有映射列，和eval-source-map有相似的缺点 出错信息– 列 四种打包模式，由上到下越来越快。快的同时，也意味着对代码调试的困难越大建议： 如果大型项目可以使用source-map,中小型项目使用eval-source-map就可以完全应对。 强调：source-map只适用于开发阶段，上线一定要修改这些配置。 推荐线上用的cheap-module-source-map, 方便线上出问题找原因带module的为把module的代码也打入代码中带inline的，会把打包的代码放到代码中cheap,只考虑业务代码，不考虑module里的代码 配置webpack.config.js的devtool可以根据不同情况修改对应的值 12345678output: { // 输出的路径 path: path.resolve(__dirname, 'dist'), // 输出文件的名称 filename: '[name].js', publicPath: website.publicPath},devtool: 'source-map', 总结-第16节这节学习了配置devtool，方便在开发环境调试代码。一篇讲的不错的博客 官网地址 第17节： 实战技巧： 开发和生产并行配置这节讲开发和生产不同环境的不同配置 依赖不同开发环境和生产环境的依赖是不同的 开发依赖 只在开发中用来帮助你进行开发，简化代码，或生成兼容设置的依赖包。在package.json中devDependencies中的包是开发使用的。在生产环境用不到。生产依赖 一些框架的核心代码，比如vue, element-ui, react, 这些包在dependencies中 npm安装假如项目中使用jQuery库，一般有三种安装法。 11npm install jquery 安装完成后，package.json中并没有这个包的依赖。如果别人协同开发，直接npm install，项目无法正常运行，不推荐。 21npm install jquery --save 安装完成后，在package.json的dependencies中。是生产环境需要依赖的包。上线时需要依赖。 31npm install jquery --save-dev 安装完成后，在package.json的devDevpendencies中,是开发环境依赖的包，上线不需要这些包的依赖。 安装全部依赖包1npm install 会安装package.json中的所有包 安装生产环境依赖包1npm install --production 配置生产和开发并行以前的配置中设置了一个变量website,用于静态资源找到正确路径。如果生产环境和测试环境不一样，需要来回切换，这时候可用下面的方法配置。 修改package.json命令添加dev何止，通过环境变量来区分。 123456&quot;scripts&quot;: { &quot;liveserver&quot;: &quot;live-server ./ --port=9090&quot;, &quot;dev&quot;: &quot;set type=dev&amp;webpack&quot;, &quot;build&quot;: &quot;set type=build&amp;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot;}, 修改webpack.config.js文件利用node的语法读取type的值，然后根据type的值进行判断设置不同的变量。 12345678910if(process.env.type === 'build') { const website = { publicPath: 'http://localhost:8089/' }} else { const website = { publicPath: 'http://localhost:8089/' }} 如果想看某个值，可以console.log打印出来 1console.log(process.env.type) 打印console.log( encodeURIComponent(process.env.type) );发现报错 mac下的package.json设置mac电脑需要把set换成export，并且多加一个&amp;,具体代码 12345&quot;scripts&quot;: { &quot;server&quot;: &quot;webpack-dev-server --open&quot;, &quot;dev&quot;:&quot;export type=dev&amp;&amp;webpack&quot;, &quot;build&quot;: &quot;export type=build&amp;&amp;webpack&quot;}, 总结-第17节通过配置不同的参数来区分不同的环境，从而达到不同环境打包不同代码。 第18节： 实战技巧： webpack模块化配置所有配置文件都放在webpack.config.js中会显得代码冗余，不利于维护。 如何进行模块化？ 可以把生产环境的写到一个模块中，开发环境、测试环境都分开放到一个文件中。 这节学习如何将webpack.config.js模块化 js的模块化实现先看一下es6中的模块化代码 1234function alertMsg (msg) { alert('info: ' + msg);}module.exports = alertMsg; 声明一个alertMsg方法，并把这个方法用module.exports暴露出去。 然后在其他文件中用import引入，并使用。 12import alertMsg from './utils.js'alertMsg(); 了解了JavaScript的模块化后，来写webpack的模块化 webpack模块化这里用webpack.config.js中的entry入口哦文件进行模块化设置，单独做成一个模块 1. 在根目录建一个webpackConfig文件夹，新建entry_webpack.js，如下12345678910111213// 声明entry 变量const entry = {};// 声明路径属性entry.path = { entry: './src/entry.js', entry2: './src/entry2.js'}// 这里还可以写其他的// entry.env.type之类的//模块化导出module.exports = entry; 2. 在webpack.config.js中引入，这里只能用require引入1const entry = require('./webpackConfig/entry_webpack.js') 在入口处修改如下代码 1entry: entry.path, 这时可以运行npm run dev进行测试，会发现正常运行 总结-第18节模块化是必不可少的操作，一定要动手练习。 第19节： 实战技巧： 优雅打包第三方类库-shimming有时候避免不了打包第三方类库，这时候该怎么操作。 这节学习如何优雅正确的用webpack引入第三方库。讲两种方法 引入jQuery第一种安装jquery1npm install --save jquery juqery要在生产环境和开发环境用，所以要用–save安装 修改entry.js文件安装好需要引入到entry.js中，这里直接用import引入 1import $ from 'jquery' 这里不需要写相对路径，因为jquery的包是在node_modules里，只要写一个包名，系统就会自动为我们查找。 引入jQuery后就可以在文件中，使用jQuery，修改代码，测试 12345$('#gogo').animate({height : &quot;150&quot; } , 1000 ) .animate({width : &quot;300&quot; } , 1000 ) .hide(2000) .animate({height : &quot;show&quot; , width : &quot;show&quot; , opacity : &quot;show&quot; } , 1000 ) .animate({height : &quot;500&quot;} , 1000 ); 代码顺利运行，可以看到jQuery库引用成功。 注意：不仅可以在入口处引入，还可以在任何需要的js中引入。webpack不会重复打包，他只打包一次。 第二种用plugin引入上面的方法，只是普通的引入，webpack只负责打包，没有全局感。 这个方法在webpack.config.js中配置，不需要在入库文件中引入，而是webpack自动作全局引入。 这个插件是ProvicePlugin 文档 ProvicePlugin是webpack自带的插件，要现在webpack.config.js中引入webpack。 1const webpack = require('webpack') 在plugins中配置 123456new webpack.ProvidePlugin({ $: 'jQuery', _: 'lodash', _join: ['lodash', 'join']}) 配置好后，就可以在其他文件直接使用$, 而不用在每个组件引入jQuery。 这种全局的引入，在实际工作中也可以很好的规范项目所使用的第三方库。 总结-第19节每个项目都可能引入第三方类库。像一些成熟的框架都有自己的webpack框架，如vue-cli。 很多情况下，我们还是要手动更改这些配置好的webpack来适用于我们自己的项目。 所以这节课的内容也非常重要。 第20节： 实战技巧： watch的正确使用方法在初级开发阶段，使用webpack-dev-server可以充当服务器和完成打包任务，但随着项目的进一步完善，可能需要前后联调或两个前端合并代码时，就需要一个公共的服务器。这时候，每次手动打包显然效率太低，我们希望的场景是代码发生变化后，只要保存，webpack就自动为我们进行打包。 这个工具就是watch。 这节课学完后，会发现在开发中更加得心应手了。 watch设置12345678watchOptions: { // 检测修改的时间，以毫秒为单位 poll: 100, // 防止重复保存而发生编译错误。这里设置的500是半秒内重复保存，不进行打包 aggregeateTimeout: 500, // 不监听的目录 ignored: /node_modules/}, 注意ignored这里不能用双引号 没有配置的情况下，直接webpack –watch (-w) 是不起作用的 配置好后，就可以痛快的使用watch了。大大加快了开发效率，不用反复手动打包。 BannerPlugin插件工作中每个人的代码都要写备注，方便发生问题时，可以找到写代码的人，有时候也用于版权声明。 这个插件就是BannerPlugin,使用后会在js中加上我们的版权或开发者声明 在webpack.config.js的plugins里配置 1new webpack.BannerPlugin('版权所有，仅限学习使用~~') 注意： 用这个插件，需要提前引入webpack.编译后，在每个文件的头部，会有编译信息。 第21节： 实战技巧： webpack优化黑技能无论写什么程序，都要有颗不断优化的心。 这节课来学习工作中常用的webpack优化黑技能。 ProvidePlugin和import在第19节中学习了如何引入第三方类库，并引入了jQuery。在引入jQuery时，用了2种方法。第一种是import，第二种是用ProvidePlugin插件。这两种方法有什么区别呢？ import方法： 引用后不管在代码中用不用，都会把这个类库打包，这样有时会产生代码冗余。 ProvideP方法： 引用后只有在类库使用时，才按需打包，所以建议工作中使用插件的方式进行引入。 具体打包差别可以自行练习，查看打包结果。差距明显。 抽离jQuery上面只是优化的第一步，工作中会发现，不使用的类库我们也不会引入，所以上面只是必要操作的一步。往往把第三类类库抽离出来，才是最好的解决办法。 第一步： 修改入口文件抽离的第一步是修改入口文件，把jQuery加入到入口文件中，看下面代码。webpack.config.js 12345entry.path = { entry: './src/entry.js', jquery: 'jquery', entry2: './src/entry2.js'} 第二步：引入插件需要引入optimize优化插件，插件里是需要配置的，具体代码 12345678new webpack.optimize.CommonsChunkPlugin({ // name对应入口文件中的名字，这里是jquery name: 'jquery', // 把文件打包到哪里，路径地址 filename: 'assets/js/jquery.min.js', // 最小打包的文件模块数，这里直接写2 minChunks: 2}) minChunks是固定配置，不写不行，会打包失败 filename可以省略，直接打包到根目录下，这里直接打包到dist目录下 配置完成后可以先删掉原来的dist目录，再用webpack打包，会发现jQuery被抽离了出来，并且entry.js变的很小。 多个第三方库抽离会了jquery抽离，在实际开发中，会引用不止一个第三方类库，也需要抽离。 这里用引入Vue举例，看看如何抽离出来。 第一步： 先用npm进行安装1npm install vue --save 注意这里是–save，不是–save-dev，因为生产环境也要用到 第二步： 在入口配置中引入Vue和jquery123456entry.path = { entry: './src/entry.js', jquery: 'jquery', vue: 'vue', entry2: './src/entry2.js'} 只比上边多了个vue 第三步：修改CommonsChunkPlugin配置需要修改两个位置： 在name属性里把原来的字符串改为数组。因为要引用多个模块， 所以是数组。 在filename属性中把输出的文件名改为匹配符[name],这项操作就是打包出来的名字跟随我们打包前的模块名。 12345678new webpack.optimize.CommonsChunkPlugin({ // name对应入口文件中的名字，这里是jquery name: ['jquery', 'vue'], // 把文件打包到哪里，路径地址 filename: 'assets/js/[name].js', // 最小打包的文件模块数，这里直接写2 minChunks: 2}) 配置好后，在控制台用npm run build 打包。jquery和Vue被抽离出来了。 总结-第21节在项目开发中，会使用很多第三方类库，比较好的做法就是把这些第三方类库全部抽离处理，这样在项目维护和性能上都是不错的选择。学了这个技巧后，在工作中要会使用。 jquery作为插件引入后，在其他文件中怎么用呢还是需要有 providePlugin来支撑的，不能去掉。 123new webpack.ProvidePlugin({ $: 'jquery'}), 第22节： 实战技巧： 静态资源集中输出工作中会有一些已经存在但在项目中没有引用的图片资源或者其他静态资源（比如设计图、开发文档），这些静态资源有可能是文档，也有可能是一些额外的图片。项目组长会要求你打包时保留这些静态资源，直接打包到指定文件夹。其实打包这些资源只需要用到copy-webpack-plugin。 使用copy-webpack-plugincopy-webpack-plugin就是专门为我们做静态资源转移的插件，不过它需要安装。 插件安装1npm install --save-dev copy-webpack-plugin 引入插件安装好后，需要在webpack.config.js的头部引入这个插件 1const copyWebpackPlugin = require('copy-webpack-plugin') 配置插件在plugins里进行配置,注意这里是数组 1234new copyWebpackPlugin([{ from: __dirname+ '/src/public', to: './public'}]) from: 要打包的静态资源目录地址，__dirname指项目目录，可以直接定位到本机的项目目录。 to: 要打包到的文件路径，跟随output配置的目录。所以这里不用加__dirname. 配置好后，运行webpack，会发现图片按照配置打包到了指定目录。 总结-第22节现在学起来已经很容易了，已经掌握了webpack的基本知识，剩下的就是不断练习和在实际项目中发现新的需求，然后找到新的loader或者plugin来解决问题。 第23节： 实战技巧： JSON配置文件的使用在实际工作中，我们的项目都会配置一个json的文件或API文件，作为项目的配置文件。有时也会从后台读取一个json文件。 这节课就学习如何在webpack环境中使用JSON. 在webpack1或webpack2中，需要加载一个json-loader的loader，但在webpack4.x中，不需要额外引入。 读取JSON内容 在index.html中加个div，并给个id. 1&lt;div id=&quot;jsonArea&quot;&gt;&lt;/div&gt; 到src文件夹下，找到入口文件，entry.js,修改代码。如下： 12let json = require('../config.json');document.getElementById('jsonArea').innerHTML = json.name; 引入json文件，并插入到dom中。 运行npm run server ，就可以看到效果。 说说热更新在devServer中配置hot: truehotOnly: true 热更新失败时，不刷新整个页面 在webpack4.x中，启用热加载很容易，只要加入HotModuleReplacementPlugin这个插件就可以了。 在plugin里配置 123plugins: [ new webpack.HotModuleReplacementPlugin()] 现在，启动npm run server后，修改index.html中的内容，浏览器就可以自动更新最新页面 123456// 如果某个js模块更新了，只更新某个模块，而不是所有模块都更新if (module.hot) { module.hot.accept('./number', () =&gt; { number(); });} 这里的热更新和平时写程序的热加载不是一回事，比如说我们Vue和React中的热更新，并不是刷新整个页面，而是一个局部的更新，而这里的更新是刷新了整个页面这个区别要搞清楚。 第24节： 剧终： webpack自学技巧传授这节课学一些自学webpack的技巧，让大家可以在本教程结束后继续自行精进。 学习推荐 webpack 官网 中文官网 深入浅出 Webpack Webpack插件 hard-source-webpack-plugin提升打包效率非常明显 webpack之监测配置文件的修改而自动构建在webpack的自动构建中，一般情况下我们只是监测到源文件的变化，如果修改webpack的配置文件就不会发生自动构建。通过使用node的nodemon模块来达到目的。 一、安装nodemon 1234// 全局安装npm install -g nodemon// 本地安装npm install --save-dev nodemon 二、使用nodemon nodemon --watch ./config/webpack.dev.js 解释： – watch config 表示监测config目录下的文件变化– dev.js则为webpack本来的通过 node dev.js形式执行的构建起始文件总体意思就是：监测config中的文件变化并重新执行dev.js文件 如果nodemon是本地安装需要如下处理： 12345// 在package.json中scripts中加如下配置&quot;startNodemon&quot;:&quot;nodemon --watch config dev.js&quot;//在命令行中执行npm run startNodemon 在package.json中的配置 123456{ &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack ...&quot; &quot;dev&quot;: &quot;nodemon --watch config dev.js --exec npm run start&quot; }} 说明 –exec 配置运行的命令 –watch 监听些文件变化，当变化的时候自动重启 node服务器app.js自动重启 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;nodemon app.js &quot;}, 实际使用中，如果package.json中的main配置了，但是路径不对，会报错找不到文件导致无法自动重启 webpack npm install 报错解决执行npm install 报错: npm ERR! Cannot read property 'match' of undefined 解决办法: 依次执行以下命令 1234rm -rf node_modulesrm package-lock.jsonnpm cache clear --forcenpm install Clean plugin for webpack在打包之前清除打包文件 npm install --save-dev clean-webpack-plugin 用法 123456789const { CleanWebpackPlugin } = require('clean-webpack-plugin');const webpackConfig = { plugins: [ new CleanWebpackPlugin() ],};module.exports = webpackConfig; 自己实现webpack-dev-server在node中使用webpack npm install express webpack-dev-middleware -D 1234567891011121314151617const express = require('express');const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const config = require('./webpack.config.js');// 用webpack结合config编译代码const complier = webpack(config);const app = express();app.use(webpackDevMiddleware(complier), { publicPath: config.output.publicPath});app.listen(3000, () =&gt; { console.log('server is running');}); webpack.config.js 配置 123scripts: { 'server': 'node server.js'} tree shaking只支持ES Module!!! import { add } from './math.js'; 底层是静态引入方式 不支持 const add = require('./math.js); commonJs 是动态引入, 不支持tree shaking webpack.config.js 123optimization: { usedExports: true} 在package.json中 对哪个文件不做筛选，在sideEffects里以数组的方式加入对css文件不做处理sideEffects: ['*.css'] false为对所有文件筛选 123{ &quot;sideEffects&quot;: false} mode: 为development时，打包不会删除代码，会删除导出 webpack区分 开发模式和 production模式依赖webpack-merge npm install webpack-merge -D webpack.common.js 公共的配置 123456789101112const merge = require('webpack-merge');module.exports = { entry: { main: './src/index.js' }, module: { } output: { }} webpack.prod.js, 保留线上独有的配置 123456789const merge = require('webpack-merge');const commConfig = require('./webpack.common.js');const prodConfig = { mode: 'production', devtool: 'cheap-module-source-map'}module.exports = merge(commonConfig, prodConfig); webpack.dev.js, 保留开发环境独有的配置 1234567891011const merge = require('webpack-merge');const commConfig = require('./webpack.common.js');const devConfig = { mode: 'development', devServer: { hot: true }}module.exports = merge(commonConfig, devConfig); package.json 1234scripts: { &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;} 可以把所有配置文件都放到build文件夹里, 需要改package.json里的配置(output, scripts等) 检查打包位置对不对，清除文件对不对 Code Splitting–有疑问SplitChunksPlugin 拆分代码，提升项目性能 比如引入lodash之类的类库，打包生成的文件会多1MB左右 将2MB的文件拆分成两个1MB的文件加载 当业务逻辑发生改变时，只加载业务逻辑代码，不加载基础类库的代码 在webpack.config.js中增加配置—-同步代码 12345optimization: { splitChunks: { chunks: 'all' }} 异步代码（import,无需做任何配置会自动进行代码分割） 代码支持异步import npm install babel-plugin-dynamic-import-webpack --save-dev Lazy Loading 懒加载，Chunk 是什么–有疑问通过import异步加载模块 可以让页面加载更快 babel-plugin-syntax-dynamic-import 点击页面才会加载getComponent 123456789101112function getComponent() { return import(/** webpackChunkName: &quot;lodash&quot; */ 'lodash').then({ default: _ }) =&gt; { var element = document.createElement('div'); element.innerHTML = _.join(['11', '22'], '-'); return element; });}document.addEventListener('click', () =&gt; { getComponent().then(element =&gt; { document.body.appendChild(element); })}) 123456async function getComponent() { const { default: _ } = await import(/** webpackChunkName: &quot;lodash&quot; */ 'lodash'); var element = document.createElement('div'); element.innerHTML = _.join(['11', '22'], '-'); return element;} 打包分析，Preloading, Prefetching官方工具链接 webpack分析工具analyse 生成打包描述文件package.json 123scripts: { &quot;analyze&quot;: 'webpack --profile --json &gt; stats.json'} 分析网站，需科学上网 webpack-bundle-analyzer 小知识-文件利用率command+shift+p 搜索coverage, 可以看文件利用率 提高代码的使用率 多写异步代码，性能才能得到提升 chunks: ‘async’ 才能真正提升网站性能 webpack与浏览器缓存(Caching)performace: false 可以不提示性能问题 通过文件名添加hash值来缓存 生产环境 1234output: { filename: '[name].[contenthash].js', chunkFilename: '[name].[contenthash].js'} library打包文档地址 externals开发类库的打包，供第三方以不同的方式(import, require, script)引入使用 123456789101112mode: 'production',// 如果遇到lodash库，不打包到代码里，业务里要用的话，先引用lodash，再引用libraryexternals: ['lodash'],output: { path: path.resolve(__dirname, 'dist'), filename: 'library.js' // 以script方式引入 library: 'library', // 以import和require方式引入 libraryTarget: 'umd'} package.json 1main: &quot;./dist/index.js' 12npm addusernpm publish PWA打包配置网站访问过一次之后，可以一直被缓存, serviceWorker workbox-webpack-plugin 123456789101112// Inside of webpack.config.js:const {GenerateSW} = require('workbox-webpack-plugin');module.exports = { // Other webpack config... plugins: [ // Other plugins... new GenerateSW({ option: 'value', }) ]}; TypeScript 打包配置npm install ts-loader typescript -D 12345rules: [{ test: /\\.tsx?$/, use: 'ts-loader', exclude: /node_modules/,}] tsconfig.json 12345678{ &quot;compilerOptions&quot;: { &quot;outDir&quot;: &quot;./dist&quot;, &quot;module&quot;: &quot;es6&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;allowJs&quot;: true }} npm install @types/lodash --save-dev这样在代码中typescript可以识别lodash中的方法，并提示语法不规范等错误 DefinitelyTyped webpack性能优化 跟上技术的迭代(npm, yarn, Node版本升级) 在尽可能少的模块上用loader excludes或include plugin尽可能少，并保证可靠性 resolve参数合理配置 12345678910resolve: { extendsions: ['.js', '.jsx'], // 从哪个文件导入模块, 不要配置过多的 mainFields: ['index', 'main'], // 创建 import 或 require 的别名 alias: { 'utils': path.resolve(__dirname, '../utils'), 'assets': path.resolve(__dirname, '../assets'), }} extendsions: 不要把所有后缀都加到这里, 如css, jpg等, 会增加文件查找复杂度 使用DLLPlugin提高打包速度 每一次引入第三方包都会进行分析，消耗时间 webpack.dll.js 123456789101112131415161718192021const path = require('path');const webpack = require('webpack');module.exports = { entry: { vendors: ['react', 'react-dom'], lodash: ['lodash'] }, output: { filename: '[name].dll.js', path: path.resolve(__dirname, '../dll'), // 可以在控制台使用的变量,通过全局变量暴露出来 library: '[name]' }, plugins: [ new webpack.dllPlugin({ name: '[name]', path: path.resolve(__dirname, '../dll/[name].manifest.json') }) ]} webpack.common.js 1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path');const fs = require('fs');const addAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');const webpack = require('webpack');const plugins = [ new HtmlWebpackPlugin({ template: 'src/index.html' }), new CleanWebpackPlugin(['dist'], { root: path.resolve(__dirname, '../') })];const files = fs.readdirSync(path.resolve(__dirname, '../dll'));files.forEach(file =&gt; { if (/.*\\.dll.js/.test(file)) { plugins.push(new addAssetHtmlWebpackPlugin({ filePath: path.resolve(__dirname, '../dll',file) })) } if (/.*\\.manifest.json/.test(file)) { plugins.push(new webpack.DllReferencePlugin({ manifest: path.solve(__dirname, '../dll/', file) })) }});module.exports = { entry: { vendors: ['react', 'react-dom'], lodash: ['lodash'] }, output: { filename: '[name].dll.js', path: path.resolve(__dirname, '..dll'), // 可以在控制台使用的变量,通过全局变量暴露出来 library: '[name]' }, plugins} npm install add-asset-html-webpack-plugin --save 目标： 第一次打包时把常用的库放到一个文件，再次引用不再从node_modules里找 第三方模块只打包一次 引入第三方模块时，用dll文件引入 先打包npm run build:dll 打包webpack.dll.js，再运行npm run build 1234&quot;scripts&quot;: {&quot;build&quot;: &quot;webpack --progress --colors --devtool cheap-module-source-map&quot;,&quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js&quot;}, 控制包文件大 thread-loader, paraller-webpack, happypack多进程打包 合理使用sourceMap 结合stats分析打包结果 开发环境内存编译 开发环境无用插件剔除(开发环境没必要压缩之类的) 多页面打包配置多个entry对应多个html文件 webpack.common.js 123456789101112131415161718192021222324252627282930const makePlugins = (configs) =&gt; { const plugins = [ new CleanWebpackPlugin(['dist'], { root: path.resolve(__dirname, '../') }) ]; Object.keys(configs.entry).forEach(item =&gt; { plugins.push( new HtmlWebpackPlugin({ template: 'src/index.html', filename: `${item}.html`, chunks: ['runtime', 'vendors', item] }), ) }); // dllplugins return plugins;}const configs = { entry: { index: './src/index.js', list: './src/list.js' }, plugins};config.plugins = makePlugins(config);module.exports = config; 如何编写一个loader常用功能: 国际化替换中英文, 捕获异常(在function外加trycatch) loader API replaceLoader.js 123456789const loaderUtils = require('loader-utils');module.exports = function(source) { const options = loaderUtils.getOptions(); const result = source.replace('hello ', options.name); // 等于 return result this.callback(null, result);} webpack.config.js 123456789101112131415resolveLoader: { // path.resolve(__dirname, './loaders/replaceLoader.js)可以不用写这么多,直接写name modules: ['node_modules', './loaders']},module: { rules: [{ test: /\\.js/, use: [{ loader: 'replaceLoader', options: { name: 'lee' } }] }]} 复杂的replaceLoader.js 12345678910const loaderUtils = require('loader-utils');module.exports = function(source) { const options = loaderUtils.getOptions(); const callback = this.async(); setTimeout(() =&gt; { const result = source.replace('dell', options.name); callback(null, result); }, 1000);} 如何编写一个Plugin打包的某个时刻，是插件生效的场景，比如打包之前，清除dist目录compiler hookscopyright-webpack-plugin.js 1234567891011121314151617181920212223242526class CopyrightWebpackPlugin { constructor(options) { console.log('插件被使用了', options); } apply(compiler) { // 同步写法 compiler.hooks.emit.tap('CopyrightWebpackPlugin', () =&gt; { }); // 异步写法 compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (compilation, cb) =&gt; { // compilation.assets为打包后的文件 compilation.assets['copyright.txt'] = { source: function() { return 'copyright by hello world' }, size: function() { return 21; } } // 一定要加回调 cb(); }) }}module.exports = CopyrightWebpackPlugin; webpack.config.js 1234567const copyrightWebpackPlugin = require('./plugins/copyright-webpack-plugin');plugins: [ new copyrightWebpackPlugin({ name: 'world' })] 用node调试工具调试webpack123&quot;scripts&quot;: { &quot;debug&quot;: &quot;node --inspect --inspect-brk node_modules/webpack/bin/webpack.jss&quot;} 在插件中写debugger，会自动跳到该断点 [CreateReactApp](https://github.com/facebook/create-react-app）项目Webpack解析npm run eject查看webpack配置 Vue项目配置新建vue.config.js配置","link":"/posts/Webpack-%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"},{"title":"前端经验积累","text":"判断一个对象是不是数组 instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。 12345678var a={};var b=[];console.log(a instanceof Object);//trueconsole.log(b instanceof Array);//true注意！！！！！！console.log(b instanceof Object);//true Array.isArray() 使用Object.prototype上的原生toString()方法判断。 1234console.log(Object.prototype.toString.call(a));//[object Object]console.log(Object.prototype.toString.call(b));//[object Array]同理判断一个对象是否是函数：console.log(Object.prototype.toString.call(obj)==='[object Function]') //true或false obj.constructor===Array //true 真值 / 假值（Truthy / Falsy）以下为false false 0 “”（空字符串） null undefined NaN 12345678910111213!0 // true -- 0 is false, 所以返回true!!0 // false -- 0 is falsy so !0 returns true so !(!0) returns false!!&quot;&quot; // false -- empty string is falsy so NOT (NOT false) equals falsenew Boolean(0) // falsenew Boolean(1) // truelet a = [] == true // a is false since [].toString() give &quot;&quot; back.let b = [1] == true // b is true since [1].toString() give &quot;1&quot; back.let c = [2] == true // c is false since [2].toString() give &quot;2&quot; back.在内部，当一个对象与布尔值比较时，比如[] == true，它其实进行的是[].toString() == true。 JS语句为什么不能以“function”和大括号开头 以function开头，但必须是一个函数声明语句 以大括号开头，但该大括号不再被当做一个对象处理，而是当做一个语句块处理 综上两条说明，JS语句可以以function，也可以以大括号作为开头，前提是必须符合JS中的语法规范 123456{a: 'a'}.a; // Uncaught SyntaxError: Unexpected token .function(){}.toString(); // Uncaught SyntaxError: Unexpected token ({}.toString(); // Uncaught SyntaxError: Unexpected token .“{}.toString();” 等同于: “; .toString();” 未通过对象主体调用“toString”方法，不符合JS中期待的表达式 Object.assign, JSON.stringify是深拷贝吗不是的话怎么解决 shallowCopy（浅拷贝）或 deepCopy（深拷贝） 深拷贝造成了 CPU 和内存的浪费 深拷贝如果是只有最底层一个元素改变，会造成性能影响，怎么解决? immutable Object.assign()可以对非嵌套对象进行深拷贝的方法,如果对象中出现嵌套情况,那么其对被嵌套对象的行为就成了普通的浅拷贝.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。 对象解构运算，也是浅拷贝。 JSON对象中包含两个方法, stringify()和parse(),前者可以将对象JSON化,而后者可以将JSON格式转换为对象.这是一种可以实现深拷贝的方法.但这种方法的缺陷是会破坏原型链,并且无法拷贝属性值为function的属性所以如果只是想单纯复制一个嵌套对象,可以使用此方法 缺点是你创建一个临时的，可能很大的字符串，只是为了把它重新放回解析器。另一个缺点是这种方法不能处理循环对象。而且循环对象经常发生。例如，当您构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。 12345678910111213141516171819202122232425262728const x = {};const y = {x};x.y = y; // Cycle: x.y.x.y.x.y.x.y.x...const copy = JSON.parse(JSON.stringify(x)); // throws!let bar = JSON.parse(JSON.stringify(foo));Object.assign({}, foo);let obj = { a: 0, b: 20,}obj = {...obj, a: obj.a + 1}Structured Clone 结构化克隆算法MessageChannel缺点是它是异步的。虽然这并无大碍，但是有时候你需要使用同步的方式来深度拷贝一个对象function structuralClone(obj) { return new Promise(resolve =&gt; { const {port1, port2} = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); });}const obj = /* ... */;const clone = await structuralClone(obj); es7 … 的方式直接{…obj}赋值属于浅复制，在修改值时{…obj,a:1}就起到了类深复制的效果更新一个 Object immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发 链接 Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。 为什么immutable比较两个对象不同会快？原因如下：和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。用法：is(map1,map2) 123456789101112131415161718192021这是原来的 reducer：case 'apple/EAT_APPLE': newState = Object.assign({}, state, { apples: [ ...state.apples.slice(0, action.payload), Object.assign({}, state.apples[action.payload], { isEaten: true }), ...state.apples.slice(action.payload + 1) ] }) return newState;这是使用 immutable.js 库的reducer :import { fromJS } from 'immutable';case 'apple/EAT_APPLE': return fromJS(state).setIn(['apples',action.payload,'isEaten'], true).toJS();团队约定 state 都用 immutable 内部的数据类型，就可以连 fromJS 和 toJS 的转化都省了，超级方便！ JSONP 后端返回alert(data)，前端会执行吗因为后端把回调方法名转成另一个名字将data包在里边，所以不会执行alert。 为什么是jsonp, img, iframe也可以，为什么？ jsonp全名叫做json with padding函数调用，数据都被包裹传递到参数中了， 将服务端的数据用padding包起来，所谓的padding就相当于一个函数。假设我们原来有数据 {“data”,”something”}，用一个名为callback的padding包起来之后 就成了 callback({“data”:”something”})，这样将script标签加载完毕之后，会立马执行这个函数，并将数据当做参数传了进去。如果我们可以事先在前端事先指定一个函数名，并定义这个函数。然后告诉后端，用这个函数名作为padding包裹数据。那么当前端动态创建script标签之后，script加载完毕了就会执行这个函数，这样我们就成功的跨域获得了数据~ 从开发者工具里面可以看到实际发送的请求 Request URL:https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924 这里可以看出来jQuery自动生成的padding是jsonp1430727166924返回的数据：;jsonp1430727166924({“rating”:{“max”:10,”numRaters”:336,”average”:”7.0”,”min”:0},”price”:”15.00元”}); js,css执行顺序，并行串行，阻塞链接DOM文档的加载顺序是由上而下的顺序加载； 1、DOM加载到link标签 ==css文件的加载是与DOM的加载并行的==，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中； 2、DOM加载到script标签 由于==js文件不会与DOM并行加载==，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验； js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现； 所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。至到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。 嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。 浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。 3、解决方法 前提，js是外部脚本； 在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞； 在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果； 同时使用defer和async属性时，defer属性会失效； 可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。 进制转换123456789101112131415//十进制转其他var x=110; alert(x);alert(x.toString(8)); alert(x.toString(32)); alert(x.toString(16)); //其他转十进制var x='110';alert(parseInt(x,2)); alert(parseInt(x,8)); alert(parseInt(x,16)); //其他转其他 //先用parseInt转成十进制再用toString转到目标进制 alert(String.fromCharCode(parseInt(141,8))) alert(parseInt('ff',16).toString(2)); 两个对象判断==引用下温特大大的总结就是：只要记住 null 只和undefined 相等，有 number 都转 number，有 boolean 也转 number，有 string 都转 string，对象互相不等，NaN 互相不等就可以了。 12345678910111213141516171819console.log([] == []) // falseconsole.log(![] == false) // falseconsole.log([] == false) // trueconsole.log(!!'hello') // trueconsole.log('hello' == true) // 'hello'==1 falseconsole.log(typeof(typeof('hello')))typeof的运算数未定义,返回的就是 “undefined”.运算数为数字 typeof(x) = “number”字符串 typeof(x) = “string”布尔值 typeof(x) = “boolean”对象,数组和null typeof(x) = “object”函数 typeof(x) = “function” FOUC无样式内容闪烁Flash of Uncompiled Content 原因大致为： 1，使用import方法导入样式表。 2，将样式表放在页面底部 3，有几个样式表，放在html结构的不同位置。 解决方法： 使用LINK标签将样式表放在文档HEAD中。 v-cloak 用v-text v-if, v-show 1234567891011&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;&lt;!-- same as --&gt;&lt;span&gt;{{msg}}&lt;/span&gt;// &lt;div&gt; 不会显示，直到编译结束。[v-cloak] {display: none;}&lt;div v-cloak&gt;{{ message }}&lt;/div&gt; js实现jQuery.clone123456789逐级递归；递归中收集每个元素的全部信息，包括该元素上绑定的所有事件。复制时候重现按照获得的事件列表逐个加载回去。除此之外主要可能是考虑各种兼容，包括cloneNode方法的兼容，获取元素属性时候的某些标签的兼容。 i18n（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。 ajax参数链接 1234567891011121314151617181.url: 发送请求的地址2.type: 请求方式（post或get3.timeout: 请求超时时间（毫秒）4.async: 默认设置为true，异步请求5.cache: 从浏览器缓存中加载请求信息6.data: 发送到服务器的数据7.dataType: xml,html, json,text8.beforeSend：发送请求前，执行一些操作9.complete：完成后调用的回调函数10.success：请求成功后调用的回调函数11.error:12.contentType：13.dataFilter：16.ifModified： jQuery插件123456789101112//闭包限定命名空间(function ($) { $.fn.extend({ &quot;highLight&quot;:function(options){ //do something } });})(window.jQuery);//调用$(&quot;p&quot;).highLight(); //调用自定义 高亮插件 exports, module.exports区别1234567exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exportsexports在module.exports 被改变后，失效。1. module.exports 初始值为一个空对象 {}2. exports 是指向的 module.exports 的引用3. require() 返回的是 module.exports 而不是 exports 上传文件方式 form表单上传文件 原生js实现ajax上传文件 var xml=new XMLHttpRequest(); var data=new FormData; //创建formdata对象 data.append(“testfile”,document.getElementById(“file_upload”).files[0]);//找到对象之后的file[0]对应的就是文件对象 xml.open(“POST”,”/test/“,true); jquery实现ajax上传文件 12345678910111213var data=new FormData;data.append(&quot;testfile&quot;,document.getElementById(&quot;file_upload&quot;).files[0]);$.ajax({ url:&quot;/test/&quot;, type:&quot;POST&quot;, dataType:&quot;JSON&quot;, data:data, contentType: false, processData: false, success:function(rst){ }) }) form+iframe上传文件 Sass @mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin通过 @include来调用。 @mixin通过 @include调用后解析出来的样式是以拷贝形式存在的，而继承则是以联合声明的方式存在的， 12345678910111213141516//sass style//-------------------------------@mixin center-block { margin-left:auto; margin-right:auto;}.demo{ @include center-block;}//css style//-------------------------------.demo{ margin-left:auto; margin-right:auto;} cookie和session区别1234567891011121314151，session 在服务器端， cookie 在客户端（浏览器）2，session 默认被存在在服务器 的一个文件里（不是内存）3，session 的运行依赖 session id， 而 session id 是存在 cookie 中的， 也就是说，如果浏览器禁用了 cookie ， 同时 session 也会失效 （但是可以通过其它方式实现， 比如在 url 中传递 session_id）4，session 可以放在 文件、数据库、或内存中都可以。5，用户验证这种场合一般会用 session因此，维持一个会话的核心就是客户端的唯一标识，即 session id AMD, CMD, CommonJS==记忆方法== ARAMD– require.js CSCMD– sea.js A AMD A在前，提前加载 C CMD C在后，延迟加载 1234567891011121314151617181920212223242526272829303132333435363738node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD，// a.js// -------- node -----------module.exports = { a : function() {}, b : 'xxx'};// ----------- AMD or CMD ----------------define(function(require, exports, module){ module.exports = { a : function() {}, b : 'xxx' };});AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。区别：1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.2. CMD 推崇依赖就近，AMD 推崇依赖前置。ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。 import引入模块import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。 import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。 注意:import必须放在文件的最开始.import命令是编译阶段执行的，在代码运行之前,表达式和变量只有在运行时才能得到结果的语法结构。import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）所以import中不能含有表达式或者变量,因此无法实现动态加载.因此，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。这样的设计，有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。 ES6 模块与 CommonJS 模块的差异123CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块是运行时加载，ES6 模块是编译时输出接口ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 position取值12345678910ralative是指相对定位元素仍保持其未定位前的形状，它原本所占的空间仍保留。absolute是指绝对定位 即完全离开文档流, 相关于position属性非static值的比来父级元素进行偏移。 如果不存在这样的父对象，则依据body对象。而其层叠通过z-index属性定义fixed: 固定定位 固定定位：即完全离开文档流，相关于视区进行偏移。static：元素框正常生成inherit：继承值，对象将继承其父对象相应的值。 类数组转换为数组的方法12Array.prototype.slice.call(arguments); call和apply, bind区别这三个参数的返回值区别 12345678910111213141516171819202122232425262728293031323334353637383940414243作用完全一样，唯一的区别就在参数上call 接收的参数不固定，第一个参数是函数体内 this 的指向，第二个参数以下是依次传入的参数。apply接收两个参数，第一个参数也是函数体内 this 的指向。第二个参数是一个集合对象（数组或者类数组）记忆方法：apply ---- array 要传数组call ---- 逗号隔开三个的使用区别：都是用来改变函数的this对象的指向的；第一个参数都是this要指向的对象；都可以利用后续参数传参；bind是返回对应函数，便于稍后调用，apply、call是立即调用；bind（）--也是改变函数体内this的指向;bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数；let obj1={ a:222};let obj2={ a:111, fn:function(){ alert(this.a); }}obj2.fn.call(obj1);//222call 和 apply 两个主要用途就是1.改变 this 的指向（把 this 从 obj2 指向到 obj1 ）2.方法借用（ obj1 没有 fn ，只是借用 obj2 方法） 箭头函数怎么绑定全局this箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值， 1234567891011var obj = { i: 10, b: () =&gt; console.log(this.i, this), c: function() { console.log( this.i, this) }}obj.b(); // undefined window{...}作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象 es6新特性链接 foreach, map, reduce, filter区别函数声明&amp;函数表达式的区别1234567891011121314151617181920212223242526函数声明中函数名是必须的；函数表达式中则是可选的 //函数声明function sum(a, b) { return a + b;}alert(sum(1, 2));//函数表达式/* var s = function sum(a, b) { return a + b;}alert(s(1, 2)); */var s = function(a, b) { return a + b;}alert(s(1, 2));//以上两种都可以二、用函数声明定义的函数,函数可以在函数声明之前调用,而用函数表达式定义的函数只能在声明之后调用。【根本原因在于解析器对这两种定义方式读取的顺序不同:解析器会事先读取函数声明，即函数声明放在任意位置都可以被调用；对于函数表达式，解析器只有在读到函数表达式所在那行的时候才执行】使用var 表达式定义函数， 只有变量声明提前了，变量初始化代码仍然在原来的位置 DOM事件流事件捕获阶段处于目标阶段事件冒泡阶段 addEventListener(evtype,fn,useCapture)123456789101112131415161718useCapture是true，则事件处理函数在捕获阶段被执行，否则 在冒泡阶段执行因为如果被监听的元素没有子元素，那么哪个监听代码写在前面，就先执行哪个！&lt;label&gt;Click me &lt;input type=&quot;text&quot;&gt;&lt;/label&gt;&lt;script&gt; document.querySelector('label').addEventListener('click',function () { console.log(1) }) document.querySelector('input').addEventListener('click',function () { console.log(2) })&lt;/script&gt;因为label和input是有绑定的点击label后，浏览器自动帮你再点击一次label过程就是先进行一次事件机制，这一次对内部input元素的事件监听是不管不问的，所以先打出1结束后，再进行一次事件机制，这一次，按照正常事件机制流程走，所以接着打出了2,1 阻止冒泡window.event.cancelBubble = true e.preventDefault(); return false 都能阻止 stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡 git 问题1234567891011121314151617git回退到某个commit版本git reset --hard commitId强制提交git push -f origin master删除分支git branch -d branchname git 删除远程分支git push origin branchnamerebase 和 merge区别rebase，合并的结果好看，一条线，但合并过程中出现冲突的话，比较麻烦（rebase过程中，一个commit出现冲突，下一个commit也极有可能出现冲突，一次rebase可能要解决多次冲突）；merge，合并结果不好看，一堆线交错，但合并有冲突的话，只要解一次就行了；commit 粒度把握得好，就直接 merge，把握不好，先 rebase 把粒度调整好了，再 merge。 let var const 区别12345678910111213141516let 的「创建」过程被提升了，但是初始化没有提升。let在未定义之前使用，会报错var 的「创建」和「初始化」都被提升了。function 的「创建」「初始化」和「赋值」都被提升了。let 声明的变量的作用域是块级的；let 不能重复声明已存在的变量；let 有暂时死区，不会被提升。for( let i = 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域for( let i = 0; i&lt; 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。 js链接 闭包链接 闭包就是能够读取其他函数内部变量的函数。 闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。 在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 最大用处有两个，一是可以读取函数内部的变量，（创建局部变量，保护局部变量不会被访问和修改）。另一个就是让这些变量的值始终保持在内存中。 闭包常见用途： 创建特权方法用于访问控制事件处理程序及回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let add=(function(){let now=0;return { doAdd:function(){ now++; console.log(now);}}})()add.doAdd() //1add.doAdd() //2add.doAdd() //3now 这个变量，并没有随着函数的执行完毕而被回收，而是继续保存在内存里面。由于 add 里面有函数是依赖于 now 这个变量。所以 now 不会被销毁，回收。由于 now 在外面访问不到 var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()());// 由于方法里有this.name, 这里的this的是window，所以这里是The Windowvar name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getNameFunc : function(){ var that = this; return function(){ return that.name; }; } }; alert(object.getNameFunc()()); // 这里的that指向object 判断是否为数组12345if(typeof Array.isArray===&quot;undefined&quot;){ Array.isArray = function(arg){ return Object.prototype.toString.call(arg)===&quot;[object Array]&quot; };} 找出数组中的最大值1234567891011//第一种方法var a=[1,2,3,6,5,4];var max=Math.max.apply(null,a);console.log(max);//第二种方法var a=[1,2,3,6,5,4];var max=eval('Math.max('+a.toString()+')');console.log(max);Math.max(...[-1, 5, 11, 3]) Math.max.apply(Math, [-1, 5, 11, 3]) Javascript的this用法链接链接2 1234567this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window 问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢? 用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针! 也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法 123456789101112131415161718192021222324252627282930313233343536373839404142var a = 1;var obj = { a: 2, test: function() { setTimeout(function(){ console.log(this.a); }.bind(this), 0); }};obj.test(); // 2// setTimeout不止两个参数setTimeout(function(a, b){ console.log(a); // 3 console.log(b); // 4},0, 3, 4);箭头函数比较特殊，没有自己的this，它使用封闭执行上下文(函数或是global)的 this 值。var x=11;var obj={ x:22, say:()=&gt;{ console.log(this.x); //this指向window }}obj.say();// 11obj.say.call({x:13}) // 11x = 14obj.say() // 14//对比一下var obj2={ x:22, say() { console.log(this.x); //this指向window }}obj2.say();// 22obj2.say.call({x:13}) // 13 一、纯粹的函数调用 属于全局性调用，因此this就代表全局对象Global在严格模式下，默认绑定会将 this 指向 undefined 二、作为对象方法的调用 this就指这个上级对象三 作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。 四 apply调用 this指的就是这第一个参数。 apply()的参数为空时，默认调用全局对象。 五 this指向绑定事件的dom元素document.querySelector(“#id”).onclick =function(){ this == document.querySelector(“#id”)} 12345678910if(!(&quot;a&quot; in window)){ var a = 10;}console.log(a); // undefined// window.hasOwnProperty(&quot;a&quot;) === true ..//不用多说了. a 还真存在原型链上// 值是 Location 这个 API 的数据 1234567891011var count = 0;console.log(typeof count === &quot;number&quot;); // true , 这个不用解释了console.log(!!typeof count === &quot;number&quot;); // false// 这里涉及到就是优先级和布尔值的问题// typeof count 就是字符串&quot;number&quot;// !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true// 最后才=== 比较 , true === &quot;number&quot; , return false 123456789101112131415161718192021222324(function(){ var a = b = 3;})()console.log(typeof a === &quot;undefined&quot;); // falseconsole.log(typeof b === &quot;undefined&quot;); // false// 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(=号自左向右)// 那个函数可以拆成这样(function() var a; /* 局部变量,外部没法访问*/ b = 3; /* 全局变量,so . window.b === 3 , 外部可以访问到*/ a = b;})()// 注意a只有在闭包里才能访问(a=3)，在外部是undefined !!!!!!!!!!!!!!!!!// 若是改成这样,这道题应该是对的console.log(typeof b === &quot;number&quot; &amp;&amp; b ===3); // true 123456789101112131415161718192021function foo(something){ this.a = something;}var obj1 = { foo:foo};var obj2 = {};obj1.foo(2)console.log(obj1.a) // 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 windowobj1.foo.call(obj2,3); // 用 call 强行改变上下文为 obj2内console.log(obj2.a); // 3var bar = new obj1.foo(4); // 这里产生了一个实例console.log(obj1.a); // 2console.log(bar.a); // 4; new的绑定比隐式和显式绑定优先级更高 Q: 设计模式你了解多少1http://www.cnblogs.com/tugenhua0707/p/5198407.html Q: JS 的基本数据类型有哪些12345678910111213141516ObjectUndefinedNullNumberBooleanStringSymbol (ECMAScript 6 新定义) 5 种原始类型即 Undefined Null Number Boolean String 除了Object和Symbol不是，其他都是 Q: null 和 undefined 的差异12345678910111213大体说一下,想要知其所以然请引擎搜索相同点:在 if 判断语句中,值都默认为 false大体上两者都是代表 无 ,具体看差异差异:null 转为数字类型值为0,而 undefined 转为数字类型为 NaN(Not a Number)undefined 是代表调用一个值而该值却没有赋值,这时候默认则为 undefinednull 是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)设置为 null 的变量或者对象会被内存收集器回收 Q: 清除浮动的方式有哪些?比较好的是哪一种123456789101112131415161718192021222324252627282930313233常用的一般为三种 .clearfix , clear:both , overflow:hidden ;.clearfix:after { font-size: 0; content:&quot;&quot;;//设置内容为空 height:0;//高度为0 line-height:0;//行高为0 display:block;//将文本转为块级元素 visibility:hidden;//将元素隐藏 clear:both//清除浮动}另一种写法.clearfix:before, .clearfix:after { content:&quot;&quot;; display:table;}.clearfix:after{ clear:both; overflow:hidden;}.clearfix{ zoom:1;// 为了兼容IE}&lt;!--用display:table 是为了避免外边距margin重叠导致的margin塌陷,内部元素默认会成为 table-cell 单元格的形式--&gt;clear:both :若是用在同一个容器内相邻元素上,那是贼好的...有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷overflow:hidden :这种若是用在同个容器内,可以形成 BFC 避免浮动造成的元素塌陷 Q: 跨域问题详情 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859我一般用这三种, cors , nginx反向代理 , jsonpjsonp : 单纯的 get 一些数据,局限性很大...就是利用script标签的src属性来实现跨域。浏览器支持好调用失败不会返回各种HTTP状态码给后端传json格式的数据会报415错误，请求格式不正确callback添加恶意script标签，造成xss漏洞只能够实现get请求参数可见nginx 反向代理 : 主要就是用了 nginx.conf 内的 proxy_pass http://xxx.xxx.xxx,会把所有请求代理到那个域名,有利也有弊吧..cors可控性较强,需要前后端都设置,兼容性 IE10+ ,CORS需要浏览器和服务器同时支持。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。比如Access-Control-Allow-Origin: http://foo.example // 子域乃至整个域名或所有域名是否允许访问Access-Control-Allow-Methods: POST, GET, OPTIONS // 允许那些行为方法Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // 允许的头部字段Access-Control-Max-Age: 86400 // 有效期cros 的配置不仅仅这些,还有其他一些,具体引擎吧....若是我们要用 nginx 或者 express 配置 cors 应该怎么搞起? 来个简易版本的nginxlocation / { # 检查域名后缀 add_header Access-Control-Allow-Origin xx.xx.com; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type; add_header Access-Control-Max-Age 86400;}express, 当然这货也有一些别人封装好的 cors 中间件,操作性更强...let express = require('express'); let app = express(); //设置所有请求的头部app.all('*', (req, res, next) =&gt; { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); next(); });有些还会跟你死磕,,除了这些还有其他姿势么...我说了一个HTML5的 postMessage ......因为真心没用过,只是以前查阅的时候了解了下..只能大体点下这货用于 iframe 传递消息居多, 大体有这么两步步window 打开一个实例,传递一个消息到一个x域名x 域名下监听 message 事件,获取传递的消息这货的兼容性没那么好,而且没考虑周全的下容易遭受 CSRF 攻击 Q: 对于XSS 和 CSRF 如何防范12345678910111213141516171819202122232425262728293031323334353637383940414243444546 XSS主要是指跨脚本攻击, 其实就相当于执行js脚本.XSS的防范1. 验证用户输入的内容, 是否符合规则.2. 转义 &lt;&gt; 造成代码直接运行的的标签.. 轮询或者正则替换而面试官说这种的效率最低下,找相关资料若是有用到 cookie ,设置为 http-only ,避免客户端的篡改CSP(Content Security Policy)以白名单的机制对网站加载或执行的资源起作用。在网页中，这样的策略通过 HTTP 头信息或者 meta元素定义。CSP虽然提供了强大的安全保护，但是他也造成了如下问题：Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本。CSRF跨域假冒请求有3个特性: 跨域, cookie, 请求方式.CSRF的防范一般这几种验证码,用户体验虽然不好,验证 HTTP Referer 字段,判断请求来源token加密解密 ,前端和后台双方协定一个token内容尽量使用JSON类型传输 form 传输的格式为: Content-Type: application/x-www-form-urlencoded 而,JSON的传输类型为: Content-Type: application/json form 没有办法去模仿JSON类型进行传输DNS劫持, 事实上更偏向于User developer实际上对这个也无能为力。HTTP(ISP) 劫持 使用HTTPS 加密方式传输 替换你的js的提供商，使用HTTPS路径进行加载。验证码造成的体验不好,token 滥用造成的性能问题,轮询替换造成的响应时间等 Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么链接 promise 是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。 好处异步操作队列化，比传统的异步操作回调函数和事件更合理更强大。 能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 ==Promise对象三种状态：== Pending（进行中）Fulfilled（已完成，又称为Resolved）Rejectd（已失败） 一些需要注意的小点,如下 在 Pending 转为另外两种之一的状态时候,状态不可在改变.. Promise 的 then 为异步.而( new Promise() )构造函数内为同步 Promise 的 catch 不能捕获任意情况的错误(比如 then 里面的 setTimout 内手动抛出一个 Error ) Promise 的 resolve 若是传入值而非函数,会发生值穿透的现象 Promise 还有一些自带的方法,比如 race , all ,前者有任一一个解析完毕就返回,后者所有解析完毕返回… ==Promise 方法：== then： 用链式调用的方式执行回调函数。通过 resolve 方法把 Promise 的状态置为完成态（Resolved），这时 then 方法就能捕捉到变化，并执行“成功”情况的回调。then方法返回的是一个新的Promise实例 reject： 把 Promise 的状态置为已失败（Rejected），这时 then 方法执行“失败”情况的回调 catch：和 then 的第二个参数一样，用来指定 reject 的回调 当执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么也不会报错卡死 js，而是会进到这个 catch 方法中。 all: 提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。 当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。 当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。 race:只要有一个异步操作执行完毕，就立刻执行 then 回调。注意：其它没有执行完毕的异步操作仍然会继续执行，而不是停止。 Promise对象两个特点 对象状态只由异步操作结果决定。resolve方法会使Promise对象由pendding状态变为fulfilled状态；reject方法或者异常会使得Promise对象由pendding状态变为rejected状态。Promise状态变化只有上图这两条路径。 对象状态一旦改变，任何时候都能得到这个结果。 即状态一旦进入fulfilled或者rejected，promise便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。 Promise构造方法接受一个方法作为参数，该方法传入两个参数，resolve和reject。 resolve用来将Promise对象的状态置为成功，并将异步操作结果value作为参数传给成功回调函数。 reject用来将Promise对象的状态置为失败，并将异步操作错误error作为参数传给失败回调函数。 then方法绑定两个回调函数，第一个用来处理Promise成功状态，第二个用来处理Promise失败状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Promise 和 ajax 没有直接关系. promise 只是为了解决&quot;回调地狱&quot;Promise 并不能消灭回调地狱，但是它可以使回调变得可控。异步回调的问题：嵌套层次深，难以维护无法正常使用return和catch throw多个回调之间难以建立联系，一个回调函数一旦开启，就无法对其操作无法正常索引堆栈信息从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。var promise = new Promise(function(resolve, reject) { // ... some code if ( /* 异步操作成功 */ ) { resolve(value); } else { reject(error); }});promise.then(function(value) { // success}, function(error) { // failure});模拟回调函数function runAsync(callback){ setTimeout(function(){ console.log('执行完成'); callback('随便什么数据'); }, 2000);}runAsync(function(data){ console.log(data);});getUserAdmin() .then(getProjects) .then(getModules) .then(getInterfaces) .then(procResult) Promise 必知必会（十道题）链接 123456789101112```# Generator 函数[链接](https://cnodejs.org/topic/542953d42ca9451e1bf3c251)Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态 function* helloWorldGenerator() { yield ‘hello’; yield ‘world’; return ‘ending’;}var hw = helloWorldGenerator(); const gen = function* () { const f1 = yield readFile(‘/etc/fstab’); const f2 = yield readFile(‘/etc/shells’); console.log(f1.toString()); console.log(f2.toString());};写成async函数，就是下面这样。 const asyncReadFile = async function () { const f1 = await readFile(‘/etc/fstab’); const f2 = await readFile(‘/etc/shells’); console.log(f1.toString()); console.log(f2.toString());};一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 上面已经介绍了说yield是暂停标志，下面对yield进行一些介绍： （1）、yield后面的表达式只有当调用next时，才会执行yield后面的表达式。 （2）、yield表达式只能写在Generator函数中 ，而不能写在普通的函数中。 （3）、yield表达式如果与其他表达式相结合，必须写在()里面。 yield与return的异同点： 相同点：都可以返回紧跟后面表达式的值 不同点：(a)、在一个函数内部只能存在一个return语句，而可以存在多个yield语句；(b)、return没有记忆功能，在Generator函数中只有当遍历器对象调用next时 才会返回yield后面表达式的值， 当下一次调用时从上一条yield语句后开始执行， 而return后面的表达式只要函数执行就立即返回。(c)、正常函数只有一个返回值，而Generator函数可以有多个返回值。 Generator函数被执行时，返回的是指向函数内部的遍历器对象，只有调用遍历器对象的next方法时，才会返回yield后面函数表达式的值，但是，其实yield表达式的值一直都是undefined。如果在Generator的函数中传递参数且存在多个yield表达式时，那么调用next方法时就要注意传参了：next()中传递的参数就是上一个yield表达式的返回值。 1234567# 面试题网站[链接](http://www.bslxx.com)# 作用域 函数和变量的可访问范围。作用域分为全局作用域 函数作用域和eval作用域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 原型[链接](https://www.jianshu.com/p/dee9f8b14771)原型其实就是上述所说的继承中的父类。原型链 :利用原型串起一个继承链，让一个引用类型继承另一个引用类型的属性和方法，再以此类推下去.当一个引用类型继承另一个引用类型的属性和方法时候就会产生一个原型连。当某个函数当成构造函数来调用时，就会产生一个构造函数的实例。这个实例上会拥有一个 __proto__ 属性，这个属性指向该实例的构造函数的原型对象(也可以称为该实例的原型对象)。定律：每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性原型链是依赖于__proto__，而不是prototype**实例与原型**当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。 var A = new Person(); Person.prototype = A;原型对象（Person.prototype）是 构造函数（Person）的一个实例。↓#### Person.prototype.constructor == Person#### person1.__proto__ == Person.prototype实例的构造函数属性（constructor）指向构造函数。↓#### person1.constructor == Person#### Object.prototype.__proto__ === null#### person.constructor === Person.prototype.constructor == Person#### obj.__proto__ == Object.getPrototypeOf(obj) 原型和原型链是JS实现继承的一种模型。原型链的形成是真正是靠__proto__ 而非prototype## 什么是原型链 由于__proto__是任何对象都有的属性，而js里万物皆对象， 所以会形成一条__proto__连起来的链条，递归访问__proto__最终到头，并且值是null 当js引擎查找对象属性时，先查找对象本身是否存在该属性， 如果不存在，会在原型链上查找，但不会查找自身的prototype var A = function(){}; var a = new A(); console.log(a.__proto__); //A {}（即构造器function A 的原型对象） console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象） console.log(a.__proto__.__proto__.__proto__); //null 123# 目录 actionsassetscomponentsreducersstoreviewsindex.js 123# prototype问题 function Foo() { getName = function () { alert (1); }; return this;}Foo.getName = function () { alert (2);};Foo.prototype.getName = function () { alert (3);};var getName = function () { alert (4);};function getName() { alert (5);} //请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); //答案：Foo.getName();//2getName();//4Foo().getName();//1getName();//1new Foo.getName();//2new Foo().getName();//3new new Foo().getName();//3 123# var和函数的提前声明 function fn(a) { console.log(a); var a = 2; function a() {} console.log(a);} fn(1); 输出：function a() {} 2 我们知道var和function是会提前声明的，而且function是优先于var声明的（如果同时存在的话），所以提前声明后输出的a是个function，然后代码往下执行a进行重新赋值了，故第二次输出是2。 http://www.cnblogs.com/zichi/p/4359786.html 12345# javascript实现将多个有序数组合并为一个有序数组的算法[链接](https://segmentfault.com/a/1190000010302469) let ret=arr.reduce((arr1,arr2)=&gt;arr1.concat(arr2)).sort((a,b)=&gt;a-b);ret=Array.from(new Set(ret));console.log(ret); 123# new操作符具体干了什么呢 1、创建一个新对象2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）3、执行构造函数中的代码（为这个新对象添加属性）4、返回新对象 var obj = {};obj.proto = Base.prototype;Base.call(obj); 创建一个新对象foo； 并将它的proto__指向其构造函数的prototype，foo.__proto = Foo.prototype; 动态将this指向新对象，Foo.apply(foo，arguments); 执行函数体中的代码； 放回新对象foo; 12345# 怎么画一条0.5px的边[链接：](https://juejin.im/post/5ab65f40f265da2384408a95) 可以通过直接设置宽高border为0.5px、设置box-shadow的垂直方向的偏移量为0.5px、借助线性渐变linear-gradient、使用transform: scaleY(0.5)的方法，使用SVG的方法。最后发现transfrom scale/svg的方法兼容性和效果都是最好的，svg可以支持复杂的图形，所以在viewport是1的情况下，可以使用transform/SVG画0.5px，而如果viewport的缩放比例不是1的话，那么直接画1px即可。 .hairline-border { box-shadow: 0 0 0 1px;}@media (min-resolution: 2dppx) { .hairline-border { box-shadow: 0 0 0 0.5px; }}@media (min-resolution: 3dppx) { .hairline-border { box-shadow: 0 0 0 0.33333333px; }}@media (min-resolution: 4dppx) { .hairline-border { box-shadow: 0 0 0 0.25px; }} 12345# 从 arguments 到剩余参数如果你想在 ES5 中让函数(或方法)接受任意数量的参数，必须使用特殊变量 arguments： function logAllArguments() { for (var i=0; i &lt; arguments.length; i++) { console.log(arguments[i]); }} ES6 中则可以通过 … 运算符定义一个剩余参数(在下面示例中是args)： function logAllArguments(…args) { for (const arg of args) { console.log(arg); }} 如果有一部分固定参数，剩余参数就更适用了： function format(pattern, …args) { ···} 在 ES5 中处理同样的事情有点麻烦： function format(pattern) { var args = [].slice.call(arguments, 1); ···} 123456789101112131415161718192021# 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)[连接](https://github.com/qiu-deqing/FE-interview#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BB%A5http%E4%B8%BA%E4%BE%8B)1. 输入url2. 查看缓存3. 解析URL4. 组装HTTP请求报文5. 获取主机ip6. 建立tcp连接7. 发送http请求8. 服务器检查请求头信息9. 响应报文通过tcp返回10. 关闭tcp四次握手11. 检查状态码12. 缓存13. 解码14. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本15. 显示页面 在浏览器地址栏输入URL浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤如果资源未缓存，发起新请求如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期HTTP1.1增加了Cache-Control: max-age,值为以秒为单位的最大新鲜时间浏览器解析URL获取协议，主机，端口，path浏览器组装一个HTTP（GET）请求报文浏览器获取主机ip地址，过程如下：浏览器缓存本机缓存hosts文件路由器缓存ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样）打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口服务器发回SYN=1， ACK=X+1， Seq=Y的响应包客户端发送ACK=Y+1， Seq=ZTCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作服务器将响应报文通过TCP连接发送回浏览器浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：主动方发送Fin=1， Ack=Z， Seq= X报文被动方发送ACK=X+1， Seq=Z报文被动方发送Fin=1， ACK=X， Seq=Y报文主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同如果资源可缓存，进行缓存对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释构建DOM树：Tokenizing：根据HTML规范将字符流解析为标记Lexing：词法分析将标记转换为对象并定义属性和规则DOM construction：根据HTML标记关系将对象组成DOM树解析过程中遇到图片、样式表、js文件，启动下载构建CSSOM树：Tokenizing：字符流转换为标记流Node：根据标记创建节点CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树:从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none对每一个可见节点，找到恰当的CSSOM规则并应用发布可视节点的内容和计算样式js解析如下：浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()浏览器在Document对象上触发DOMContentLoaded事件此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件显示页面（HTML解析过程中会逐步显示页面） 浏览器渲染主要流程HTML解析出DOM TreeCSS解析出Style Rules将二者关联生成Render TreeLayout 根据Render Tree计算每个节点的信息Painting 根据计算好的信息绘制整个页面 12345# Q: 网站性能优化[原文](https://segmentfault.com/a/1190000013963213#articleHeader0) 代码层面优化： 一、加载和执行 css方面 将样式表放到页面顶部 不使用CSS表达式 使用link不使用@import 不使用IE的Filter Javascript方面 将脚本放到页面底部,body标签内底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 合并一些小图片( css sprite )压缩图片 图片转dataUrl 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 图片编码优化 二、 数据存取 - 尽量使用字面量和局部变量 （局部变量在方法运行过后会自行释放，用完手动置为null或undefined也行）， 减少使用对象和数组, 三、 DOM编程**（常见的性能瓶颈） - 最坏的方式就是在循环中操作或者访问DOM，非常消耗性能。 减少DOM数量 - 遍历dom querySelectorAll()是获取元素最快的API 返回的是一个NodeList querySelector() 返回的是element, querySelectorAll()还有一点就是可以同时获取两类元素 - 重绘和重排都是代价昂贵；尽量减少 重排何时发生： 1.添加或删除可见DOM元素 2.元素位置改变 3.元素尺寸改变（内外边距、边框厚宽高等） 4.内容改变 （内容导致尺寸变化的时候） 5.页面渲染器初始化 6.浏览器窗口尺寸变化 四、 算法和流程控制 - 循环 (当循环体复杂度为X时，优化方案优先减少循环体的复杂度， 循环体复杂度大于X时，优化方案优先减少迭代次数 ) - 条件语句 当条件较少时 使用if-else更易读， 而当条件较多时if-else性能负担比switch大，易读性也没switch好。 优化if-else的方法是：尽可能的把可能出现的条件放在首位， 五、 字符串和正则表达式 - 字符串 join是比较快的，也是大量字符串拼接的唯一高效方式 六、 快速响应的用户界面 - 浏览器UI线程 浏览器限制JavaScript任务的运行时间，限制两分钟， 可以防止恶意代码不断执行来锁定你的浏览器 单个JavaScript操作的花费总时间应该小于等于100ms， 这就意味着在100ms内响应用户的操作，不然就会让用户感受到迟钝感 - 定时器让出时间片断 使用时间戳计算获得程序运行时间， 以便快速找到运行时间较长的代码部分进行优化 七、 Ajax - 数据传输 数据的传输同样影响性能 - 数据格式 - Ajax性能 避免不必要的请求： 使Ajax可缓存：服务端设置HTTP头信息确保响应会被浏览器缓存 客户端讲获取的信息存到本地避免再次请求 （localstorage sessionstorage cookice） 设置HTTP头信息，expiresgaosu告诉浏览器缓存多久 减少HTTP请求，合并css、js、图片资源文件等或使用MXHR 通过次要文件用Ajax获取可缩短页面加载时间 减小cookie大小 引入资源的域名不要包含cookie 八、编程实践 - 避免双重求值 eval()、Function慎用， 定时器第一个参数建议函数而不是字符串都能避免字符串双重求值 - 使用对象或者数组直接量 - 避免重复工作 A:延迟加载（懒加载） B:条件预加载 - 使用JavaScript速度快的部分 A.位操作 B.原生方法，首先原生方法是最快的，而且浏览器会缓存部分原生方法 C.复杂计算时多使用Math对象 D.querySelector和querySelectorAll是查询最快的 九、 构建并部署高性能JavaScript应用 1.合并多个js文件 2.预处理js文件 3.js压缩 4.js的HTTP压缩 5.缓存js文件 6.处理缓存问题 7.使用内容分发网络（CDN） 移动方面 保证组件小于25k Pack Components into a Multipart Document content方面 按需加载资源 非必须组件延迟加载 未来所需组件预加载 在网站 HTML 中的链接属性上增加 rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记。 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 Server方面 使用CDN 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。 方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询 避免重定向：多余的中间访问 用dns-prefetch &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//mat1.gtimg.com&quot;&gt; 动静分离 使用nginx的反向代理，对静态资源的请求直接nginx处理，或放到CDN 动态请求转发给tomcat处理 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 Brotli 是一个比较新的文件压缩算法，目前正变得越来越受欢迎。 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 十、 工具 若是打包的代码尽可能切割成多个 chunk ,减少单一 chunk 过大 HTTP的缓存头使用的合理 减小第三方库的依赖 对于代码应该考虑性能来编写,比如使用 requestAnimationFrame 绘制动画,尽可能减少页面重绘(DOM 改变) 渐进升级,引入 preload 这些预加载资源 看情况用 server worker 来缓存资源(比如移动端打算搞 PWA) 比如从服务端着手: 带宽,域名解析, 多域名解析等 使用负载均衡方案 多节点部署 页面做服务端渲染,减小对浏览器的依赖(不用客户端解析) 渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度) 当然,这是这些都是很片面的点到...实际工作中去开展要复杂的多; 使用索引加速数据库查询 页面静态化CMS 多个维度考虑,优化 DOM 绘制时间,资源加载时间,域名解析这些; 要全面的优化一个项目是一个大工程… 123# 优雅降级和渐进增强 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。针对不同版本的hack为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验 123# js控制css3动画 开始事件 AnimationStart结束事件 AnimationEnd重复运动事件 AnimationIteration 每次开始动画迭代都触发animationiteration W3c标准：animationstart animationiteration animationendWebkit：webkitAnimationStart webkitAnimationIteration webkitAnimationEndFirefox：animationstart animationiteration animationendOpera：animationstart animationiteration animationendIE10：MSAnimationStart MSAnimationIteration MSAnimationEnd var e = document.getElementById(“left1”); e.addEventListener(“animationend”, function() { alert(‘css3运动结束！’);}); 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Object循环key- for...in循环：只遍历对象自身的和继承的可枚举的属性。 通常用for in来遍历对象的键名 for in更适合遍历对象，不要使用for in遍历数组。for in 循环会把数组其他扩展方法也循环- for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引namefor-of循环是遍历实现iterator接口的成员只要是一个对象部署了Symbol.interator接口，就可以用for...of遍历该对象，同时也可以调用该接口的Symbol.interator方法调用next()方法对对象进行遍历，不同的是for..of是对该对象的值的输出，而next()返回的是对象。在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。- Object.keys()：返回对象自身的所有可枚举的属性的键名。- JSON.stringify()：只串行化对象自身的可枚举的属性。- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。- ==for...in循环出的是key，for...of循环出的是value==- ==for...of不能循环普通的对象，需要通过和Object.keys()搭配使用==-如果实在想用for...of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组然后遍历：## 结论1. 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。2. for...in循环出的是key，for...of循环出的是value3. 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足4. for...of不能循环普通的对象，需要通过和Object.keys()搭配使用记忆jueqiao :已核对 偶数vin h（k）对象 o 数组 value 如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组然后遍历： var student={ name:’wujunchuan’, age:22, locate:{ country:’china’, city:’xiamen’, school:’XMUT’ }}for(var key of Object.keys(student)){ //使用Object.keys()方法获取对象key的数组 console.log(key+”: “+student[key]);} for in 可以遍历到myObject的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性 for (var key in myObject) { if（myObject.hasOwnProperty(key)){ console.log(key); }}","link":"/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"},{"title":"清新冥想","text":"[TOC] 第一节–初识冥想冥想练习的特点冥想与任何组织宗教无关，适用于每个人作用: 能够缓解压力，缓解焦虑，改善睡眠，提高工作效率，与身边的人和事建立更好的联系等 容易上手 轻松掌握简洁有效，每天只需十分钟 冥想的原理是什么，通过什么发挥作用 答案是正念 什么是”正念”通过专注，激发心灵的力量 今心为念，活在当下的心就是念。 与之相对的，还有两种状态: 活在昨天和活在明天,是引发负面情绪的根源 活在昨天会想起对时间的荒废，与他人的争执，学习和工作的不顺，从而感到沮丧和后悔 活在明天会尝试规划未来，设想许多还没发生的事，小到家长里短，大到国家大事，倍感压力焦虑 如果心总在过去和未来之间摇摆，就会忽视最重要的当下 正念要做的就是通过刻意的引导，帮你的注意力凝聚起来，把内心从过去和未来的拉扯中解脱出来，回归当下，而不是逃避现实 在冥想的经典练习中，正念呼吸最容易掌握 正念呼吸的练习要点想象自己处于一个安静，不会被打扰的地方找一个有靠背的地方坐下 现在闭上你的双眼，挺直上身，轻轻抬起头由下至上用心感受你的腿部，臀部，腰部，背部慢慢的你会感觉到肌肉的酸痛这是正常的现象因为痛是感知我们身体的主要方式， 将注意力集中到鼻子让我们开始做几次深呼吸 让自己沉浸在此时此刻深吸一口气然后深深呼气反复呼吸几次让你现在的紧张感得到完全的释放 当你变的平静就让呼吸回到普通状态 保持自然的呼吸不要试图去改变呼吸的节奏把注意力附属在你的呼吸上顺着空气进入你的身体 感受身体哪个部位最强烈可能是上下起伏的腹部或者肺部也可能是冷的或热的空气经过鼻腔 把注意力放在你身体感觉最强烈的部位并把全部注意力放在那里 跟随你的呼吸一直到每一次吸气的末端 当吸气结束的时候再一路跟随呼气，直到结束 你可能会出现走神受到一些关于过去和未来想法的干扰开始不由自主的评判和思考没有关系 当你意识到自己走神时不需要评价这样是好是坏 只需要将注意力再转移到呼吸上 可以通过计数方式吸气数一，呼气数二一吸气，二呼气 请按自己喜欢的节奏呼吸一段时间仔细观察每一段的呼吸的长度变化，力度变化 感受呼吸如何带动身体 现在花一点时间来留意一下身体的感觉请放松心情 不要刻意评判这次练习的效果因为这会为你增添新的负担 练习就是最好的学习 当你继续冥想学习不仅练习本身会变得越来越简单压力和焦虑也会逐渐消失 本次练习已接近尾声把注意力回到你所处的环境 轻轻活动你的手指，脚趾舒展身体慢慢的睁开眼睛 祝贺你，你已经成功的完成了一次冥想练习 在过去的十分钟里掌握了正念的核心思想-专注当下通过呼吸练习的方式完成了对身体的感知和对注意力的操控 第二节 冥想的本质当下指的是此时此刻，注意力需要集中的地方 怎样才算“专注当下”全神贯注，把注意力集中到正在做的事情上。拒绝一心多用 人并不总是活在当下，走神是我们的常态 导致走神的三大原因发达的感官接收大量不需要的信息丰富的联想产生源源不断的杂念 –联想偶尔会带来灵感，但会耗费精力，占据时间，明明没有偷懒，手头上的事却没做多少为了逃避压力，通过发呆放空自己 –通过放空缓解压力，只是自我安慰，发呆的同时时间在流逝，最后工作还要做 今后在遇到这种情况，不要自责只需要将注意力拉回到当前在做的事情上 冥想练习的本质冥想练习所做的，就是反复将注意力从其他地方拽回当下。因此冥想可以融入到日常生活中，无时不刻的练习。 练习是最好的学习 第三节 乔布斯与冥想乔布斯的冥想过程集中注意力，让思想平静 思想不会轻易平静，需要耐心等待 当平静到来，直觉就会变得灵敏，看到更加广阔的世界 专注当下的好处远离浮躁，进入平静的内心状态激活直觉，获得更加灵敏的感知洞察细节，通过信息差决定成败 心怀感恩欲望持续膨胀，一味索取只会在打到目标后获得短暂的幸福，更多时间陷入了了求而不得的痛苦和焦虑当中。 意识到并重视我们已经拥有的一切，内心的充盈与知足，同样会带来平静和幸福。 第四节 复习课 正念的基本概念 冥想练习的特点 正念呼吸的要点 专注当下的深处含义 分心走神的三个原因 冥想是一种生活方式 乔布斯的冥想过程 1 专注当下的重要性 2 为什么要心怀感恩 第五节 情绪调整情绪的特点情绪的产生不适一蹴而就，而是逐渐积累情绪的维持依赖于真实存在的事物情绪会自发趋于平稳 如何调整情绪找到引发情绪的原因用更积极的视角看待让注意力与情绪隔离 把情绪当成无关的念头，注意力集中在有意义的事情，可以大大降低情绪对生活的影响，等空闲下来再慢慢找原因 冥想练习对情绪调整的帮助通过灵敏的感知，精确找到情绪波动的原因强化对注意力的控制有效的隔离以避免负面情绪的扩大 第六节 冥想与禅什么是禅早在先秦时代，中国人就掌握了通过静坐锻炼思维、生发智慧的方法，但没有命名 佛教传入中国后，将这种训练称为禅 禅是超越宗教范围的顿悟与创见 禅修对冥想的帮助提升冥想练习的效果更好的将专注当下的态度融入生活为看清自我和改变生活打下思想基础 禅心与初心禅心没有含义，怀有禅心是为了对内心与自身存在产生惊奇，并通过发掘本心回应惊奇 初心是初学者的心，要随时准备好去接受、去怀疑，对所有的可能性敞开 第七节 掌控杂念呼吸的意义每个人都是一扇敞开的门一呼一吸穿门而过，就会觉察到自我呼吸是内心世界与外部世界的交汇处 关于掌控杂念想要清除杂念，是因为担心被杂念干扰心绪 越想清除杂念，就会在杂念中越陷越深 最好的掌控方式就是不掌控，“无为而治”自由来去的杂念并不会扰乱心绪 真正的混乱之源是对杂念的掌控欲和企图心 自由是杂念的自由，而不是意识的自由 第八节 期待与收获期望与收获往往有落差庐山烟雨浙江潮，未至千般恨不消。到得还来别无事，庐山烟雨浙江潮。 曾经的朝思暮想，成真时往往变成”不过如此”如果不能正确对待，这种落差就会削弱我们练习的积极性，让我们无法坚持冥想 收获不如期待怎么办不忘初心: 永远像初学者一样谦虚且开放 回忆小时候对长高的渴望 佛性与开悟 不做评判: 像对待杂念一样，忽视功利心 滴水穿石，厚积薄发 见山是山，见水是水见山不是山，见水不是水见山是山，见水是水 第九节 避免兴奋收获超出期待未必是件好事因为我们会产生兴奋和骄傲 如果不刻意的排除这两种情绪，之后的冥想练习就会逐渐向错误的方向偏离 为什么要尽量避免兴奋兴奋会让情绪波动 心绪波动是我们持之以恒练习冥想的最大阻碍 对于冥想本身的兴趣不是真正的兴趣，冥想的目的是激发对自己日常生活的兴趣 第十节 冥想的方向什么是修行中最重要的事最重要的不是努力，而是找到一个正确的方向 如果你的努力指向不正确的方向，付出的努力往往就是白忙一场 冥想的正确方向是什么通常在做一件事情时，人们是有目的的，想要有所成就，得到某种结果 冥想的正确方向是”无目的”, 可以明确事情的目的，但不执著于目的。 为什么不要骄傲人的惯性思维是有目的，想要做到无目的，就需要改变思维方式，每当因达到目的而产生情绪波动时，及时察觉并予以打断。 在所有的情绪中，目的性最强的就是骄傲 我们不会无缘无故的骄傲，一定是因为做到来了某些事情，达到了某些目的，证明了自我，才会产生骄傲。 用淡淡的喜悦取代骄傲 第十一节 不要惧怕失去这世上的一切都早已存在，并将继续存在下去。 我们从未真正意义的拥有什么，所有也就不存在真正意义上的失去。 所有的得与失，只是其他存在与我们狭窄的视线恰巧发生了交错，看到时被我们误以为拥有，看不到时又被我们误以为失去。 如果我们不去看，就不会有任何的事物从我们的目光中消失. 第十二节 复习课第八节回顾第九节回顾第十节回顾第十一节回顾 第十三节 关于沟通关于沟通沟通是探索自我的准备工作 沟通包括两个部分: 表达自我和倾听他人 良好的表达和倾听是相辅相成的 如何进行良好的沟通表达自我时需要做到坦诚，情绪稳定和有亲和力 倾听他人时要注意把所有的成见和主观意见摆在一边，不要进行太多善与恶、对与错的价值判断 第十四节 亲子沟通父母与子女间的沟通最常见的沟通问题，往往发生在最亲密的关系之间 父母对子女只有善意，但姿态却总是高高在上 对于父母的叮嘱，子女天然抱有抵触情绪 由于是最亲密的人，父母和子女间的沟通往往是不加掩饰的，因而会有丰富的个人情感浸透在表达中 最真实的爱是沟通的基础良好的沟通需要保持最自然的状态，表达自己最真实的感受 父母和子女之间，无论进行怎样的沟通，底层的感受一定是彼此的爱，因此不要吝啬对爱的表达 哪怕你暂时还学不会沟通技巧，不擅长倾听，只要能够把内心最真实的感受及时的传达，同样可以改善沟通 第十五节 努力的意义“风停见花落，鸟鸣觉山静。”在事情的样貌发生改变之前，我们通常意识不到它真正的样子。冥想练习也是如此。专注于呼吸的时候，你的心会完全静下来，感受不到任何东西，你只是坐着。但你从练习中得到的静，却会在接下来的日常生活中发挥激励作用。 努力的意义，在于努力本身 很多人把生活当成农民种地的过程，先播种，再耕作，经过漫长的等待和不懈的努力，最后获得丰收，这其实是对生活的一种误解。 如果你把自己的努力定义成种地，把收获定义成丰收，那生活就只有漫长的等待和收获时短暂的快乐，你会错过每一天劳动时与自然的亲切相处，专注耕作时内心的平静，对自己的觉察，技能的熟练与提升，以及生活充实而带来的满足感。 第十六节 习惯的力量奇葩的小习惯才是成功秘诀？经过科学家的研究发现，多次执行一套相同的动作和准备程序，确实可以使大脑和身体自我调整，进入执行工作的最佳状态。 习惯本身就是力量 如果你能够确定一个固定的时间段，坚持每天进行十分钟的呼吸练习，即便是冥想本身的思想还没有充分掌握，单单这个习惯本身就会为你带来大量的帮助。 第十七节 精神的三个部分“自我”的概念是难以捉摸的每个人都有很多面，有坏脾气的时候，有温柔的时候，有特别开心的时候，也有无缘无故感到抑郁和沮丧的时候。 真正的自我，到底是内心的幽暗处发出声音的那个人，还是对生活充满热爱的那个人呢？如果每一面都是真实的自我，这些矛盾的存在又如何融合在一起呢？ 弗洛伊德将人的精神分为三个部分：本我，自我和超我本我即原我，是指原始的自己，包含生存所需的基本欲望、冲动和生命力。本我是一切心理能量之源，本我按快乐原则行事，它不理会社会道德、外在的行为规范，它唯一的要求是获得快乐，避免痛苦，本我的目标非常简单，就是追求个体的舒适，生存及繁殖。 第十八节 何为超我什么是超我？超我是人格系统中专管道德的司法部门。它由人的道德律法和自我理想等构成，可简单区分为“理想”、“良心”两个层次。其中“理想”中既包括自我理想，又包括社会理想。 自己理想中想要成为的人，以及社会主流价值观所认可的英雄人物、道德楷模的形象，会汇总融合成为一套个体为自己所设的行为价值标准，而超我就是负责监督我们按照这套标准行事的人格。 超我会不停的劝导我们表现的更加成熟，更加善良，追求卓越。当本我产生违反道德或社会秩序的欲望和冲动时，超我就会让这些冲动生成罪恶感和内疚，从而抑制本我。 第十九节 自我的作用自我处于社会生活的现实要求、超我的道德追求与本我的利益追求之间，按照现实原则协调矛盾，尽可能地寻找权宜之计。 通俗一点来说，无论是本我还是超我，都只是提供建议，自我才是个体最终行为表现的决策者，时而管理本我，时而服从超我，既要尽量满足本我的欲望，又要顾及到超我的道德准则。 第二十节 自我的本质自我，就像水一样把自我比做是水。水倒在不同的杯子里面，它就是不同的形状。而我们的生活和思考，就是把水从一个杯子转移到另一个杯子。你能够感知到的，呈现出来的，自己每时每刻表现出来的行为，就是水在杯子中形成形状的过程。 自我是什么如果水的大部分时间，就是从一个杯子转移到另一个杯子，那水就是一团不停的转移，不停改变形状的东西。自我也是如此。不同的角度，有不同的解释，但存在一种最贴切的表达：如果我们一切的想法都是围绕生活展开的，那自我就是不停的体验、思考，活在当下的那个意识。这就是为什么，冥想并不鼓励大家去定义自我，而是鼓励大家发现和探索自我。只有不断的体验、思考、感受生活，自我才得以展开，呈现出不同的样子。 第二十一节 梦的来源(1)梦的来源 —— 记忆人们所经历、体会过的东西，是构成梦的全部原材料。记忆与梦境的联系并不是简单的重复回播，往往会通过夸大和拼接的方式呈现，把记忆中的片段变成一个新的场景或故事。 容易出现在梦境中的记忆 —— 遗忘记忆遗忘记忆，指的就是人在梦里往往能够知道并记起一些清醒状态时所不晓或者忘却的事。这些事在梦境中出现时，不会被当成是自身已有的知识或经历，这让我们感到一头雾水，以为这是梦中自己想象或者创造出来的事物。 第二十二节 梦的来源(2)童年记忆梦有一种奇妙的力量，即便是孩童时代里，那些久远的已经被我们的记忆遗失在阴暗角落里的东西，梦也能够把它们召回，重现在我们的脑海中。 梦不但能够将一些深藏的童年经历挖掘出来，还能保持那些特定的人物、事件和场景分毫不变，保持它们最鲜活最生动的原始状态。 里程碑事件的小细节在梦境中，成为焦点的往往是重要事件里旁枝末节、甚至是最空洞无物的东西。那些被我们热切渴望、倾注了浓厚兴趣的事物在梦中的戏份并不多，相反，一次偶然的邂逅、不太重要的见闻或是零零碎碎的一点事物，往往成为梦中元素的真正来源。 第二十三节 梦的来源(3)梦是一种应激反应一定是我们先受到了某种刺激，才会根据这种刺激产生相对应的梦境。举个例子的话，我们的梦境就像是一个餐厅的厨师做饭：记忆是各种各样的食材，而受到的刺激就是客人点餐时下的订单，厨师先收到订单，再会决定选取哪些食材，进行怎样的加工。 外部的知觉刺激所谓知觉刺激，就是通过外界对身体感官形成的刺激。比如一道刺眼的强光、强烈的噪音、浓烈的气味，或者身体某个部位露出被子时感受到寒冷。这种刺激能够非常明确的引发对应的梦境：当窗外公鸡报晓，梦中也许就会听到某个人在惊声尖叫。 第二十四节 梦的来源(4)幻想刺激幻想刺激，指的就是我们躺在床上，闭上眼后脑海中浮现的各种画面。如果这些被我们想象出来的画面一直维持到入睡的前一刻，它们就很有可能继续保持自己的样子，与梦境相结合。 身体内部的刺激当某些器官处于兴奋状态或生病时，就会传递出类似疼痛的信号。与清醒时的状态相比，睡眠时的心灵对躯体所发生的变化有着更为深入而广泛的感知，接纳身体各部位的信号以及身体变化产生的感受，并通过影响梦境的方式呈现出来。 深度思考刺激日有所思，夜有所梦。如果我们在生活、学习和工作中，对某些事物的思考专注深刻，那么这种思考就很有可能渗透到潜意识当中，即便我们入睡，思考也不会停止。这种潜意识的思考不仅会体现在梦中，甚至会比清醒时更有创造力，解决那些没能解决的问题。 第二十五节 关于梦的记忆冥想对于解决难题的益处冥想练习能够帮助我们专注当下，产生更多的深度思考。深度思考刺激可以将我们的思维延续到梦境，比清醒时刻更有创造力，从而解决棘手的难题。 关于梦的记忆通过回忆，梦可以被重新记起来。可我们总会有这样的感觉：夜里的梦包罗万象、多姿多彩，比我们能回想起来的部分要丰富得多。而且，随着时间的流逝，我们关于梦的记忆还会逐渐淡去 关于梦的记忆，有些深刻、有些模糊、有些则被完全遗忘，但总的来说，我们可以确认一点：相比起清醒时刻的记忆，关于梦的记忆我们有着更加强烈的遗忘趋势，而这种遗忘的趋势无法被我们自己所掌控，我们无法选择自己希望记住的梦和不想记住的梦。 第二十六节 对梦的遗忘哪些原因导致了我们对梦境的遗忘？第一点：在同一时间内，我们能够观察和接收信息的数量是非常有限的。 你可以把梦境理解为屏幕上的一幅图像，醒来的一瞬间，屏幕会在我们眼前闪过，然后瞬间黑屏。由于第一时间我们的视角只能集中于图像上的某一部分，我们能够记住的梦境也只有一部分。 第二点：大脑记忆事物是需要重复巩固的，而大部分的梦境都是独一无二，难以重温的体验。 第三点：大脑不擅长记忆没有联系的内容，而大多数梦不会表现的井井有条，往往是天马行空。 第二十七节 梦境中的思维特征梦境中的思维特征第一个特征，指的是梦境具有一种清醒时候不具备的能力，那就是把全部的想法都用幻想出来的画面和场景展现。或者说，用幻觉取代了思维活动。 在梦境当中，所有的观念都会转变为幻觉，用类似于戏剧化的方式呈现出来，我们不是导演和评论家，而是演员和观众。 第二个特征，就是梦境中我们不会带有任何成见。不论是多么荒谬的，真实世界中绝无可能发生的事情，都有可能在梦中出现，并且被我们泰然自若的接受。 第二十八节 梦的意义(1)梦存在的意义是什么在生活中，自我会参考超我和本我的感受，从而作出决定。这意味着只要我们保持清醒，道德和欲望就无时不刻影响着自我。将隐蔽的本性揭示在我们面前就是梦存在的最大意义。 这种本性并非我们当下的真实面目，而是让我们看到在一种别样的生存方式下，我们有可能成为的样子。 第二十九节 梦的意义(2)突破性进步通常情况下，我们进步的过程都是非常局限的，因为我们自己心里有一杆秤，会先判断什么是好的，什么是对的，什么是有道德的，什么是让我们开心的。换句话说，本我和超我会指引我们进步的方向，但同时也限制我们只能向一个方向前进。梦能够将人最真实的本性展现出来，让我们窥探到自己内心最私密的东西，也让我们得以绕开本我和超我的局限，实现突破性的进步。 拓展视野当人在梦中实现了自然状态的回归，尽情展现着自我的本能。随着心灵逐渐摆脱了已知观念的束缚，我们就能够从这个世界自然真实的一面获取更多的启发。在对事物的一切处理上，梦的本质反映出了我们自身更真实的一面，这一面的丰富程度超出了我们在清醒生活中通过观察、思考和学习了解到的全部。梦境通过真实的力量，让我们看到更广阔的世界。 第三十节 复习课梦的来源人们所经历、体会过的东西，是构成梦的原材料。梦境不会让记忆重复上演，但往往会通过夸大和拼接的方式呈现，把记忆中的片段变成一个新的场景或故事。所有记忆都可能出现在梦境中，相对而言，有三类记忆出现的次数最多：遗忘记忆、童年记忆、和我们经历过的重要事件中不起眼的小细节。 催生梦境的刺激外界对感官形成的刺激、我们躺在床上，闭上眼后脑海中浮现的各种画面、身体器官传递出的信号、清醒时候的深度思考，都会引发对应的梦境 为什么会遗忘梦境1、 在同一时间内，我们能够观察和接收信息的数量是非常有限的，而关于梦的记忆是瞬间的大量信息。2、 大脑记忆事物是需要重复巩固的，而大部分的梦境都是独一无二，难以重温的体验。3、 大脑不擅长记忆没有联系的内容，而大多数梦不会表现的井井有条，往往是天马行空。 梦境的思维特征梦境能够把全部的想法都用幻想出来的画面和场景展现，而且不会带有任何成见。不论是多么荒谬的，真实世界中绝无可能发生的事情，都有可能在梦中出现，并且被我们泰然自若的接受。正因如此，梦境才会将隐蔽的本性揭示在我们面前，让我们窥探到自己内心最私密的东西，也让我们得以绕开本我和超我的局限，实现突破性的进步。通过真实的力量，让我们看到更广阔的世界。 第三十一节 人的需求（1）何为欲望准确来说，欲望就是由人的本性产生的，想达到某种目的的需求。我们可以通过马斯洛的需求层次理论来拆分欲望。 生理需求生理需求是人们最原始、最基本的需要。它是最强烈的不可避免的最底层需要，也是推动人们行动的强大动力。但当一个人的生理需求没有得到满足时，其他一切需要均退居次要地位。 安全需求安全需求指的是人们对于自身安全的追求。包括人身安全、身体健康、稳定的收入、稳定的社会关系和工作等等。安全需求比生理需求更高一级，当人的生理需求得到满足以后，安全需求就会显现。 第三十二节 人的需求（2）社交需求社交需求又叫归属与爱的需要，是指我们每个人对家庭、集体、朋友、同事的关怀、爱护和理解的渴望。在生活中最令我们感到美好的友情、信任、温暖和爱情，都属于社交需求的范畴。 尊重需求尊重需求包含内部尊重和外部尊重两种。内部尊重指的是人对于自己的评价和要求，希望自己具备较强的能力和道德，在各种不同环境中都能够适应挑战、充满信心、独立自主。外部尊重是指人们渴望自己拥有一个体面且受到承认的社会地位，有一定的威信，自己的个人能力和取得的成就能够得到他人的认可、尊重、信赖和赞誉。 第三十三节 人的需求（3）认知需求认知需求，指的是人对自身和周围世界的探索、理解以及解决疑难问题的渴望。人类文明能有今天这么惊人的发展，很大程度上就是得益于认知需求的推动。当我们解决了温饱，拥有了爱情和友情，受到了尊重，发展科学技术，探索世界就会成为我们新的目标。 审美需求“爱美之心人皆有之”，每个人都喜欢欣赏美的事物，无论是美丽的面孔、壮丽的风景、还是艺术家的杰作。 自我实现需求自我实现需求是最高等级的需要，指的是人们会竭尽所能，使自己趋于完美，实现自己的理想和目标，获得成就感。自我实现需求最大的特点是我们不再把目光集中在外界，而是回归自我，不再执着于达成某种目的，生活本身就成为了最大的目的。 第三十四节 择偶的意义择偶行为是社会生活的中心想要在行为层面上更好的理解欲望，需要在所有的社会活动中找到一个最广泛、最重要、最便于理解的行为，没有哪种行为能够像寻找伴侣一样，驱动着我们需求的方方面面。 爱情是社交需求的重要组成部分，情感关系的稳定性影响到我们的安全需求，和伴侣的彼此尊重和学习满足了认知需求和尊重需求，美好和谐的家庭有助于人的自我实现。可以说，几乎每一层次的需求，都离不开与伴侣的相处。 如果男性能够了解女性的诉求，女性能够代入男性的视角，性别差异带来的沟通代沟就会得到缓解。 第三十五节 择偶偏好是男生不用心，还是女生太挑剔在两性关系中，之所以女性对细节有更多要求，背后原因要追溯到上古时代。在如今这个发达的社会当中，人们的生活追求是丰富且复杂的，爱情也被赋予了浓厚的人文意义。但是，在生活贫瘠，尚未开化的年代里，人和世界上大部分生命一样，只有两种简单明确的诉求：生存和繁衍。 没有崇高的爱情，也缺乏完善的社会背景，在那个年代里，择偶行为是完全围绕繁衍展开的。想要孕育一个生命，男性只需要很小的成本，而女性却需要承受接近一年的孕期，这是一项不可推卸的、消耗巨大的投资。 正因如此，女性必须在选择伴侣时严格把关，注重细节。因为一旦做出了选择，几乎就是赌上了自己的一生。随着科学技术的发展，生育已经是可以控制的事情。人们选择伴侣也不再是只为了繁衍，甚至还有丁克家庭的出现。但祖祖代代千百年来形成的心理特征，早已融入了本能当中，不会轻易的从我们身上抹去。 第三十六节 两种能力、三个特征两种天生的能力女性在选择伴侣时，天然具备两种能力。第一种能力是从男性的成千上万种差异中，筛选出最具价值的少数特征。知道观察一个人的时候要重点关注哪些方面。第二种能力是把关键的特征与自己的个人需要和独特境况结合进行分析。 三类关键特征女性关注的关键特征主要分为三类：资源、潜力和生活基础。 资源指的是一个男性在当下获取和控制社会资源的能力，这种能力由经济实力、社会地位和合适的年龄共同组成。 对经济实力的适度关注，并不是拜金主义或者攀附权贵，而是对自己和未来生活负责的本能行为。 第三十七节 社会地位与年龄偏好看重社会地位的原因社会地位和经济实力具有较强的相关性。社会地位更高的人普遍拥有更多财富，对经济实力的追求也会折射在社会地位之中。 社会地位象征着一个人是否被社会主流的价值观所承认。选择社会地位高的男性作为伴侣，其实就相当于征求了整个社会的意见，能够有效的降低做出错误判断的概率。 年龄偏好与背后的复杂思考表面上看，大叔和小鲜肉都很受女生的欢迎，年龄似乎不会影响男性的魅力。但这种喜爱，更类似于粉丝对于偶像的追捧，或是对于少数几个特征的偏好。根据心理学权威戴维巴斯教授的研究，真正到了组建家庭，敲定人生大事的时候，大部分女性倾向于选择比自己大三岁半左右的男性作为伴侣。 这种本能偏好的背后，其实是多种因素权衡取舍后的综合考虑：男性的年龄越大，社会地位和经济实力就越强，但发展潜力则越来越少，如果过于年长，沟通上会有代沟，夫妻二人携手共度的时光也会更短。 第三十八节 潜力偏好与潜力相关的特征潜力由三个特征共同组成：分别是勤奋、情绪稳定性与才华。如果说经济实力和社会地位代表了当下掌控的资源，那么一个勤奋、情绪稳定且才华横溢的人，即便当前身无分文，也没有较高的社会地位，也会因为能够在未来长期的、持续的获取资源，同样获得女性的偏爱。 从长期来看，自认为工作努力，才华横溢，并且得到周围人认可的个体，比起其他人获得了更高的教育水平，拥有更高的年收入，并且预期会有更多的升职机会。 如果生活是一场没有变数的竞争，那么只依靠努力与才华出众就足够了。但人生总是充满了变数，保持稳定，拥抱变化的能力同样很重要，这就是情绪稳定性的作用。 情商的全称叫做情绪商数，跟情绪稳定性是非常类似的概念。情商高形容的并不是“会说话，会看人脸色办事”，而是指能够快速适应生活的各种变化，能够在承受压力的情况下保持常态。 第三十九节 生活基础偏好与生活基础相关的特征生活基础由四个具体的特征共同组成，分别是和谐共处、体格、健康和对爱的承诺。 和谐相处，意味着性格互补、思想相似。互补的性格能够降低伴侣间发生争吵的概率，思想的相似意味着类似的生活习惯、爱好，还能确保在人生的长远追求上保持一致。 良好的体格和健康，既满足了审美需求，也照顾了安全需求。 对爱的承诺也非常重要。如果男性不能下定决心建立长期关系，他的条件再好，对于女性来说也有可能是竹篮打水一场空。这就是为什么会有求婚这个环节，而且还要用昂贵的婚戒来为这份承诺增添分量。 在你意识不到的地方，本能也会思考在择偶时，我们并不会刻意去围绕这些复杂的因素逐一思考。但潜意识中无法直接感知到的心理活动会本能地进行判断，并通过情绪的方式直接传递结果。 这部分无法感知的自我，是探索自我之旅非常重要的研究对象。 第四十节 两性的择偶差异女性对男性的改变从繁衍本能的角度出发，男性对于择偶的要求并不复杂，因为最理想的策略并不是寻找最合适的伴侣，承诺爱情和相伴终生，而是和尽可能多的女性保持亲密关系。数量比质量更重要，那么也就谈不上要筛选伴侣。 男性之所以变得“专一”，一方面是人不止会根据本能思考，另一方面，是因为女性不仅要求男性有资源、有潜力，还要求他对爱情进行承诺。专一的男性会更受欢迎，能够把自己专一的基因遗传下来。 第四十一节 年轻、健康与忠诚判断健康的方式在医学不发达的上古时代，只能通过观察外部特征来判断健康情况。外部特征主要有两种，一种是行为特征，比如活泼的性格、走路时轻快的步伐。另一种是身体特征，比如丰满的嘴唇、明亮的肤色、光滑的皮肤、清澈的眼神、富有光泽的头发和匀称的肌肉。这些能够体现健康的象征，恰恰也是我们在审美时的偏好。 爱美之心，人皆有之。从根源上来说，最初的美，就是能够反映健康状态的身体特征。当我们觉得一个人好看的时候，其实是本能通过自己的判断，认可了对方的健康状况。 第四十二节 复习课择偶偏好的起源生命的两个基本诉求是生存和繁衍，择偶行为是由繁衍诉求衍生出来的。为了在择偶时做出正确的判断，需要从人的成千上万种差异中，筛选出最具价值的少数特征，这些特征就是择偶偏好。 这种偏好不需要刻意思考，而是通过潜意识中无法直接感知到的心理活动进行判断，并通过情绪的方式直接传递结果。 女性的择偶偏好生育需要女性进行巨大的投入，需要伴侣给予充足的资源支持，因此女性的择偶偏好是围绕“资源”展开的。 女性关注的关键特征主要分为三类：资源、潜力和生活基础。 资源指的是一个男性在当下获取和控制社会资源的能力，这种能力由经济实力、社会地位和合适的年龄共同组成。 潜力指的是在未来长期、持续获取资源的能力，这种能力由三个特征共同组成：分别是勤奋、情绪稳定性与才华。 资源带来的生活条件的保证只是基础，人与人之间的相处是否愉悦、能否培养深厚的感情也很重要。因此，除了资源和潜力，还需要生活基础。生活基础由四个具体的特征共同组成，分别是和谐共处、体格、健康和对爱的承诺。 男性的择偶偏好女性很少会担心男性缺乏生育能力，择偶主要是为了找到可靠的，能够承担起父亲责任的伴侣；而男性择偶，首先要找到具备生育能力的伴侣。因此，男性的择偶偏好是围绕“生育能力”展开的。 男性关注的关键特征主要分为三类：健康、年轻和忠诚。 第四十三节 何为潜意识什么是潜意识潜意识是一个心理学的专业词汇，潜是潜在、潜力的潜，最早由弗洛伊德提出，指的是人类心理活动中，不能认知或没有认知到的部分，是人们“已经发生，但没有体现在意识中的心理活动过程”。 弗洛伊德把潜意识具体分为了两个部分，一部分叫前意识，一部分叫无意识。前意识属于潜意识里有可能进入意识的部分；而无意识属于绝对无法感知到的那部分意识。 在弗洛伊德的心理学理论中，无意识、前意识和意识是三个层次不同，但又相互联系的系统结构。 第四十四节 潜意识的短期影响潜意识的短期影响潜意识对生活的影响，可以从短期和长期两个角度来看。所谓短期影响，就是即时发生的，对我们行为的引导。 择偶偏好就是一种：潜意识会根据本能的择偶偏好，影响我们看待他人的方式。比如，哪怕对一个人还不了解的时候，有些人你会一见钟情，产生天然的好感，而有些人没有得罪过你，你却打心底里就想要和他保持距离。 第四十五节 潜意识的长期影响潜意识的长期影响 —— 均值回归均值回归是一个与股票相关的概念。它的意思是：从短期来看，一个公司的股价会有波动，会有大幅度的涨和跌，难以预测，但把时间尺度放到五年十年，甚至更久，这个公司的真实价值是多少，股价就会稳定在什么水平。 如果不考虑非同寻常的好运或者厄运，人的一生，其实也是均值回归的过程。只从局部上看，决定人生走向的，是竞争的结果和我们选择的路径。但随着时间的推移，人终究会回到自己的均值。那个均值就是你的潜意识，是你内心最深处的冲动，是你到底是一个什么样的人。 人生最重要的事情就是如何清楚地认识自己：我的性格如何，我有什么优缺点，我喜欢做什么工作，我喜欢什么样的生活方式。我的梦想是改变世界，获得尊敬，还是住在一个有山有水的地方，每天遛狗、做饭、和朋友打打牌、陪自己的家人。 不是智商和情商，而是潜意识中的那个真实的自我，决定了你愿意为什么奋斗，决定了你对一份事业的热情和责任心，把自己放在什么样的位置是舒服的。而这些因素，最终决定了你的人生。 第四十六节 大象与骑象人进一步探索自我 —— 关于幸福幸福是我们所有人的追求目标，却在不同的人心中有不同的定义。在接下来的课程中，我们会通过十个主题的展开，从浮躁喧嚣的环境中抽离出来，看清自己的本心。你认为幸福是什么，它就是什么。 第一个主题 —— 大象与骑象人假设人的心理分为不同的两部分：我们能感知到的自我是一个骑在大象背上的人，而不能被感知到的自我，就是大象本身。骑象人手里握着缰绳，可以指挥大象转弯、停止或是前进。需要注意的是，当大象没有自己的想法时，我们才可以指挥。一旦大象真的想要做什么，它就会自顾自的走。 第四十七节 大象的本质心理的两套运行机制自我是一个由大象和骑象人共同组成的复杂组织。组织的内部包含了各种不同的角色，心灵和身体、理性和感性，以及左脑和右脑。经过了多年的研究和分析，心理学家们把两两对立的元素统一起来，将人的心理分成了两套运作机制：主动控制和自动化处理。 大象 —— 自动化处理大部分的心理活动会在我们没有意识到的时候自动发生，并对身体产生实质性的影响。这种自动化处理的机制，又被称为潜意识。由于意识不到，这种自动化处理的机制不够理智，但和一次只能思考一两件事情的骑象人比起来，大象的优势就是可以同时处理大量任务。 第四十八节 人象冲突(1)为什么杰出的人是少数骑象人代表了有意识的、主动控制后的思考。大象包含我们内心的感觉、本能反应、情绪和直觉，代表了自动化的心理活动。大象和骑象人各有优势，只要配合良好，就成组成一个杰出的个体。但是，在大部分人的心中，大象和骑象人之间会产生复杂的冲突，很难形成一个良好的整体。 人象冲突 —— 当下与未来骑象人目光长远，而大象只盯着当下。如果骑象人不能控制大象，人就会为了微不足道的短期利益而放弃未来更好的发展机会。 第四十九节 人象冲突(2)人象冲突 —— 心理活动的循环当骑象人产生一个目标，并且大象也愿意执行时，大象就会分出一部分精力用于检查目标的完成情况并加以协助，直到确认完成才停止。这种合作模式在完成实际行动时非常合适，但应用在心理活动时就很容易陷入死循环。 以消除杂念为例：如果骑象人的目标是消除杂念，那么大象也会开始自动检查杂念是否消除。每当骑象人把杂念清除，大象就会把杂念再拽回来，看看消除的是不是它。你越是想要清除杂念，大象就越卖力的检查，杂念反而在脑海里生根发芽。 第五十节 人象冲突(3)人象冲突 —— 骑象人的解释误区我们能感知到的自我，产生的思考和意识，都是以骑象人的身份进行的。这会让我们形成一种刻板的印象：误以为我们的所有观点、情感和行为，都是骑象人先进行思考，再传达给大象。 但事实并非如此。很多时候，是大象自己做出了决定。骑象人所做的并不是决定，而是想办法拼凑出一些语句和道理来解释自己的所作所为。 如果我们总是试图用理性来解释自己的所作所为，就会在遇到那些根本无法解释的内心冲动时陷入迷茫；或者在每一次立下誓言却无法坚持的时候质疑自己的虚伪和软弱。 第五十一节 大象很聪明大象很“聪明”人和象的博弈看上去很像理性与感性，人性与兽性的对抗，但事实并非如此。大象不等同于不理性的自我，只是它的理性无法被直接感知。 心理学家通过实验发现：屏幕上飞速闪过的、无法被我们意识到的词语，依然对我们产生了影响。这说明，骑象人无法感知的细节，可以被大象感知，而且大象具备一定的认知能力。 能够通过感官观察世界，进行思考的，不只有被我们感知到的意识，还有一个敏感且聪明的大象。这就是为什么，我们的情绪总是会没有道理、莫名其妙的改变。而从另一个角度来看，想要改善自己的心情，不能只靠把事情想通，外部环境的细节也很重要。 第五十二节 对幸福的理解对幸福的三种常见理解在一部分人的心中，幸福的样子是很具体的。他们把幸福与物质绑定起来，对获得财富抱有极大的热情，坚信最大的幸福来自于获得自己想要的身外之物。 在另一部分人的心中，幸福不是庸俗的物质，而是精神上的财富。比如他人的认可、较高的社会地位、真挚的友情，美满的家庭。 还有人认为，追求身外之物，或强求世事如自己所愿，最后都是一场空。真正的幸福只能来自于自己的内心，断除对身外之物的执着，对身边的一切都采取平和接受的态度。 第五十三节 调整预期提升幸福感的技巧 —— 调整预期保持进展，能够把长期目标带来的短暂幸福，变成一步一步前进的兴奋和满足。是一种锦上添花、扩大幸福的方式。但是，生活中不只有好事，难免还会遇到些厄运降临。想要提升幸福感，除了锦上添花，还需要雪中送炭，这时候就需要调整预期。 人对于当下处境的看待方式，高度取决于他对生活的心理预期。每个人都有自己羡慕的对象，但同样，每个人都被别人羡慕着。改变生活很难，但调整预期只需要我们换个角度。如果我们能够做到“羡慕自己“，幸福就会随之降临。 第五十四节 对生命的理解你认为生命本身是什么，它就是什么”“没有事实，只有感受。”世界是客观的，但你所理解的生活，你看到的事实，都是客观存在经过自己思考加工后才形成的。 意义是我们自己赋予的，这意味着我们也有改变意义的权力和能力，明确这一点，我们就能够明白一颗强大内心的重要：除非你觉得悲惨，否则没有什么是悲惨的；同理，除非你知足常乐，否则没有什么事能让你快乐。 生活本身没有任何枷锁，是悲观的解读方式建造了内心的牢笼。因此，改变预期并不只是一种技巧，究其根源，是一种更加广阔、更加包容的看待世界和生活的态度。 第五十五节 幸福方程式幸福由何组成自弗洛伊德以来，心理学界的主流观点认为，人的个性主要受童年时期环境的影响。20世纪90年代，研究人员又在有关幸福的研究中发现：一个人快乐与否、性格如何，其实与基因的关系密切，与后天环境则不太相关。 人的幸福，究竟是先天决定，还是后天形成？为了回答这些疑问，积极心理学的开创人塞利格曼组织了专家研究小组，经过了长期的观察和实验，得出了幸福方程式。 幸福方程式幸福方程式：H=S+C+V。先天的幸福指数、所处环境的生活条件和看待生活的态度，这三者共同决定了我们真正感知到的幸福。这说明幸福不全是天生的，我们对幸福的追求并不是徒劳。但在追求的过程中，光注重物质，改善生活条件是不行的；只改变态度也是不行的，要尽量兼顾这两者才可以。 第五十六节 影响幸福感的因素(1)值得改变的外部因素 —— 噪声生活条件是无数外部因素共同组成的，在众多因素之中，有五点容易被忽视，却能显著影响生活。 居住环境的噪声就是其中之一：研究显示，无论过了多久，人都无法做到完全适应噪声干扰。甚至有研究显示，人有时为了适应噪声，认知功能会因而受损。各式各样、间歇出现的噪声都会干扰我们的注意力，增加我们的压力。 值得改变的外部因素 —— 通勤时间很多人为了住大一点儿的房子，宁愿住到离公司较远的地方。但大房子带来的快乐是短暂的，随着预期提高，人很快就能适应空间变大的好处。但无论是自己开车的塞车之苦，还是一路挤地铁，长时间通勤的痛苦却是持续的，通勤时间的延长还意味着要牺牲睡眠和休息时间。 第五十七节 影响幸福感的因素(2)值得改变的外部因素 —— 掌控感居住环境的噪音，和漫长的通勤时间，有一个重要的共同点，那就是这两项因素之所以让人恼火，是因为我们无法控制它们。通过实验发现，如果人们认为自己可以控制噪声，这个想法就会让他们觉得噪声没那么烦人。 因此，增强自己对生活的掌控感，是提升活力和快乐的一大利器。哪怕是遇到了艰巨的挑战，也要认真规划，拆解成能够掌握的小任务。 值得改变的外部因素 —— 天然的缺陷人们有一个共识，那就是人要扬长避短，与其把精力集中在改善缺点，不如强化自己的优势，更容易在社会中取得成功。但想要追求幸福感，查漏补缺的优先级就要更高。哪怕是看似肤浅的改变，只要能掩饰自己的天然缺陷，就能立竿见影的让人感到更自信，更快乐。 第五十八节 建立良好人际关系值得改变的外部因素 —— 人际关系人是社会动物。因此在影响一个人幸福与否的所有外在因素中，最重要的因素，正是人际关系的好坏及多寡。如果处于不和谐的人际关系中，就算我们没看到对方，两人之间的冲突也还是会萦绕在脑海中，持续伤害着我们的情绪，每天都会持续，让人和幸福感远离。 建立良好人际关系的两个原则第一条原则，是要主动。随着人类社会的发展，一个人能建立的社交网络变得越来越庞大，这意味着朋友间的常态并不是相聚，而是疏离。疏离久了，你或许就会对友情产生怀疑，如果没能及时的缓解，这种怀疑就有可能成为永久的误会，友情也就不复存在。 第二条原则，是不要追求公平。人际关系不能量化，也就不可能像数学中的等式那样，用一个等号来连接两个人。在人与人的交往中，付出本身就是一种快乐，只有这样理解友情，你的内心才能平和的容纳他人。 第五十九节 逆境的好处(1)逆境的正面效应健康心理学方面的研究一度把重点放在逆境和压力所造成的负面影响上，并把生活中遭遇的苦难作为失去幸福的主要原因。但随着社会发展和生活环境的进步研究人员开始探讨巨大压力可能为人们带来哪些好处，也就是“创伤后成长”。 逆境中获益 —— 激发潜藏力量一旦你能挺身面对人生的挑战，便可激发自己原本潜藏的能力，而这些能力会改变我们原本对自我秉持的观念。如果你遭受了以前不能想象的苦难，但最终挺过来了，你就会发现我们其实比自己以为的更坚强，而这种认知会给自己带来信心，以面对未来的挑战。 第六十节 逆境的好处(2)逆境中获益 —— 改善人际关系逆境就像是一个漏斗，让我们知道谁是酒肉朋友，谁是可以患难与共的好友。除此之外，逆境还会强化人际关系，让我们打开心扉。我们会对自己关心的人表现出爱意，而在患难时关心我们的人，我们会对其心存爱心与感激。 逆境中获益 —— 重新审视人生创伤能够改变你对人生追求、对当下和对他人的看法，让你想清楚，到底什么才是最重要的事情。人们总是把名利看得比自身还重要，对于已经拥有的东西都视为理所当然，不知珍惜。但生命受到重大威胁时，人往往会幡然醒悟，这种思维上的转变，能够帮助人们用更积极更知足的态度来面对自己的处境。 第六十一节 复习课知识点回顾大象与骑象人：人有两套心理运行机制，骑象人代表了有意识的、主动控制后的思考。大象包含我们内心的感觉、本能反应、情绪和直觉，代表了自动化的心理活动。大象和骑象人各有优势，只要配合良好，就成组成一个杰出的个体。 人象之间主要的三种冲突：当下与未来、心理活动的循环、骑象人的解释误区。人和象的博弈看上去很像理性与感性，人性与兽性的对抗，但大象不等同于不理性的自我，骑象人无法感知的细节可以被大象感知，而且大象具备一定的认知能力。 提升幸福感的两个技巧：保持前进和调整预期。保持前进，指的是把远大的理想分解成一些可以完成，取得进展的小目标，每朝目标前进一步，就能够源源不断的感到兴奋和满足。改变预期不只是一种技巧，究其根源，是一种更加广阔、更加包容的看待世界和生活的态度。 幸福方程式：先天的幸福指数、所处环境的生活条件和看待生活的态度，这三者共同决定了我们真正感知到的幸福。 容易被忽视，却能显著影响生活的外部因素：噪声、通勤时间、掌控感、天然缺陷和人际关系。 逆境对于幸福的正面效应：激发潜藏力量、改善人际关系、重新审视人生。 第六十二节 关于学习的误区(1)关于学习的误区 —— 一万小时定律最近几年，1万小时定律这个概念非常热门：只要把一个技能重复练习，练习时间超过一万小时，就一定成为这个行业的专家。这种认识非常片面，因为投入的时间只是基础，如果没有掌握正确的学习方法，投入再多时间，也只能达到熟练，而不能精通。 研究表明，一旦某个人的表现达到了熟练水平，并且可以做到自动化，那么，即使再多“练习”几年，也不会有什么进步。 第六十三节 关于学习的误区(2)关于学习的误区 —— 高估天赋的作用人们通常以为，某个人在任何特定行业或领域内的潜力，不可避免地受到天生才能的限制，只有依靠天生就具有的一些固定潜力才能成就杰出。但事实上，潜力不只是天生的，它还能通过我们一生中经历的各种各样的事情来创造。只要善于学习，我们可以创造自己的潜力。 在我们当下这个时代，许多人拥有着超常的能力，那些能力胜过人类历史上任何时代的人。显然，人的身体构造没有变化，并不是因为现代人的基因有巨大改变，比上世纪的人更有天赋，而是人们更善于学习了。 第六十四节 有目的的学习(1)有目的学习的特点 —— 目标定义明确没有目标的练习：每天都要练习。有目标的练习：每天都要练习三个小时有明确目标的练习：把练习曲连续弹奏三次，期间不犯任何错误，并且保持适当的速度。 所谓明确的目标，就是指你能够在学习的过程中，根据这个目标对自己进行评价，判断自己是否成功的达成了这个目标。 有目的学习的特点 —— 保持专注提高专注度最常用的方式是隔离干扰源。比如寻找安静的学习场所、打开手机的勿扰模式、关闭网络。除此之外，还可以通过一些有仪式感的动作和行为进行心理暗示，帮助自己进入到专注状态。比如学习之前给自己鼓鼓掌，喝一杯咖啡，或者进行一次冥想呼吸练习。 有目的学习的特点 —— 要有反馈在学习的过程中，你必须知道某件事情自己做得对不对，如果不对，你到底怎么错了。如果你清楚自己是在哪一个环节出问题，就可以围绕这个环节进行针对性的练习。如果你知道自己实现目标的进度，就可以灵活的调整学习计划。 第六十五节 有目的的学习(2)有目的学习的特点 —— 要走出舒适区走出舒适区，是有目的的练习最为重要的一个组成部分。所谓舒适区，指的就是那些不太费力，很容易就能想到，并且一定可以做到的事情。 走出舒适区有两种方式：第一种是做很有难度，挑战自己极限的事情，第二种是尝试自己没做过的事情。前者最需要的是决心，而后者更需要的是创意。 大家可以多问自己两个问题：1、你有没有达到自己的极限。2、你有没有尝试新的练习方法？如果两个问题的答案都是否定的，就需要提醒自己要走出舒适区。 第六十六节 心理表征是什么心理表征是什么就是指我们了解的某个物体、某个观点、某些信息或者其它任何事物在思维中对应的样子。心理表征可以是具体的视觉形象，也可以是抽象的概念。 有效学习的本质就是建立高质量的心理表征一个领域的专家，和普通人最大的区别，就是前者通过多年的有效练习，针对本行业或领域中自己可能遇到的各种不同局面，创建了高度复杂和精细的表征，这些表征使他们能够做出更快更准确的决策，并在特定的局面上更有效地应对。 第六十七节 心理表征的作用(1)心理表征有助于寻找规律细分来说，心理表征对规律的把握具体表现有两种，第一种是预测未来。优秀球员可以通过少量细节把球场上发生的事情与记忆库中丰富的心理表征进行匹配，如果能够匹配成功，他就可以预判这件事接下来的走向，从而提前做好应对。 第二种是归纳和分类。以攀岩为例。攀岩者在攀爬时，会遇到不同的把手，这些把手要求采用各种不同的握法，如果在把手上运用了错误的抓握方法，就有很大可能从墙上掉下来。 没有经验的攀岩者，必须边爬边想，遇到每个把手都要识别和判断适合哪种抓握方法。而经验丰富的攀岩者在对各种把手建立心理表征时，会按照握法分类，再把同一种握法对应的把手归纳到同一组。他们在攀爬时就可以使用心理表征轻松做出决策。 第六十八节 心理表征的作用（2）心理表征有助于解释信息在学习的过程中，我们会接受海量的信息。心理表征的一个重要好处在于，可以帮助我们高效的理解信息，并把它保存在记忆之中，组织它、分析它，并用它来决策。 如果你只是认识汉字，而没有对应的心理表征，那你在阅读的时候，只会看到不同的汉字毫无意义的随机排布，根本无法进行任何的理解。 如果建立了相关的心理表征，当我们看到“猫”这个字的时候，就会将这个汉字与它的发音联系到一起，并与我们常见到的一种小小的、长毛的、会发出“喵喵”叫声、通常与狗无法和谐相处的动物联系起来，从而理解这个字。 心理表征对于解释信息的帮助无处不在，国际象棋高手可以看懂棋谱，职业音乐家可以看懂一首新曲子的乐谱，程序员能够理解复杂对代码，也是这样的道理。 第六十九节 心理表征的作用（3）心理表征有助于组织信息理解和解释信息需要借助心理表征。但理解只是基础，音乐家不光要会读乐谱，还要能够根据乐谱做出带有自己风格的演绎，甚至要自己作曲，这时候就需要组织信息。 精心创建的心理表征，主要优势就是可以在组织信息时吸收和考虑更多的信息。比如常人对于“发烧”建立的心理表征就是“由感冒引起”，而医生不会把病人的症状与其他相关数据视为相互孤立的信息，而是作为更大整体中的一部分来看待，联想到几十种上百种可能性。 第七十节 心理表征的作用（4）心理表征有助于执行学习计划有效学习的基础是有目的的学习。有目的学习有四个特点，第一点就是要有定义明确的目标。有了目标之后，我们就可以围绕目标进行细致的安排，制定一个包含进度的学习计划。具体的学习过程，其实就是执行这个计划。 在学习过程当中，我们最容易遇到的问题，就是学习计划的制订与实际情况并不相符，比如高估了自己的执行力和学习速度、或者遇到了许多没有预料到的突发情况，这些问题会严重阻碍我们的学习。 为学习目标构建更精细的心理表征，能够让目标的执行路径更明确、更有条理，指导我们有条理的执行计划，从而更准确的预见学习过程，确保学习计划能够符合实际。 第七十一节 有效学习的基础开展有效学习的重要基础 —— 寻找好导师有效学习的核心是建立精密的心理表征。自己练习时，你必须依靠自己的心理表征来监测自己的表现，并判断自己在哪些地方做得不对。 虽然这不是不可能做到的，但比起找一位经验丰富的导师来观察你，并向你提供反馈相比，单凭自己的力量来练习，不但艰难得多，而且效果差得多，在学习过程的早期尤其如此。 好的导师明白学习一项技能的最佳顺序，能够理解并示范正确的方式来展示各种技能，可以提供有效反馈，甚至还能设计一些专门用来克服特定缺陷的练习活动，在导师的指导下，激情十足、孜孜不倦的学生能够更加迅速地取得进步。 第七十二节 如何寻找导师如何辨认好导师好的导师应当是在所属行业或领域之中有一定成就的人，因为大部分导师只能引导你达到他们或者他们的学生曾经达到过的水平。 好导师应当具备一定的教育经验。很多成就突出的人并不能胜任导师的角色，他们自己能够做出杰出的成绩，并不意味着他的技巧和经验可以复制到其他人身上。 选择导师时，要记得询问导师的过往经验，可以和这位导师以前或现在的学生交谈。交谈时要注意围绕三个核心问题展开： 1、这些学生的水平如何？ 2、他们技能的提升，多大程度上归功于导师？ 3、他们对导师的评价如何？ 没有导师时的替代方案想要在没有导师的时候有效地练习某种技能，有三个词非常重要：专注、反馈和纠正。 无论你采用什么样的练习方式，都要在练习的过程中保持专注，在练习结束后对自己进行评价记录，找到行业专家在这个练习中的表现，跟自己对比，由此制订改良的方案，并在下一次练习时根据方案来纠正自己。 第七十三节 如何坚持学习新年决心效应俗话说万事开头难。但对于学习来说，着手做并不难，坚持不懈才是难事。很多人都有在新年时指定目标和计划的习惯，但随着时间的推移，无论你最开始有多热情，放弃的意愿都会越来越强，很少有人能够真正的达成目标。 能否坚持的关键是动机我们做一件事情的动机，包括两个组成部分：继续前行的理由和停下脚步的理由。如果停下脚步的理由战胜了继续前行的理由，失去了动机，你就很难坚持。因此，想要坚持就要保持动机，要么强化继续前行的理由，要么弱化停下脚步的理由。 如何弱化停下脚步的理由1、找到最舒适的学习时间，并固定下来。 2、找出那些可能干扰你练习的事情，想办法将它们的影响控制在最小。我们必须要明确，固定的学习时间中一定不能做其他事情，无论是不是正事。 第七十四节 步履不停如何增强继续前行的理由学习一个技能最初的理由，一般有两种：发自内心的热爱和社会动机。前者比较罕见，但动力会非常强大。如果没有外力的阻挠，兴趣就会成为最好的老师，督促着我们坚持学习并乐在其中。 社会动机就是受到外界影响才产生的动机，比较常见但动力较弱，如果不采取相应的措施，社会动机很难支撑我们长期坚持。有两个方法，可以显著的强化社会动机，帮助我们坚持学习。 第一种方法，是将对同一件事情感兴趣的人聚集起来，或者加入一个现有的，所有成员有着共同目标的团体，并和集体中的其他人建立良好的人际关系。 第二种方法，是建立坚信自己能够成功的信念。许多复杂的技能，需要日积月累，厚积薄发的学习才能看到成效。但是，在看到成效之前，很少有人能够接受这种毫无起色的状态，转而认定自己的学习是徒劳的，从而放弃坚持。因此，哪怕是自我欺骗，我们都要坚信自己能够成功。 第七十五节 复习课复习课 关于学习的两个误区一万小时定律、高估天赋的作用。 有效学习的基础： 有目的学习。 有目的学习的四要素： 目标定义明确、保持专注、有反馈，走出舒适区。 有效学习的本质： 建立高质量的心理表征。 心理表征的四个特点： 有助于寻找规律、解释信息、组织信息和执行计划。 好导师对学习非常重要： 我们可以依靠自己的心理表征来监测自己的表现，但比起找一位经验丰富的导师来观察你，并向你提供反馈相比，单凭自己的力量来练习，不但艰难得多，而且效果差得多。 好导师的两个特征： 在所属领域和行业有一定的成就，并且有过成功的教育经历。 在选择导师时，可以和这位导师以前或现在的学生交谈，解答三个核心问题展开：1、这些学生的水平如何？2、他们技能的提升，多大程度上归功于导师？3、他们对导师的评价如何？ 没有导师的替代方案： 三个关键词：专注、反馈、纠正。 无论你采用什么样的练习方式，都要在练习的过程中保持专注，在练习结束后对自己进行评价记录，找到行业专家在这个练习中的表现，跟自己对比，由此制订改良的方案，并在下一次练习时根据方案来纠正自己。 如何坚持学习？ 想要坚持学习，就要保持动机，要么强化继续前行的理由，要么弱化停下脚步的理由。 如何弱化停下脚步的理由？ 1、找到最舒适的学习时间，并固定下来。 2、找出那些可能干扰你练习的事情，想办法将它们的影响控制在最小。 如何强化继续前行的理由？ 1、将对同一件事情感兴趣的人聚集起来，或者加入一个现有的，所有成员有着共同目标的团体，并和集体中的其他人建立良好的人际关系。 2、建立坚信自己能够成功的信念。 第七十六节 自控力的组成自控力是能够提高的高度自律似乎是一项与生俱来的天赋，不过事实并非如此。正如同学习专业技能可以不依赖天赋，自控力也是人人都能具备的能力。著名的心理学专家、斯坦福大学的麦格尼格尔教授，通过多年来对人们改变想法、情绪和习惯的观察，摸索出了一套能够切实有效提高自控力的方法。 自控力的三种组成我想要：落实不想做的事（起床、工作） 我不要：拒绝诱惑（抵制零食和烟酒） 我需要：自我认知与价值判断 第七十七节第七十八节第七十九节第八十节","link":"/posts/%E6%B8%85%E6%96%B0%E5%86%A5%E6%83%B3/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习方法","slug":"学习方法","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"Alfred","slug":"Alfred","link":"/tags/Alfred/"},{"name":"效率","slug":"效率","link":"/tags/%E6%95%88%E7%8E%87/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","link":"/tags/CSS3/"},{"name":"代码示例","slug":"代码示例","link":"/tags/%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"nextTick","slug":"nextTick","link":"/tags/nextTick/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"setTimeout","slug":"setTimeout","link":"/tags/setTimeout/"},{"name":"setImmediate","slug":"setImmediate","link":"/tags/setImmediate/"},{"name":"EventLoop","slug":"EventLoop","link":"/tags/EventLoop/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"es8","slug":"es8","link":"/tags/es8/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"for of","slug":"for-of","link":"/tags/for-of/"},{"name":"generator","slug":"generator","link":"/tags/generator/"},{"name":"iterator","slug":"iterator","link":"/tags/iterator/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"进程管理","slug":"进程管理","link":"/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"代码优化","slug":"代码优化","link":"/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"antDesign","slug":"antDesign","link":"/tags/antDesign/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"终端","slug":"终端","link":"/tags/%E7%BB%88%E7%AB%AF/"},{"name":"iTerm2","slug":"iTerm2","link":"/tags/iTerm2/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"封装","slug":"封装","link":"/tags/%E5%B0%81%E8%A3%85/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"定时器","slug":"定时器","link":"/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"name":"组合函数","slug":"组合函数","link":"/tags/%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/"},{"name":"compose","slug":"compose","link":"/tags/compose/"},{"name":"哲学","slug":"哲学","link":"/tags/%E5%93%B2%E5%AD%A6/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"监控","slug":"监控","link":"/tags/%E7%9B%91%E6%8E%A7/"},{"name":"经验积累","slug":"经验积累","link":"/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"思维导图","slug":"思维导图","link":"/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"},{"name":"沟通技巧","slug":"沟通技巧","link":"/tags/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/"},{"name":"百度小程序","slug":"百度小程序","link":"/tags/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"React迁移到百度小程序","slug":"React迁移到百度小程序","link":"/tags/React%E8%BF%81%E7%A7%BB%E5%88%B0%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"知识点","slug":"知识点","link":"/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"处理问题","slug":"处理问题","link":"/tags/%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/"},{"name":"线上事故","slug":"线上事故","link":"/tags/%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/"},{"name":"运动","slug":"运动","link":"/tags/%E8%BF%90%E5%8A%A8/"},{"name":"跑步","slug":"跑步","link":"/tags/%E8%B7%91%E6%AD%A5/"},{"name":"日常积累","slug":"日常积累","link":"/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"理论知识","slug":"理论知识","link":"/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"SmartGit","slug":"SmartGit","link":"/tags/SmartGit/"},{"name":"GitKraken","slug":"GitKraken","link":"/tags/GitKraken/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"SSR","slug":"SSR","link":"/tags/SSR/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"业务","slug":"业务","link":"/tags/%E4%B8%9A%E5%8A%A1/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"精读","slug":"精读","link":"/tags/%E7%B2%BE%E8%AF%BB/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"webpack4","slug":"webpack4","link":"/tags/webpack4/"},{"name":"冥想","slug":"冥想","link":"/tags/%E5%86%A5%E6%83%B3/"}],"categories":[{"name":"es6","slug":"es6","link":"/categories/es6/"},{"name":"http","slug":"http","link":"/categories/http/"},{"name":"网络","slug":"http/网络","link":"/categories/http/%E7%BD%91%E7%BB%9C/"}]}