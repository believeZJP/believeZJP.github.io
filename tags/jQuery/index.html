<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: jQuery - believeZJP</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="believeZJP"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="believeZJP"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="积土成山，风雨兴焉；积水成渊，蛟龙生焉;"><meta property="og:type" content="blog"><meta property="og:title" content="believeZJP"><meta property="og:url" content="http://believezjp.oriht.com/"><meta property="og:site_name" content="believeZJP"><meta property="og:description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://believezjp.oriht.com/img/og_image.png"><meta property="article:author" content="believeZJP"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://believezjp.oriht.com"},"headline":"believeZJP","image":["http://believezjp.oriht.com/img/og_image.png"],"author":{"@type":"Person","name":"believeZJP"},"description":"积土成山，风雨兴焉；积水成渊，蛟龙生焉;"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?60d1b1f3f98701021581fc14f9ca17b7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="believeZJP" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/believeZJP"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">jQuery</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-11-29T13:42:02.000Z" title="2018-11-29T13:42:02.000Z">2018-11-29</time>发表</span><span class="level-item"><time dateTime="2018-11-29T13:42:02.000Z" title="2018-11-29T13:42:02.000Z">2018-11-29</time>更新</span><span class="level-item">23 分钟读完 (大约3442个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/jQuery%E6%8F%92%E4%BB%B6%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86/">jQuery插件思路整理</a></h1><div class="content"><h2 id="jQuery插件的封装"><a href="#jQuery插件的封装" class="headerlink" title="jQuery插件的封装"></a>jQuery插件的封装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>

<p>闭包的作用<br>–避免全局依赖<br>–避免第三方破坏<br>–兼容jQuery操作符‘$’和jQuery</p>
<!---more--->

<h2 id="开发方式"><a href="#开发方式" class="headerlink" title="开发方式"></a>开发方式</h2><ul>
<li>类级别组件开发</li>
<li>即给jQuery命名空间下添加新的全局函数，也称静态方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如：<code>$.ajax,$.extend()</code></p>
<ul>
<li>对象级别组件开发</li>
<li>即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法, 也称动态方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里 <code>$.fn === $.prototype</code><br>例如：<code>addClass()、attr()</code> 等，需要创建实例来调用</p>
<ul>
<li>链式调用<br>eg: <code>$(&quot;div&quot;).next().addClass()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li><p>return this 返回当前对象，来维护插件的链式调用</p>
</li>
<li><p>each 循环实现每个元素的访问</p>
</li>
<li><p>单例模式</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> me = $(<span class="built_in">this</span>),</span><br><span class="line">        instance = me.data(<span class="string">&quot;myPlugin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        me.data(<span class="string">&quot;myPlugin&quot;</span>,(instance= <span class="keyword">new</span> Plugin()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码说明：<br>-如果实例存在则不再重新创建实例<br>-利用data()来存放插件对象的实例</p>
<p>   jQuery插件的开发包括两种：<br>一种是类级别的插件开发，即给jQuery添加新的全局函数，相当于给jQuery类本身添加方法。jQuery的全局函数就是属于jQuery命名空间的函数，另一种是对象级别的插件开发，即给jQuery对象添加方法。下面就两种函数的开发做详细的说明。<br>1、类级别的插件开发<br>类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子就是$.AJAX()这个函数，将函数定义于jQuery的命名空间中。关于类级别的插件开发可以采用如下几种形式进行扩展：<br>1.1 添加一个新的全局函数<br>添加一个全局函数，我们只需如下定义：<br>Java代码  </p>
<p>jQuery.foo = function() {<br>alert(‘This is a test. This is only a test.’);<br>};</p>
<p>1.2 增加多个全局函数<br>添加多个全局函数，可采用如下定义：<br>Java代码  </p>
<p>jQuery.foo = function() {<br>alert(‘This is a test. This is only a test.’);<br>};<br>jQuery.bar = function(param) {<br>alert(‘This function takes a parameter, which is “‘ + param + ‘“.’);<br>};<br>调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar(‘bar’);<br>1.3 使用jQuery.extend(object);<br>Java代码  </p>
<p>jQuery.extend({<br>foo: function() {<br>alert(‘This is a test. This is only a test.’);<br>},<br>bar: function(param) {<br>alert(‘This function takes a parameter, which is “‘ + param +’”.’);<br>}<br>});  </p>
<p>1.4 使用命名空间<br>虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法封装到另一个自定义的命名空间。<br>Java代码  </p>
<p>jQuery.myPlugin = {<br>foo:function() {<br>alert(‘This is a test. This is only a test.’);<br>},<br>bar:function(param) {<br>alert(‘This function takes a parameter, which is “‘ + param + ‘“.’);<br>}<br>};<br>采用命名空间的函数仍然是全局函数，调用时采用的方法：<br>$.myPlugin.foo();<br>$.myPlugin.bar(‘baz’);  </p>
<p>通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。<br>2、对象级别的插件开发<br>对象级别的插件开发需要如下的两种形式：、<br>形式1：<br>Java代码  </p>
<p>(function($){<br>$.fn.extend({<br>pluginName:function(opt,callback){<br>          // Our plugin implementation code goes here.<br>}<br>})<br>})(jQuery);<br>形式2：<br>Java代码  </p>
<p>(function($) {<br>$.fn.pluginName = function() {<br>     // Our plugin implementation code goes here.<br>};<br>})(jQuery);<br>       上面定义了一个jQuery函数,形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突.<br>2.1 在JQuery名称空间下申明一个名字<br>这是一个单一插件的脚本。如果你的脚本中包含多个插件，或者互逆的插件（例如： $.fn.doSomething() 和$.fn.undoSomething()），那么你需要声明多个函数名字。但是，通常当我们编写一个插件时，力求仅使用一个名字来包含它的所有内容。我们的示例插件命名为“highlight“</p>
<p>Java代码  </p>
<p>$.fn.hilight = function() {<br>  // Our plugin implementation code goes here.<br>};<br>我们的插件通过这样被调用：<br>$(‘#myDiv’).hilight();</p>
<p>但是如果我们需要分解我们的实现代码为多个函数该怎么办？有很多原因：设计上的需要；这样做更容易或更易读的实现；而且这样更符合面向对象。 这真是一个麻烦事，把功能实现分解成多个函数而不增加多余的命名空间。出于认识到和利用函数是javascript中最基本的类对象，我们可以这样做。就像其他对象一样，函数可以被指定为属性。因此我们已经声明“hilight”为jQuery的属性对象，任何其他的属性或者函数我们需要暴露出来的，都可以在”hilight” 函数中被声明属性。稍后继续。<br>2.2 接受options参数以控制插件的行为<br>让我们为我们的插件添加功能指定前景色和背景色的功能。我们也许会让选项像一个options对象传递给插件函数。例如：<br>Java代码  </p>
<p>// plugin definition<br>$.fn.hilight = function(options) {<br>  var defaults = {<br>    foreground: ‘red’,<br>    background: ‘yellow’<br>  };<br>  // Extend our default options with those provided.<br>  var opts = $.extend(defaults, options);<br>  // Our plugin implementation code goes here.<br>};<br>我们的插件可以这样被调用：<br>$(‘#myDiv’).hilight({<br>  foreground: ‘blue’<br>});</p>
<p>2.3 暴露插件的默认设置<br>我们应该对上面代码的一种改进是暴露插件的默认设置。这对于让插件的使用者更容易用较少的代码覆盖和修改插件。接下来我们开始利用函数对象。</p>
<p>Java代码  </p>
<p>// plugin definition<br>$.fn.hilight = function(options) {<br>  // Extend our default options with those provided.<br>  // Note that the first arg to extend is an empty object -<br>  // this is to keep from overriding our “defaults” object.<br>  var opts = $.extend({}, $.fn.hilight.defaults, options);<br>  // Our plugin implementation code goes here.<br>};<br>// plugin defaults - added as a property on our plugin function<br>$.fn.hilight.defaults = {<br>  foreground: ‘red’,<br>  background: ‘yellow’<br>};<br>现在使用者可以包含像这样的一行在他们的脚本里：<br>//这个只需要调用一次，且不一定要在ready块中调用<br>$.fn.hilight.defaults.foreground = ‘blue’;<br>接下来我们可以像这样使用插件的方法，结果它设置蓝色的前景色：<br>$(‘#myDiv’).hilight();</p>
<p>如你所见，我们允许使用者写一行代码在插件的默认前景色。而且使用者仍然在需要的时候可以有选择的覆盖这些新的默认值：<br>// 覆盖插件缺省的背景颜色<br>$.fn.hilight.defaults.foreground = ‘blue’;<br>// …<br>// 使用一个新的缺省设置调用插件<br>$(‘.hilightDiv’).hilight();<br>// …<br>// 通过传递配置参数给插件方法来覆盖缺省设置<br>$(‘#green’).hilight({<br>  foreground: ‘green’<br>});<br>2.4 适当的暴露一些函数<br>这段将会一步一步对前面那段代码通过有意思的方法扩展你的插件（同时让其他人扩展你的插件）。例如，我们插件的实现里面可以定义一个名叫”format”的函数来格式化高亮文本。我们的插件现在看起来像这样，默认的format方法的实现部分在hiligth函数下面。<br>Java代码  </p>
<p>// plugin definition<br>$.fn.hilight = function(options) {<br>  // iterate and reformat each matched element<br>  return this.each(function() {<br>    var $this = $(this);<br>    // …<br>    var markup = $this.html();<br>    // call our format function<br>    markup = $.fn.hilight.format(markup);<br>    $this.html(markup);<br>  });<br>};<br>// define our format function<br>$.fn.hilight.format = function(txt) {<br>return ‘<strong>‘ + txt + ‘</strong>‘;<br>};<br>      我们很容易的支持options对象中的其他的属性通过允许一个回调函数来覆盖默认的设置。这是另外一个出色的方法来修改你的插件。这里展示的技巧是进一步有效的暴露format函数进而让他能被重新定义。通过这技巧，是其他人能够传递他们自己设置来覆盖你的插件，换句话说，这样其他人也能够为你的插件写插件。<br>      考虑到这个篇文章中我们建立的无用的插件，你也许想知道究竟什么时候这些会有用。一个真实的例子是Cycle插件.这个Cycle插件是一个滑动显示插件，他能支持许多内部变换作用到滚动，滑动，渐变消失等。但是实际上，没有办法定义也许会应用到滑动变化上每种类型的效果。那是这种扩展性有用的地方。 Cycle插件对使用者暴露”transitions”对象，使他们添加自己变换定义。插件中定义就像这样：<br>$.fn.cycle.transitions = {<br>// …<br>};<br>这个技巧使其他人能定义和传递变换设置到Cycle插件。<br>2.5 保持私有函数的私有性<br>这种技巧暴露你插件一部分来被覆盖是非常强大的。但是你需要仔细思考你实现中暴露的部分。一但被暴露，你需要在头脑中保持任何对于参数或者语义的改动也许会破坏向后的兼容性。一个通理是，如果你不能肯定是否暴露特定的函数，那么你也许不需要那样做。<br>那么我们怎么定义更多的函数而不搅乱命名空间也不暴露实现呢？这就是闭包的功能。为了演示，我们将会添加另外一个“debug”函数到我们的插件中。这个 debug函数将为输出被选中的元素格式到firebug控制台。为了创建一个闭包，我们将包装整个插件定义在一个函数中。<br>Java代码  </p>
<p> (function($) {<br>  // plugin definition<br>  $.fn.hilight = function(options) {<br>    debug(this);<br>    // …<br>  };<br>  // private function for debugging<br>  function debug($obj) {<br>    if (window.console &amp;&amp; window.console.log)<br>      window.console.log(‘hilight selection count: ‘ + $obj.size());<br>  };<br>//  …<br>})(jQuery);</p>
<p>我们的“debug”方法不能从外部闭包进入,因此对于我们的实现是私有的。<br>2.6 支持Metadata插件<br>在你正在写的插件的基础上，添加对Metadata插件的支持能使他更强大。个人来说，我喜欢这个Metadata插件，因为它让你使用不多的”markup”覆盖插件的选项（这非常有用当创建例子时）。而且支持它非常简单。更新：注释中有一点优化建议。<br>Java代码  </p>
<p>$.fn.hilight = function(options) {<br>  // …<br>  // build main options before element iteration<br>  var opts = $.extend({}, $.fn.hilight.defaults, options);<br>  return this.each(function() {<br>    var $this = $(this);<br>    // build element specific options<br>    var o = $.meta ? $.extend({}, opts, $this.data()) : opts;<br>    //…<br> 这些变动行做了一些事情：它是测试Metadata插件是否被安装如果它被安装了，它能扩展我们的options对象通过抽取元数据这行作为最后一个参数添加到JQuery.extend，那么它将会覆盖任何其它选项设置。现在我们能从”markup”处驱动行为,如果我们选择了“markup”：<br> 调用的时候可以这样写： jQuery.foo(); 或 $.foo();</p>
<p>Java代码  </p>
<!--  markup  -->
<div class="hilight { background: 'red', foreground: 'white' }">
  Have a nice day!
</div>
<div class="hilight { foreground: 'orange' }">
  Have a nice day!
</div>
<div class="hilight { background: 'green' }">
  Have a nice day!
</div>
现在我们能高亮哪些div仅使用一行脚本：  
$('.hilight').hilight();

<p>2.7 整合<br>下面使我们的例子完成后的代码：</p>
<p>Java代码  </p>
<p>// 创建一个闭包<br>(function($) {<br>  // 插件的定义<br>  $.fn.hilight = function(options) {<br>    debug(this);<br>    // build main options before element iteration<br>    var opts = $.extend({}, $.fn.hilight.defaults, options);<br>    // iterate and reformat each matched element<br>    return this.each(function() {<br>      $this = $(this);<br>      // build element specific options<br>      var o = $.meta ? $.extend({}, opts, $this.data()) : opts;<br>      // update element styles<br>      $this.css({<br>        backgroundColor: o.background,<br>        color: o.foreground<br>      });<br>      var markup = $this.html();<br>      // call our format function<br>      markup = $.fn.hilight.format(markup);<br>      $this.html(markup);<br>    });<br>  };<br>  // 私有函数：debugging<br>  function debug($obj) {<br>    if (window.console &amp;&amp; window.console.log)<br>      window.console.log(‘hilight selection count: ‘ + $obj.size());<br>  };<br>  // 定义暴露format函数<br>  $.fn.hilight.format = function(txt) {<br>    return ‘<strong>‘ + txt + ‘</strong>‘;<br>  };<br>  // 插件的defaults<br>  $.fn.hilight.defaults = {<br>    foreground: ‘red’,<br>    background: ‘yellow’<br>  };<br>// 闭包结束<br>})(jQuery);</p>
<p>这段设计已经让我创建了强大符合规范的插件。我希望它能让你也能做到。<br>3、总结<br>jQuery为开发插件提拱了两个方法，分别是：<br>jQuery.fn.extend(object);  给jQuery对象添加方法。<br>jQuery.extend(object);  为扩展jQuery类本身.为类添加新的方法。<br>3.1 jQuery.fn.extend(object);<br>fn 是什么东西呢。查看jQuery代码，就不难发现。<br>jQuery.fn = jQuery.prototype = {<br>init: function( selector, context ) {//….<br>//……<br>};<br>原来 jQuery.fn = jQuery.prototype.对prototype肯定不会陌生啦。虽然 javascript　没有明确的类的概念，但是用类来理解它，会更方便。jQuery便是一个封装得非常好的类，比如我们用 语句　$(“#btn1”) 会生成一个 jQuery类的实例。<br>jQuery.fn.extend(object); 对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。<br>比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这么做：<br>$.fn.extend({<br>     alertWhileClick:function(){<br>         $(this).click(function(){<br>              alert($(this).val());<br>          });<br>      }<br>});<br>$(“#input1”).alertWhileClick(); //页面上为：<input id="input1" type="text"/><br>$(“#input1”)　为一个jQuery实例，当它调用成员方法 alertWhileClick后，便实现了扩展，每次被点击时它会先弹出目前编辑里的内容。<br>3.2 jQuery.extend(object);<br>为jQuery类添加添加类方法，可以理解为添加静态方法。如：<br>$.extend({<br>    add:function(a,b){return a+b;}<br>});<br>便为　jQuery　添加一个为 add　的　“静态方法”，之后便可以在引入 jQuery　的地方，使用这个方法了，$.add(3,4); //return 7</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-07-03T13:42:02.000Z" title="2018-07-03T13:42:02.000Z">2018-07-03</time>发表</span><span class="level-item"><time dateTime="2018-11-29T13:42:02.000Z" title="2018-11-29T13:42:02.000Z">2018-11-29</time>更新</span><span class="level-item">2 小时读完 (大约16587个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/">前端经验积累</a></h1><div class="content"><h1 id="判断一个对象是不是数组"><a href="#判断一个对象是不是数组" class="headerlink" title="判断一个对象是不是数组"></a>判断一个对象是不是数组</h1><ol>
<li>instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;;</span><br><span class="line">var b&#x3D;[];</span><br><span class="line">console.log(a instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">console.log(b instanceof Array);&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">注意！！！！！！</span><br><span class="line">console.log(b instanceof Object);&#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Array.isArray()</p>
</li>
<li><p>使用Object.prototype上的原生toString()方法判断。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(a));&#x2F;&#x2F;[object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(b));&#x2F;&#x2F;[object Array]</span><br><span class="line">同理判断一个对象是否是函数：</span><br><span class="line">console.log(Object.prototype.toString.call(obj)&#x3D;&#x3D;&#x3D;&#39;[object Function]&#39;)    &#x2F;&#x2F;true或false</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>obj.constructor===Array   //true</li>
</ol>
<h1 id="真值-假值（Truthy-Falsy）"><a href="#真值-假值（Truthy-Falsy）" class="headerlink" title="真值 / 假值（Truthy / Falsy）"></a>真值 / 假值（Truthy / Falsy）</h1><p>以下为false</p>
<ul>
<li>false</li>
<li>0</li>
<li>“”（空字符串）</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">!0 &#x2F;&#x2F; true -- 0 is false, 所以返回true</span><br><span class="line">!!0 &#x2F;&#x2F; false -- 0 is falsy so !0 returns true so !(!0) returns false</span><br><span class="line">!!&quot;&quot; &#x2F;&#x2F; false -- empty string is falsy so NOT (NOT false) equals false</span><br><span class="line"></span><br><span class="line">new Boolean(0) &#x2F;&#x2F; false</span><br><span class="line">new Boolean(1) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let a &#x3D; [] &#x3D;&#x3D; true &#x2F;&#x2F; a is false since [].toString() give &quot;&quot; back.</span><br><span class="line">let b &#x3D; [1] &#x3D;&#x3D; true &#x2F;&#x2F; b is true since [1].toString() give &quot;1&quot; back.</span><br><span class="line">let c &#x3D; [2] &#x3D;&#x3D; true &#x2F;&#x2F; c is false since [2].toString() give &quot;2&quot; back.</span><br><span class="line"></span><br><span class="line">在内部，当一个对象与布尔值比较时，</span><br><span class="line">比如[] &#x3D;&#x3D; true，它其实进行的是[].toString() &#x3D;&#x3D; true。</span><br></pre></td></tr></table></figure>

<h1 id="JS语句为什么不能以“function”和大括号开头"><a href="#JS语句为什么不能以“function”和大括号开头" class="headerlink" title="JS语句为什么不能以“function”和大括号开头"></a>JS语句为什么不能以“function”和大括号开头</h1><ul>
<li>以function开头，但必须是一个函数声明语句</li>
<li>以大括号开头，但该大括号不再被当做一个对象处理，而是当做一个语句块处理</li>
<li>综上两条说明，JS语句可以以function，也可以以大括号作为开头，前提是必须符合JS中的语法规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;a: &#39;a&#39;&#125;.a;   &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line">function()&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token (</span><br><span class="line">&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line"></span><br><span class="line">“&#123;&#125;.toString();” 等同于: “; .toString();” 未通过对象主体调用“toString”方法，不符合JS中期待的表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Object-assign-JSON-stringify是深拷贝吗"><a href="#Object-assign-JSON-stringify是深拷贝吗" class="headerlink" title="Object.assign, JSON.stringify是深拷贝吗"></a>Object.assign, JSON.stringify是深拷贝吗</h1><p>不是的话怎么解决</p>
<p>shallowCopy（浅拷贝）或 deepCopy（深拷贝）</p>
<p>深拷贝造成了 CPU 和内存的浪费</p>
<p>深拷贝如果是只有最底层一个元素改变，会造成性能影响，怎么解决? immutable</p>
<p>Object.assign()可以对非嵌套对象进行深拷贝的方法,<br>如果对象中出现嵌套情况,那么其对被嵌套对象的行为就成了普通的浅拷贝.<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。</p>
<p>对象解构运算，也是浅拷贝。</p>
<p>JSON对象中包含两个方法, stringify()和parse(),前者可以将对象JSON化,而后者可以将JSON格式转换为对象.这是一种可以实现深拷贝的方法.<br>但这种方法的缺陷是会破坏原型链,并且无法拷贝属性值为function的属性<br>所以如果只是想单纯复制一个嵌套对象,可以使用此方法</p>
<p>缺点是你创建一个临时的，可能很大的字符串，只是为了把它重新放回解析器。另一个缺点是这种方法不能处理循环对象。而且循环对象经常发生。例如，当您构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const x &#x3D; &#123;&#125;;</span><br><span class="line">const y &#x3D; &#123;x&#125;;</span><br><span class="line">x.y &#x3D; y; &#x2F;&#x2F; Cycle: x.y.x.y.x.y.x.y.x...</span><br><span class="line">const copy &#x3D; JSON.parse(JSON.stringify(x)); &#x2F;&#x2F; throws!</span><br><span class="line"></span><br><span class="line">let bar &#x3D; JSON.parse(JSON.stringify(foo));</span><br><span class="line">Object.assign(&#123;&#125;, foo);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a: 0,</span><br><span class="line">    b: 20,</span><br><span class="line">&#125;</span><br><span class="line">obj &#x3D; &#123;...obj, a: obj.a + 1&#125;</span><br><span class="line"></span><br><span class="line">Structured Clone 结构化克隆算法</span><br><span class="line">MessageChannel</span><br><span class="line">缺点是它是异步的。虽然这并无大碍，</span><br><span class="line">但是有时候你需要使用同步的方式来深度拷贝一个对象</span><br><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;port1, port2&#125; &#x3D; new MessageChannel();</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#x2F;* ... *&#x2F;;</span><br><span class="line">const clone &#x3D; await structuralClone(obj);</span><br></pre></td></tr></table></figure>

<p>es7 … 的方式<br>直接{…obj}赋值属于浅复制，在修改值时{…obj,a:1}就起到了类深复制的效果<br>更新一个 Object</p>
<h3 id="immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"><a href="#immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发" class="headerlink" title="immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"></a>immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发</h3><p> <a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/3">链接</a></p>
<p> Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。</p>
<p>为什么immutable比较两个对象不同会快？原因如下：<br>和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。用法：is(map1,map2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">这是原来的 reducer：</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    newState &#x3D; Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        apples: [</span><br><span class="line">            ...state.apples.slice(0, action.payload),</span><br><span class="line">            Object.assign(&#123;&#125;, state.apples[action.payload], &#123; isEaten: true &#125;),</span><br><span class="line">            ...state.apples.slice(action.payload + 1)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">    return newState;</span><br><span class="line"></span><br><span class="line">这是使用 immutable.js 库的reducer :</span><br><span class="line"></span><br><span class="line">import &#123; fromJS &#125; from &#39;immutable&#39;;</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    return fromJS(state).setIn([&#39;apples&#39;,action.payload,&#39;isEaten&#39;], true).toJS();</span><br><span class="line"></span><br><span class="line">团队约定 state 都用 immutable 内部的数据类型，就可以连 fromJS 和 toJS 的转化都省了，超级方便！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="JSONP-后端返回alert-data-，前端会执行吗"><a href="#JSONP-后端返回alert-data-，前端会执行吗" class="headerlink" title="JSONP 后端返回alert(data)，前端会执行吗"></a>JSONP 后端返回alert(data)，前端会执行吗</h1><p>因为后端把回调方法名转成另一个名字将data包在里边，所以不会执行alert。</p>
<p>为什么是jsonp, img, iframe也可以，为什么？</p>
<p>jsonp全名叫做json with padding<br>函数调用，数据都被包裹传递到参数中了，</p>
<p>将服务端的数据用padding包起来，所谓的padding就相当于一个函数。假设我们原来有数据 {“data”,”something”}，用一个名为callback的padding包起来之后 就成了 callback({“data”:”something”})，这样将script标签加载完毕之后，会立马执行这个函数，并将数据当做参数传了进去。如果我们可以事先在前端事先指定一个函数名，并定义这个函数。然后告诉后端，用这个函数名作为padding包裹数据。那么当前端动态创建script标签之后，script加载完毕了就会执行这个函数，这样我们就成功的跨域获得了数据~</p>
<p>从开发者工具里面可以看到实际发送的请求</p>
<p>Request URL:<a target="_blank" rel="noopener" href="https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924">https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924</a></p>
<p>这里可以看出来jQuery自动生成的padding是jsonp1430727166924返回的数据：;jsonp1430727166924({“rating”:{“max”:10,”numRaters”:336,”average”:”7.0”,”min”:0},”price”:”15.00元”});</p>
<h1 id="js-css执行顺序，并行串行，阻塞"><a href="#js-css执行顺序，并行串行，阻塞" class="headerlink" title="js,css执行顺序，并行串行，阻塞"></a>js,css执行顺序，并行串行，阻塞</h1><p><a target="_blank" rel="noopener" href="http://blog.jobbole.com/12749/">链接</a><br>DOM文档的加载顺序是由上而下的顺序加载；</p>
<p>1、DOM加载到link标签</p>
<p>==css文件的加载是与DOM的加载并行的==，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；</p>
<p>2、DOM加载到script标签</p>
<p>由于==js文件不会与DOM并行加载==，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；</p>
<p>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现；</p>
<p>所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。至到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。</p>
<p>嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。</p>
<p>浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>
<p>3、解决方法</p>
<p>前提，js是外部脚本；</p>
<p>在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；</p>
<p>在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；</p>
<p>同时使用defer和async属性时，defer属性会失效；</p>
<p>可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。</p>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;十进制转其他</span><br><span class="line">var x&#x3D;110;  </span><br><span class="line">alert(x);</span><br><span class="line">alert(x.toString(8));  </span><br><span class="line">alert(x.toString(32));  </span><br><span class="line">alert(x.toString(16));  </span><br><span class="line">&#x2F;&#x2F;其他转十进制</span><br><span class="line">var x&#x3D;&#39;110&#39;;</span><br><span class="line">alert(parseInt(x,2));  </span><br><span class="line">alert(parseInt(x,8));  </span><br><span class="line">alert(parseInt(x,16));  </span><br><span class="line">&#x2F;&#x2F;其他转其他  </span><br><span class="line">&#x2F;&#x2F;先用parseInt转成十进制再用toString转到目标进制  </span><br><span class="line">alert(String.fromCharCode(parseInt(141,8)))  </span><br><span class="line">alert(parseInt(&#39;ff&#39;,16).toString(2));  </span><br></pre></td></tr></table></figure>

<h1 id="两个对象判断"><a href="#两个对象判断" class="headerlink" title="两个对象判断=="></a>两个对象判断==</h1><p>引用下温特大大的总结就是：<br>只要记住 null 只和undefined 相等，<br>有 number 都转 number，<br>有 boolean 也转 number，<br>有 string 都转 string，<br>对象互相不等，<br>NaN 互相不等就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log([] &#x3D;&#x3D; []) &#x2F;&#x2F; false</span><br><span class="line">console.log(![] &#x3D;&#x3D; false) &#x2F;&#x2F; false</span><br><span class="line">console.log([] &#x3D;&#x3D; false) &#x2F;&#x2F; true</span><br><span class="line">console.log(!!&#39;hello&#39;) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;hello&#39; &#x3D;&#x3D; true) &#x2F;&#x2F; &#39;hello&#39;&#x3D;&#x3D;1  false</span><br><span class="line">console.log(typeof(typeof(&#39;hello&#39;)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typeof的运算数未定义,返回的就是 “undefined”.</span><br><span class="line"></span><br><span class="line">运算数为数字 typeof(x) &#x3D; “number”</span><br><span class="line"></span><br><span class="line">字符串 typeof(x) &#x3D; “string”</span><br><span class="line"></span><br><span class="line">布尔值 typeof(x) &#x3D; “boolean”</span><br><span class="line"></span><br><span class="line">对象,数组和null typeof(x) &#x3D; “object”</span><br><span class="line"></span><br><span class="line">函数 typeof(x) &#x3D; “function”</span><br></pre></td></tr></table></figure>

<h1 id="FOUC无样式内容闪烁"><a href="#FOUC无样式内容闪烁" class="headerlink" title="FOUC无样式内容闪烁"></a>FOUC无样式内容闪烁</h1><p>Flash of Uncompiled Content</p>
<p>原因大致为： 1，使用import方法导入样式表。 2，将样式表放在页面底部 3，有几个样式表，放在html结构的不同位置。</p>
<p>解决方法： 使用LINK标签将样式表放在文档HEAD中。</p>
<ol>
<li><p>v-cloak</p>
</li>
<li><p>用v-text</p>
</li>
<li><p>v-if, v-show</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- same as --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// <span class="tag">&lt;<span class="name">div</span>&gt;</span> 不会显示，直到编译结束。</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="js实现jQuery-clone"><a href="#js实现jQuery-clone" class="headerlink" title="js实现jQuery.clone"></a>js实现jQuery.clone</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">逐级递归；</span><br><span class="line"></span><br><span class="line">递归中收集每个元素的全部信息，包括该元素上绑定的所有事件。</span><br><span class="line"></span><br><span class="line">复制时候重现按照获得的事件列表逐个加载回去。</span><br><span class="line"></span><br><span class="line">除此之外主要可能是考虑各种兼容，</span><br><span class="line">包括cloneNode方法的兼容，</span><br><span class="line">获取元素属性时候的某些标签的兼容。</span><br></pre></td></tr></table></figure>

<h1 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h1><p>（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。</p>
<h1 id="ajax参数"><a href="#ajax参数" class="headerlink" title="ajax参数"></a>ajax参数</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huiyuantang/p/5458278.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.url: 发送请求的地址</span><br><span class="line">2.type: 请求方式（post或get</span><br><span class="line">3.timeout: 请求超时时间（毫秒）</span><br><span class="line">4.async: 默认设置为true，异步请求</span><br><span class="line">5.cache: 从浏览器缓存中加载请求信息</span><br><span class="line">6.data: 发送到服务器的数据</span><br><span class="line">7.dataType: xml,html, json,text</span><br><span class="line">8.beforeSend：发送请求前，执行一些操作</span><br><span class="line">9.complete：完成后调用的回调函数</span><br><span class="line">10.success：请求成功后调用的回调函数</span><br><span class="line">11.error:</span><br><span class="line">12.contentType：</span><br><span class="line">13.dataFilter：</span><br><span class="line"></span><br><span class="line">16.ifModified：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;闭包限定命名空间</span><br><span class="line">(function ($) &#123;</span><br><span class="line">    $.fn.extend(&#123;</span><br><span class="line">        &quot;highLight&quot;:function(options)&#123;</span><br><span class="line">            &#x2F;&#x2F;do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(window.jQuery);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">$(&quot;p&quot;).highLight(); &#x2F;&#x2F;调用自定义 高亮插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="exports-module-exports区别"><a href="#exports-module-exports区别" class="headerlink" title="exports, module.exports区别"></a>exports, module.exports区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports</span><br><span class="line"></span><br><span class="line">exports在module.exports 被改变后，失效。</span><br><span class="line"></span><br><span class="line">1. module.exports 初始值为一个空对象 &#123;&#125;</span><br><span class="line">2. exports 是指向的 module.exports 的引用</span><br><span class="line">3. require() 返回的是 module.exports 而不是 exports</span><br></pre></td></tr></table></figure>

<h1 id="上传文件方式"><a href="#上传文件方式" class="headerlink" title="上传文件方式"></a>上传文件方式</h1><ul>
<li><p>form表单上传文件</p>
  <form action="/test/" method="POST" enctype="multipart/form-data">
</li>
<li><p>原生js实现ajax上传文件<br>   var xml=new XMLHttpRequest();</p>
<p>  var data=new FormData; //创建formdata对象</p>
<p>  data.append(“testfile”,document.getElementById(“file_upload”).files[0]);//找到对象之后的file[0]对应的就是文件对象</p>
<p>  xml.open(“POST”,”/test/“,true);</p>
</li>
<li><p>jquery实现ajax上传文件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data&#x3D;new FormData;</span><br><span class="line">data.append(&quot;testfile&quot;,document.getElementById(&quot;file_upload&quot;).files[0]);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;&#x2F;test&#x2F;&quot;,</span><br><span class="line">    type:&quot;POST&quot;,</span><br><span class="line">    dataType:&quot;JSON&quot;,</span><br><span class="line">    data:data,</span><br><span class="line">    contentType: false,</span><br><span class="line">    processData: false,</span><br><span class="line">    success:function(rst)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>form+iframe上传文件</p>
<h1 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h1><p> @mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin通过 @include来调用。</p>
<p> @mixin通过 @include调用后解析出来的样式是以拷贝形式存在的，而继承则是以联合声明的方式存在的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sass style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">@mixin center-block &#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br><span class="line">.demo&#123;</span><br><span class="line">    @include center-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;css style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">.demo&#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1，session 在服务器端，</span><br><span class="line">    cookie 在客户端（浏览器）</span><br><span class="line">2，session 默认被存在在服务器</span><br><span class="line">    的一个文件里（不是内存）</span><br><span class="line">3，session 的运行依赖 session id，</span><br><span class="line">    而 session id 是存在 cookie 中的，</span><br><span class="line">    也就是说，如果浏览器禁用了 cookie ，</span><br><span class="line">    同时 session 也会失效</span><br><span class="line">    （但是可以通过其它方式实现，</span><br><span class="line">    比如在 url 中传递 session_id）</span><br><span class="line">4，session 可以放在 文件、数据库、或内存中都可以。</span><br><span class="line">5，用户验证这种场合一般会用 session</span><br><span class="line">因此，维持一个会话的核心就是</span><br><span class="line">客户端的唯一标识，即 session id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="AMD-CMD-CommonJS"><a href="#AMD-CMD-CommonJS" class="headerlink" title="AMD, CMD, CommonJS"></a>AMD, CMD, CommonJS</h1><p>==记忆方法==</p>
<p>AR<br>AMD– require.js</p>
<p>CS<br>CMD– sea.js</p>
<p>A AMD A在前，提前加载</p>
<p>C CMD C在后，延迟加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">node的module遵循CommonJS规范，</span><br><span class="line">requirejs遵循AMD，seajs遵循CMD，</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------- node -----------</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  a : function() &#123;&#125;,</span><br><span class="line">  b : &#39;xxx&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------- AMD or CMD ----------------</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  module.exports &#x3D; &#123;</span><br><span class="line">    a : function() &#123;&#125;,</span><br><span class="line">    b : &#39;xxx&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。</span><br><span class="line">它采用异步方式加载模块，模块的加载不影响它后面语句的运行。</span><br><span class="line">所有依赖这个模块的语句，都定义在一个回调函数中，</span><br><span class="line">等到加载完成之后，这个回调函数才会运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line"></span><br><span class="line">1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</span><br><span class="line">不过 RequireJS 从 2.0 开始，</span><br><span class="line">也改成可以延迟执行（根据写法不同，处理方式不同）。</span><br><span class="line">CMD 推崇 as lazy as possible.</span><br><span class="line"></span><br><span class="line">2. CMD 推崇依赖就近，AMD 推崇依赖前置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="import引入模块"><a href="#import引入模块" class="headerlink" title="import引入模块"></a>import引入模块</h3><p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>注意:import必须放在文件的最开始.import命令是编译阶段执行的，在代码运行之前,表达式和变量只有在运行时才能得到结果的语法结构。import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）所以import中不能含有表达式或者变量,因此无法实现动态加载.<br>因此，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。<br>这样的设计，有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br></pre></td></tr></table></figure>

<h1 id="position取值"><a href="#position取值" class="headerlink" title="position取值"></a>position取值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ralative是指相对定位</span><br><span class="line">元素仍保持其未定位前的形状，它原本所占的空间仍保留。</span><br><span class="line"></span><br><span class="line">absolute是指绝对定位</span><br><span class="line">    即完全离开文档流, 相关于position属性非static值的比来父级元素进行偏移。</span><br><span class="line">    如果不存在这样的父对象，则依据body对象。而其层叠通过z-index属性定义</span><br><span class="line">fixed: 固定定位</span><br><span class="line">    固定定位：即完全离开文档流，相关于视区进行偏移。</span><br><span class="line">static：元素框正常生成</span><br><span class="line">inherit：继承值，对象将继承其父对象相应的值。</span><br></pre></td></tr></table></figure>

<h1 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="call和apply-bind区别"><a href="#call和apply-bind区别" class="headerlink" title="call和apply, bind区别"></a>call和apply, bind区别</h1><p>这三个参数的返回值区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">作用完全一样，唯一的区别就在参数上</span><br><span class="line"></span><br><span class="line">call 接收的参数不固定，</span><br><span class="line">第一个参数是函数体内 this 的指向，</span><br><span class="line">第二个参数以下是依次传入的参数。</span><br><span class="line"></span><br><span class="line">apply接收两个参数，</span><br><span class="line">第一个参数也是函数体内 this 的指向。</span><br><span class="line">第二个参数是一个集合对象（数组或者类数组）</span><br><span class="line"></span><br><span class="line">记忆方法：</span><br><span class="line"></span><br><span class="line">apply ---- array 要传数组</span><br><span class="line">call  ---- 逗号隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三个的使用区别：</span><br><span class="line">都是用来改变函数的this对象的指向的；</span><br><span class="line">第一个参数都是this要指向的对象；</span><br><span class="line">都可以利用后续参数传参；</span><br><span class="line">bind是返回对应函数，便于稍后调用，apply、call是立即调用；</span><br><span class="line">bind（）--也是改变函数体内this的指向;</span><br><span class="line">bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let obj1&#x3D;&#123;</span><br><span class="line">    a:222</span><br><span class="line">&#125;;</span><br><span class="line">let obj2&#x3D;&#123;</span><br><span class="line">    a:111,</span><br><span class="line">    fn:function()&#123;</span><br><span class="line">        alert(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.fn.call(obj1);&#x2F;&#x2F;222</span><br><span class="line"></span><br><span class="line">call 和 apply 两个主要用途就是</span><br><span class="line"></span><br><span class="line">1.改变 this 的指向（把 this 从 obj2 指向到 obj1 ）</span><br><span class="line"></span><br><span class="line">2.方法借用（ obj1 没有 fn ，只是借用 obj2 方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="箭头函数怎么绑定全局this"><a href="#箭头函数怎么绑定全局this" class="headerlink" title="箭头函数怎么绑定全局this"></a>箭头函数怎么绑定全局this</h1><p>箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () &#x3D;&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  &#x2F;&#x2F; undefined window&#123;...&#125;</span><br><span class="line"></span><br><span class="line">作为方法的箭头函数this指向全局window对象，</span><br><span class="line">而普通函数则指向调用它的对象</span><br></pre></td></tr></table></figure>

<h1 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h1><p><a target="_blank" rel="noopener" href="http://caibaojian.com/es6-features.html">链接</a></p>
<h1 id="foreach-map-reduce-filter区别"><a href="#foreach-map-reduce-filter区别" class="headerlink" title="foreach, map, reduce, filter区别"></a>foreach, map, reduce, filter区别</h1><h1 id="函数声明-amp-函数表达式的区别"><a href="#函数声明-amp-函数表达式的区别" class="headerlink" title="函数声明&amp;函数表达式的区别"></a>函数声明&amp;函数表达式的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">函数声明中函数名是必须的；函数表达式中则是可选的</span><br><span class="line"> &#x2F;&#x2F;函数声明</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(1, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数表达式</span><br><span class="line">&#x2F;* var s &#x3D; function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2)); *&#x2F;</span><br><span class="line"></span><br><span class="line">var s &#x3D; function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2));</span><br><span class="line">&#x2F;&#x2F;以上两种都可以</span><br><span class="line"></span><br><span class="line">二、用函数声明定义的函数,函数可以在函数声明之前调用,而用函数表达式定义的函数只能在声明之后调用。</span><br><span class="line"></span><br><span class="line">【根本原因在于解析器对这两种定义方式读取的顺序不同:解析器会事先读取函数声明，即函数声明放在任意位置都可以被调用；</span><br><span class="line"></span><br><span class="line">对于函数表达式，解析器只有在读到函数表达式所在那行的时候才执行】</span><br><span class="line"></span><br><span class="line">使用var 表达式定义函数， 只有变量声明提前了，变量初始化代码仍然在原来的位置</span><br></pre></td></tr></table></figure>

<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段</p>
<h5 id="addEventListener-evtype-fn-useCapture"><a href="#addEventListener-evtype-fn-useCapture" class="headerlink" title="addEventListener(evtype,fn,useCapture)"></a>addEventListener(evtype,fn,useCapture)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">useCapture是true，则事件处理函数在捕获阶段被执行，否则 在冒泡阶段执行</span><br><span class="line"></span><br><span class="line">因为如果被监听的元素没有子元素，那么哪个监听代码写在前面，就先执行哪个！</span><br><span class="line"></span><br><span class="line">&lt;label&gt;Click me &lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#39;label&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;)</span><br><span class="line">    document.querySelector(&#39;input&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">因为label和input是有绑定的</span><br><span class="line">点击label后，浏览器自动帮你再点击一次label</span><br><span class="line">过程就是先进行一次事件机制，这一次对内部input元素的事件监听是不管不问的，所以先打出1</span><br><span class="line">结束后，再进行一次事件机制，这一次，按照正常事件机制流程走，所以接着打出了2,1</span><br></pre></td></tr></table></figure>

<p>阻止冒泡<br>window.event.cancelBubble = true</p>
<p>e.preventDefault();</p>
<p>return false</p>
<p>都能阻止<br> stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。<br>stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡</p>
<h1 id="git-问题"><a href="#git-问题" class="headerlink" title="git 问题"></a>git 问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git回退到某个commit版本</span><br><span class="line"></span><br><span class="line">git reset --hard commitId</span><br><span class="line">强制提交</span><br><span class="line">git push -f origin master</span><br><span class="line">删除分支</span><br><span class="line">git branch -d branchname  </span><br><span class="line"></span><br><span class="line">git 删除远程分支</span><br><span class="line">git push origin branchname</span><br><span class="line"></span><br><span class="line">rebase 和 merge区别</span><br><span class="line"></span><br><span class="line">rebase，合并的结果好看，一条线，但合并过程中出现冲突的话，比较麻烦（rebase过程中，一个commit出现冲突，下一个commit也极有可能出现冲突，一次rebase可能要解决多次冲突）；merge，合并结果不好看，一堆线交错，但合并有冲突的话，只要解一次就行了；</span><br><span class="line"></span><br><span class="line">commit 粒度把握得好，就直接 merge，把握不好，先 rebase 把粒度调整好了，再 merge。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="let-var-const-区别"><a href="#let-var-const-区别" class="headerlink" title="let var const 区别"></a>let var const 区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let 的「创建」过程被提升了，但是初始化没有提升。</span><br><span class="line"></span><br><span class="line">let在未定义之前使用，会报错</span><br><span class="line"></span><br><span class="line">var 的「创建」和「初始化」都被提升了。</span><br><span class="line"></span><br><span class="line">function 的「创建」「初始化」和「赋值」都被提升了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let 声明的变量的作用域是块级的；</span><br><span class="line">let 不能重复声明已存在的变量；</span><br><span class="line">let 有暂时死区，不会被提升。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域</span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) &#123; 循环体 &#125; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog">js链接</a></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">链接</a></p>
<p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。</p>
<p>在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>最大用处有两个，<br>一是可以读取函数内部的变量，<br>（创建局部变量，保护局部变量不会被访问和修改）。<br>另一个就是让这些变量的值始终保持在内存中。</p>
<p>闭包常见用途：</p>
<p>创建特权方法用于访问控制<br>事件处理程序及回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">let add&#x3D;(function()&#123;</span><br><span class="line">let now&#x3D;0;</span><br><span class="line">return &#123;</span><br><span class="line"> doAdd:function()&#123;</span><br><span class="line">    now++;</span><br><span class="line">    console.log(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">add.doAdd() &#x2F;&#x2F;1</span><br><span class="line">add.doAdd() &#x2F;&#x2F;2</span><br><span class="line">add.doAdd() &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">now 这个变量，并没有随着函数的执行完毕而被回收，</span><br><span class="line">而是继续保存在内存里面。</span><br><span class="line"></span><br><span class="line">由于 add 里面有函数是依赖于 now 这个变量。所以 now 不会被销毁，回收。</span><br><span class="line">由于 now 在外面访问不到</span><br><span class="line"></span><br><span class="line"> var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于方法里有this.name, 这里的this的是window，所以这里是The Window</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that &#x3D; this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line">　　</span><br><span class="line">&#x2F;&#x2F; 这里的that指向object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(typeof Array.isArray&#x3D;&#x3D;&#x3D;&quot;undefined&quot;)&#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg)&#123;</span><br><span class="line">        return Object.prototype.toString.call(arg)&#x3D;&#x3D;&#x3D;&quot;[object Array]&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="找出数组中的最大值"><a href="#找出数组中的最大值" class="headerlink" title="找出数组中的最大值"></a>找出数组中的最大值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;Math.max.apply(null,a);</span><br><span class="line">console.log(max);</span><br><span class="line">&#x2F;&#x2F;第二种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;eval(&#39;Math.max(&#39;+a.toString()+&#39;)&#39;);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">Math.max(...[-1, 5, 11, 3])</span><br><span class="line"> Math.max.apply(Math, [-1, 5, 11, 3])</span><br></pre></td></tr></table></figure>

<h1 id="Javascript的this用法"><a href="#Javascript的this用法" class="headerlink" title="Javascript的this用法"></a>Javascript的this用法</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">链接</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yangbingbinga/article/details/61424363">链接2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this是Javascript语言的一个关键字。</span><br><span class="line"></span><br><span class="line">它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</span><br><span class="line"></span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window</p>
<p>问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢?</p>
<p>用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针!</p>
<p>也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  test: function() &#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(this.a);</span><br><span class="line">    &#125;.bind(this), 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.test();  &#x2F;&#x2F;  2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setTimeout不止两个参数</span><br><span class="line">setTimeout(function(a, b)&#123;</span><br><span class="line">  console.log(a);   &#x2F;&#x2F; 3</span><br><span class="line">  console.log(b);   &#x2F;&#x2F; 4</span><br><span class="line">&#125;,0, 3, 4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">箭头函数比较特殊，没有自己的this，它使用封闭执行上下文(函数或是global)的 this 值。</span><br><span class="line"></span><br><span class="line">var x&#x3D;11;</span><br><span class="line">var obj&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say:()&#x3D;&gt;&#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();&#x2F;&#x2F; 11</span><br><span class="line">obj.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 11</span><br><span class="line">x &#x3D; 14</span><br><span class="line">obj.say() &#x2F;&#x2F; 14</span><br><span class="line">&#x2F;&#x2F;对比一下</span><br><span class="line">var obj2&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say() &#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.say();&#x2F;&#x2F; 22</span><br><span class="line">obj2.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 13</span><br></pre></td></tr></table></figure>

<h3 id="一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global"><a href="#一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global" class="headerlink" title="一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global"></a>一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global</h3><p>在严格模式下，默认绑定会将 this 指向 undefined</p>
<h3 id="二、作为对象方法的调用-this就指这个上级对象"><a href="#二、作为对象方法的调用-this就指这个上级对象" class="headerlink" title="二、作为对象方法的调用    this就指这个上级对象"></a>二、作为对象方法的调用    this就指这个上级对象</h3><h3 id="三-作为构造函数调用"><a href="#三-作为构造函数调用" class="headerlink" title="三 作为构造函数调用"></a>三 作为构造函数调用</h3><p>   所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
<h3 id="四-apply调用"><a href="#四-apply调用" class="headerlink" title="四 apply调用"></a>四 apply调用</h3><p>  this指的就是这第一个参数。<br>  apply()的参数为空时，默认调用全局对象。</p>
<h3 id="五-this指向绑定事件的dom元素"><a href="#五-this指向绑定事件的dom元素" class="headerlink" title="五 this指向绑定事件的dom元素"></a>五 this指向绑定事件的dom元素</h3><p>document.querySelector(“#id”).onclick =function(){<br>    this == document.querySelector(“#id”)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(!(&quot;a&quot; in window))&#123;</span><br><span class="line">    var a &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; window.hasOwnProperty(&quot;a&quot;) &#x3D;&#x3D;&#x3D; true ..</span><br><span class="line">&#x2F;&#x2F;不用多说了. a 还真存在原型链上</span><br><span class="line">&#x2F;&#x2F; 值是 Location 这个 API 的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">console.log(typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; true , 这个不用解释了</span><br><span class="line"></span><br><span class="line">console.log(!!typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及到就是优先级和布尔值的问题</span><br><span class="line">&#x2F;&#x2F; typeof count 就是字符串&quot;number&quot;</span><br><span class="line">&#x2F;&#x2F; !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true</span><br><span class="line">&#x2F;&#x2F; 最后才&#x3D;&#x3D;&#x3D; 比较 , true &#x3D;&#x3D;&#x3D; &quot;number&quot; , return false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var a &#x3D; b &#x3D; 3;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(typeof a &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(&#x3D;号自左向右)</span><br><span class="line">&#x2F;&#x2F; 那个函数可以拆成这样</span><br><span class="line"></span><br><span class="line">(function()</span><br><span class="line">  var a; &#x2F;* 局部变量,外部没法访问*&#x2F;</span><br><span class="line">  b &#x3D; 3; &#x2F;* 全局变量,so . window.b &#x3D;&#x3D;&#x3D; 3 , 外部可以访问到*&#x2F;</span><br><span class="line">  a &#x3D; b;</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 注意a只有在闭包里才能访问(a&#x3D;3)，在外部是undefined  !!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若是改成这样,这道题应该是对的</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D;3</span><br><span class="line">); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">  this.a &#x3D; something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(2)</span><br><span class="line"></span><br><span class="line">console.log(obj1.a) &#x2F;&#x2F; 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2,3); &#x2F;&#x2F; 用 call 强行改变上下文为 obj2内</span><br><span class="line">console.log(obj2.a); &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">var  bar &#x3D; new obj1.foo(4); &#x2F;&#x2F; 这里产生了一个实例</span><br><span class="line">console.log(obj1.a); &#x2F;&#x2F; 2</span><br><span class="line">console.log(bar.a); &#x2F;&#x2F; 4;  new的绑定比隐式和显式绑定优先级更高</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-设计模式你了解多少"><a href="#Q-设计模式你了解多少" class="headerlink" title="Q: 设计模式你了解多少"></a>Q: 设计模式你了解多少</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cnblogs.com&#x2F;tugenhua0707&#x2F;p&#x2F;5198407.html</span><br></pre></td></tr></table></figure>

<h1 id="Q-JS-的基本数据类型有哪些"><a href="#Q-JS-的基本数据类型有哪些" class="headerlink" title="Q: JS 的基本数据类型有哪些"></a>Q: JS 的基本数据类型有哪些</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line">Undefined</span><br><span class="line">Null</span><br><span class="line">Number</span><br><span class="line">Boolean</span><br><span class="line">String</span><br><span class="line">Symbol (ECMAScript 6 新定义)</span><br><span class="line"></span><br><span class="line"> 5 种原始类型即</span><br><span class="line"> Undefined</span><br><span class="line"> Null</span><br><span class="line"> Number</span><br><span class="line"> Boolean</span><br><span class="line"> String</span><br><span class="line"></span><br><span class="line"> 除了Object和Symbol不是，其他都是</span><br></pre></td></tr></table></figure>

<h1 id="Q-null-和-undefined-的差异"><a href="#Q-null-和-undefined-的差异" class="headerlink" title="Q: null 和 undefined 的差异"></a>Q: null 和 undefined 的差异</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">大体说一下,想要知其所以然请引擎搜索</span><br><span class="line"></span><br><span class="line">相同点:</span><br><span class="line"></span><br><span class="line">在 if 判断语句中,值都默认为 false</span><br><span class="line">大体上两者都是代表 无 ,具体看差异</span><br><span class="line">差异:</span><br><span class="line"></span><br><span class="line">null 转为数字类型值为0,而 undefined 转为数字类型为 NaN(Not a Number)</span><br><span class="line">undefined 是代表调用一个值而该值却没有赋值,这时候默认则为 undefined</span><br><span class="line">null 是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)</span><br><span class="line">设置为 null 的变量或者对象会被内存收集器回收</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-清除浮动的方式有哪些-比较好的是哪一种"><a href="#Q-清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="Q: 清除浮动的方式有哪些?比较好的是哪一种"></a>Q: 清除浮动的方式有哪些?比较好的是哪一种</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">常用的一般为三种 .clearfix , clear:both , overflow:hidden ;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  content:&quot;&quot;;&#x2F;&#x2F;设置内容为空</span><br><span class="line">　height:0;&#x2F;&#x2F;高度为0</span><br><span class="line">　line-height:0;&#x2F;&#x2F;行高为0</span><br><span class="line">　display:block;&#x2F;&#x2F;将文本转为块级元素</span><br><span class="line">　visibility:hidden;&#x2F;&#x2F;将元素隐藏</span><br><span class="line">　clear:both&#x2F;&#x2F;清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另一种写法</span><br><span class="line"></span><br><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line"> content:&quot;&quot;;</span><br><span class="line"> display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line"> clear:both;</span><br><span class="line"> overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;&#x2F;&#x2F; 为了兼容IE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">用display:table 是为了避免外边距margin重叠导致的margin塌陷,</span><br><span class="line">内部元素默认会成为 table-cell 单元格的形式</span><br><span class="line">--&gt;</span><br><span class="line">clear:both :若是用在同一个容器内相邻元素上,那是贼好的...有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</span><br><span class="line"></span><br><span class="line">overflow:hidden :这种若是用在同个容器内,可以形成 BFC 避免浮动造成的元素塌陷</span><br></pre></td></tr></table></figure>

<h1 id="Q-跨域问题"><a href="#Q-跨域问题" class="headerlink" title="Q: 跨域问题"></a>Q: 跨域问题</h1><p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/21976">详情</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">我一般用这三种, cors , nginx反向代理 , jsonp</span><br><span class="line"></span><br><span class="line">jsonp : 单纯的 get 一些数据,局限性很大...就是利用script标签的src属性来实现跨域。</span><br><span class="line"></span><br><span class="line">浏览器支持好</span><br><span class="line">调用失败不会返回各种HTTP状态码</span><br><span class="line">给后端传json格式的数据会报415错误，请求格式不正确</span><br><span class="line">callback添加恶意script标签，造成xss漏洞</span><br><span class="line">只能够实现get请求</span><br><span class="line">参数可见</span><br><span class="line"></span><br><span class="line">nginx 反向代理 : 主要就是用了 nginx.conf 内的 proxy_pass http:&#x2F;&#x2F;xxx.xxx.xxx</span><br><span class="line">,会把所有请求代理到那个域名,有利也有弊吧..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cors</span><br><span class="line"></span><br><span class="line">可控性较强,需要前后端都设置,兼容性 IE10+ ,</span><br><span class="line">CORS需要浏览器和服务器同时支持。IE8+：IE8&#x2F;9需要使用XDomainRequest对象来支持CORS。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example &#x2F;&#x2F; 子域乃至整个域名或所有域名是否允许访问</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS &#x2F;&#x2F; 允许那些行为方法</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type &#x2F;&#x2F; 允许的头部字段</span><br><span class="line">Access-Control-Max-Age: 86400 &#x2F;&#x2F; 有效期</span><br><span class="line">cros 的配置不仅仅这些,还有其他一些,具体引擎吧....</span><br><span class="line"></span><br><span class="line">若是我们要用 nginx 或者 express 配置 cors 应该怎么搞起? 来个简易版本的</span><br><span class="line"></span><br><span class="line">nginx</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   # 检查域名后缀</span><br><span class="line">    add_header Access-Control-Allow-Origin xx.xx.com;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;</span><br><span class="line">    add_header Access-Control-Max-Age 86400;</span><br><span class="line">&#125;</span><br><span class="line">express, 当然这货也有一些别人封装好的 cors 中间件,操作性更强...</span><br><span class="line">let express &#x3D; require(&#39;express&#39;);  </span><br><span class="line">let app &#x3D; express();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置所有请求的头部</span><br><span class="line">app.all(&#39;*&#39;, (req, res, next) &#x3D;&gt;  &#123;  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  </span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br><span class="line">有些还会跟你死磕,,除了这些还有其他姿势么...我说了一个HTML5的 postMessage ....</span><br><span class="line"></span><br><span class="line">..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下</span><br><span class="line"></span><br><span class="line">这货用于 iframe 传递消息居多, 大体有这么两步步</span><br><span class="line"></span><br><span class="line">window 打开一个实例,传递一个消息到一个x域名</span><br><span class="line">x 域名下监听 message 事件,获取传递的消息</span><br><span class="line">这货的兼容性没那么好,而且没考虑周全的下容易遭受 CSRF 攻击</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-对于XSS-和-CSRF-如何防范"><a href="#Q-对于XSS-和-CSRF-如何防范" class="headerlink" title="Q: 对于XSS 和 CSRF 如何防范"></a>Q: 对于XSS 和 CSRF 如何防范</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> XSS主要是指跨脚本攻击, 其实就相当于执行js脚本.</span><br><span class="line"></span><br><span class="line">XSS的防范</span><br><span class="line"></span><br><span class="line">1. 验证用户输入的内容, 是否符合规则.</span><br><span class="line">2. 转义 &lt;&gt; 造成代码直接运行的的标签..</span><br><span class="line">    轮询或者正则替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而面试官说这种的效率最低下,找相关资料</span><br><span class="line">若是有用到 cookie ,设置为 http-only ,避免客户端的篡改</span><br><span class="line"></span><br><span class="line">CSP(Content Security Policy)</span><br><span class="line">以白名单的机制对网站加载或执行的资源起作用。</span><br><span class="line">在网页中，这样的策略通过 HTTP 头信息或者 meta</span><br><span class="line">元素定义。CSP虽然提供了强大的安全保护，</span><br><span class="line">但是他也造成了如下问题：Eval及相关函数被禁用、</span><br><span class="line">内嵌的JavaScript代码将不会执行、</span><br><span class="line">只能通过白名单来加载远程脚本。</span><br><span class="line"></span><br><span class="line">CSRF跨域假冒请求</span><br><span class="line"></span><br><span class="line">有3个特性: 跨域, cookie, 请求方式.</span><br><span class="line">CSRF的防范一般这几种</span><br><span class="line"></span><br><span class="line">验证码,用户体验虽然不好,</span><br><span class="line">验证 HTTP Referer 字段,判断请求来源</span><br><span class="line">token加密解密 ,前端和后台双方协定一个token内容</span><br><span class="line"></span><br><span class="line">尽量使用JSON类型传输</span><br><span class="line">    form 传输的格式为:</span><br><span class="line">    Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">    而,JSON的传输类型为:</span><br><span class="line">    Content-Type: application&#x2F;json form</span><br><span class="line">    没有办法去模仿JSON类型进行传输</span><br><span class="line"></span><br><span class="line">DNS劫持, 事实上更偏向于User</span><br><span class="line">    developer实际上对这个也无能为力。</span><br><span class="line"></span><br><span class="line">HTTP(ISP) 劫持</span><br><span class="line">    使用HTTPS 加密方式传输</span><br><span class="line">    替换你的js的提供商，使用HTTPS路径进行加载。</span><br><span class="line"></span><br><span class="line">验证码造成的体验不好,</span><br><span class="line">token 滥用造成的性能问题,轮询替换造成的响应时间等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-谈谈你对-Promise-的理解-和-ajax-有关系么"><a href="#Q-谈谈你对-Promise-的理解-和-ajax-有关系么" class="headerlink" title="Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么"></a>Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么</h1><p><a target="_blank" rel="noopener" href="http://imweb.io/topic/57a0760393d9938132cc8da9">链接</a></p>
<p>promise 是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>异步操作队列化，比传统的异步操作回调函数和事件更合理更强大。</p>
<p>能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p>
<p>==Promise对象三种状态：==</p>
<p>Pending（进行中）<br>Fulfilled（已完成，又称为Resolved）<br>Rejectd（已失败）</p>
<p>一些需要注意的小点,如下</p>
<p>在 Pending 转为另外两种之一的状态时候,状态不可在改变..</p>
<p>Promise 的 then 为异步.而( new Promise() )构造函数内为同步</p>
<p>Promise 的 catch 不能捕获任意情况的错误(比如 then 里面的 setTimout 内手动抛出一个 Error )</p>
<p>Promise 的 resolve 若是传入值而非函数,会发生值穿透的现象</p>
<p>Promise 还有一些自带的方法,比如 race , all ,前者有任一一个解析完毕就返回,后者所有解析完毕返回…</p>
<p>==Promise 方法：==</p>
<p>then： 用链式调用的方式执行回调函数。通过 resolve 方法把 Promise 的状态置为完成态（Resolved），这时 then 方法就能捕捉到变化，并执行“成功”情况的回调。<br>then方法返回的是一个新的Promise实例</p>
<p>reject： 把 Promise 的状态置为已失败（Rejected），这时 then 方法执行“失败”情况的回调</p>
<p>catch：和 then 的第二个参数一样，用来指定 reject 的回调   当执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么也不会报错卡死 js，而是会进到这个 catch 方法中。</p>
<p>all:  提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p>
<ul>
<li><p>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。</p>
</li>
<li><p>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
</li>
</ul>
<p>race:只要有一个异步操作执行完毕，就立刻执行 then 回调。<br>注意：其它没有执行完毕的异步操作仍然会继续执行，而不是停止。</p>
<h3 id="Promise对象两个特点"><a href="#Promise对象两个特点" class="headerlink" title="Promise对象两个特点"></a>Promise对象两个特点</h3><ol>
<li><p>对象状态只由异步操作结果决定。resolve方法会使Promise对象由pendding状态变为fulfilled状态；reject方法或者异常会使得Promise对象由pendding状态变为rejected状态。Promise状态变化只有上图这两条路径。</p>
</li>
<li><p><strong>对象状态一旦改变，任何时候都能得到这个结果。</strong> 即状态一旦进入fulfilled或者rejected，promise便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。</p>
</li>
<li><p>Promise构造方法接受一个方法作为参数，该方法传入两个参数，resolve和reject。</p>
</li>
<li><p>resolve用来将Promise对象的状态置为成功，并将异步操作结果value作为参数传给成功回调函数。</p>
</li>
<li><p>reject用来将Promise对象的状态置为失败，并将异步操作错误error作为参数传给失败回调函数。</p>
</li>
<li><p>then方法绑定两个回调函数，第一个用来处理Promise成功状态，第二个用来处理Promise失败状态。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Promise 和 ajax 没有直接关系. promise 只是为了解决&quot;回调地狱&quot;</span><br><span class="line">Promise 并不能消灭回调地狱，但是它可以使回调变得可控。</span><br><span class="line"></span><br><span class="line">异步回调的问题：</span><br><span class="line"></span><br><span class="line">嵌套层次深，难以维护</span><br><span class="line">无法正常使用return和catch throw</span><br><span class="line">多个回调之间难以建立联系，一个回调函数一旦开启，就无法对其操作</span><br><span class="line">无法正常索引堆栈信息</span><br><span class="line"></span><br><span class="line">从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... some code</span><br><span class="line">    if ( &#x2F;* 异步操作成功 *&#x2F; ) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">模拟回调函数</span><br><span class="line">function runAsync(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行完成&#39;);</span><br><span class="line">        callback(&#39;随便什么数据&#39;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getUserAdmin()</span><br><span class="line">    .then(getProjects)</span><br><span class="line">    .then(getModules)</span><br><span class="line">    .then(getInterfaces)</span><br><span class="line">    .then(procResult)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a>Promise 必知必会（十道题）</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a04066351882517c416715d">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># Generator 函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;cnodejs.org&#x2F;topic&#x2F;542953d42ca9451e1bf3c251)</span><br><span class="line"></span><br><span class="line">Generator 函数是一个普通函数，但是有两个特征。</span><br><span class="line"></span><br><span class="line">一是，function关键字与函数名之间有一个星号；</span><br><span class="line"></span><br><span class="line">二是，函数体内部使用yield语句，定义不同的内部状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br>}<br>var hw = helloWorldGenerator();</p>
<p>const gen = function* () {<br>  const f1 = yield readFile(‘/etc/fstab’);<br>  const f2 = yield readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>写成async函数，就是下面这样。</p>
<p>const asyncReadFile = async function () {<br>  const f1 = await readFile(‘/etc/fstab’);<br>  const f2 = await readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。<br>以后，每次调用遍历器对象的next方法，<br>就会返回一个有着value和done两个属性的对象。<br>value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；<br>done属性是一个布尔值，表示是否遍历结束。</p>
<p>上面已经介绍了说yield是暂停标志，下面对yield进行一些介绍：</p>
<p>（1）、yield后面的表达式只有当调用next时，才会执行yield后面的表达式。</p>
<p>（2）、yield表达式只能写在Generator函数中 ，而不能写在普通的函数中。</p>
<p>（3）、yield表达式如果与其他表达式相结合，必须写在()里面。</p>
<p>yield与return的异同点：</p>
<p>相同点：都可以返回紧跟后面表达式的值</p>
<p>不同点：<br>(a)、在一个函数内部只能存在一个return语句，而可以存在多个yield语句；<br>(b)、return没有记忆功能，在Generator函数中只有当遍历器对象调用next时<br>    才会返回yield后面表达式的值，<br>    当下一次调用时从上一条yield语句后开始执行，<br>    而return后面的表达式只要函数执行就立即返回。<br>(c)、正常函数只有一个返回值，而Generator函数可以有多个返回值。</p>
<p>Generator函数被执行时，返回的是指向函数内部的遍历器对象，<br>只有调用遍历器对象的next方法时，才会返回yield后面函数表达式的值，<br>但是，其实yield表达式的值一直都是undefined。<br>如果在Generator的函数中传递参数且存在多个yield表达式时，<br>那么调用next方法时就要注意传参了：<br>next()中传递的参数就是上一个yield表达式的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 面试题网站</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com)</span><br><span class="line"></span><br><span class="line"># 作用域</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数和变量的可访问范围。<br>作用域分为全局作用域  函数作用域和eval作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 原型</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dee9f8b14771)</span><br><span class="line"></span><br><span class="line">原型其实就是上述所说的继承中的父类。</span><br><span class="line"></span><br><span class="line">原型链 :利用原型串起一个继承链，让一个引用类型继承另一个引用类型的属性和方法，再以此类推下去.</span><br><span class="line">当一个引用类型继承另一个引用类型的属性和方法时候就会产生一个原型连。</span><br><span class="line">当某个函数当成构造函数来调用时，就会产生一个构造函数的实例。这个实例上会拥有一个 __proto__ 属性，这个属性指向该实例的构造函数的原型对象(也可以称为该实例的原型对象)。</span><br><span class="line"></span><br><span class="line">定律：</span><br><span class="line"></span><br><span class="line">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line"></span><br><span class="line">原型链是依赖于__proto__，而不是prototype</span><br><span class="line"></span><br><span class="line">**实例与原型**</span><br><span class="line"></span><br><span class="line">当读取实例的属性时，</span><br><span class="line">如果找不到，就会查找与对象关联的原型中的属性，</span><br><span class="line">如果还查不到，就去找原型的原型，一直找到最顶层为止。</span><br><span class="line"></span><br><span class="line">通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。</span><br><span class="line"></span><br><span class="line">在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。</span><br><span class="line"></span><br><span class="line"> var A &#x3D; new Person();</span><br><span class="line"> Person.prototype &#x3D; A;</span><br><span class="line"></span><br><span class="line">原型对象（Person.prototype）是 构造函数（Person）的一个实例。↓</span><br><span class="line"></span><br><span class="line">#### Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### person1.__proto__ &#x3D;&#x3D; Person.prototype</span><br><span class="line"></span><br><span class="line">实例的构造函数属性（constructor）指向构造函数。↓</span><br><span class="line"></span><br><span class="line">#### person1.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null</span><br><span class="line"></span><br><span class="line">#### person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### obj.__proto__ &#x3D;&#x3D; Object.getPrototypeOf(obj)</span><br><span class="line"></span><br><span class="line"> 原型和原型链是JS实现继承的一种模型。</span><br><span class="line">原型链的形成是真正是靠__proto__ 而非prototype</span><br><span class="line"></span><br><span class="line">## 什么是原型链</span><br><span class="line"></span><br><span class="line"> 由于__proto__是任何对象都有的属性，而js里万物皆对象，</span><br><span class="line"> 所以会形成一条__proto__连起来的链条，递归访问__proto__最终到头，并且值是null</span><br><span class="line"></span><br><span class="line"> 当js引擎查找对象属性时，先查找对象本身是否存在该属性，</span><br><span class="line"> 如果不存在，会在原型链上查找，但不会查找自身的prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>var A = function()&#123;&#125;;
var a = new A();
console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null</code></pre>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>actions<br>assets<br>components<br>reducers<br>store<br>views<br>index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># prototype问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function Foo() {<br>    getName = function () { alert (1); };<br>    return this;<br>}<br>Foo.getName = function () { alert (2);};<br>Foo.prototype.getName = function () { alert (3);};<br>var getName = function () { alert (4);};<br>function getName() { alert (5);}</p>
<p>//请写出以下输出结果：<br>Foo.getName();<br>getName();<br>Foo().getName();<br>getName();<br>new Foo.getName();<br>new Foo().getName();<br>new new Foo().getName();</p>
<p>//答案：<br>Foo.getName();//2<br>getName();//4<br>Foo().getName();//1<br>getName();//1<br>new Foo.getName();//2<br>new Foo().getName();//3<br>new new Foo().getName();//3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># var和函数的提前声明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function fn(a) {<br>  console.log(a);<br>  var a = 2;<br>  function a() {}<br>  console.log(a);<br>}</p>
<p>fn(1);<br>　　输出：function  a() {} 2<br>　　<br>　　<br>我们知道var和function是会提前声明的，<br>而且function是优先于var声明的（如果同时存在的话），<br>所以提前声明后输出的a是个function，<br>然后代码往下执行a进行重新赋值了，故第二次输出是2。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zichi/p/4359786.html">http://www.cnblogs.com/zichi/p/4359786.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># javascript实现将多个有序数组合并为一个有序数组的算法</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010302469)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let ret=arr.reduce((arr1,arr2)=&gt;arr1.concat(arr2)).sort((a,b)=&gt;a-b);<br>ret=Array.from(new Set(ret));<br>console.log(ret);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># new操作符具体干了什么呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1、创建一个新对象<br>2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）<br>3、执行构造函数中的代码（为这个新对象添加属性）<br>4、返回新对象</p>
<p>var obj  = {};<br>obj.<strong>proto</strong> = Base.prototype;<br>Base.call(obj);</p>
<p>创建一个新对象foo；</p>
<p>并将它的<strong>proto__指向其构造函数的prototype，<br>foo.__proto</strong> = Foo.prototype;</p>
<p>动态将this指向新对象，Foo.apply(foo，arguments);</p>
<p>执行函数体中的代码；</p>
<p>放回新对象foo;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 怎么画一条0.5px的边</span><br><span class="line"></span><br><span class="line">[链接：](https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5ab65f40f265da2384408a95)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过直接设置宽高border为0.5px、<br>设置box-shadow的垂直方向的偏移量为0.5px、<br>借助线性渐变linear-gradient、<br>使用transform: scaleY(0.5)的方法，<br>使用SVG的方法。<br>最后发现transfrom scale/svg的方法兼容性和效果都是最好的，<br>svg可以支持复杂的图形，<br>所以在viewport是1的情况下，<br>可以使用transform/SVG画0.5px，<br>而如果viewport的缩放比例不是1的话，那么直接画1px即可。</p>
<p>.hairline-border {<br>  box-shadow: 0 0 0 1px;<br>}<br>@media (min-resolution: 2dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.5px;<br>  }<br>}<br>@media (min-resolution: 3dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.33333333px;<br>  }<br>}<br>@media (min-resolution: 4dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.25px;<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从 arguments 到剩余参数</span><br><span class="line"></span><br><span class="line">如果你想在 ES5 中让函数(或方法)接受任意数量的参数，必须使用特殊变量 arguments：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function logAllArguments() {<br>    for (var i=0; i &lt; arguments.length; i++) {<br>        console.log(arguments[i]);<br>    }<br>}</p>
<p>ES6 中则可以通过 … 运算符定义一个剩余参数(在下面示例中是args)：</p>
<p>function logAllArguments(…args) {<br>    for (const arg of args) {<br>        console.log(arg);<br>    }<br>}</p>
<p>如果有一部分固定参数，剩余参数就更适用了：</p>
<p>function format(pattern, …args) {<br>    ···<br>}</p>
<p>在 ES5 中处理同样的事情有点麻烦：</p>
<p>function format(pattern) {<br>    var args = [].slice.call(arguments, 1);<br>    ···<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</span><br><span class="line"></span><br><span class="line">[连接](https:&#x2F;&#x2F;github.com&#x2F;qiu-deqing&#x2F;FE-interview#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BB%A5http%E4%B8%BA%E4%BE%8B)</span><br><span class="line"></span><br><span class="line">1. 输入url</span><br><span class="line">2. 查看缓存</span><br><span class="line">3. 解析URL</span><br><span class="line">4. 组装HTTP请求报文</span><br><span class="line">5. 获取主机ip</span><br><span class="line">6. 建立tcp连接</span><br><span class="line">7. 发送http请求</span><br><span class="line">8. 服务器检查请求头信息</span><br><span class="line">9. 响应报文通过tcp返回</span><br><span class="line">10. 关闭tcp四次握手</span><br><span class="line">11. 检查状态码</span><br><span class="line">12. 缓存</span><br><span class="line">13. 解码</span><br><span class="line">14. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</span><br><span class="line">15. 显示页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器地址栏输入URL<br>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，<br>足够新鲜直接提供给客户端，否则与服务器进行验证。<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：<br>HTTP1.0提供Expires，<br>值为一个绝对时间表示缓存新鲜日期<br>HTTP1.1增加了Cache-Control: max-age,<br>值为以秒为单位的最大新鲜时间<br>浏览器解析URL获取协议，主机，端口，path<br>浏览器组装一个HTTP（GET）请求报文<br>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存</p>
<p>DNS递归查询（可能存在负载均衡导致每次IP不一样）<br>打开一个socket与目标IP地址，端口建立TCP链接，<br>三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z<br>TCP链接建立后发送HTTP请求</p>
<p>服务器接受请求并解析，将请求转发到服务程序，<br>如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
<p>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，<br>返回304等对应状态码<br>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作<br>服务器将响应报文通过TCP连接发送回浏览器<br>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，<br>关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</p>
<p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，<br>这些情况处理与2XX不同<br>如果资源可缓存，进行缓存<br>对响应进行解码（例如gzip压缩）</p>
<p>根据资源类型决定如何处理（假设资源为HTML文档）</p>
<p>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，<br>执行js脚本，这些操作没有严格的先后顺序，以下分别解释<br>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树<br>解析过程中遇到图片、样式表、js文件，启动下载<br>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</p>
<p>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，<br>不可见节点包括：<br>1）script,meta这样本身不可见的标签。<br>2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式<br>js解析如下：<br>浏览器创建Document对象并解析HTML，<br>将解析到的元素和文本节点添加到文档中，<br>此时document.readystate为loading</p>
<p>HTML解析器遇到没有async和defer的script时，<br>将他们添加到文档中，然后执行行内或外部脚本。<br>这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。<br>这样就可以用document.write()把文本插入到输入流中。<br>同步脚本经常简单定义函数和注册事件处理程序，<br>他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。<br>脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。<br>异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</p>
<p>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，<br>禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，<br>等这些内容完成载入并且所有异步脚本完成载入和执行，<br>document.readState变为complete,window触发load事件<br>显示页面（HTML解析过程中会逐步显示页面）</p>
<h1 id="浏览器渲染主要流程"><a href="#浏览器渲染主要流程" class="headerlink" title="浏览器渲染主要流程"></a>浏览器渲染主要流程</h1><p>HTML解析出DOM Tree<br>CSS解析出Style Rules<br>将二者关联生成Render Tree<br>Layout 根据Render Tree计算每个节点的信息<br>Painting 根据计算好的信息绘制整个页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Q: 网站性能优化</span><br><span class="line"></span><br><span class="line">[原文](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000013963213#articleHeader0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码层面优化：</p>
<p>一、加载和执行</p>
<pre><code>css方面

将样式表放到页面顶部
不使用CSS表达式
使用link不使用@import
不使用IE的Filter

Javascript方面

将脚本放到页面底部,body标签内底部
将javascript和css从外部引入
压缩javascript和css
删除不需要的脚本
减少DOM访问
合理设计事件监听器


图片方面

优化图片：根据实际颜色需要选择色深、压缩
优化css精灵
合并一些小图片( css sprite )压缩图片
图片转dataUrl
不要在HTML中拉伸图片
保证favicon.ico小并且可缓存
图片编码优化</code></pre>
<p>二、 数据存取<br>    - 尽量使用字面量和局部变量<br>        （局部变量在方法运行过后会自行释放，用完手动置为null或undefined也行），<br>        减少使用对象和数组,</p>
<p>三、 DOM编程**（常见的性能瓶颈）<br>    - 最坏的方式就是在循环中操作或者访问DOM，非常消耗性能。<br>    减少DOM数量<br>    - 遍历dom<br>        querySelectorAll()是获取元素最快的API 返回的是一个NodeList<br>        querySelector() 返回的是element,<br>        querySelectorAll()还有一点就是可以同时获取两类元素</p>
<pre><code>- 重绘和重排都是代价昂贵；尽量减少
    重排何时发生：
    1.添加或删除可见DOM元素
    2.元素位置改变
    3.元素尺寸改变（内外边距、边框厚宽高等）
    4.内容改变 （内容导致尺寸变化的时候）
    5.页面渲染器初始化
    6.浏览器窗口尺寸变化</code></pre>
<p>四、 算法和流程控制<br>    - 循环<br>        (当循环体复杂度为X时，优化方案优先减少循环体的复杂度，<br>        循环体复杂度大于X时，优化方案优先减少迭代次数 )<br>    - 条件语句<br>        当条件较少时 使用if-else更易读，<br>        而当条件较多时if-else性能负担比switch大，易读性也没switch好。<br>        优化if-else的方法是：尽可能的把可能出现的条件放在首位，</p>
<p>五、 字符串和正则表达式<br>    - 字符串<br>        join是比较快的，也是大量字符串拼接的唯一高效方式</p>
<p>六、 快速响应的用户界面<br>    - 浏览器UI线程<br>        浏览器限制JavaScript任务的运行时间，限制两分钟，<br>        可以防止恶意代码不断执行来锁定你的浏览器</p>
<pre><code>    单个JavaScript操作的花费总时间应该小于等于100ms，
    这就意味着在100ms内响应用户的操作，不然就会让用户感受到迟钝感

- 定时器让出时间片断
    使用时间戳计算获得程序运行时间，
    以便快速找到运行时间较长的代码部分进行优化</code></pre>
<p>七、 Ajax<br>    - 数据传输<br>        数据的传输同样影响性能<br>    - 数据格式<br>    - Ajax性能<br>        避免不必要的请求：<br>        使Ajax可缓存：服务端设置HTTP头信息确保响应会被浏览器缓存<br>        客户端讲获取的信息存到本地避免再次请求<br>        （localstorage sessionstorage cookice）<br>        设置HTTP头信息，expiresgaosu告诉浏览器缓存多久<br>        减少HTTP请求，合并css、js、图片资源文件等或使用MXHR<br>        通过次要文件用Ajax获取可缩短页面加载时间</p>
<pre><code>    减小cookie大小
    引入资源的域名不要包含cookie</code></pre>
<p>八、编程实践<br>    - 避免双重求值<br>        eval()、Function慎用，<br>        定时器第一个参数建议函数而不是字符串都能避免字符串双重求值<br>    - 使用对象或者数组直接量<br>    - 避免重复工作<br>        A:延迟加载（懒加载）<br>        B:条件预加载<br>    - 使用JavaScript速度快的部分<br>        A.位操作<br>        B.原生方法，首先原生方法是最快的，而且浏览器会缓存部分原生方法<br>        C.复杂计算时多使用Math对象<br>        D.querySelector和querySelectorAll是查询最快的</p>
<p> 九、 构建并部署高性能JavaScript应用<br>    1.合并多个js文件<br>    2.预处理js文件<br>    3.js压缩<br>    4.js的HTTP压缩<br>    5.缓存js文件<br>    6.处理缓存问题<br>    7.使用内容分发网络（CDN）</p>
<p>移动方面</p>
<pre><code>保证组件小于25k
Pack Components into a Multipart Document

content方面

按需加载资源
非必须组件延迟加载
未来所需组件预加载
    在网站 HTML 中的链接属性上增加
    rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记。

将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
减少iframe数量
不要404

Server方面

使用CDN
减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。
方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
避免重定向：多余的中间访问
用dns-prefetch

&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//mat1.gtimg.com&quot;&gt;

动静分离
使用nginx的反向代理，对静态资源的请求直接nginx处理，或放到CDN
动态请求转发给tomcat处理

添加Expires或者Cache-Control响应头
对组件使用Gzip压缩
    Brotli 是一个比较新的文件压缩算法，目前正变得越来越受欢迎。
配置ETag
Flush Buffer Early
Ajax使用GET进行请求
避免空src的img标签</code></pre>
<p>十、 工具</p>
<pre><code>若是打包的代码尽可能切割成多个 chunk ,减少单一 chunk 过大
HTTP的缓存头使用的合理
减小第三方库的依赖
对于代码应该考虑性能来编写,比如使用 requestAnimationFrame 绘制动画,尽可能减少页面重绘(DOM 改变)
渐进升级,引入 preload 这些预加载资源
看情况用 server worker 来缓存资源(比如移动端打算搞 PWA)
比如从服务端着手:

带宽,域名解析, 多域名解析等
使用负载均衡方案 多节点部署
页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)
渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)
当然,这是这些都是很片面的点到...实际工作中去开展要复杂的多;


使用索引加速数据库查询
页面静态化CMS</code></pre>
<p>多个维度考虑,优化 DOM 绘制时间,资源加载时间,域名解析这些;</p>
<p>要全面的优化一个项目是一个大工程…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 优雅降级和渐进增强</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优雅降级：<br>Web站点在所有新式浏览器中都能正常工作，<br>如果用户使用的是老式浏览器，<br>则代码会检查以确认它们是否能正常工作。<br>针对不同版本的hack为那些无法支持功能的<br>浏览器增加候选方案，<br>使之在旧式浏览器上以某种形式降级体验<br>却不至于完全失效.</p>
<p>渐进增强：<br>从被所有浏览器支持的基本功能开始，<br>逐步地添加那些只有新式浏览器才支持的功能,<br>向页面增加无害于基础浏览器的<br>额外样式和功能的。<br>当浏览器支持时，<br>它们会自动地呈现出来并发挥作用。</p>
<p>保证所有人都能访问页面的基本内容和功能<br>同时为高级浏览器和高带宽用户提供<br>更好的用户体验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># js控制css3动画</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开始事件 AnimationStart<br>结束事件 AnimationEnd<br>重复运动事件 AnimationIteration  每次开始动画迭代都触发animationiteration</p>
<p>W3c标准：animationstart animationiteration animationend<br>Webkit：webkitAnimationStart webkitAnimationIteration webkitAnimationEnd<br>Firefox：animationstart animationiteration animationend<br>Opera：animationstart animationiteration animationend<br>IE10：MSAnimationStart MSAnimationIteration MSAnimationEnd</p>
<p>var e = document.getElementById(“left1”);  </p>
<p>e.addEventListener(“animationend”, function() {<br>    alert(‘css3运动结束！’);<br>});  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Object循环key</span><br><span class="line"></span><br><span class="line">- for...in循环：只遍历对象自身的和继承的可枚举的属性。</span><br><span class="line">    通常用for in来遍历对象的键名</span><br><span class="line">    for in更适合遍历对象，不要使用for in遍历数组。</span><br><span class="line"></span><br><span class="line">for in 循环会把数组其他扩展方法也循环</span><br><span class="line"></span><br><span class="line">- for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</span><br><span class="line"></span><br><span class="line">for-of循环是遍历实现iterator接口的成员</span><br><span class="line"></span><br><span class="line">只要是一个对象部署了Symbol.interator接口，就可以用for...of遍历该对象，同时也可以调用该接口的Symbol.interator方法调用next()方法对对象进行遍历，不同的是for..of是对该对象的值的输出，而next()返回的是对象。</span><br><span class="line"></span><br><span class="line">在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</span><br><span class="line"></span><br><span class="line">- Object.keys()：返回对象自身的所有可枚举的属性的键名。</span><br><span class="line">- JSON.stringify()：只串行化对象自身的可枚举的属性。</span><br><span class="line">- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;for...in循环出的是key，for...of循环出的是value&#x3D;&#x3D;</span><br><span class="line">- &#x3D;&#x3D;for...of不能循环普通的对象，需要通过和Object.keys()搭配使用&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">如果实在想用for...of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组</span><br><span class="line">然后遍历：</span><br><span class="line"></span><br><span class="line">## 结论</span><br><span class="line"></span><br><span class="line">1. 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。</span><br><span class="line"></span><br><span class="line">2. for...in循环出的是key，for...of循环出的是value</span><br><span class="line"></span><br><span class="line">3. 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足</span><br><span class="line"></span><br><span class="line">4. for...of不能循环普通的对象，需要通过和Object.keys()搭配使用</span><br><span class="line"></span><br><span class="line">记忆jueqiao :</span><br><span class="line"></span><br><span class="line">已核对 偶数v</span><br><span class="line"></span><br><span class="line">in h（k）对象  o 数组 value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组<br>然后遍历：</p>
<p>var student={<br>    name:’wujunchuan’,<br>    age:22,<br>    locate:{<br>    country:’china’,<br>    city:’xiamen’,<br>    school:’XMUT’<br>    }<br>}<br>for(var key of Object.keys(student)){<br>    //使用Object.keys()方法获取对象key的数组<br>    console.log(key+”: “+student[key]);<br>}</p>
<p>for in 可以遍历到myObject的原型方法method,<br>如果不想遍历原型方法和属性的话，<br>可以在循环内部判断一下,<br>hasOwnPropery方法可以判断<br>某属性是否是该对象的实例属性</p>
<p>for (var key in myObject) {<br>　　if（myObject.hasOwnProperty(key)){<br>　　　　console.log(key);<br>　　}<br>}</p>
<pre><code></code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-26T13:42:02.000Z" title="2018-04-26T13:42:02.000Z">2018-04-26</time>发表</span><span class="level-item"><time dateTime="2018-11-29T13:42:02.000Z" title="2018-11-29T13:42:02.000Z">2018-11-29</time>更新</span><span class="level-item">2 小时读完 (大约15098个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/React%20%E5%92%8CVue/">React和Vue</a></h1><div class="content"><h1 id="在jsx文件中为什么一定要引用react"><a href="#在jsx文件中为什么一定要引用react" class="headerlink" title="在jsx文件中为什么一定要引用react"></a>在jsx文件中为什么一定要引用react</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JSX 语法就是用React.createElement()来构建 React 元素的。</span><br><span class="line">它接受三个参数，第一个参数可以是一个标签名。</span><br><span class="line">如div、span，或者 React 组件。</span><br><span class="line">第二个参数为传入的属性。</span><br><span class="line">第三个以及之后的参数，皆作为组件的子组件。</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement()</span><br><span class="line"></span><br><span class="line">React.cloneElement()与React.createElement()相似，</span><br><span class="line">不同的是它传入的第一个参数是一个 React</span><br><span class="line">元素，而不是标签名或组件。</span><br><span class="line">新添加的属性会并入原有的属性，</span><br><span class="line">传入到返回的新元素中，而就的子元素奖杯替换。</span><br><span class="line"></span><br><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h1><p>React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。</p>
<h2 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass()"></a>React.createClass()</h2><p>React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Greeting &#x3D; React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h2><p>ES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Greeting extemds React.Component&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="无状态函数"><a href="#无状态函数" class="headerlink" title="无状态函数"></a>无状态函数</h1><p>无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。</p>
<h1 id="元素与组件的区别"><a href="#元素与组件的区别" class="headerlink" title="元素与组件的区别"></a>元素与组件的区别</h1><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="componentWillReceiveProps应用场景"><a href="#componentWillReceiveProps应用场景" class="headerlink" title="componentWillReceiveProps应用场景"></a>componentWillReceiveProps应用场景</h1><p>如果子组件需要的数据是直接由父组件通过props传递过来就不需要在componentwillreceiveprops中setState，但是如果子组件有自己的状态，同时这个状态依赖于父组件的数据，那么就需要子组件单独进行setState操作，否则无法完成子组件的更新。同时有一点，在componentwillreceiveprops中写setState不会再次触发子组件的render。解释一下：父组件setState时会触发子组件的render，此时如果在子组件的componentwillreceiveprops里setState，给人的感觉是会再一次触发子组件的render（加上前面的一次就是两次），实际情况是不会的</p>
<h1 id="vuex和redux使用有什么不同"><a href="#vuex和redux使用有什么不同" class="headerlink" title="vuex和redux使用有什么不同"></a>vuex和redux使用有什么不同</h1><p>Vuex 其实是一个针对 Vue 特化的 Flux，主要是为了配合 Vue 本身的响应式机制。当然吸取了一些 Redux 的特点，比如单状态树和便于测试和热重载的 API，但是也选择性的放弃了一些在 Vue 的场景下并不契合的特性，比如强制的 immutability（在保证了每一次状态变化都能追踪的情况下强制的 immutability 带来的收益就很有限了）、为了同构而设计得较为繁琐的 API、必须依赖第三方库才能相对高效率地获得状态树的局部状态等等（相比之下 Vuex 直接用 Vue 本身的计算属性就可以）所以 Vue + Vuex 会更简洁，也不需要考虑性能问题，代价就是 Vuex 只能和 Vue 配合。Vue + Redux 也不是不可以，但是 Redux 作为一个泛用的实现和 Vue 的契合度肯定不如 Vuex。</p>
<h1 id="nextTick的作用，原理，用api的场景"><a href="#nextTick的作用，原理，用api的场景" class="headerlink" title="nextTick的作用，原理，用api的场景"></a>nextTick的作用，原理，用api的场景</h1><p>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</p>
<p>也许有人会问，我在 Vue 实例方法中修改了数据，然后再在 $nextTick 回调中获取该数据在相应 DOM 元素所绑定的内容（或属性）殊无必要，我为什么需要这样的 API 呢？</p>
<p>考虑这样一种场景，你有一个 jQuery 插件，希望在 DOM 元素中某些属性发生变化之后重新应用该插件，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。</p>
<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</p>
<p>原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。</p>
<p>当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    example: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; modify data</span><br><span class="line">      this.message &#x3D; &#39;changed&#39;</span><br><span class="line">      &#x2F;&#x2F; DOM is not updated yet</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; DOM is now updated</span><br><span class="line">        &#x2F;&#x2F; &#96;this&#96; is bound to the current instance</span><br><span class="line">        this.doSomethingElse()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</p>
<h1 id="vue的props，state-compute区别"><a href="#vue的props，state-compute区别" class="headerlink" title="vue的props，state, compute区别"></a>vue的props，state, compute区别</h1><p>data: Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。</p>
<p>props: 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
<p>两个的区别就是data是响应式的？</p>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p>注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>
<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。</p>
<h1 id="react-native-和原生的怎么通信"><a href="#react-native-和原生的怎么通信" class="headerlink" title="react native 和原生的怎么通信"></a>react native 和原生的怎么通信</h1><h1 id="pure-component"><a href="#pure-component" class="headerlink" title="pure component"></a>pure component</h1><p>React15.3中新加了一个 PureComponent 类， 也就是纯组件，取代其前身 PureRenderMixin , PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，</p>
<p>可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。</p>
<h1 id="React-Native-与-原生交互"><a href="#React-Native-与-原生交互" class="headerlink" title="React Native 与 原生交互"></a>React Native 与 原生交互</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41dd77a83c13">链接</a></p>
<h1 id="vue-js-和vue-runtime-js区别"><a href="#vue-js-和vue-runtime-js区别" class="headerlink" title="vue.js 和vue.runtime.js区别"></a>vue.js 和vue.runtime.js区别</h1><p>vue.js</p>
<p>完整版：同时包含编译器和运行时的版本。</p>
<p>runtime.js</p>
<p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p>
<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p>
<h1 id="高阶组件？？-解决了什么问题"><a href="#高阶组件？？-解决了什么问题" class="headerlink" title="高阶组件？？ 解决了什么问题"></a>高阶组件？？ 解决了什么问题</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010371752">链接</a></p>
<p>适配器模式，</p>
<p>高阶函数的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。</p>
<p>对于高阶组件，它描述的便是接受React组件作为输入，输出一个新的React组件的组件。</p>
<p>高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的React组件，供其他组件调用。</p>
<p>高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用。</p>
<h1 id="setState源码剖析，多次调用解密"><a href="#setState源码剖析，多次调用解密" class="headerlink" title="setState源码剖析，多次调用解密"></a>setState源码剖析，多次调用解密</h1><p>setState流程还是很复杂的，设计也很精巧，<br>避免了重复无谓的刷新组件。它的主要流程如下</p>
<ol>
<li><p>enqueueSetState将state放入队列中，并调用enqueueUpdate处理要更新的Component</p>
</li>
<li><p>如果组件当前正处于update事务中，则先将Component存入dirtyComponent中。否则调用batchedUpdates处理。</p>
</li>
<li><p>batchedUpdates发起一次transaction.perform()事务<br>开始执行事务初始化，运行，结束三个阶段</p>
<p> 1 初始化：事务初始化阶段没有注册方法，故无方法要执行</p>
<p> 2 运行：执行setSate时传入的callback方法，一般不会传callback参数</p>
<p> 3 结束：更新isBatchingUpdates为false，并执行FLUSH_BATCHED_UPDATES这个wrapper中的close方法<br>FLUSH_BATCHED_UPDATES在close阶段，会循环遍历所有的dirtyComponents，调用updateComponent刷新组件，并执行它的pendingCallbacks, 也就是setState中设置的callback。</p>
</li>
</ol>
<p>会调用到batchedUpdates进行批处理更新，<br>React以事务的方式处理组件update，事务处理完后会调用wrapper.close(),</p>
<h1 id="react-diff"><a href="#react-diff" class="headerlink" title="react diff"></a>react diff</h1><p><a target="_blank" rel="noopener" href="https://github.com/purplebamboo/blog/issues/3">链接</a></p>
<p>三大要点</p>
<ul>
<li>tree diff<br>  两棵树只会对同一层次的节点进行比较。</li>
<li>component diff<br>  判断是否是同一类型组件</li>
<li>element diff<br>  同一节点 插入，删除，移动属性</li>
</ul>
<p>在reactjs中我们需要更新时都是调用的setState</p>
<p>setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。</p>
<p>就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新。</p>
<p>会合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了。</p>
<p>本质上还是递归调用receiveComponent的过程。</p>
<p>这里注意两个函数：</p>
<p>inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。</p>
<p>_shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。</p>
<p>==简单回顾下reactjs的差异算法：==</p>
<p>首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。</p>
<p>react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。</p>
<p>每个类型的元素都要处理好自己的更新：</p>
<p>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</p>
<p>text节点的更新很简单，直接更新文案。</p>
<p>浏览器基本元素的更新，分为两块：</p>
<p>先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。</p>
<p>然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。<br>整个reactjs的差异算法就是这个样子。</p>
<p>最核心的两个_shouldUpdateReactComponent以及diff,patch算法。</p>
<p>//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</p>
<p>_patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20346379?refer=purerender">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"></span><br><span class="line">React 通过制定大胆的 diff 策略，将 O(n3)</span><br><span class="line">复杂度的问题转换成 O(n) 复杂度的问题；</span><br><span class="line"></span><br><span class="line">React 通过分层求异的策略，对 tree diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">React 通过相同类生成相似树形结构，</span><br><span class="line">不同类生成不同树形结构的策略，</span><br><span class="line">对 component diff 进行算法优化；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">React 通过设置唯一 key的策略，</span><br><span class="line">对 element diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">建议，在开发组件时，保持稳定的 DOM</span><br><span class="line">结构会有助于性能的提升；</span><br><span class="line"></span><br><span class="line">建议，在开发过程中，尽量减少类似将最后一个节点移</span><br><span class="line">动到列表首部的操作，当节点数量过大或更新操作</span><br><span class="line">过于频繁时，在一定程度上会影响 React 的渲染性能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree diff</span><br><span class="line"></span><br><span class="line">React 对树的算法进行了简洁明了的优化，</span><br><span class="line">即对树进行分层比较，两棵树只会对同一层次的</span><br><span class="line">节点进行比较。</span><br><span class="line"></span><br><span class="line">component diff</span><br><span class="line"></span><br><span class="line">如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</span><br><span class="line"></span><br><span class="line">如果不是，则将该组件判断为 dirty component，</span><br><span class="line">从而替换整个组件下的所有子节点。</span><br><span class="line"></span><br><span class="line">对于同一类型的组件，有可能其 Virtual DOM</span><br><span class="line">没有任何变化，如果能够确切的知道这点那可以</span><br><span class="line">节省大量的 diff 运算时间，因此 React 允许用户通过</span><br><span class="line">shouldComponentUpdate() 来判断该组件是否需要进行 diff。</span><br><span class="line"></span><br><span class="line">element diff</span><br><span class="line"></span><br><span class="line">当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</span><br><span class="line"></span><br><span class="line">INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</span><br><span class="line"></span><br><span class="line">MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild&#x3D;nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</span><br><span class="line"></span><br><span class="line">REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</span><br><span class="line"></span><br><span class="line">React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。</span><br><span class="line"></span><br><span class="line">针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="设计组件"><a href="#设计组件" class="headerlink" title="设计组件"></a>设计组件</h1><p>组件尽量只做渲染，逻辑处理放到reducer中</p>
<h1 id="redux-中的action"><a href="#redux-中的action" class="headerlink" title="redux 中的action"></a>redux 中的action</h1><p>Action Creator 的唯一功能就是返回一个Action供 dispatch 进行调用。</p>
<p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件：</p>
<p>是一个纯文本对象</p>
<p>只具备 type 、payload、error 和 meta 中的一个或者多个属性。</p>
<p>type 字段不可缺省，其它字段可缺省</p>
<p>若 Action 报错，error 字段不可缺省，切必须为 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">在 redux 全家桶中，可以利用 redux-actions 来创建符合 FSA 规范的Action：</span><br><span class="line"></span><br><span class="line">import &#123;creatAction&#125; from &#39;redux-actions&#39;;</span><br><span class="line"></span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO)</span><br><span class="line">&#x2F;&#x2F;same as</span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO,data&#x3D;&gt;data)</span><br><span class="line"></span><br><span class="line">Redux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件：</span><br><span class="line"></span><br><span class="line">redux-thunk</span><br><span class="line">redux-promise</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用connect将组件绑定到redux</span><br><span class="line">export const ButtonContainer &#x3D; connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Buttons);</span><br><span class="line"></span><br><span class="line">容器组件实现 mapStateToProps()（用于将状态映射到数据）</span><br><span class="line">和 mapDispatchToProps()（用于将状态映射到行为）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</span><br><span class="line"></span><br><span class="line">操作发起时的 Action</span><br><span class="line">操作成功时的 Action</span><br><span class="line">操作失败时的 Action</span><br><span class="line"></span><br><span class="line">操作开始时，送出一个 Action，触发 State 更新为&quot;正在操作&quot;状态，View 重新渲染</span><br><span class="line"></span><br><span class="line">用户触发第一个 Action，这个跟同步操作一样，没有问题；</span><br><span class="line">如何才能在操作结束时，系统自动送出第二个 Action 呢？</span><br><span class="line"></span><br><span class="line">Action 是由store.dispatch方法发送的。</span><br><span class="line">而store.dispatch方法正常情况下，参数只能是对象，</span><br><span class="line">不能是函数。</span><br><span class="line"></span><br><span class="line">这时，就要使用中间件redux-thunk。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fetchPosts &#x3D; postTitle &#x3D;&gt; (dispatch, getState) &#x3D;&gt; &#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  return fetch(&#96;&#x2F;some&#x2F;API&#x2F;$&#123;postTitle&#125;.json&#96;)</span><br><span class="line">    .then(response &#x3D;&gt; response.json())</span><br><span class="line">    .then(json &#x3D;&gt; dispatch(receivePosts(postTitle, json)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法一</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;));</span><br><span class="line">&#x2F;&#x2F; 使用方法二</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;)).then(() &#x3D;&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">看这里，返回的是Promise，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>==用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。==</p>
<p>store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。</p>
<p>Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，</p>
<p>Redux的单向数据流是同步操作，驱动Redux流程的是action对象，每一个action对象被派发到Store上之后，同步地被分配给所有的reducer函数，每个reducer都是纯函数，纯函数不产生任何副作用，自然是完成数据操作之后立刻同步返回，reducer返回的结果又被同步地拿去更新Store上的状态数据，更新状态数据的操作会立刻被同步给监听Store状态改变的函数，从而引发作为视图的React组件更新过程。</p>
<p>这个过程从头到尾，Redux马不停蹄地一路同步执行，根本没有执行异步操作的机会，那应该在哪里插入访问服务器的异步操作呢？</p>
<p>Redux创立之初就意识到了这种问题，所以提供了thunk这种解决方法，但是thunk并没有作为Redux的一部分一起发布，而是存在一个独立的redux-thunk发布包中，</p>
<p>redux-thunk只是Redux中异步操作的解决方法之一</p>
<p>在Redux架构下，一个action对象在通过store.dispatch派发，在调用reducer函数之前，会先经过一个中间件的环节，这就是产生异步操作的机会，实际上redux-thunk提供的就是一个Redux中间件，我们需要在创建Store时用上这个中间件。</p>
<h1 id="异步action对象"><a href="#异步action对象" class="headerlink" title="异步action对象"></a>异步action对象</h1><h2 id="非常好的讲解"><a href="#非常好的讲解" class="headerlink" title="非常好的讲解"></a><a target="_blank" rel="noopener" href="http://geek.csdn.net/news/detail/202352">非常好的讲解</a></h2><p>当我们想要让Redux帮忙处理一个异步操作的时候，代码一样也要派发一个action对象，毕竟Redux单向数据流就是由action对象驱动的。但是这个引发异步操作的action对象比较特殊，我们叫它们“异步action对象”。</p>
<p>前面例子中的action构造函数返回的都是一个普通的对象，这个对象包含若干字段，其中必不可少的字段是type，但是“异步action对象”不是一个普通JavaScript对象，而是一个函数。</p>
<p>如果没有redux-thunk中间件的存在，这样一个函数类型的action对象被派发出来会一路发送到各个reducer函数，reducer函数从这些实际上是函数的action对象上是无法获得type字段的，所以也做不了什么实质的处理。</p>
<p>不过，有了redux-thunk中间件之后，这些action对象根本没有机会触及到reducer函数，在中间件一层就被redux-thunk截获。</p>
<p>redux-thunk的工作是检查action对象是不是函数，如果不是函数就放行，完成普通action对象的生命周期，而如果发现action对象是函数，那就执行这个函数，并把Store的dispatch函数和getState函数作为参数传递到函数中去，处理过程到此为止，不会让这个异步action对象继续往前派发到reducer函数。</p>
<p>举一个并不涉及网络API访问的异步操作例子，在Counter组件中存在一个普通的同步增加计数的action构造函数increment，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const increment &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  type: ActionTypes.INCREMENT,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>派发increment执行返回的action对象，Redux会同步更新Store状态和视图，但是我们现在想要创造一个功能，能够发出一个“让Counter组件在1秒之后计数加一”的指令，这就需要定义一个新的异步action构造函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const incrementAsync &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      dispatch(increment());</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">异步action构造函数incrementAsync返回的是一个新的函数，这样一个函数被dispatch函数派发之后，会被redux-thunk中间件执行，于是setTimeout函数就会发生作用，在1秒之后利用参数dispatch函数派发出同步action构造函数increment的结果。</span><br><span class="line"></span><br><span class="line">这就是异步action的工作机理，这个例子虽然简单，但是可以看得出来，异步action最终还是要产生同步action派发才能对Redux系统产生影响。</span><br><span class="line"></span><br><span class="line">redux-thunk要做的工作也就不过如此，但因为引入了一次函数执行，而且这个函数还能够访问到dispatch和getState，就给异步操作带来了可能。</span><br><span class="line"></span><br><span class="line">action对象函数中完全可以通过fetch发起一个对服务器的异步请求，当得到服务器结果之后，通过参数dispatch，把成功或者失败的结果当做action对象再派发出去。这一次派发的是普通的action对象，就不会被redux-thunk截获，而是直接被派发到reducer，最终驱动Store上状态的改变。</span><br><span class="line"></span><br><span class="line">通常我们在组件的componentDidMount函数中做请求服务器的事情，因为当生命周期函数componentDidMount被调用的时候，表明装载过程已经完成，组件需要渲染的内容已经在DOM树上出现，对服务器的请求可能依赖于已经渲染的内容，在componentDidMount函数中发送对服务器请求是一个合适的时机。</span><br><span class="line"></span><br><span class="line">fetch函数执行会立刻返回，返回一个Promise类型的对象，所以后面会跟上一大串then和catch的语句。每个Promise成功的时候，对应的then中的回调函数会被调用；如果失败，对应catch中的回调函数也被调用。</span><br><span class="line"></span><br><span class="line"># vue声明组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一、全局注册<br>// 注册<br>Vue.component(‘my-component’, {<br>  template: ‘<div>A custom component!</div>‘<br>})</p>
<p>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</p>
<p>用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？</p>
<p>// 创建根实例<br>new Vue({<br>  el: ‘#example’<br>})</p>
<p>二、局部注册<br>var Child = {<br>  template: ‘<div>A custom component!</div>‘<br>}</p>
<p>new Vue({<br>  // …<br>  components: {<br>    // <my-component> 将只在父组件模板中可用<br>    ‘my-component’: Child<br>  }<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 检测变化的注意事项</span><br><span class="line"></span><br><span class="line">Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</span><br><span class="line"></span><br><span class="line">Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</span><br><span class="line"></span><br><span class="line">Vue.set(vm.someObject, &#39;b&#39;, 2)</span><br><span class="line"></span><br><span class="line">this.$set(this.someObject,&#39;b&#39;,2)</span><br><span class="line"></span><br><span class="line">想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代替 &#96;Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)&#96;</span><br><span class="line">this.someObject &#x3D; Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># watch 深度监听</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;deep： true&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</span><br><span class="line"></span><br><span class="line">不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue &#x3D;&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    a: function (val, oldVal) {<br>      console.log(‘new: %s, old: %s’, val, oldVal)<br>    },<br>    // 方法名<br>    b: ‘someMethod’,<br>    // 深度 watcher<br>    c: {<br>      handler: function (val, oldVal) { /* … <em>/ },<br>      deep: true<br>    },<br>    // 该回调将会在侦听开始之后被立即调用<br>    d: {<br>      handler: function (val, oldVal) { /</em> … <em>/ },<br>      immediate: true<br>    },<br>    e: [<br>      function handle1 (val, oldVal) { /</em> … <em>/ },<br>      function handle2 (val, oldVal) { /</em> … <em>/ }<br>    ],<br>    // watch vm.e.f’s value: {g: 5}<br>    ‘e.f’: function (val, oldVal) { /</em> … */ }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 异步更新队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>this.$nextTick(function () {<br>    console.log(this.$el.textContent) // =&gt; ‘更新完成’<br>  })</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性 computed</span><br><span class="line"></span><br><span class="line">对于任何复杂逻辑，你都应当使用计算属性。</span><br><span class="line"></span><br><span class="line">当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;方法和计算属性：&#x3D;&#x3D; 两种方式的最终结果确实是完全相同的。</span><br><span class="line"></span><br><span class="line">不同的是计算属性是基于它们的依赖进行缓存的。</span><br><span class="line"></span><br><span class="line">计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage</span><br><span class="line">计算属性会立即返回之前的计算结果，而不必再次执行函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>computed: {<br>    // 计算属性的 getter<br>    reversedMessage: function () {<br>      // <code>this</code> 指向 vm 实例<br>      return this.message.split(‘’).reverse().join(‘’)<br>    }<br>}</p>
<p>  console.log(vm.reversedMessage) // =&gt; ‘olleH’<br>vm.message = ‘Goodbye’<br>console.log(vm.reversedMessage) // =&gt; ‘eybdooG’</p>
<p>// 在组件中<br>methods: {<br>  reversedMessage: function () {<br>    return this.message.split(‘’).reverse().join(‘’)<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性的 setter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// …<br>computed: {<br>  fullName: {<br>    // getter<br>    get: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>    },<br>    // setter<br>    set: function (newValue) {<br>      var names = newValue.split(‘ ‘)<br>      this.firstName = names[0]<br>      this.lastName = names[names.length - 1]<br>    }<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># watch 侦听器</span><br><span class="line"></span><br><span class="line">虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</span><br><span class="line"></span><br><span class="line">使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    // 如果 <code>question</code> 发生改变，这个函数就会运行<br>    question: function (newQuestion, oldQuestion) {<br>      this.answer = ‘Waiting for you to stop typing…’<br>      this.getAnswer()<br>    }<br>},</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># getters作用</span><br><span class="line"></span><br><span class="line">Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</span><br><span class="line"></span><br><span class="line">this.$store.getters.doneTodosCount</span><br><span class="line"></span><br><span class="line"># mapGetters 辅助函数</span><br><span class="line"></span><br><span class="line">mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</span><br><span class="line"></span><br><span class="line"># 提交 mutation 的另一种方式是直接使用包含 type 属性的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>store.commit({<br>  type: ‘increment’,<br>  amount: 10<br>})</p>
<p>store.commit(‘increment’, {<br>  amount: 10<br>})<br>可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，<br>或者使用 mapMutations 辅助函数将组件中的 methods<br>映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 分发 Action</span><br><span class="line"></span><br><span class="line">Action 通过 store.dispatch 方法触发：</span><br><span class="line"></span><br><span class="line">store.dispatch(&#39;increment&#39;)</span><br><span class="line"></span><br><span class="line"># vue组件类型, 怎么定义一个组件</span><br><span class="line"></span><br><span class="line"># vue切换路由</span><br><span class="line"></span><br><span class="line">其他方式 不留痕迹</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">一、router.push(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&lt;router-link :to&#x3D;&quot;...&quot;&gt; router.push(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const userId &#x3D; 123</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">二、 router.replace(location, onComplete?, onAbort?)</span><br><span class="line">跟 router.push 很像，唯一的不同就是，它不会向 history</span><br><span class="line">添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</span><br><span class="line"></span><br><span class="line">三、router.go(n)</span><br><span class="line">在 history 记录中向前或者后退多少步，</span><br><span class="line">类似 window.history.go(n)。</span><br></pre></td></tr></table></figure>

<h1 id="vue-router传参方式"><a href="#vue-router传参方式" class="headerlink" title="vue-router传参方式"></a>vue-router传参方式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">query 和params</span><br><span class="line"> &#123; <span class="attr">path</span>: <span class="string">&#x27;/news/:id&#x27;</span>, <span class="attr">component</span>: NewsDetail &#125;,</span><br><span class="line">      &lt;span&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line"><span class="number">1</span>、用法</span><br><span class="line">    query要用path来引入，params要用name来引入，</span><br><span class="line">    接收参数都是类似的，</span><br><span class="line">    分别是<span class="built_in">this</span>.$route.query.name和<span class="built_in">this</span>.$route.params.name。</span><br><span class="line"></span><br><span class="line">    接收参数时，已经是$route而不是$router了哦！！</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、展示</span><br><span class="line">　　query更加类似于我们ajax中get传参，params则类似于post，</span><br><span class="line">　　说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</span><br><span class="line"></span><br><span class="line">query:</span><br><span class="line">params:</span><br></pre></td></tr></table></figure>

<h1 id="受控组件-非受控组件"><a href="#受控组件-非受控组件" class="headerlink" title="受控组件 非受控组件"></a>受控组件 非受控组件</h1><h1 id="没有任何嵌套关系的组件之间传值"><a href="#没有任何嵌套关系的组件之间传值" class="headerlink" title="没有任何嵌套关系的组件之间传值"></a>没有任何嵌套关系的组件之间传值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(1) Event Emitter&#x2F;Target&#x2F;Dispatcher</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.addEventListener(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.dispatchEvent(‘click’);</span><br><span class="line"></span><br><span class="line">(2) Publish &#x2F; Subscribe</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">globalBroadcaster.subscribe(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">globalBroadcaster.publish(‘click’);</span><br><span class="line"></span><br><span class="line">(3) Signals</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.clicked.add(function() &#123; alert(‘click’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.clicked.dispatch();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="this-setState-参数"><a href="#this-setState-参数" class="headerlink" title="this.setState()参数"></a>this.setState()参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这个函数接受两个参数，</span><br><span class="line">第一个参数表示上一个状态值，</span><br><span class="line">第二参数表示当前的 props，</span><br><span class="line">第二个参数是 state 导致的页面变化完成后的回调，等价于componentDidUpdate。</span><br><span class="line"></span><br><span class="line">this.setState((prevState, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">setState的关键点:</span><br><span class="line"></span><br><span class="line">setState不会立刻改变React组件中state的值；</span><br><span class="line">setState通过引发一次组件的更新过程来引发重新绘制；</span><br><span class="line">多次setState函数调用产生的效果会合并。</span><br><span class="line"></span><br><span class="line">当setState被调用时，能驱动组件的更新过程，引发componentDidUpdate、render等一系列函数的调用。</span><br></pre></td></tr></table></figure>

<h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><p>主要分为三段，mount（挂载）、update（更新）、unmount（卸载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">一、mount，即挂载阶段，</span><br><span class="line">    第一次让组件出现在页面中的过程，React会将render的返回值插入到页面中，</span><br><span class="line">    这个过程会暴露以下几个钩子（hook）：</span><br><span class="line"></span><br><span class="line">    constructor()       &#x2F;&#x2F; 初始化props和state</span><br><span class="line"></span><br><span class="line">    　　初始化getDefaultProps()和getInitialState()</span><br><span class="line"></span><br><span class="line">    　　getDefaultProps: 执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的</span><br><span class="line">这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制</span><br><span class="line"></span><br><span class="line">getInitialState : 控件加载之前执行，返回值会被用于state的初始化值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    　　初始化</span><br><span class="line">    componentWillMount()    &#x2F;&#x2F; 将要被插入</span><br><span class="line"></span><br><span class="line">    执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次</span><br><span class="line"></span><br><span class="line">    render()    &#x2F;&#x2F; 将return的内容插入到页面里</span><br><span class="line">    componentDidMount()   &#x2F;&#x2F; 插入完成后的动作</span><br><span class="line">        在组件被装配后立即调用。</span><br><span class="line">        初始化使得DOM节点应该进行到这里。</span><br><span class="line">        若你需要从远端加载数据，</span><br><span class="line">        这是一个适合实现网络请求的地方。</span><br><span class="line">        在该方法里设置状态将会触发重渲。</span><br><span class="line"></span><br><span class="line">二、update，即更新阶段，如果数据有任何变动就会来这一阶段，这个过程有5个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillReceiveProps( nextprops )   &#x2F;&#x2F; 接受需要更新的props</span><br><span class="line">    　　在装配了的组件接收到新属性前调用。</span><br><span class="line">    　　若你需要更新状态响应属性改变（例如，重置它），</span><br><span class="line">    　　你可能需对比this.props和nextProps</span><br><span class="line">    　　并在该方法中使用this.setState()处理状态改变。</span><br><span class="line"></span><br><span class="line">    注意即使属性未有任何改变，React可能也会调用该方法，因此若你想要处理改变，请确保比较当前和之后的值。这可能会发生在当父组件引起你的组件重渲。</span><br><span class="line"></span><br><span class="line">　　shouldComponentUpdate( nextProps, nextState )   &#x2F;&#x2F; 请问要不要更新组件 true&#x2F;false</span><br><span class="line"></span><br><span class="line">        接收到新属性或状态时，</span><br><span class="line">        shouldComponentUpdate() 在渲染前被调用。默认为true。</span><br><span class="line">        该方法并不会在初始化渲染或当使用forceUpdate()时被调用。</span><br><span class="line">        当他们状态改变时，返回false 并不能阻止子组件重渲。</span><br><span class="line">        若shouldComponentUpdate()返回false，componentWillUpdate()将不会被调用。</span><br><span class="line">　　componentWillUpdate()  &#x2F;&#x2F; 准备更新组件啦</span><br><span class="line"></span><br><span class="line">　　render() &#x2F;&#x2F; 更新</span><br><span class="line"></span><br><span class="line">　　componentDidUpdate()   &#x2F;&#x2F; 更新完成</span><br><span class="line">    该方法并不会在初始化渲染时调用。</span><br><span class="line">三、unmount，即卸载过程，当一个组件要从页面移除时，会进入这个过程，其中有一个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillUnmount()    &#x2F;&#x2F; 要卸载啦</span><br><span class="line">    可以在该方法里处理任何必要的清理工作，</span><br><span class="line">    例如解绑定时器，取消网络请求，</span><br><span class="line">    清理任何在componentDidMount环节创建的DOM元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一般我们只在这几个钩子里setState：</span><br><span class="line"></span><br><span class="line">componentWillMount()</span><br><span class="line"></span><br><span class="line">componentDidMount()</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redux原理"><a href="#Redux原理" class="headerlink" title="Redux原理"></a>Redux原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Redux 和 React 没有直接关系，</span><br><span class="line">它瞄准的目标是应用状态管理。</span><br><span class="line"></span><br><span class="line">核心概念是 Map&#x2F;Reduce 中的 Reduce。</span><br><span class="line">且 Reducer 的执行是同步，</span><br><span class="line">产生的 State 是 Immutable 的。</span><br><span class="line"></span><br><span class="line">改变 State 只能通过向 Reducer dispatch actions 来完成。</span><br><span class="line"></span><br><span class="line">State 的不同字段，可以通过不同的 Reducers 来分别维护。</span><br><span class="line">combineReducers 负责组合这些 Reducers，</span><br><span class="line">前提是每个 Reducer 只能维护自己关心的字段。</span><br><span class="line"></span><br><span class="line">Action 对象只能是 Javascript Plain Object，</span><br><span class="line">但是通过在 store 上装载 middleware，</span><br><span class="line">则可以任意定义 action 对象的形式，</span><br><span class="line">反正会有特定的 middleware 负责</span><br><span class="line">将此 action 对象变为 Javascript Plain Object。</span><br><span class="line"></span><br><span class="line">可以以middleware 链条为集中点实现很多控制逻辑，</span><br><span class="line">例如 Log，Undo, ErrorHandler 等。</span><br><span class="line"></span><br><span class="line">Redux 仅仅专注于应用状态的维护，</span><br><span class="line">reducer、dispatch&#x2F;middleware 是两个常用扩展点、</span><br><span class="line">Higher-order Store 则仅针对需要扩展全部 Store 功能时使用。</span><br><span class="line"></span><br><span class="line">react-redux 是 Redux 针对 React&#x2F;React-Native 的 Binding，</span><br><span class="line">connect&#x2F;selector 是扩展点，</span><br><span class="line">负责将 store 中的状态添加到 React component 的 props 中。</span><br><span class="line"></span><br><span class="line">Redux 借用了很多函数式编程的思想，</span><br><span class="line">了解函数式编程会利于理解其实现原理，</span><br><span class="line">虽然使用它不需要了解很多函数式编程的概念。</span><br><span class="line">和 Flux 相比，Redux 的概念更精简、约定更严格、状态更确定、而是扩展却更灵活。</span><br><span class="line"></span><br><span class="line">通过 https:&#x2F;&#x2F;github.com&#x2F;xgrommx&#x2F;awesome-redux 可以获得大量参考。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;3334467e4b32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redux有三大准则</span><br><span class="line"></span><br><span class="line">单一数据源</span><br><span class="line">整个应用状态，都应该被存储在单一store的对象树中。</span><br><span class="line"></span><br><span class="line">只读状态</span><br><span class="line">唯一可以修改状态的方式，</span><br><span class="line">就是发送（dispatch）一个动作（Action），</span><br><span class="line">通俗来讲，就是说只有getter，没有setter。</span><br><span class="line"></span><br><span class="line">使用纯函数去修改状态</span><br><span class="line">纯函数保障了状态的稳定性，</span><br><span class="line">不会因不同环境导致应用程序出现不同情况，</span><br><span class="line">听说是redux真正的精髓，日后可以深入了解。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="谈谈MVVM模式"><a href="#谈谈MVVM模式" class="headerlink" title="谈谈MVVM模式"></a>谈谈MVVM模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</span><br><span class="line"></span><br><span class="line">DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</span><br><span class="line"></span><br><span class="line">MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</span><br><span class="line"></span><br><span class="line">在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</span><br><span class="line"></span><br><span class="line">ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-mvvm和mvc区别"><a href="#2-mvvm和mvc区别" class="headerlink" title="2:mvvm和mvc区别"></a>2:mvvm和mvc区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvc和mvvm其实区别并不大。都是一种设计思想。</span><br><span class="line">主要就是mvc中Controller演变成mvvm中的viewModel。</span><br><span class="line">mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，</span><br><span class="line">加载速度变慢，影响用户体验。</span><br><span class="line">和当 Model 频繁发生变化，开发者需要主动更新到View 。</span><br></pre></td></tr></table></figure>

<h1 id="让CSS只在当前组件中起作用"><a href="#让CSS只在当前组件中起作用" class="headerlink" title="让CSS只在当前组件中起作用"></a>让CSS只在当前组件中起作用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将当前组件的&lt;style&gt;修改为&lt;style scoped&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Vue中使用插件的步骤"><a href="#Vue中使用插件的步骤" class="headerlink" title="Vue中使用插件的步骤"></a>Vue中使用插件的步骤</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件</span><br><span class="line">使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, &#123; someOption: true &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件的使用和自己创建公用组件"><a href="#组件的使用和自己创建公用组件" class="headerlink" title="组件的使用和自己创建公用组件"></a>组件的使用和自己创建公用组件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步：在components目录新建你的组件文件（indexPage.vue），</span><br><span class="line">    script一定要export default &#123;&#125;</span><br><span class="line">第二步：在需要用的页面（组件）中导入：</span><br><span class="line">    import indexPage from &#39;@&#x2F;components&#x2F;indexPage.vue&#39;</span><br><span class="line">第三步：注入到vue的子组件的components属性上面,components:&#123;indexPage&#125;</span><br><span class="line">第四步：在template视图view中使用，</span><br><span class="line">问题有indexPage命名，使用的时候则index-page。</span><br></pre></td></tr></table></figure>

<h1 id="vue如何实现按需加载配合webpack设置"><a href="#vue如何实现按需加载配合webpack设置" class="headerlink" title="vue如何实现按需加载配合webpack设置"></a>vue如何实现按需加载配合webpack设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。</span><br><span class="line">不进行页面按需加载引入方式：import  home   from &#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;</span><br><span class="line">进行页面按需加载的引入方式：const  home &#x3D; r &#x3D;&gt; require.ensure( [], () &#x3D;&gt; r (require(&#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;)))</span><br></pre></td></tr></table></figure>

<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a><keep-alive></keep-alive>作用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</span><br></pre></td></tr></table></figure>

<h1 id="vue-route模式"><a href="#vue-route模式" class="headerlink" title="vue-route模式"></a>vue-route模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">默认为hash，但是用hash模式的话，页面地址会加#</span><br><span class="line"></span><br><span class="line">所以一般采用 history模式</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># vue阻止事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　.stop 阻止事件冒泡<br>　.prevent 阻止默认事件<br>　.capture　阻止事件捕获<br>　.once 只触发一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># router传参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>routes: [<br>    {<br>        path: ‘/linkParams/:name’,<br>        name:’linkParams’,<br>        component: linkParams<br>    }<br>]</p>
<p>获取name</p>
<p>let name = this.$route.params.name</p>
<p>// 字符串,这里的字符串是路径path匹配噢，不是router配置里的name<br>this.$router.push(‘home’)</p>
<p>// 对象<br>this.$router.push({ path: ‘home’ })</p>
<p>// 命名的路由 这里会变成 /user/123<br>this.$router.push({ name: ‘user’, params: { userId: 123 }})</p>
<p>// 带查询参数，变成 /register?plan=private<br>this.$router.push({ path: ‘register’, query: { plan: ‘private’ }})</p>
<p>router.beforeEach((to, from, next)=&gt;{<br>  //do something<br>  next();<br>});<br>router.afterEach((to, from, next) =&gt; {<br>    console.log(to.path);<br>});</p>
<p>每个钩子方法接收三个参数：</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p>
<p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
<p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
<p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SSR实现原理</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。<br>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。<br>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。<br>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端。</p>
<p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue实例初始化的过程中实现依赖管理的分析</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com&#x2F;a&#x2F;vue&#x2F;2018&#x2F;0301&#x2F;1795.html)</span><br><span class="line"></span><br><span class="line">大致的总结下就是：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initState的过程中，<br>将props,computed,data等属性通过Object.defineProperty<br>来改造其getter/setter属性，<br>并为每一个响应式属性实例化一个observer观察者。<br>这个observer内部dep记录了这个响应式属性的所有依赖。</p>
<p>当响应式属性调用setter函数时，<br>通过dep.notify()方法去遍历所有的依赖，<br>调用watcher.update()去完成数据的动态响应。</p>
<p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，<br>通过Object.defineProperty()来劫持各个属性的setter，getter，<br>在数据变动时发布消息给订阅者，<br>触发相应的监听回调。</p>
<p>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，<br>包括子属性对象的属性，<br>都加上 setter和getter<br>这样的话，<br>给这个对象的某个值赋值，就会触发setter，<br>那么就能监听到了数据变化</p>
<p>第二步：compile解析模板指令，<br>将模板中的变量替换成数据，<br>然后初始化渲染页面视图，<br>并将每个指令对应的节点绑定更新函数，<br>添加监听数据的订阅者，一旦数据有变动，<br>收到通知，更新视图</p>
<p>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，<br>主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，<br>能调用自身的update()方法，<br>并触发Compile中绑定的回调，则功成身退。</p>
<p>第四步：MVVM作为数据绑定的入口，<br>整合Observer、Compile和Watcher三者，<br>通过Observer来监听自己的model数据变化，<br>通过Compile来解析编译模板指令，<br>最终利用Watcher搭起Observer和Compile之间的通信桥梁，<br>达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue声明组件的state是用data方法，那为什么data是通过一个function来返回一个对象，而不是直接写一个对象呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：从语法上说，如果不用function返回就会出现语法错误导致编译不通过。从原理上的话，大概就是组件可以被多次创建，如果不使用function就会使所有调用该组件的页面公用同一个数据域，这样就失去了组件的概念了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># vuex</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> State、 Getter、Mutation 、Action、 Module<br>通过状态（数据源）集中管理驱动组件的变化<br>（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中；<br>改变状态的方式是提交mutations，<br>这是个同步的事物； 异步逻辑应该封装在action中。</p>
<p>一、Action 类似于 mutation，不同在于：<br>二、Action 提交的是 mutation，而不是直接变更状态。<br>三、Action 可以包含任意异步操作</p>
<p>一、getters 可以对State进行计算操作，它就是Store的计算属性<br>二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>三、 如果一个状态只在一个组件内使用，是可以不用getters</p>
<p>二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 说下vue组件之间的通信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：<br>非父子组件间通信，Vue 有提供 Vuex，以状态共享方式来实现通信</p>
<p>prop 向下传递，事件向上传递。<br>还可以通过$emit方法出发一个消息，然后$on接收这个消息</p>
<p>兄弟组件间的数据通讯，它们将会 寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法 。</p>
<p>var Event = new Vue()<br>//父组件<br> Event.$on(“a-msg”, function (a) {<br>    this.a = a;<br>  }.bind(this));</p>
<p>// 子组件<br> Event.$emit(“a-msg”, this.a);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue 生命周期</span><br><span class="line"></span><br><span class="line"># 简单描述每个周期具体适合哪些场景</span><br><span class="line"></span><br><span class="line">Create  Mount  Update  Destroy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>beforeCreate（创建前）,<br>created（创建后）,</p>
<p>beforeMount(载入前),<br>mounted（载入后）,</p>
<p>beforeUpdate（更新前）,<br>updated（更新后）,</p>
<p>beforeDestroy（销毁前）,<br>destroyed（销毁后）</p>
<p>每个钩子函数都在啥时间触发</p>
<p>beforeCreate<br>在实例初始化之后，<br>数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>
<p>created<br>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>beforeMount<br>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p>mounted<br>挂载元素，获取到DOM节点<br>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。<br>如果 root 实例挂载了一个文档内元素，<br>当 mounted 被调用时 vm.$el 也在文档内。</p>
<p>beforeUpdate<br>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p>updated<br>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。<br>然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<p>beforeDestroy<br>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p>destroyed<br>Vue 实例销毁后调用。<br>调用后，Vue 实例指示的所有东西都会解绑定，<br>所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
<p>生命周期钩子的一些常见使用方法：</p>
<p>beforecreate : 可以在这加个loading事件，<br>在加载实例时触发</p>
<p>created : 初始化完成时需要执行的事件写在这里，<br>如在这结束loading事件，异步请求也适宜在这里调用</p>
<p>mounted: 在这发起后端请求，拿回数据，配合路由钩子做一些事情</p>
<p>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框 你确认删除XX吗？<br>nextTick : 更新数据后立即操作dom<br>activated::keep-alive组件激活时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># v-show和v-if指令的共同点和不同点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏<br>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</p>
<p>v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。<br>因此，如果需要频繁切换 v-show 较好，<br>如果在运行时条件不大可能改变 v-if 较好。</p>
<p>1.v-if 指令可以应用于template包装元素上，<br>而v-show不支持template<br>2.将v-show应用在组件上时，因为指令的优先级<br>v-else 会出现问题，<br>解决办法就是用另一个 v-show 替换 v-else</p>
<p>// 错误<br><custom-component v-show="condition"></custom-component></p>
<p v-else>这可能也是一个组件</p>
     // 正确做法
<custom-component v-show="condition"></custom-component>
<p v-show="!condition">这可能也是一个组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># vue 父子组件嵌套时，组件内部的各个生命周期钩子触发先后顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
顺序是 先创建父组件(父组件beforeMount)，然后才创建子组件，当子组件创建完成并且实体dom挂载完成后(子组件先mounted)父组件才挂载完成(父组件mounted)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># h函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
它来自单词 hyperscript，
这个单词通常用在 virtual-dom 的实现中。
Hyperscript 本身是指

<p>生成HTML 结构的 script 脚本，<br>因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言）</p>
<p>个人理解：<br>createElement 函数是用来生成 HTML DOM<br>元素的，也就是上文中的 generate HTML<br>structures，也就是 Hyperscript，<br>这样作者才把 createElement 简写成 h。</p>
<p>大概的翻译下：<br>render: h =&gt; h(App) 是下面内容的缩写：</p>
<p>render: function (createElement) {<br>    return createElement(App);<br>}<br>进一步缩写为(ES6 语法)：</p>
<p>render (createElement) {<br>    return createElement(App);<br>}<br>再进一步缩写为：</p>
<p>render (h){<br>    return h(App);<br>}<br>按照 ES6 箭头函数的写法，就得到了：</p>
<p>render: h =&gt; h(App);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># react-redux中connect函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010188279)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>connect方法做的事情是<br>将state和dispatch绑定到Connect组件的参数上，<br>然后Connect组件将你当前的App组件封装起来，<br>使得App组件可以通过props获取到父<br>组件Connect传递的state和props。</p>
<p>Provider是顶层组件的作用，<br>将store作为上下文提供给全局共享，<br>而Connect组件是局部组件，将某个react组件包装起来，<br>传递指定的state和props给该组件访问。</p>
<p>connect()返回值是Connect组件（请注意大小写的区别）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue和React区别</span><br><span class="line"></span><br><span class="line">### 相同</span><br><span class="line"></span><br><span class="line">- 使用 Virtual DOM</span><br><span class="line">- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</span><br><span class="line">- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</span><br><span class="line"></span><br><span class="line">都是JavaScript的UI框架，专注于创造前端的富应用。</span><br><span class="line">不同于早期的JavaScript框架“功能齐全”，</span><br><span class="line"></span><br><span class="line">### 区别</span><br><span class="line"></span><br><span class="line">- **性能**</span><br><span class="line"></span><br><span class="line">    计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。</span><br><span class="line"></span><br><span class="line">    Vue可以更快地计算出Virtual DOM的差异，</span><br><span class="line">    这是由于它在渲染过程中，</span><br><span class="line">    会跟踪每一个组件的依赖关系，</span><br><span class="line">    不需要重新渲染整个组件树。</span><br><span class="line"></span><br><span class="line">    而对于React而言，每当应用的状态被改变时，</span><br><span class="line">    全部子组件都会重新渲染。</span><br><span class="line">    当然，这可以通过shouldComponentUpdate</span><br><span class="line">    这个生命周期方法来进行控制，</span><br><span class="line">    但Vue将此视为默认的优化。</span><br><span class="line"></span><br><span class="line">- **JSX和Templates**</span><br><span class="line"></span><br><span class="line">    React 中，所有的组件的渲染功能都依靠 JSX</span><br><span class="line">    可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。</span><br><span class="line"></span><br><span class="line">    模板比起 JSX 读写起来更自然。</span><br><span class="line">    基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。</span><br><span class="line">    可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。</span><br><span class="line"></span><br><span class="line">    vue的模板语法去除了往视图&#x2F;组件中添加逻辑的诱惑，保持了关注点分离。</span><br><span class="line"></span><br><span class="line">    与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已。</span><br><span class="line"></span><br><span class="line">- **组件作用域内的 CSS**</span><br><span class="line"></span><br><span class="line">    Vue 设置样式的默认方法是单文件组件里类似 style 的标签。</span><br><span class="line">    可选 scoped 属性会自动添加一个唯一的属性</span><br><span class="line"></span><br><span class="line">    CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的</span><br><span class="line"></span><br><span class="line">- **Props**</span><br><span class="line"></span><br><span class="line">    JSX库中，数据通过props传到子组件中去。</span><br><span class="line"></span><br><span class="line">    在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”</span><br><span class="line"></span><br><span class="line">    在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。</span><br><span class="line"></span><br><span class="line">- **构建工具**</span><br><span class="line"></span><br><span class="line">    React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。</span><br><span class="line"></span><br><span class="line">- **配套框架**</span><br><span class="line"></span><br><span class="line">    Vue的核心团队维护着vue-router和vuex，</span><br><span class="line">    它们由官方维护支持且与核心库同步更新的。</span><br><span class="line">    而React的react-router和react-redux则是由社区成员维护，</span><br><span class="line">    创建了一个更分散的生态系统</span><br><span class="line"></span><br><span class="line">- **向下扩展**</span><br><span class="line"></span><br><span class="line">    React 学习曲线陡峭，学 React 前，你需要知道 JSX 和 ES2015，</span><br><span class="line"></span><br><span class="line">- **原生渲染**</span><br><span class="line"></span><br><span class="line">    Weex 还在积极发展，成熟度也不能和 React Native 相抗衡。</span><br><span class="line"></span><br><span class="line">&lt;https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5a9b8417518825558251ce15&gt;</span><br><span class="line"></span><br><span class="line"># redux原理</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000004236064)</span><br><span class="line"></span><br><span class="line"># redux流程</span><br><span class="line"></span><br><span class="line">[Redux 入门教程](http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;2016&#x2F;09&#x2F;redux_tutorial_part_one_basic_usages.html)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// store<br>// Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>//数据集合，就叫做 State<br>const state = store.getState();</p>
<p>// Action Creator定义一个函数来生成 Action<br>const ADD_TODO = ‘添加 TODO’;</p>
<p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p>
<p>const action = addTodo(‘Learn Redux’);</p>
<p>//store.dispatch()是 View 发出 Action 的唯一方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>store.dispatch({<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>});</p>
<p>store.dispatch(addTodo(‘Learn Redux’));</p>
<p>//Reducer State 的计算过程就叫做 Reducer。<br>接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<p>const reducer = function (state, action) {<br>  // …<br>  return new_state;<br>};</p>
<p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }<br>};</p>
<p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2<br>});</p>
<p>Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p>
<p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p>
<p>reducer最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<p>不得改写参数<br>不能调用系统 I/O 的API<br>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</p>
<p>必须返回一个全新的对象<br>// State 是一个对象<br>function reducer(state, action) {<br>  return Object.assign({}, state, { thingToChange });<br>  // 或者<br>  return { …state, …newState };<br>}</p>
<p>// State 是一个数组<br>function reducer(state, action) {<br>  return […state, newItem];<br>}</p>
<pre><code></code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-04-23T13:42:02.000Z" title="2018-04-23T13:42:02.000Z">2018-04-23</time>发表</span><span class="level-item"><time dateTime="2018-11-29T13:42:02.000Z" title="2018-11-29T13:42:02.000Z">2018-11-29</time>更新</span><span class="level-item">14 分钟读完 (大约2074个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/%E5%8E%9F%E5%9E%8B/">原型</a></h1><div class="content"><h2 id="js原型继承的几种方式"><a href="#js原型继承的几种方式" class="headerlink" title="js原型继承的几种方式"></a>js原型继承的几种方式</h2><ol>
<li>原型链继承</li>
</ol>
<p>2，构造函数继承（对象冒充继承）</p>
<p>3，组合继承（原型链继承+构造函数继承）</p>
<p>4，原型式继承</p>
<p>5, 寄生组合式继承</p>
<p>一。原型链继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=<span class="string">&quot;run&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="string">&quot;20&quot;</span>; <span class="comment">//Run继承了Show,通过原型，形成链条</span></span><br><span class="line">&#125;</span><br><span class="line">Run.prototype=<span class="keyword">new</span> Show();</span><br><span class="line"><span class="keyword">var</span> show=<span class="keyword">new</span> Run();</span><br><span class="line">alert(show.name)<span class="comment">//结果：run</span></span><br></pre></td></tr></table></figure>

<p>二。构造函数继承（对象冒充继承）</p>
<p>为了解决引用共享和超类型无法传参的问题，我们采用一种叫借用构造函数的技术，或<br>者成为对象冒充(伪造对象、经典继承)的技术来解决这两种问题</p>
<p>2.优缺点<br>可以实现多继承,不能继承原型属性/方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=[<span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Hello&#x27;</span>]</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Desk</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    Box.call(<span class="built_in">this</span>,age); <span class="comment">//对象冒充，给超类型传参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> desk = <span class="keyword">new</span> Desk(<span class="number">200</span>);</span><br><span class="line">alert(desk.age);<span class="comment">//200</span></span><br><span class="line">alert(desk.name);<span class="comment">//[&#x27;Lee&#x27;,&#x27;Jack&#x27;,&#x27;Hello&#x27;]</span></span><br><span class="line">desk.name.push(<span class="string">&#x27;AAA&#x27;</span>); <span class="comment">//添加的新数据，只给 desk</span></span><br><span class="line">alert(desk.name)<span class="comment">//[&#x27;Lee&#x27;,&#x27;Jack&#x27;,&#x27;Hello&#x27;,&#x27;AAA&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>三。组合继承（原型链继承+构造函数继承）</p>
<p>借用构造函数虽然解决了刚才两种问题， 但没有原型， 复用则无从谈起。 所以， 我们需<br>要原型链+借用构造函数的模式，这种模式成为组合继承。</p>
<p>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = [<span class="string">&#x27;Lee&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>]</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Box.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Desk</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Box.call(<span class="built_in">this</span>, age); <span class="comment">//对象冒充</span></span><br><span class="line">&#125;</span><br><span class="line">Desk.prototype = <span class="keyword">new</span> Box(); <span class="comment">//原型链继承</span></span><br><span class="line">Desk.prototype.constructor = Desk; <span class="comment">// 组合继承也是需要修复构造函数指向的。</span></span><br><span class="line"><span class="keyword">var</span> desk = <span class="keyword">new</span> Desk(<span class="number">100</span>);</span><br><span class="line">alert(desk.run());</span><br></pre></td></tr></table></figure>

<p>四。原型式继承</p>
<p>这种继承借助原型并基于已有的对象创建新对象，<br>同时还不必因此创建自定义类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">o</span>) </span>&#123; <span class="comment">//传递一个字面量函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//创建一个构造函数</span></span><br><span class="line">F.prototype = o; <span class="comment">//把字面量函数赋值给构造函数的原型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">//最终返回出实例化的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box = &#123; <span class="comment">//字面量对象</span></span><br><span class="line">    name : <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">    arr : [<span class="string">&#x27;哥哥&#x27;</span>,<span class="string">&#x27;妹妹&#x27;</span>,<span class="string">&#x27;姐姐&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> box1 = obj(box); <span class="comment">//传递</span></span><br><span class="line">alert(box1.name);</span><br><span class="line">box1.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">alert(box1.name);</span><br><span class="line">alert(box1.arr);</span><br><span class="line">box1.arr.push(<span class="string">&#x27;父母&#x27;</span>);</span><br><span class="line">alert(box1.arr);</span><br><span class="line"><span class="keyword">var</span> box2 = obj(box); <span class="comment">//传递</span></span><br><span class="line">alert(box2.name);</span><br><span class="line">alert(box2.arr); <span class="comment">//引用类型共享了</span></span><br></pre></td></tr></table></figure>

<p>五。寄生组合式继承</p>
<p>寄生组合式继承解决了两次调用的问题，组合式继承就会有两次调用的情况</p>
<p>基本模型如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);  <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType;              <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype;                <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面的寄生式继承和寄生组合模型式继承还搞不懂，哈哈哈，好尴尬</p>
<p>寄生组合继承，解决了两次调用的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Person.prototype.constructor == Person;</span><br><span class="line">person1.__proto__ == Person.prototype;</span><br><span class="line">person1.constructor == Person;</span><br><span class="line"></span><br><span class="line">person1.__proto__ === Person.prototype</span><br><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line">Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.__proto__</span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">b.constructor === <span class="built_in">Array</span>;</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">c.constructor === <span class="built_in">Date</span>;</span><br><span class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">d.constructor === <span class="built_in">Function</span>;</span><br><span class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function）</span></span><br><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Boolean</span>.prototype)  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">RegExp</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Error</span>.prototype)    <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype)     <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype)   <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">Person.__proto__ == <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype)<span class="comment">// function()&#123;&#125; (空函数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Array</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype) <span class="comment">// [] (空数组)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"> animal.price = <span class="number">2000</span>;</span><br><span class="line"> dog.prototype = animal;</span><br><span class="line"> <span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"> <span class="built_in">console</span>.log(dog.price) <span class="comment">//undefined</span></span><br><span class="line"> <span class="built_in">console</span>.log(tidy.price) <span class="comment">// 2000</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原型和原型链是JS实现继承的一种模型。<br>原型链的形成是真正是靠<strong>proto</strong> 而非prototype</p>
<h2 id="JavaScript继承实现"><a href="#JavaScript继承实现" class="headerlink" title="JavaScript继承实现"></a>JavaScript继承实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;动物发声:&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line">Dog.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过原型链找‘基本类’原型里的同名方法</span></span><br><span class="line">    <span class="built_in">this</span>.__proto__.__proto__.speak.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪, 我是&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line">Cat.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过原型链找‘基本类’原型里的同名方法</span></span><br><span class="line">    <span class="built_in">this</span>.__proto__.__proto__.speak.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;喵喵, 我是&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animalSpeak</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animalSpeak(<span class="keyword">new</span> Dog(<span class="string">&#x27;大黄&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log()</span><br><span class="line">animalSpeak(<span class="keyword">new</span> Cat(<span class="string">&#x27;小喵&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//动物发声:</span></span><br><span class="line"><span class="comment">//汪汪, 我是 大黄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物发声:</span></span><br><span class="line"><span class="comment">//喵喵, 我是 小喵</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享"><a href="#Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享"></a>Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享</h2><p>我在写的时候,用了两种,一个是 ES5和 ES6的方案</p>
<p>ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">ParentClass.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m parent!&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//若是要多个参数可以用apply 结合 ...解构</span></span><br><span class="line">    ParentClass.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype = <span class="built_in">Object</span>.create(ParentClass.prototype);</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line">SubClass.prototype.sayChildHello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m child &quot;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testA = <span class="keyword">new</span> SubClass(<span class="string">&#x27;CRPER&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create()的polyfill</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    function pureObject(o)&#123;</span></span><br><span class="line"><span class="comment">        //定义了一个临时构造函数</span></span><br><span class="line"><span class="comment">         function F() &#123;&#125;</span></span><br><span class="line"><span class="comment">         //将这个临时构造函数的原型指向了传入进来的对象。</span></span><br><span class="line"><span class="comment">         F.prototype = obj;</span></span><br><span class="line"><span class="comment">         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。</span></span><br><span class="line"><span class="comment">         //因为该实例的原型是obj对象。</span></span><br><span class="line"><span class="comment">         return new F();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// ES6: 其实就是ES5的语法糖,不过可读性很强..</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m parent!&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayChildHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m child &quot;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上</span></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;override parent method !,I&#x27;m sayHello Method&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testA = <span class="keyword">new</span> SubClass(<span class="string">&#x27;CRPER&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>到这里就结束了么…不,这只是笔试,</p>
<p>问的时候你用过静态方法,静态属性,私有变量么?</p>
<p>这个静态方法是ES6之后才有这么个玩意,有这么些特点</p>
<p>方法不能给 this引用,可以给类直接引用<br>静态不可以给实例调用,比如 let a = new ParentClass =&gt; a.sayHello() 会抛出异常<br>父类静态方法,子类非 static 方法没法覆盖父类<br>静态方法可以给子类继承<br>静态属性可以继承也可以被修改<br>看下面的代码..</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m parent!&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">testFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;emm...Parent test static Func&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayChildHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m child &quot;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;override parent method !,I&#x27;m sayHello Method&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">testFunc2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">super</span>.testFunc() + <span class="string">&#x27;fsdafasdf&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ParentClass.sayHello(); <span class="comment">// success print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> ParentClass(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">a.sayHello() <span class="comment">// throw error</span></span><br><span class="line"></span><br><span class="line">SubClass.sayHello(); <span class="comment">// 同名 static 可以继承且覆盖</span></span><br><span class="line"></span><br><span class="line">SubClass.testFunc2(); <span class="comment">// 可以继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testA = <span class="keyword">new</span> SubClass(<span class="string">&#x27;CRPER&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>私有变量这个我没答出来,只是说了下没有 private 这个关键字和基本用下划线的人为区分</p>
<p>所以回来只是找了下相关的资料,发现有一个比较好的模拟方案,就是 WeakMap ;</p>
<p>WeakMap 可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了.</p>
<p>const _ = new WeakMap(); // 实例化,value 必须为对象,有 delete,get,has,set四个方法,看名字都知道了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWeakMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id, barcode</span>)</span> &#123;</span><br><span class="line">        __.set(<span class="built_in">this</span>, &#123; id,barcode &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">testFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; id,barcode &#125; = __.get(<span class="built_in">this</span>); <span class="comment">// 获取对应的值</span></span><br><span class="line">        <span class="keyword">return</span> &#123; id,barcode &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hardy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hardy</p><p class="is-size-6 is-block">不积跬步无以至千里</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">96</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">88</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/believeZJP" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/believeZJP"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="微博" href="https://weibo.com/u/6021664425"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="tencent://message/?uin=421790588&amp;Site=www&amp;Menu=yes"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/es6/"><span class="level-start"><span class="level-item">es6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/http/"><span class="level-start"><span class="level-item">http</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/http/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-29T11:36:01.000Z">2020-12-29</time></p><p class="title"><a href="/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%97%E8%A1%A8/">思维导图列表</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-27T07:25:36.000Z">2020-11-27</time></p><p class="title"><a href="/posts/%E7%BE%BD%E6%AF%9B%E7%90%83%E9%80%9F%E6%88%90/">羽毛球速成</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-11T08:55:34.116Z">2020-09-11</time></p><p class="title"><a href="/posts/Alfred/">Alfred</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-08-20T08:18:50.000Z">2020-08-20</time></p><p class="title"><a href="/posts/React%E4%B8%ADAPI%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">React中API使用的正确姿势</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-07-23T16:06:49.000Z">2020-07-24</time></p><p class="title"><a href="/posts/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8standard%E8%A7%84%E8%8C%83%E5%B9%B6%E7%94%A8eslint%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/">项目使用standard规范并用eslint自动格式化代码</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Alfred/"><span class="tag">Alfred</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS3/"><span class="tag">CSS3</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EventLoop/"><span class="tag">EventLoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitKraken/"><span class="tag">GitKraken</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koa/"><span class="tag">Koa</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NodeJS/"><span class="tag">NodeJS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Promise/"><span class="tag">Promise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-Native/"><span class="tag">React Native</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React%E8%BF%81%E7%A7%BB%E5%88%B0%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">React迁移到百度小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSR/"><span class="tag">SSR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SmartGit/"><span class="tag">SmartGit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/antDesign/"><span class="tag">antDesign</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/async/"><span class="tag">async</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/await/"><span class="tag">await</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compose/"><span class="tag">compose</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es8/"><span class="tag">es8</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/for-of/"><span class="tag">for of</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/generator/"><span class="tag">generator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iTerm2/"><span class="tag">iTerm2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iterator/"><span class="tag">iterator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jQuery/"><span class="tag">jQuery</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nextTick/"><span class="tag">nextTick</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setImmediate/"><span class="tag">setImmediate</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setTimeout/"><span class="tag">setTimeout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack4/"><span class="tag">webpack4</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%9A%E5%8A%A1/"><span class="tag">业务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"><span class="tag">代码示例</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%A5%E6%83%B3/"><span class="tag">冥想</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%8E%E7%AB%AF/"><span class="tag">后端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%93%B2%E5%AD%A6/"><span class="tag">哲学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tag">基础知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/"><span class="tag">处理问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"><span class="tag">学习方法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">学习笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"><span class="tag">定时器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%81%E8%A3%85/"><span class="tag">封装</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"><span class="tag">思维导图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF/"><span class="tag">技术</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8F%92%E4%BB%B6/"><span class="tag">插件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87/"><span class="tag">效率</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"><span class="tag">日常积累</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99/"><span class="tag">正则</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/"><span class="tag">沟通技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">理论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">百度小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9B%91%E6%8E%A7/"><span class="tag">监控</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="tag">知识点</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E8%AF%BB/"><span class="tag">精读</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/"><span class="tag">线上事故</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/"><span class="tag">组合函数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%88%E7%AB%AF/"><span class="tag">终端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"><span class="tag">经验积累</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%91%E6%AD%A5/"><span class="tag">跑步</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%90%E5%8A%A8/"><span class="tag">运动</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><span class="tag">进程管理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="believeZJP" height="28"></a><p class="is-size-7"><span>&copy; 2020 believeZJP</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>