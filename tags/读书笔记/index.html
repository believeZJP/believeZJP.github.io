<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: 读书笔记 - believeZJP</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="believeZJP"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="believeZJP"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="积土成山，风雨兴焉；积水成渊，蛟龙生焉;"><meta property="og:type" content="blog"><meta property="og:title" content="believeZJP"><meta property="og:url" content="http://believezjp.oriht.com/"><meta property="og:site_name" content="believeZJP"><meta property="og:description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://believezjp.oriht.com/img/og_image.png"><meta property="article:author" content="believeZJP"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://believezjp.oriht.com"},"headline":"believeZJP","image":["http://believezjp.oriht.com/img/og_image.png"],"author":{"@type":"Person","name":"believeZJP"},"description":"积土成山，风雨兴焉；积水成渊，蛟龙生焉;"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?60d1b1f3f98701021581fc14f9ca17b7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="believeZJP" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/believeZJP"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">读书笔记</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-04T10:48:00.000Z" title="2020-04-04T10:48:00.000Z">2020-04-04</time>发表</span><span class="level-item"><time dateTime="2020-04-04T10:48:00.000Z" title="2020-04-04T10:48:00.000Z">2020-04-04</time>更新</span><span class="level-item">10 分钟读完 (大约1568个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/%E3%80%8A%E6%88%91%E7%94%9F%E6%9C%89%E6%B6%AF%E6%84%BF%E6%97%A0%E5%B0%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《我生有涯愿无尽》读书笔记</a></h1><div class="content"><p>摘自得到APP</p>
<h2 id="怎样像梁漱溟那样，依靠自学，建立独立的思想体系"><a href="#怎样像梁漱溟那样，依靠自学，建立独立的思想体系" class="headerlink" title="怎样像梁漱溟那样，依靠自学，建立独立的思想体系"></a>怎样像梁漱溟那样，依靠自学，建立独立的思想体系</h2><p>梁漱溟说，人们总以为知道很多，处处显得很渊博才算学问。 <strong>其实渊博并不算学问。什么才是学问呢？是能把眼前的道理和材料加以系统化、深刻化。</strong> 他把这个建立独立思想、获得真正学问的过程，分成了八个步骤。</p>
<p>第一步是通过用心思来建立主见。梁漱溟说，什么是哲学的道理？其实就是偏见，美其名曰的话，可以说是主见。只要是哲学家，就一定是极端的。哲学家用心思地思考问题，寻找能够贯通一切的普遍性道理。只要这个主见建立起来，他就不会再接受模棱两可、混乱矛盾的东西，会坚定地排斥不同观点。<strong>人通过独立思考获得的主见也许是浅薄的，但纵然浅薄，也是真正属于自己的。</strong> 他说，胡适的主见就很浅，但因为是他独立的心得，而且理论亲切动人，所以能自成一派。别人不行，因为连浅薄的主见都没有。</p></div><a class="article-more button is-small is-size-7" href="/posts/%E3%80%8A%E6%88%91%E7%94%9F%E6%9C%89%E6%B6%AF%E6%84%BF%E6%97%A0%E5%B0%BD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-05-17T09:03:35.000Z" title="2019-05-17T09:03:35.000Z">2019-05-17</time>发表</span><span class="level-item"><time dateTime="2019-05-17T09:03:35.000Z" title="2019-05-17T09:03:35.000Z">2019-05-17</time>更新</span><span class="level-item">1 小时读完 (大约8954个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%B2%BE%E8%AF%BB%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E5%8D%B7/">精读你不知道的JavaScript上卷</a></h1><div class="content"><p>[TOC]</p>
<h2 id="I-第1章作用域是什么"><a href="#I-第1章作用域是什么" class="headerlink" title="I-第1章作用域是什么"></a>I-第1章作用域是什么</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>JavaScript是一门编译语言</p>
<p>传统的编译语言在代码执行前会经历三个步骤(编译)</p>
<ul>
<li><p>分词/词法分析(Tokenizing/Lexing)</p>
<p>  将由字符组成的字符串分解成(对编程语言来说)有意义的代码块(词法单元token)</p>
</li>
<li><p>解析/语法分析(Parsing)</p>
<p>  将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树(抽象语法树Abstract Syntax Tree，AST)。</p>
</li>
<li><p>代码生成</p>
<p>  将 AST 转换为可执行代码</p>
</li>
</ul>
<p>JavaScript引擎编译过程比普通编译语言更复杂<br>在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。<br>用尽了各种办法(比如 JIT，可以延迟编译甚至实施重编译)来保证性能最佳。</p>
<h3 id="理解作用域-建议多读几遍"><a href="#理解作用域-建议多读几遍" class="headerlink" title="理解作用域(建议多读几遍)"></a>理解作用域(建议多读几遍)</h3><p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</p>
<p>可以将 RHS 理解成 retrieve his source value(取到它的源值)，这意味着“得到某某的值”。<br>在概念上最好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”。</p>
<p>如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。</p>
<p>赋值操作符会导致 LHS 查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。</p>
<p>遍历嵌套作用域链的规则: 从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>
<hr>
<p>编码经验：减少无意义的变量查找次数和未定义变量的查找，可以提升效率</p>
<hr>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>RHS 查询遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。</p>
<p>非严格模式：引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。</p>
<p>严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。</p>
<p>如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。</p>
<p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>

<ol>
<li><p>找出所有的LHS查询(这里有3处!)</p>
<p> c = ..;、a = 2(隐式变量分配)、b = ..</p>
</li>
<li><p>找出所有的RHS查询(这里有4处!)</p>
<p> foo(2..、= a;、a ..、.. b</p>
</li>
</ol>
<h2 id="I-第2章-词法作用域"><a href="#I-第2章-词法作用域" class="headerlink" title="I-第2章 词法作用域"></a>I-第2章 词法作用域</h2><p>词法作用域就是定义在词法阶段的作用域。</p>
<p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p>
<p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p>
<hr>
<p>在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。</p>
<p>全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问<code>window.a</code>，通过这种方式可以访问那些被同名变量所遮蔽的全局变量。</p>
<p>但非全局的变量如果被遮蔽了，无论如何都无法被访问到。</p>
<hr>
<h3 id="欺骗语法"><a href="#欺骗语法" class="headerlink" title="欺骗语法"></a>欺骗语法</h3><p>JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。</p>
<p>前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。</p>
<p>后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。</p>
<p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。会导致性能下降。<strong>不要使用它们。</strong></p>
<h2 id="I-第3章-函数作用域和块作用域"><a href="#I-第3章-函数作用域和块作用域" class="headerlink" title="I-第3章 函数作用域和块作用域"></a>I-第3章 函数作用域和块作用域</h2><blockquote>
<p>开发中，函数写的太多了。怎样才是个好的函数？我们常讲封装。封装函数，封装常用的方法，通过这章内容可以学习到为什么要封装，封装的好处和一些封装的方法。</p>
</blockquote>
<p>函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(在嵌套的作用域中也可以使用)。<br>这种设计方案能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。</p>
<h3 id="利用函数作用域隐藏内部实现"><a href="#利用函数作用域隐藏内部实现" class="headerlink" title="利用函数作用域隐藏内部实现"></a>利用函数作用域隐藏内部实现</h3><p>正确的代码应该考虑到如何选择作用域来包含变量和函数。遵循最小授权原则。</p>
<hr>
<p>最小授权或最小暴露原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</p>
<hr>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>b</code> 和函数 <code>doSomethingElse(..)</code> 是 <code>doSomething(..)</code> 内部具体实现的“私有”内容。<br>给予外部作用域对 <code>b</code> 和 <code>doSomethingElse(..)</code> 的“访问权限”不仅没有必要，而且可能是“危险”的，<br>因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了doSomething(..) 的适用条件。<br>更“合理”的设计会将这些私有的具体内容隐藏在 <code>doSomething(..)</code> 内部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> b;</span><br><span class="line">    b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>功能和效果都没受影响，设计上将具体内容私有化，设计良好的软件都会依此进行实现。</strong></p>
<h4 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h4><p>隐藏作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        i = <span class="number">3</span>; <span class="comment">// 修改for循环所属作用域中的i</span></span><br><span class="line">        <span class="built_in">console</span>.log( a + i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        bar( i * <span class="number">2</span> ); <span class="comment">// 糟糕，无限循环了!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这里用<code>var i = 3;</code>和 <code>j = 3;</code>都可以解决这个问题，但使用作用域来“隐藏”内部声明是唯一的最佳选择。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li><p>全局命名空间</p>
<p> 在jQuery时代，引用各种第三方库尤为明显。如果组件没有很好的将内部私有函数和变量隐藏起来会引起很多问题。</p>
<p> 最佳实践：声明一个名字足够独特的变量，通常是一个对象。所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。</p>
<p> 示例</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line">    awesome: <span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块管理</p>
<p> 从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。</p>
</li>
</ol>
<h3 id="函数作用域优化"><a href="#函数作用域优化" class="headerlink" title="函数作用域优化"></a>函数作用域优化</h3><p>函数作用域需要显示声明函数名和调用该函数</p>
<p>采用包装函数来解决，将函数声明转成表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- 添加这一行</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    &#125;)(); <span class="comment">// &lt;-- 以及这一行</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</span><br></pre></td></tr></table></figure>

<h4 id="匿名和具名函数"><a href="#匿名和具名函数" class="headerlink" title="匿名和具名函数"></a>匿名和具名函数</h4><h5 id="匿名函数表达式"><a href="#匿名函数表达式" class="headerlink" title="匿名函数表达式"></a>匿名函数表达式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I waited 1 second!&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>

<p>这叫作匿名函数表达式，因为 <code>function()..</code> 没有名称标识符。函数表达式可以是匿名的，<br>而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p>
<p>匿名函数缺点：</p>
<ol>
<li>匿名函数在栈追踪中不会显示函数名，调试很困难。</li>
<li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。<br>另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li>
<li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li>
</ol>
<p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。<br>给函数表达式指定一个函数名可以有效解决以上问题。<br><strong>始终给函数表达式命名是一个最佳实践</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;-- 快看，我有名字了!</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;I waited 1 second!&quot;</span> );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>

<h5 id="立即执行函数表达式-IIFE-Immediately-Invoked-Function-Expression"><a href="#立即执行函数表达式-IIFE-Immediately-Invoked-Function-Expression" class="headerlink" title="立即执行函数表达式(IIFE Immediately Invoked Function Expression)"></a>立即执行函数表达式(IIFE Immediately Invoked Function Expression)</h5><p>将函数包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数。<br>比如 <code>(function foo()&#123; .. &#125;)()</code>, 另一种形式<code>(function()&#123; .. &#125;())</code>。两种形式在功能上是一致的。</p>
<p>IIFE进阶用法，把它们当作函数调用并传递参数进去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> <span class="built_in">global</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">global</span>.a ); <span class="comment">// 2</span></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。<br>这对于改进代码风格是非常有帮助的。</p>
<p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。<br>这种模式在 UMD(Universal Module Definition)项目中被广泛使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>) </span>&#123;</span><br><span class="line">    def( <span class="built_in">window</span> );</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> <span class="built_in">global</span> </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">global</span>.a ); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p><code>&#123;&#125;</code>, <code>for</code>, <code>if</code>, <code>with</code>, <code>try/catch</code>, <code>let</code>, <code>const</code>都是声明块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">    &#123; <span class="comment">// &lt;-- 显式的块</span></span><br><span class="line">        <span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">        bar = something( bar ); <span class="built_in">console</span>.log( bar );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</strong></p>
<h2 id="I-第4章-提升"><a href="#I-第4章-提升" class="headerlink" title="I-第4章 提升"></a>I-第4章 提升</h2><blockquote>
<p>编译器在编译代码时是从上到下一行行编译的吗？</p>
</blockquote>
<p>引擎会在执行 JavaScript 代码之前先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</p>
<p>变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。</p>
<p>注意：函数声明会被提升，<strong>包括函数表达式的赋值在内的赋值操作</strong>并不会提升。</p>
<p><strong>函数会首先被提升，然后才是变量。</strong></p>
<p>后面的函数声明可以覆盖前面的，如下输出3</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式不会提升</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个代码被引擎解析如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题!</p>
<p>用<code>let</code>和<code>const</code>可以解决重复声明的问题。</p>
<h2 id="I-第5章-作用域闭包"><a href="#I-第5章-作用域闭包" class="headerlink" title="I-第5章 作用域闭包"></a>I-第5章 作用域闭包</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
<p>经典示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 2 —— 这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>

<p>bar() 在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为引擎有垃圾回收器用来释放不再使用的内存空间。<br>由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p>
<p>而闭包的“神奇”之处正是可以阻止这件事情的发生。<br>由于 bar() 所声明的位置在foo内部，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。</p>
<p>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>
<p>循环经典案例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i ); <span class="comment">// 以每秒一次的频率输出五次 6</span></span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。</p>
<p>改进，为每次迭代生成新的作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( j );</span><br><span class="line">        &#125;, j*<span class="number">1000</span> );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>let</code>解决。let变量在循环过程中不止被声明一次，每次迭代都会声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块模式需要具备两个必要条件。</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( something );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( another.join( <span class="string">&quot; ! &quot;</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// modifying the public API</span></span><br><span class="line">        publicAPI.identify = identify2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">identify1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( id );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">identify2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( id.toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> publicAPI = &#123;</span><br><span class="line">        change: change,</span><br><span class="line">        identify: identify1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> publicAPI;</span><br><span class="line">&#125;)( <span class="string">&quot;foo module&quot;</span> );</span><br><span class="line"></span><br><span class="line">foo.identify(); <span class="comment">// foo module</span></span><br><span class="line">foo.change();</span><br><span class="line">foo.identify(); <span class="comment">// FOO MODULE</span></span><br></pre></td></tr></table></figure>

<p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>
<h4 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply( impl, deps );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        get: get</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>核心代码是这行<code>modules[name] = impl.apply( impl, deps );</code></strong><br>为了模块的定义引入了包装函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。</p>
<p>看看怎么使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MyModules.define( <span class="string">&quot;bar&quot;</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Let me introduce: &quot;</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello: hello</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">MyModules.define( <span class="string">&quot;foo&quot;</span>, [<span class="string">&quot;bar&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">&quot;hippo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = MyModules.get( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> foo = MyModules.get( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">    bar.hello( <span class="string">&quot;hippo&quot;</span> )</span><br><span class="line">); <span class="comment">// Let me introduce: hippo</span></span><br><span class="line"></span><br><span class="line">foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多花一点时间来研究这些示例代码并完全理解闭包的作用吧。最重要的是要理解模块管理器没有任何特殊的“魔力”。<br>它们符合前面列出的模块模式的两个特点:为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。<br>换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。</p>
<h4 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h4><p>ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立的模块来处理。<br>每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。</p>
<p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。</p>
<p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上(在我们的例子里是 hello)。<br>module 会将整个模块的 API 导入并绑定到一个变量上(在我们的例子里是 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公共 API。<br>这些操作可以在模块定义中根据需要使用任意多次。</p>
<p>bar.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Let me introduce: &quot;</span> + who;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> hello;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>baz.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar.hello( <span class="string">&quot;rhino&quot;</span> )); <span class="comment">// Let</span></span><br></pre></td></tr></table></figure>

<h2 id="II-第1章-关于this"><a href="#II-第1章-关于this" class="headerlink" title="II-第1章 关于this"></a>II-第1章 关于this</h2><p>this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。</p>
<p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>
<p>this<strong>既不指向函数自身也不指向函数的词法作用域</strong></p>
<p><strong>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</strong></p>
<h2 id="II-第2章-this全面解析"><a href="#II-第2章-this全面解析" class="headerlink" title="II-第2章 this全面解析"></a>II-第2章 this全面解析</h2><p>从<a target="_blank" rel="noopener" href="https://juejin.im/post/5efe67276fb9a07e5d76be30">上一章</a>知道理解this，就是要理解<code>函数被调用的位置</code>。但实践起来有点复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要的是分析调用栈，在当前正在执行函数前一个调用中。在函数第一行设置&#96;debugger&#96;,开发者工具调用栈的第二个元素就是真正的调用位置。</span><br></pre></td></tr></table></figure>

<h3 id="四条绑定规则"><a href="#四条绑定规则" class="headerlink" title="四条绑定规则"></a>四条绑定规则</h3><h4 id="1-独立调用"><a href="#1-独立调用" class="headerlink" title="1. 独立调用"></a>1. 独立调用</h4><p>独立函数调用，即使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</p>
<p>this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 <code>strict mode</code> 下时，默认绑定才能绑定到全局对象;严格模式下与 foo() 的调用位置无关:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h4><p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>一个最常见的 this 绑定问题是被隐式绑定的函数会丢失绑定对象，它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名!</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// a 是全局对象的属性 bar(); // &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>回调函数里也会有this丢失现象</p>
<h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h3><p><code>call</code>和<code>apply</code>可以直接指定 this 的绑定对象，称之为显式绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>( bar, <span class="number">10</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 硬绑定的 bar 不可能再修改它的 this</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在<code>bar</code>中强制把foo的this绑定到obj上，无论之后怎么调用bar，都不会修改this。这种显示强绑定，称为硬绑定。</p>
<p>ES5 中提供了内置的方法<code>Function.prototype.bind</code>也是强绑定。</p>
<h4 id="API调用的“上下文”-context"><a href="#API调用的“上下文”-context" class="headerlink" title="API调用的“上下文”(context)"></a>API调用的“上下文”(context)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</span><br><span class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>

<p>这种也是通过call和apply实现的显示绑定。</p>
<h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h3><p>js通过new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建(构造)一个全新的对象。</li>
<li>这个新对象会被执行原型连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>四条绑定原则的优先级</p>
<ol>
<li>由new调用? 绑定到新创建的对象。</li>
<li>由call或者apply(或者bind)调用? 绑定到指定的对象。</li>
<li>由上下文对象调用? 绑定到那个上下文对象。</li>
<li>默认:在严格模式下绑定到undefined，否则绑定到全局对象。</li>
</ol>
<h3 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h3><p>把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值<br>在调用时会被忽略，实际应用的是默认绑定规则。</p>
<p>函数的间接引用，会导致应用默认绑定。</p>
<h4 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h4><p>硬绑定可以强制绑定到指定对象(除new时)，降低了函数的灵活性。采用软绑定方式可以实现和硬绑定相同的效果，同时保留隐式绑定修改this的能力。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 捕获所有 curried 参数</span></span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">            (!<span class="built_in">this</span> || <span class="built_in">this</span> === (<span class="built_in">window</span> || <span class="built_in">global</span>)) ?</span><br><span class="line">            obj : <span class="built_in">this</span></span><br><span class="line">            curried.concat.apply( curried, <span class="built_in">arguments</span> )</span><br><span class="line">            );</span><br><span class="line">        &#125;;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this语法"><a href="#this语法" class="headerlink" title="this语法"></a>this语法</h3><p>箭头函数<code>() =&gt; &#123;&#125;</code>无法使用上述四种规则。而是<strong>根据外层（函数或者全局）作用域来决定this</strong>。<br>箭头函数可以像 <code>bind(..)</code> 一样确保函数的 this 被绑定到指定对象，它用更常见的词法作用域取代了传统的 this 机制。</p>
<p>没有箭头函数之前我们习惯采用的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>; <span class="comment">// lexical capture of this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( self.a );</span><br><span class="line">    &#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>self = this</code> 和箭头函数看起来都可以取代<code>bind(..)</code>，但是从本质上来说，它们想替代的是 this 机制。</p>
<h3 id="小结this全面解析"><a href="#小结this全面解析" class="headerlink" title="小结this全面解析"></a>小结this全面解析</h3><p>学习本章了解this绑定的方式，通过4条准则定位函数运行时this到底指向什么。</p>
<p>在箭头函数出来之后，用<code>() =&gt; &#123;&#125;</code>和<code>bind</code>可以解决大多数问题了。</p>
<p>ES5出来之后，很多js的问题被新语法取代了，但我们可以抽时间多了解新语法背后的历史，能更深入的了解js本身的魅力。</p>
<h2 id="II-第3章-对象"><a href="#II-第3章-对象" class="headerlink" title="II-第3章 对象"></a>II-第3章 对象</h2><p>对象是JavaScript的基础。</p>
<p>ECMAScript 标准定义了 8 种数据类型:</p>
<p>7 种原始类型:<br>Undefined<br>Null<br>Number<br>Boolean<br>BigInt<br>String<br>Symbol<br>和 Object</p>
<p>记忆口诀：欧呦(O)你(U)俩(2个)牛(N)逼(B)啥(S)</p>
<p>定义对象两种形式：声明形式和构造形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    key: value</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure>

<h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    [prefix + <span class="string">&quot;bar&quot;</span>]:<span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    [prefix + <span class="string">&quot;baz&quot;</span>]: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject[<span class="string">&quot;foobar&quot;</span>]; <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>js中函数不会属于一个对象，因为this是在运行时根据调用位置动态绑定的。 所以方法这个称呼不太成立。但这只是个称呼，不必太纠结。</p>
<h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>浅复制</p>
<p>对于JSON安全(可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象)的对象可以用<code>JSON.parse</code>复制</p>
<p><code>var newObj = JSON.parse(JSON.stringify(someObj));</code></p>
<p>ES6中可以用<code>Object.assign(&#123;&#125;, obj)</code>复制</p>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>属性描述符<code>writable(可写), configurable(可配置), enumerable(可枚举)</code></p>
<p>可以使用<code>Object.defineProperty</code>定义属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;KEY&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果把 enumerable 设置成 false，这个属性不会出现在枚举中（比如for..in）。但可以正常访问这个属性。</p>
<p>结合<code>writable: false</code>和<code>configurable: false</code>可以创建一个真正的常量属性(不可修改、重定义或删除)</p>
<p>禁止一个对象添加新属性并且保留已有属性，可以使用<code>Object.preventExtensions(obj)</code></p>
<p>密封：<code>Object.seal(..)</code>调用<code>Object.preventExtensions(obj)</code>把所有现有属性标记为<code>configurable: false</code>。密封后不能添加，重新配置和删除现有属性。可以修改属性的值。</p>
<p>冻结：<code>Object.freeze(..)</code>调用<code>Object.seal(..)</code>把所有数据访问属性标记为<code>writable: false</code>。这样就无法修改属性值。</p>
<h3 id="get-set"><a href="#get-set" class="headerlink" title="get, set"></a>get, set</h3><p>get: 属性访问先在对象中查找是否有名称相同的属性，没找到就遍历可能存在的原型链，找不到的话返回undefined。</p>
<p>set:</p>
<ol>
<li>先判断属性是否是访问描述符，存在setter就调用setter。</li>
<li>writable是否为false。是，非严格模式下静默失败，严格模式抛出TypeError异常。</li>
<li>都不是，设置属性值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="comment">// 给 a 定义一个 getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">// 给 a 定义一个 setter</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = <span class="number">2</span>; myObject.a; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>判断对象是否有某个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// false</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;b&quot;</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>操作符会检查属性是否在对象及其原型链中</p>
<p><code>hasOwnProperty(..)</code> 只会检查属性是否在 myObject 对象中，不会检查链。</p>
<p>所有的普通对象都可以通过对于 Object.prototype 的委托来访问 hasOwnProperty(..)，<br>但是有的对象可能没有连接到 Object.prototype(通过 Object. create(null) 来创建)。<br>在这种情况下，形如<code>myObejct.hasOwnProperty(..)</code>就会失败。</p>
<p>可以采用<code>Object.prototype.hasOwnProperty. call(myObject,&quot;a&quot;)</code>判断</p>
<p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否可枚举</span></span><br><span class="line">myObject.propertyIsEnumerable( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br><span class="line">myObject.propertyIsEnumerable( <span class="string">&quot;b&quot;</span> ); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 所有可枚举属性的数组</span></span><br><span class="line"><span class="built_in">Object</span>.keys( myObject ); <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"><span class="comment">// 所有属性，无论它们是否可枚举</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames( myObject ); <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><code>for..in</code>无法直接获取属性值，因为它遍历的是对象中的所有可枚举属性，需要手动获取属性值。<br><code>for..of</code>循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值。</p>
<h3 id="小结-第3章对象"><a href="#小结-第3章对象" class="headerlink" title="小结 第3章对象"></a>小结 第3章对象</h3><p>了解对象是什么，怎么定义，一些常用方法和特性，遍历对象。</p>
<p>工作中对象的使用是非常频繁的，熟练掌握各种API是提升技术的必备条件。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;</span><br><span class="line">    a: <span class="number">12</span>,</span><br><span class="line">    b: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">newObj.a = <span class="number">12</span>;</span><br><span class="line">newObj.b = <span class="number">23</span>;</span><br><span class="line">newObj[<span class="string">&#x27;a&#x27;</span>] = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    ...newObj</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    a: newObj.a,</span><br><span class="line">    b: newObj.b</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="II-第4章-混合对象”类“"><a href="#II-第4章-混合对象”类“" class="headerlink" title="II-第4章 混合对象”类“"></a>II-第4章 混合对象”类“</h2><blockquote>
<p>我的理解类也是一种对象而已，没那么复杂。</p>
</blockquote>
<p>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。</p>
<p>类意味着复制。<br>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。<br>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的是复制的结果。</p>
<p>JavaScript 并不会(像类那样)自动创建对象的副本。</p>
<p>混入模式用来模拟类的复制行为。Vue中也提供了类似的API,<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/mixins.html">mixin</a></p>
<h2 id="II-第5章-原型（还需多读几遍）"><a href="#II-第5章-原型（还需多读几遍）" class="headerlink" title="II-第5章 原型（还需多读几遍）"></a>II-第5章 原型（还需多读几遍）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这篇文章是JS的重中之重，要用心研读~~</span><br></pre></td></tr></table></figure>

<p>能学到的知识：</p>
<ol>
<li><p>对象查找和设置属性背后发生了什么</p>
</li>
<li><p>原型链形成的机制和特点</p>
</li>
</ol>
<p>前面说到在对象里查找属性时，如果在对象本身找不到，会继续访问对象的prototype链。如果都没有的话返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个关联到 anotherObject 的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line"><span class="built_in">console</span>.log(myObject); <span class="comment">// &#123;&#125;</span></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>现在<code>myObject</code>的<code>prototype</code>关联到<code>anotherObject</code>，<code>myObject.a</code>并不存在，但<code>myObject.a</code>结果为2</p>
<p><code>for..in</code>遍历对象时原理和查找原型链类似。任何可通过原型链访问到(并且是enumerable)的属性都会被枚举</p>
<p>当你通过各种语法进行属性查找时都会查找原型链，直到找到属性或者查找完整条原型链。</p>
<p><strong>原型链的尽头是<code>Object.prototype</code></strong><br><code>toString()</code>、<code>valueOf()</code>和其他一些通用的功能 都存在于<code>Object.prototype</code>对象上，因此语言中所有的对象都可以使用它们。</p>
<h3 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h3><p>给一个对象设置属性的过程并不简单。通过例子来看<code>myObject.foo = &quot;bar&quot;;</code></p>
<p>一、 如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p>
<p>二、 如果 foo 不是直接存在于 myObject 中，原型链就会被遍历。如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。</p>
<p>三、 如果 foo 存在于原型链上层，赋值语句 <code>myObject.foo = &quot;bar&quot;</code> 的行为就会有些不同。</p>
<p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的原型链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。</p>
<blockquote>
<p>屏蔽：在当前作用域添加属性，以隔绝访问原型链上层的同样属性</p>
</blockquote>
<p>发生屏蔽的三种情况：</p>
<ol>
<li>如果在原型链上层存在名为foo的普通数据访问属性并且没有被标记为只读，那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</li>
<li>如果在原型链上层存在foo，但是它被标记为只读，那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li>如果在原型链上层存在foo并且它是一个setter，那就一定会调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这个 setter。</li>
</ol>
<p>向原型链上层已经存在的属性赋值，不一定会触发屏蔽(第二三种)。<br>如果希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 = 操作符来赋值，而是使用 Object.defineProperty(..)来向 myObject 添加 foo。</p>
<blockquote>
<p>只读属性会阻止原型链下层屏蔽同名属性。这样做主要是为了模拟类属性的继承。你可以把原型链上层的 foo 看作是父类中的属性，它会被 myObject 继承(复制)，这样一来 myObject 中的 foo 属性也是只读，所以无法创建。但是一定要注意，实际上并不会发生类似的继承复制。这看起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不能包含 foo 属性。更奇怪的是，这个限制只存在于 = 赋值中，使用 Object. defineProperty(..) 并不会受到影响。</p>
</blockquote>
<p>有些情况下会隐式产生屏蔽，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">anotherObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a++; <span class="comment">// 隐式屏蔽!</span></span><br><span class="line">anotherObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a; <span class="comment">// 3</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">&quot;a&quot;</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>++</code> 操作相当于 <code>myObject.a = myObject.a + 1</code>。因此 ++ 操作首先会通过原型链查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着将值 3 赋给 myObject 中新建的屏蔽属性 a。</p>
<p>修改委托属性时一定要小心。如果想让 anotherObject.a 的值增加，唯一的办法是 anotherObject.a++。</p>
<h3 id="类函数"><a href="#类函数" class="headerlink" title="类函数"></a>类函数</h3><p>函数的一种特殊特性:所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象: Foo的原型。我们通过名为 Foo.prototype 的属性引用来访问它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype; <span class="comment">// &#123; &#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf( a ) === Foo.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用 new Foo() 时会创建 a，其中的一步就是给 a 一个内部的原型链，关联到 Foo.prototype 指向的那个对象。</p>
<p>在 JavaScript 中，不能创建一个类的多个实例，只能创建多个对象，它们的原型链关联的是同一个对象。在默认情况下多次实例化一个类不会进行复制， 因此这些对象之间并不会完全失去联系，它们是互相关联的。</p>
<p>通过<code>new Foo()</code>得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联。</p>
<p>实际上，绝大多数 JavaScript 开发者不知道的秘密是，new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。new Foo() 只是间接完成了我们的目标:一个关联到其他对象的新对象。</p>
<p>通过<code>Object.create(..)</code>可以直接做到这一点。</p>
<p>通常我们讲原型继承。继承意味着复制操作。JS默认不会复制对象属性。会在两个对象之间创建关联，这样一个对象可以通过委托访问另一个对象的属性和函数。</p>
<p>差异继承？</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。</p>
<p>函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.constructor === Foo; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Foo.prototype 默认(在代码中第一行声明时)有一个公有并且不可枚举的属性<code>.constructor</code>，这个属性引用的是对象关联的函数(本例中是 Foo)。<br>此外，我们可以看到通过“构造函数”调用 new Foo() 创建的对象也有一个 <code>.constructor</code> 属性，指向 “创建这个对象的函数”。</p>
<p><code>a.constructor</code> 只是通过默认的原型委托指向 Foo，这和构造毫无关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* .. */</span> &#125;</span><br><span class="line">Foo.prototype = &#123; <span class="comment">/* .. */</span> &#125;; <span class="comment">// 创建一个新原型对象</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</span><br><span class="line">a1.constructor === Foo; <span class="comment">// false!</span></span><br><span class="line">a1.constructor === <span class="built_in">Object</span>; <span class="comment">// true!</span></span><br></pre></td></tr></table></figure>

<p>Object(..) 并没有“构造”a1，看起来应该是 Foo()“构造”了它。<br>大部分开发者 都认为是 Foo() 执行了构造工作，但是问题在于，如果你认为<code>constructor</code>表示“由…… 构造”的话，a1.constructor 应该是 Foo，但是它并不是 Foo !</p>
<p>a1 并没有 .constructor 属性，所以它会委托原型链上的 Foo. prototype。但是这个对象也没有 .constructor 属性(不过默认的 Foo.prototype 对象有这 个属性!)，<br>所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象 有 .constructor 属性，指向内置的 Object(..) 函数。</p>
<p>对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用。</p>
<p><strong>constructor 并不表示被构造</strong><br>.constructor 并不是一个不可变属性。它是不可枚举的，但是它的值是可写的。此外，你可以给任意原型链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p><code>Bar.prototype = Object.create()</code><br>Object.create(..) 会凭空创建一个“新”对象并把新对象内部的原型链关联到指定的对象(本例中是 Foo.prototype)。<br>换句话说，这条语句的意思是:“创建一个新的 Bar.prototype 对象并把它关联到 Foo. prototype”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和你想要的机制不一样!</span></span><br><span class="line">Bar.prototype = Foo.prototype;</span><br><span class="line"><span class="comment">// 基本上满足你的需求，但是可能会产生一些副作用 :(</span></span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p>Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。<br>因此当你执行类似<code>Bar.prototype. myLabel = ...</code>的赋值语句时会直接修改 Foo.prototype 对象本身。<br>显然这不是你想要的结果，否则你根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会更简单一些。</p>
<p>Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象。<br>但是它使用了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些副作用(比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等)的话，<br>就会影响到 Bar() 的“后代”，后果 不堪设想。</p>
<p>对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class="line">Bar.ptototype = <span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line"><span class="comment">// ES6 开始可以直接修改现有的</span></span><br><span class="line">Bar.prototype <span class="built_in">Object</span>.setPrototypeOf( Bar.prototype, Foo.prototype );</span><br></pre></td></tr></table></figure>

<p>如果忽略掉 Object.create(..) 方法带来的轻微性能损失(抛弃的对象需要进行垃圾回收)，它实际上比 ES6 及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法。</p>
<h3 id="检查类关系"><a href="#检查类关系" class="headerlink" title="检查类关系"></a>检查类关系</h3><p><code>instanceof</code> 操作符的左操作数是一个普通的对象，右操作数是一个函数。</p>
<p>在 a 的整条原型链中是否有指向 Foo.prototype 的对象?</p>
<p>这个方法只能处理对象(a)和函数(带 .prototype 引用的 Foo)之间的关系。如果你想判断两个对象(比如 a 和 b)之间是否通过原型链关联，只用 instanceof 无法实现。</p>
<p>第二种判断反射的方法：</p>
<p><code>Foo.prototype.isPrototypeOf( a ); // true</code></p>
<p>b 是否出现在 c 的原型链中?<br><code>b.isPrototypeOf( c );</code></p>
<p>直接获取一个对象原型链的方法<code>Object.getPrototypeOf(a)</code></p>
<p><code>Object.getPrototypeOf( a ) === Foo.prototype; // true</code></p>
<p>非标准的方法<code>a.__proto__ === Foo.prototype; // true</code></p>
<p><code>.constructor</code>和<code>.__proto__</code>一样，并不存在于你正在使用的对象中 (本例中是 a)。<br>它和其他的常用函数(.toString()、.isPrototypeOf(..)，等等)<br>一样，存在于内置的 Object.prototype 中。是不可枚举的。</p>
<p>.<strong>proto</strong> 的实现大致上是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty( <span class="built_in">Object</span>.prototype, <span class="string">&quot;__proto__&quot;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf( <span class="built_in">this</span> ); &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ES6 中的 setPrototypeOf(..)</span></span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf( <span class="built_in">this</span>, o );</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><p><code>Object.create(..)</code> 会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，<br>这样我们就可以充分发挥原型链机制的威力(委托)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成 <code>.prototype</code> 和 <code>.constructor</code> 引用)。</p>
<p><code>Object.create()</code>的polyfill代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="II-第6章-行为委托"><a href="#II-第6章-行为委托" class="headerlink" title="II-第6章 行为委托"></a>II-第6章 行为委托</h2><p>委托行为意味着某些对象(XYZ)在找不到属性或者方法引用时会把这个请求委托给另一个对象(Task)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Task = &#123;</span><br><span class="line">    setID: <span class="function"><span class="keyword">function</span>(<span class="params">ID</span>) </span>&#123; <span class="built_in">this</span>.id = ID; &#125;,</span><br><span class="line">    outputID: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="built_in">this</span>.id ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 让XYZ委托Task</span></span><br><span class="line">XYZ = <span class="built_in">Object</span>.create( Task );</span><br><span class="line">XYZ.prepareTask = <span class="function"><span class="keyword">function</span>(<span class="params">ID,Label</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setID(ID);</span><br><span class="line">    <span class="built_in">this</span>.label = Label;</span><br><span class="line">&#125;;</span><br><span class="line">XYZ.outputTaskDetails = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.outputID();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.label);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。</p>
<p>写不下去了~~</p>
<p>学不精，所以讲不通</p>
<p>待我理解透彻再来更新吧</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-05-17T09:03:35.000Z" title="2019-05-17T09:03:35.000Z">2019-05-17</time>发表</span><span class="level-item"><time dateTime="2019-05-17T09:03:35.000Z" title="2019-05-17T09:03:35.000Z">2019-05-17</time>更新</span><span class="level-item">1 小时读完 (大约8151个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%B2%BE%E8%AF%BB%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E5%8D%B7/">精读你不知道的JavaScript中卷</a></h1><div class="content"><p>[TOC]</p>
<h2 id="I-第1章-类型"><a href="#I-第1章-类型" class="headerlink" title="I-第1章 类型"></a>I-第1章 类型</h2><p>一个人身上的特异性和一个人身上的特异性与惊奇性并不会对另一人产生压制。你身上的天才，会激发我身上的天才。</p>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>ECMAScript 标准定义了 8 种数据类型:</p>
<p>7 种原始类型:<br>Undefined<br>Null<br>Number<br>Boolean<br>BigInt<br>String<br>Symbol<br>和 Object(基本类型)</p>
<p>记忆口诀：欧呦(O)你(U)俩(2个)牛(N)逼(B)啥(S)</p>
<p>用typeof来查看值的类型，返回的是字符串。但类型和它们的字符串值不一一对应</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&#x27;boolean&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">12</span> === <span class="string">&#x27;number&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;12&#x27;</span> === <span class="string">&#x27;string&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">life</span>: <span class="number">12</span> &#125; === <span class="string">&#x27;object&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> BigInt(<span class="string">&#x27;1&#x27;</span>) === <span class="string">&#x27;bigint&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>(BigInt(<span class="string">&#x27;2&#x27;</span>)) === <span class="string">&#x27;object&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不一样的</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测null值的类型需要复合条件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span>;</span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">&#x27;object&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function也是JS的内置类型，实际是object的子类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;<span class="comment">/**/&#125; === &#x27;function&#x27;; // true</span></span><br><span class="line"><span class="comment">// 数组也是object的子类型</span></span><br><span class="line"><span class="comment">typeof [1,2,3] === &#x27;object&#x27; // true</span></span><br></pre></td></tr></table></figure>

<h3 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h3><p>JS中变量没有类型，值才有。变量可以随时持有任何类型的值。</p>
<p>typeof得到的结果不是该变量的类型，而是该变量持有值的类型。返回的总是字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">12</span>; <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="typeof-Undeclared"><a href="#typeof-Undeclared" class="headerlink" title="typeof Undeclared"></a>typeof Undeclared</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a; <span class="comment">// undefined</span></span><br><span class="line">b; <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<p>typeof对未定义的变量也返回<code>undefined</code>。且没有报错。</p>
<p>这是因为typeof有一个特殊的安全防范机制。</p>
<p>多个脚本会在共享的全局命名空间中加载变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Debugging is starting&#x27;</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样是安全的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> DEBUG !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&#x27;Debugging is starting&#x27;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对内建API也有帮助</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> atob === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    atob = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>typeof安全机制也可以用来判断非全局变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FeatureXYZ</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*.. my XYZ feature ..*/</span> &#125;</span><br><span class="line">    <span class="comment">// 包含doSomethingCool(..)</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomethingCool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> helper =</span><br><span class="line">            (<span class="keyword">typeof</span> FeatureXYZ !== <span class="string">&#x27;undefined&#x27;</span>) ? FeatureXYZ :</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*.. default feature ..*/</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> val = helper();</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;</span><br><span class="line">    doSomethingCool();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这里FeatureXYZ不是全局变量，也可以用typeof安全防范机制来做检查</p>
<p>也可以用依赖注入方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingCool</span>(<span class="params">FeatureXYZ</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> helper = FeatureXYZ ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*.. default feature ..*/</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> val = helper();</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型小结"><a href="#类型小结" class="headerlink" title="类型小结"></a>类型小结</h3><ol>
<li>了解JS内置类型</li>
<li>根据typeof判断类型</li>
<li>typeof的安全机制应用场景</li>
</ol>
<h2 id="I-第2章-值"><a href="#I-第2章-值" class="headerlink" title="I-第2章 值"></a>I-第2章 值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过这章的学习，可以了解，数组，字符串，特殊数值，值传递和值引用的区别</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JS的数组可容纳任何类型的值，数组声明后即可添加值，不用预设大小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, [<span class="number">3</span>]];</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] === <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">4</span>] =  <span class="number">5</span>;</span><br><span class="line">a[<span class="number">3</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>a[3]为undefined，称作”稀疏数组”（sparse array）。这里的undefined与显示赋值为undefined不同。</p>
<p>数组也是对象。可以自定义属性(不计算在数组长度内)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>];</span><br><span class="line">a[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">a.length; <span class="comment">// 1</span></span><br><span class="line">a[<span class="string">&#x27;foo&#x27;</span>]; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类数组转数组常用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice() 返回参数列表的一个数组复本。</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call( <span class="built_in">arguments</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from( <span class="built_in">arguments</span> );</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串和数组相似，都有length属性，indexOf, concat方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> b = [<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">b.length; <span class="comment">// 3</span></span><br><span class="line">a.indexOf(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line">b.indexOf(<span class="string">&#x27;o&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.concat( <span class="string">&#x27;bar&#x27;</span> );<span class="comment">// &#x27;foobar&#x27;</span></span><br><span class="line"><span class="keyword">var</span> d = b.concat( [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>] );<span class="comment">// [&#x27;f&#x27;,&#x27;o&#x27;,&#x27;o&#x27;,&#x27;b&#x27;,&#x27;a&#x27;,&#x27;r&#x27;]</span></span><br><span class="line">a === c;<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">b === d;<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a; <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">b; <span class="comment">// [&#x27;f&#x27;,&#x27;o&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
<p>借助数组方法来处理字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a.join;   <span class="comment">// undefined</span></span><br><span class="line">a.map;   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Array</span>.prototype.join.call( a, <span class="string">&#x27;-&#x27;</span> );</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Array</span>.prototype.map.call( a, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.toUpperCase() + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125; ).join( <span class="string">&#x27;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">c;    <span class="comment">// &#x27;f-o-o&#x27;</span></span><br><span class="line">d;    <span class="comment">// &#x27;F.O.O.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>字符串反转</p>
<p>字符串没有<code>reverse</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = a</span><br><span class="line"><span class="comment">// 将a的值转换为字符数组</span></span><br><span class="line">.split( <span class="string">&quot;&quot;</span> )</span><br><span class="line"><span class="comment">// 将数组中的字符进行倒转</span></span><br><span class="line">.reverse()</span><br><span class="line"><span class="comment">// 将数组中的字符拼接回字符串</span></span><br><span class="line">.join( <span class="string">&quot;&quot;</span> );</span><br><span class="line">c; <span class="comment">// &quot;oof&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果经常以字符数组方式处理字符串的话，倒不如直接用数组。在需要时使用<code>join()</code>将数组转成字符串。</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>toFixed()返回的是字符串<br>toPrecision(..) 方法用来指定有效数位的显示位数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42.59</span>;</span><br><span class="line">a.toFixed( <span class="number">0</span> ); <span class="comment">// &quot;43&quot;</span></span><br><span class="line">a.toFixed( <span class="number">1</span> ); <span class="comment">// &quot;42.6&quot;</span></span><br><span class="line">a.toFixed( <span class="number">2</span> ); <span class="comment">// &quot;42.59&quot;</span></span><br><span class="line">a.toFixed( <span class="number">3</span> ); <span class="comment">// &quot;42.590&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42.59</span>;</span><br><span class="line"></span><br><span class="line">a.toPrecision( <span class="number">1</span> ); <span class="comment">// &quot;4e+1&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">2</span> ); <span class="comment">// &quot;43&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">3</span> ); <span class="comment">// &quot;42.6&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">4</span> ); <span class="comment">// &quot;42.59&quot;</span></span><br><span class="line">a.toPrecision( <span class="number">5</span> ); <span class="comment">// &quot;42.590&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过对于 <code>.</code> 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。</p>
<p><code>42.tofixed(3)</code> 是无效语法，因为 <code>.</code> 被视为常量 <code>42.</code> 的一部分(如前所述)，所以没有 <code>.</code> 属 性访问运算符来调用 tofixed 方法。<br><code>42..tofixed(3)</code> 则没有问题，因为第一个 <code>.</code> 被视为 number 的一部分，第二个 <code>.</code> 是属性访问运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invalid syntax:</span></span><br><span class="line"><span class="number">42.</span>toFixed( <span class="number">3</span> ); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// these are all valid:</span></span><br><span class="line">(<span class="number">42</span>).toFixed( <span class="number">3</span> ); <span class="comment">// &quot;42.000&quot;</span></span><br><span class="line"><span class="number">0.42</span>.toFixed( <span class="number">3</span> ); <span class="comment">// &quot;0.420&quot;</span></span><br><span class="line"><span class="number">42.</span>.toFixed( <span class="number">3</span> ); <span class="comment">// &quot;42.000&quot;</span></span><br><span class="line"><span class="number">42</span> .toFixed(<span class="number">3</span>); <span class="comment">// &quot;42.000&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>怎样判断<code>0.1+0.2 === 0.3</code></p>
<p>最常见的方法是设置一个误差范围值，通常称为“机器精度”(machine epsilon)，对JavaScript的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。<br>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前<br>的版本写 polyfill:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.EPSILON = <span class="built_in">Math</span>.pow(<span class="number">2</span>,-<span class="number">52</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 Number.EPSILON 来比较两个数字是否相等(在指定的误差范围内):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbersCloseEnoughToEqual</span>(<span class="params">n1,n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.3</span>;</span><br><span class="line">numbersCloseEnoughToEqual( a, b );  <span class="comment">// true</span></span><br><span class="line">numbersCloseEnoughToEqual( <span class="number">0.0000001</span>, <span class="number">0.0000002</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>数字“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为 Number.MAX_SAFE_INTEGER。<br>最小整数是 -9007199254740991， 在 ES6 中 被 定 义 为 Number. MIN_SAFE_INTEGER。</p>
<p>整数检测<code>Number.isInteger(..)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42.000</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger( <span class="number">42.3</span> ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> num == <span class="string">&quot;number&quot;</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测安全的整数<code>Number.isSafeInteger(..)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Number</span>.MAX_SAFE_INTEGER );<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) );<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger( <span class="built_in">Math</span>.pow( <span class="number">2</span>, <span class="number">53</span> ) - <span class="number">1</span> );<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger) &#123; <span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>.isInteger( num ) &amp;&amp;</span><br><span class="line">        <span class="built_in">Math</span>.abs( num ) &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h3><h4 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h4><p>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名<br>称既是类型也是值。</p>
<ul>
<li>null 指空值(empty value)，曾赋过值，但是目前没有值</li>
<li>undefined 指没有值(missing value)，从未赋值</li>
</ul>
<p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而<br>undefined 却是一个标识符，可以被当作变量来使用和赋值。（不要给undefined赋值！）</p>
<h4 id="void运算符"><a href="#void运算符" class="headerlink" title="void运算符"></a>void运算符</h4><p>表达式void ___没有返回值，因此返回结果是undefined。void并不改变表达式的结果， 只是让表达式不返回值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">void</span> a, a ); <span class="comment">// undefined 42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要将代码中的值(如表达式的返回值)设为 undefined，就可以使用 void。</p>
<h4 id="特殊的数字"><a href="#特殊的数字" class="headerlink" title="特殊的数字"></a>特殊的数字</h4><p>NaN 意指“不是一个数字”(not a number)，不是数字的数字，但仍然是数字类型</p>
<p>NaN是一个特殊值，它和自身不相等，是唯一一个非自反(自反，reflexive，即x === x不成立)的值。而 NaN != NaN 为 true，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">a == <span class="literal">NaN</span>;   <span class="comment">// false</span></span><br><span class="line">a === <span class="literal">NaN</span>;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>ES6以后，可以用Number.isNaN()判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isNaN) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="built_in">window</span>.isNaN( n ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">Number</span>.isNaN( a ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN( b );<span class="comment">// false——好!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种更简单的方法</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isNaN) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n !== n;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> JavaScript 中Infinity(即 Number.POSITIVE_INfiNITY)表示无穷数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="keyword">var</span> b = -<span class="number">1</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<p>负零（-0）</p>
<p>加法和减法运算不会得到负零(negative zero)。</p>
<p>判断是否是负零</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNegZero</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    n = <span class="built_in">Number</span>( n );</span><br><span class="line">    <span class="keyword">return</span> (n === <span class="number">0</span>) &amp;&amp; (<span class="number">1</span> / n === -<span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line">isNegZero( -<span class="number">0</span> );<span class="comment">// true</span></span><br><span class="line">isNegZero( <span class="number">0</span> / -<span class="number">3</span> );<span class="comment">// true</span></span><br><span class="line">isNegZero( <span class="number">0</span> );<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度)，数字的符号位 (sign)用来代表其他信息(比如移动的方向)。<br>此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。</p>
<h4 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h4><p>ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等。<br>仅用来判断NaN和-0等情况，能用===就不用这个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = -<span class="number">3</span> * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( a, <span class="literal">NaN</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, -<span class="number">0</span> );  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">0</span> );  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>polyfill</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.is) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.is = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// test for `-0`</span></span><br><span class="line">        <span class="keyword">if</span> (v1 === <span class="number">0</span> &amp;&amp; v2 === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / v1 === <span class="number">1</span> / v2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// test for `NaN`</span></span><br><span class="line">        <span class="keyword">if</span> (v1 !== v1) &#123;</span><br><span class="line">        <span class="keyword">return</span> v2 !== v2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// everything else</span></span><br><span class="line">        <span class="keyword">return</span> v1 === v2;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h3><p>JS中，值复制还是引用复制，一切由值的类型来决定。</p>
<p>简单类型（null、undefined、字符串、数字、布尔和 ES6 中的 symbol）总是通过值复制方式来赋值/传递。</p>
<p>复合值(compound value)——对象(包括数组和封装对象)和函数，则总是通过引用复制的方式来赋值/传递。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// `b` is always a copy of the value in `a`</span></span><br><span class="line">b++;</span><br><span class="line">a; <span class="comment">// 2</span></span><br><span class="line">b; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c; <span class="comment">// `d` is a reference to the shared `[1,2,3]` value</span></span><br><span class="line">d.push( <span class="number">4</span> );</span><br><span class="line">c; <span class="comment">// [1,2,3,4]</span></span><br><span class="line">d; <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>函数传参的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x.push( <span class="number">4</span> );</span><br><span class="line">    x; <span class="comment">// [1,2,3,4]</span></span><br><span class="line">    <span class="comment">// 这里x变成了一个新数组，a还是原来的</span></span><br><span class="line">    x = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    x.push( <span class="number">7</span> );</span><br><span class="line">    x; <span class="comment">// [4,5,6,7]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">foo( a );</span><br><span class="line">a; <span class="comment">// [1,2,3,4]  not  [4,5,6,7]</span></span><br></pre></td></tr></table></figure>

<p>将 a 的值变为 [4,5,6,7]，必须更改 x 指向的数组，而不是为 x 赋值一个新的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x.push( <span class="number">4</span> );</span><br><span class="line">    x; <span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这样做不会创建新数组</span></span><br><span class="line">    x.length = <span class="number">0</span>; <span class="comment">// empty existing array in-place</span></span><br><span class="line">    x.push( <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> );</span><br><span class="line">    x; <span class="comment">// [4,5,6,7]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">foo( a );</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// [4,5,6,7]  not  [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>如果通过值复制的方式来传递复合值(如数组)，就需要为其创建一个复本，这样传递的就不再是原始值。<br><code>foo( a.slice() );</code> a.slice()返回的是数组的浅复本，foo的操作不会影响a指向的数组。<br>相反，如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值(对象、数组等)中，然后通过引用复制的方式传递。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">wrapper</span>) </span>&#123;</span><br><span class="line">    wrapper.a = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo( obj );</span><br><span class="line"></span><br><span class="line">obj.a; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h2 id="I-第3章-原生函数"><a href="#I-第3章-原生函数" class="headerlink" title="I-第3章 原生函数"></a>I-第3章 原生函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学习原生函数，封装对象包装，拆分。</span><br></pre></td></tr></table></figure>

<p>常用的原生函数<br>• String()<br>• Number()<br>• Boolean()<br>• Array()<br>• Object()<br>• Function()<br>• RegExp()<br>• Date()<br>• Error()<br>• Symbol()</p>
<p>原生函数可以被当作构造函数来使用。通过构造函数(如new String(“abc”))创建出来的是封装了基本类型值(如”abc”)的封装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;abc&quot;</span> );</span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// 是&quot;object&quot;，不是&quot;String&quot;</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( a ); <span class="comment">// &quot;[object String]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="内部属性class"><a href="#内部属性class" class="headerlink" title="内部属性class"></a>内部属性class</h3><p>所有 typeof 返回值为 “object” 的对象(如数组)都包含一个内部属性Class。这个属性无法直接访问，通过 <code>Object.prototype.toString(..)</code> 来查看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="regexp">/regex-literal/i</span> ); <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="literal">null</span> ); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="literal">undefined</span> ); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="string">&quot;abc&quot;</span> ); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="number">42</span> ); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="literal">true</span> ); <span class="comment">// &quot;[object Boolean]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h3><p>由于基本类型值没有<code>.length</code>和<code>.toString()</code>这样的属性和方法，需要通过封装对象才能访问。JS会自动为基本类型包装一个封装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase(); <span class="comment">// &quot;ABC&quot;</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什么时候应该使用封装对象。</p>
<p>如果要自行封装基本类型值，可以用Object()函数(不带new关键字)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>( a );</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>( a );</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> c; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( b ); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( c ); <span class="comment">// &quot;[object String]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h3><p>要拆封封装对象中的基本类型值，可以用valuesOf()函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;abc&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">42</span> );</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">a.valueOf(); <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">b.valueOf(); <span class="comment">// 42</span></span><br><span class="line">c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;abc&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot;&quot;</span>; <span class="comment">// b拥有了拆封后的值abc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h3><ol>
<li><p>数组</p>
<p> 永远不要创建和使用空单元数组。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>( <span class="number">3</span> );</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span> ];</span><br><span class="line"><span class="keyword">var</span> c = [];</span><br><span class="line">c.length = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object(..)、Function(..) 和 RegExp(..)</p>
<p> 不建议使用Object和Function</p>
<p> 强烈建议使用常量形式(如 /^a*b+/g)来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。<br> 与前面的构造函数不同，RegExp(..) 有时还是很有用的，比如动态定义正则表达式时:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Kyle&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> namePattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">&quot;\\b(?:&quot;</span> + name + <span class="string">&quot;)+\\b&quot;</span>, <span class="string">&quot;ig&quot;</span> );</span><br><span class="line"><span class="keyword">var</span> matches = someText.match( namePattern );</span><br></pre></td></tr></table></figure>

<p> 上述情况在JavaScript编程中时有发生，这时new RegExp(“pattern”,”flags”)就能派上用场。</p>
</li>
<li><p>Date(..) 和 Error(..)</p>
<p> 创建日期必须使用 <code>new Date()</code>。<br> Date(..) 主要用来获得当前的 Unix 时间戳(从 1970 年 1 月 1 日开始计算，以秒为单位)。 该值可以通过日期对象中的 getTime() 来获得。</p>
<p> 用<code>Date.now()</code>即可获取</p>
<p> 创建错误对象(error object)主要是为了获得当前运行栈的上下文(大部分 JavaScript 引擎通过只读属性 .stack 来访问)。<br> 栈上下文信息包括函数调用栈信息和产生错误的代码行号， 以便于调试(debug)。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">&quot;x wasn’t provided&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通常错误对象至少包含一个 message 属性，有时也不乏其他属性(必须作为只读属性访问)，如 type。<br> 除了访问 stack 属性以外，最好的办法是调用toString() 来获得经过格式化的便于阅读的错误信息。</p>
</li>
<li><p>Symbol</p>
<p> 可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键<br> 字，否则会出错:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysym = <span class="built_in">Symbol</span>( <span class="string">&quot;my own symbol&quot;</span> );</span><br><span class="line">mysym;    <span class="comment">// Symbol(my own symbol)</span></span><br><span class="line">mysym.toString(); <span class="comment">// &quot;Symbol(my own symbol)&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> mysym;   <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123; &#125;;</span><br><span class="line">a[mysym] = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols( a );</span><br><span class="line"><span class="comment">// [ Symbol(my own symbol) ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原生原型</p>
<p> 原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。</p>
<p> 这些对象包含其对应子类型所特有的行为特征。</p>
<p> Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式(无任何匹配)，而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isThisCool</span>(<span class="params">vals = <span class="built_in">Array</span>.prototype,fn = <span class="built_in">Function</span>.prototype,rx = <span class="built_in">RegExp</span>.prototype</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rx.test(</span><br><span class="line">        vals.map( fn ).join( <span class="string">&quot;&quot;</span> )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isThisCool();  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">isThisCool(</span><br><span class="line">    [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>],</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123; <span class="keyword">return</span> v.toUpperCase(); &#125;,</span><br><span class="line">    /D/</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 这种方法的一个好处是 .prototype 已被创建并且仅创建一次。相反，如果将 []、function(){} 和 /(?:)/ 作为默认值，<br> 则每次调用 isThisCool(..) 时它们都会被创建一次 (具体创建与否取决于 JavaScript 引擎，稍后它们可能会被垃圾回收)，这样无疑会造成内存和 CPU 资源的浪费。</p>
</li>
</ol>
<h2 id="I-第4章-强制类型转换"><a href="#I-第4章-强制类型转换" class="headerlink" title="I-第4章 强制类型转换"></a>I-第4章 强制类型转换</h2><p>值从一个类型转换为另一种类型，称为类型转换(type casting)。这是显示的情况，隐式的情况称为强制类型转换(coercion)。</p>
<p>类型转换发生在静态语言的编译阶段，强制类型转换发生在动态类型语言的运行时</p>
<p>在JS中统称为强制类型转换。可以通过隐式强制类型和强制类型转换来区分。</p>
<p>隐式类型转换不明显，通常是某些操作产生的副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot;&quot;</span>; <span class="comment">// 隐式强制类型转换</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">String</span>(a); <span class="comment">// 显式强制类型转换</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h3><h4 id="ToString-非字符串到字符串强制类型转换"><a href="#ToString-非字符串到字符串强制类型转换" class="headerlink" title="ToString 非字符串到字符串强制类型转换"></a>ToString 非字符串到字符串强制类型转换</h4><p>基本类型值的字符串化规则为:null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。数字极大极小值用指数形式。<br>数组的toString默认将所有单元字符串化后用<code>,</code>连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.toString(); <span class="comment">// &#x27;1,2,3,&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h4><p>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。<br>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</p>
<p>JSON字符串化用<code>stringify</code>,遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">undefined</span> );     <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; );     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( [<span class="number">1</span>,<span class="literal">undefined</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="number">4</span>] ); <span class="comment">// &quot;[1,null,null,4]&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( &#123; <span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; );  <span class="comment">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>包含循环引用的对象执行 JSON.stringify(..) 会出错。</p>
<p>如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，需要定义 toJSON() 方法来返回一个能够被字符串化的安全的 JSON 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">42</span>,</span><br><span class="line">    c: o,</span><br><span class="line">    d: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a被循环引用</span></span><br><span class="line">o.e = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于循环引用，会抛出异常</span></span><br><span class="line"><span class="comment">// JSON.stringify( a );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define a custom JSON value serialization</span></span><br><span class="line">a.toJSON = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// only include the `b` property for serialization</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="built_in">this</span>.b &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a ); <span class="comment">// &quot;&#123;&quot;b&quot;:42&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>向 <code>JSON.stringify(..)</code> 传递一个可选参数 replacer，可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。<br>如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。<br>如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined，否则返回指定的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">42</span>,</span><br><span class="line">    c: <span class="string">&quot;42&quot;</span>,</span><br><span class="line">    d: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a, [<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>] ); <span class="comment">// &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a, <span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k !== <span class="string">&quot;c&quot;</span>) <span class="keyword">return</span> v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h4><p>true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>
<p>对象(包括数组)会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</p>
<h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><ol>
<li><p>假值(false value) 可以被强制类型转换为 false 的值。</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0, -0, NaN</li>
<li>‘’</li>
</ul>
</li>
<li><p>假值对象</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">0</span> );</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">&quot;&quot;</span> );</span><br></pre></td></tr></table></figure>

<p> a, b, c都为true</p>
</li>
<li><p>真值</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;false&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;&#x27;&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );</span><br><span class="line">d; <span class="comment">// 字符串不为空所以为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );</span><br><span class="line">d; <span class="comment">// [], &#123;&#125;, function()&#123;&#125; 不为空，为true</span></span><br></pre></td></tr></table></figure>

<h3 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h3><p>代码转换清晰，可读性高，更容易理解，推荐使用。</p>
<ol>
<li><p>字符串数字互转</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">String</span>( a );</span><br><span class="line">b; <span class="comment">// &quot;42&quot;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Number</span>( c );</span><br><span class="line">d; <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = +c; <span class="comment">// 最常用~~~</span></span><br><span class="line">d; <span class="comment">// 3.14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>奇特的~运算符</p>
<p> 字位运算符(如 | 和 ~)和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字。</p>
</li>
</ol>
<p>在 -(x+1) 中唯一能够得到 0(或者严格说是 -0)的 x 值是 -1。也就是说如果 x 为 -1 时，~和一些数字值在一起会返回假值 0，其他情况则返回真值。</p>
<p><code>indexOf</code>搜索到指定字符串返回字符串所在位置(从0开始)，否则返回-1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;lo&quot;</span> ) &gt;= <span class="number">0</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// found it!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;lo&quot;</span> ) != -<span class="number">1</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// found it</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;ol&quot;</span> ) &lt; <span class="number">0</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// not found!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a.indexOf( <span class="string">&quot;ol&quot;</span> ) == -<span class="number">1</span>) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// not found!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">&quot;lo&quot;</span> );   <span class="comment">// -4   &lt;-- truthy!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (~a.indexOf( <span class="string">&quot;lo&quot;</span> )) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// found it!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">&quot;ol&quot;</span> );   <span class="comment">// 0    &lt;-- falsy!</span></span><br><span class="line">!~a.indexOf( <span class="string">&quot;ol&quot;</span> );  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!~a.indexOf( <span class="string">&quot;ol&quot;</span> )) &#123; <span class="comment">// true</span></span><br><span class="line"> <span class="comment">// not found!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&gt;= 0</code>和<code>== -1</code>这样的写法不是很好，称为“抽象渗漏”，在代码中暴露了底层的实现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉。<br><strong><code>~</code> 和 <code>indexOf()</code> 一起可以将结果强制类型转换(实际上仅仅是转换)为真 / 假值</strong></p>
<p>这种写法看起来逼格也高，哈哈</p>
<p><code>~~</code>中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。</p>
<p>只适用于 32 位数字，更重要的是它对负数的处理与 Math. floor(..) 不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor( -<span class="number">49.6</span> ); <span class="comment">// -50</span></span><br><span class="line">~~-<span class="number">49.6</span>; <span class="comment">// -49</span></span><br></pre></td></tr></table></figure>

<h3 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h3><p>解析(parseInt)允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。字符串转数字(Number)不允许出现非数字字符，否则会失败并返回 NaN。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;42px&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>( a ); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">parseInt</span>( a ); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>( b ); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>( b ); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>parseInt(..) 针对的是字符串值。向 parseInt(..) 传递其他类型的参数，比如 <code>true、function()&#123;...&#125;</code> 和 <code>[1,2,3]</code>。<br>会首先被强制类型转换为字符串，依赖这样的隐式强制类型转换并非上策，应该避免向 parseInt(..) 传递非字符串参数。</p>
<p>parseInt(..) 先将参数强制类型转换为字符串再进行解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>( <span class="number">1</span>/<span class="number">0</span>, <span class="number">19</span> ); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>怎么来处理 Infinity(1/0 的结果)最合理呢?有两个选择:”Infinity” 和 “∞”，JavaScript选择的是 “Infinity”。</p>
<p>parseInt(1/0, 19) 实际上是 parseInt(“Infinity”, 19)。第一个字符是 “I”，以 19 为基数 时值为 18。第二个字符 “n” 不是一个有效的数字字符，解析到此为止，和 “42px” 中的 “p” 一样。</p>
<p>最后的结果是 18，而非 Infinity 或者报错。所以理解其中的工作原理对于我们学习 JavaScript 是非常重要的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.000008</span> );  <span class="comment">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.0000008</span> );  <span class="comment">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="literal">false</span>, <span class="number">16</span> );  <span class="comment">// 250 (&quot;fa&quot; from &quot;false&quot;)</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="built_in">parseInt</span>, <span class="number">16</span> ); <span class="comment">// 15  (&quot;f&quot; from &quot;function..&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">&quot;0x10&quot;</span> );   <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">&quot;103&quot;</span>, <span class="number">2</span> );  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="显示转换为布尔值"><a href="#显示转换为布尔值" class="headerlink" title="显示转换为布尔值"></a>显示转换为布尔值</h3><p>显式强制类型转换为布尔值最常用的方法<code>!!</code>，第二个<code>!</code>会把结果反转回原值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> g;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>( a ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>( b ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>( c ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>( d ); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>( e ); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>( f ); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>( g ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!a; <span class="comment">// true</span></span><br><span class="line">!!b; <span class="comment">// true</span></span><br><span class="line">!!c; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!!d; <span class="comment">// false</span></span><br><span class="line">!!e; <span class="comment">// false</span></span><br><span class="line">!!f; <span class="comment">// false</span></span><br><span class="line">!!g; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>三元运算符 <code>? :</code> 判断 a 是否为真，如果是则将变量 b 赋值为 true，否则赋值为 false。 表面上这是一个显式的 ToBoolean 强制类型转换，因为返回结果是 true 或者 false。<br>然而这里涉及隐式强制类型转换，因为 a 要首先被强制类型转换为布尔值才能进行条件判断。这种情况称为“显式的隐式”，有百害而无一益，我们应彻底杜绝。<br>建议使用 Boolean(a) 和 !!a 来进行显式强制类型转换。</p>
<h3 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h3><p>不够明显的强制类型转换都可以算作隐式强制类型转换。</p>
<p>隐式强制类型转换的作用是减少冗余，让代码更简洁。可能会让代码晦涩难懂。</p>
<p><code>+</code>既能用于字符串也能用于数字。怎么判断要执行哪个操作？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a + b; <span class="comment">// &quot;420&quot;</span></span><br><span class="line">c + d; <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">a + b; <span class="comment">// &quot;1,23,4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数字转成字符串</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot;&quot;</span>;</span><br><span class="line">b; <span class="comment">// &quot;42&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果其中一个操作数是对象(包括数组)，则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用DefaultValue，以数字作为上下文。<br>数组的 valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()。因此上例中的两个数组变成了 “1,2” 和 “3,4”。+ 将它们拼接后返回 “1,23,4”。</p>
<p>如果 + 的其中一个操作数是字符串(或者通过以上步骤可以得到字符串)， 则执行字符串拼接;否则执行数字加法。</p>
<p>a + “”(隐式)和前面的String(a)(显式)之间有一个细微的差别需要注意。<br>根据 ToPrimitive抽象操作规则，a + “”会对a调用valueOf()方法，然后通过ToString抽象 操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。</p>
<p>如果a是对象，结果会不一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a + <span class="string">&quot;&quot;</span>;   <span class="comment">// &quot;42&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>( a ); <span class="comment">// &quot;4</span></span><br></pre></td></tr></table></figure>

<p>在定制 valueOf() 和 toString() 方法时需要特别小心，因为这会影响强制类型转换的结果。</p>
<p><code>-</code>减法运算符，会先转换为字符串，再转换为数字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = a - <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">b; <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>];</span><br><span class="line">a - b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔值到数字的隐式强制类型转换"><a href="#布尔值到数字的隐式强制类型转换" class="headerlink" title="布尔值到数字的隐式强制类型转换"></a>布尔值到数字的隐式强制类型转换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">arr = [<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>]</span><br><span class="line">arr.reduce(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">    sum +=item</span><br><span class="line">&#125;, sum)</span><br></pre></td></tr></table></figure>

<p>在控制台显示是NaN？？？和书里不一样</p>
<h3 id="隐式强制类型转换为布尔值"><a href="#隐式强制类型转换为布尔值" class="headerlink" title="隐式强制类型转换为布尔值"></a>隐式强制类型转换为布尔值</h3><p>(1)if (..)语句中的条件判断表达式。<br>(2)for ( .. ; .. ; .. )语句中的条件判断表达式(第二个)。<br>(3) while (..) 和 do..while(..) 循环中的条件判断表达式。<br>(4)? :中的条件判断表达式。<br>(5) 逻辑运算符 ||(逻辑或)和 &amp;&amp;(逻辑与)左边的操作数(作为条件判断表达式)。</p>
<p>以上情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的 ToBoolean 抽象操作规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;yep&quot;</span> );  <span class="comment">// yep</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (c) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;nope, never runs&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = d ? a : b;</span><br><span class="line">c;     <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a &amp;&amp; d) || c) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;yep&quot;</span> );  <span class="comment">// yep</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h3><p>JS中返回的不一定布尔值。而是两个操作数中的一个的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a || b;  <span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b;  <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">c || b;  <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">c &amp;&amp; b;  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>|| 和 &amp;&amp; 首先会对第一个操作数(a 和 c)执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p>
<p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数(a 和 c)的值，如果为 false 就返回第二个操作数(b)的值。<br>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数(b)的值，如果为 false 就返回第一个操作数(a 和 c)的值。</p>
<p>换个角度理解</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a || b;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">a ? a : b;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">a ? b : a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同三元表达式不同的是, 如果a是表达式，可能会执行两次。</span></span><br></pre></td></tr></table></figure>

<h4 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h4><p>设置默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line"> a = a || <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> b = b || <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log( a + <span class="string">&quot; &quot;</span> + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();     <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line">foo( <span class="string">&quot;yeah&quot;</span>, <span class="string">&quot;yeah!&quot;</span> ); <span class="comment">// &quot;yeah yeah!&quot;</span></span><br></pre></td></tr></table></figure>

<p>短路机制</p>
<p>a为false时，foo不会执行。比<code>if (a) &#123; foo() &#125;</code>简洁明了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h3><p><strong><code>==</code>允许在相等比较中进行强制类型转换，而<code>===</code>不允许。</strong></p>
<p>人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级 (百万分之一秒)的差别而已。<br>如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎 实现上的细微差别之外，它们之间并没有什么不同。</p>
<h4 id="抽象相等"><a href="#抽象相等" class="headerlink" title="抽象相等"></a>抽象相等</h4><p>规定如果两个值的类型相同，就仅比较它们是否相等。例如，42 等于 42，”abc” 等于 “abc”。</p>
<p>特殊情况 NaN 不等于 NaN，+0 等于 -0。</p>
<p>以 x 和 y 为值进行 x == y 比较会产生的结果可为 true 或 false。比较的执行步骤如下：</p>
<ol>
<li>若 Type(x) 与 Type(y) 相同， 则<ol>
<li>若 Type(x) 为 Undefined， 返回 true。</li>
<li>若 Type(x)为 Null， 返回 true。</li>
<li>若 Type(x)为 Number，则<ol>
<li>若 x 为 NaN，返回 false。</li>
<li>若 y 为 NaN，返回 false。</li>
<li>若 x 与 y 为相等数值，返回 true。</li>
<li>若 x 为 +0 且 y 为 −0，返回 true。</li>
<li>若 x 为 −0 且 y 为 +0，返回 true。</li>
<li>返回 false。</li>
</ol>
</li>
<li>若 Type(x) 为 String，则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。否则，返回 false。</li>
<li>若 Type(x) 为 Boolean，当 x 和 y 为同为 true 或者同为 false 时返回 true。否则，返回 false。</li>
<li>当 x 和 y 为引用同一对象时返回 true。否则，返回 false。</li>
</ol>
</li>
<li>若 x 为 null 且 y 为 undefined，返回 true。</li>
<li>若 x 为 undefined 且 y 为 null，返回 true。</li>
<li>若 Type(x) 为 Number 且 Type(y) 为 String，返回 x == ToNumber(y) 的结果。</li>
<li>若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。</li>
<li>若 Type(x) 为 Boolean，返回比较 ToNumber(x) == y 的结果。</li>
<li>若 Type(y) 为 Boolean，返回比较 x == ToNumber(y) 的结果。</li>
<li>若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。</li>
<li>若 Type(x) 为 Object 且 Type(y) 为 String 或 Number，返回比较 ToPrimitive(x) == y 的结果。</li>
<li>返回 false。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;42&quot;</span>;</span><br><span class="line">a === b; <span class="comment">// false</span></span><br><span class="line">a == b;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line">a == b; <span class="comment">// false 1==42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="literal">false</span>;</span><br><span class="line">x == y; <span class="comment">// false 42==0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="number">42</span> ];</span><br><span class="line">a == b; <span class="comment">// true 42==42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>( a ); <span class="comment">// same as `new String( a )`</span></span><br><span class="line">a === b;    <span class="comment">// false</span></span><br><span class="line">a == b;     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>( a ); <span class="comment">// same as `Object()`</span></span><br><span class="line">a == b;     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>( c ); <span class="comment">// same as `Object()`</span></span><br><span class="line">c == d;     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">Object</span>( e ); <span class="comment">// same as `new Number( e )`</span></span><br><span class="line">e == f;     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>无论什么情况下都不要使用 == true 和 == false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会失败</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会失败</span></span><br><span class="line"><span class="keyword">if</span> (a === <span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好</span></span><br><span class="line"><span class="keyword">if</span> (!!a) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也很好</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>( a )) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><p>更改内置原生原型会导致奇怪效果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">2</span> ) == <span class="number">3</span>; <span class="comment">// true，因为valueOf返回3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况也会发生，如下</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 让 a.valueOf() 每次调用都产生副作用，第一次返回 2，第二次返回 3</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> i++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">&quot;Yep, this happened.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">null</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">undefined</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">false</span>;   <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">NaN</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="number">0</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="string">&quot;&quot;</span>;    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">NaN</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>;    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&quot;&quot;</span>;   <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="literal">false</span> == [];   <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="literal">false</span> == &#123;&#125;;   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">null</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">undefined</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">NaN</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="number">0</span>;    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == [];    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == &#123;&#125;;    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">NaN</span>;    <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == [];    <span class="comment">// true -- UH OH!</span></span><br><span class="line"><span class="number">0</span> == &#123;&#125;;    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>有 7 种注释了“UH OH!”，因为它们属于假阳(false positive)的情况，里面坑很多。 “” 和 0 明显是两个不同的值，它们之间的强制类型转换很容易搞错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[] == ![] <span class="comment">// true,根据toBoolean变成[]==false</span></span><br><span class="line"><span class="number">2</span> == [<span class="number">2</span>];  <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == [<span class="literal">null</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&quot;\n&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>，== 右边的值 <code>[2]</code> 和 <code>[null]</code> 会进行 ToPrimitive 强制类型转换， 以便能够和左边的基本类型值(2 和 “”)进行比较。因为数组的 valueOf() 返回数组本身， 所以强制类型转换过程中数组会进行字符串化。<br>第一行中的 <code>[2]</code> 会转换为 <code>&quot;2&quot;</code>，然后通过 ToNumber 转换为 2。第二行中的 <code>[null]</code> 会直接转 换为 “”。<br>所以最后的结果就是 <code>2 == 2</code> 和 <code>&quot;&quot; == &quot;&quot;</code>。</p>
<p>安全运用隐式强制转换，遵循以下两个原则：</p>
<ul>
<li>如果两边的值中有 true 或者 false，千万不要使用 ==。</li>
<li>如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。</li>
</ul>
<p><strong>最好用 === 来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。</strong></p>
<h3 id="抽象关系比较"><a href="#抽象关系比较" class="headerlink" title="抽象关系比较"></a>抽象关系比较</h3><p>比较双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。</p>
<p>如果比较双方都是字符串，则按字母顺序来进行比较:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">42</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="string">&quot;43&quot;</span> ];</span><br><span class="line"></span><br><span class="line">a &lt; b; <span class="comment">// true  42&lt;43</span></span><br><span class="line">b &lt; a; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [ <span class="string">&quot;42&quot;</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="string">&quot;043&quot;</span> ];</span><br><span class="line"></span><br><span class="line">a &lt; b; <span class="comment">// false  字符串，&quot;42&quot; &lt; &quot;043&quot; 4&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [ <span class="number">4</span>, <span class="number">2</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span> ];</span><br><span class="line">a &lt; b; <span class="comment">// false &#x27;4,2&#x27; &lt; &#x27;0,4,3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line">a &lt; b; <span class="comment">// false &#x27;[object Object]&#x27; &lt; &#x27;[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下很奇怪</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line"></span><br><span class="line">a &lt; b; <span class="comment">// false</span></span><br><span class="line">a == b; <span class="comment">// false</span></span><br><span class="line">a &gt; b; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a &lt;= b; <span class="comment">// true</span></span><br><span class="line">a &gt;= b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>JS中 <code>&lt;=</code> 是“不大于”的意思(即 !(a &gt; b)，处理为 !(b &lt; a))。同理 a &gt;= b 处理为 !(a&lt;b)。</p>
<p>要避免a &lt; b中发生隐式强制类型转换，我们只能确保a和b为相同的类型， 除此之外别无他法。</p>
<p>为了保证安全，应该对关系比较中的值进行显式强制类型转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">42</span> ];</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;043&quot;</span>;</span><br><span class="line"></span><br><span class="line">a &lt; b;      <span class="comment">// false -- string comparison!</span></span><br><span class="line"><span class="built_in">Number</span>( a ) &lt; <span class="built_in">Number</span>( b ); <span class="comment">// true -- number comparison!</span></span><br></pre></td></tr></table></figure>

<h3 id="小结类型转换"><a href="#小结类型转换" class="headerlink" title="小结类型转换"></a>小结类型转换</h3><p>了解显示隐式转换</p>
<p>一般编码规范的项目都会要求强制类型转换</p>
<p>再加上用了TS之后，要求更高了。</p>
<p>不过还是要知其然，更要知其所以然。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-02-13T06:20:04.000Z" title="2019-02-13T06:20:04.000Z">2019-02-13</time>发表</span><span class="level-item"><time dateTime="2019-02-13T06:20:04.000Z" title="2019-02-13T06:20:04.000Z">2019-02-13</time>更新</span><span class="level-item">1 小时读完 (大约7241个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Javascript设计模式与开发实践-读书笔记</a></h1><div class="content"><p>读《JavaScript设计模式与开发实践》笔记摘要</p>
<h2 id="设计模式定义"><a href="#设计模式定义" class="headerlink" title="设计模式定义"></a>设计模式定义</h2><p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。<br>通俗的说：<br>设计模式是在某种场合下对某个问题的一种解决方案。<br>设计模式是给面向对象软件开发中的一些好的设计取的名字。</p>
<p>在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。<br>熟悉这些模式 的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到 某种模式作为解决方案。</p></div><a class="article-more button is-small is-size-7" href="/posts/Javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-12-06T03:32:08.000Z" title="2018-12-06T03:32:08.000Z">2018-12-06</time>发表</span><span class="level-item"><time dateTime="2018-12-06T03:32:08.000Z" title="2018-12-06T03:32:08.000Z">2018-12-06</time>更新</span><span class="level-item">15 分钟读完 (大约2257个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/Redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">Redis实战读书笔记</a></h1><div class="content"><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">redis官网</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.cn/download.html">redis中文下载安装</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.cn/documentation.html">redis中文文档</a></li>
</ul>
<p>当你需要以接近实时的速度访问快速变动的数据流时，Redis这样的键值数据库就是你的最佳选择。</p></div><a class="article-more button is-small is-size-7" href="/posts/Redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-11-07T11:34:55.000Z" title="2018-11-07T11:34:55.000Z">2018-11-07</time>发表</span><span class="level-item"><time dateTime="2018-11-07T11:34:55.000Z" title="2018-11-07T11:34:55.000Z">2018-11-07</time>更新</span><span class="level-item">1 小时读完 (大约9728个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/React%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">React进阶读书笔记</a></h1><div class="content"><h1 id="React-四大特点"><a href="#React-四大特点" class="headerlink" title="React 四大特点"></a>React 四大特点</h1><ul>
<li>声明式视图层<br>  采用JSX语法来声明视图层, 可以在视图层中随意使用各种状态数据</li>
<li>简单的更新流程<br>  从状态到UI单向数据流让React组件的更新流程更清晰</li>
<li>灵活的渲染实现<br>  基于虚拟dom渲染</li>
<li>高效的DOM操作<br>  React可以尽量减少虚拟dom到真实DOM的渲染次数, 以及每次渲染需要改变的真实DOM节点数。</li>
</ul>
<p>React只是view层, 关注的是如何根据状态创建可复用的UI组件, 如何根据组件创建可组合的UI.<br>应用复杂时, 需要结合其他库(Redux, MobX等). </p></div><a class="article-more button is-small is-size-7" href="/posts/React%E8%BF%9B%E9%98%B6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-11-07T11:05:36.000Z" title="2018-11-07T11:05:36.000Z">2018-11-07</time>发表</span><span class="level-item"><time dateTime="2018-11-07T11:05:36.000Z" title="2018-11-07T11:05:36.000Z">2018-11-07</time>更新</span><span class="level-item">26 分钟读完 (大约3838个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%AC%94%E8%AE%B0/">思维导图笔记</a></h1><div class="content"><p>1.要想高效的利用本书，很重要的一点就是必须加强练习！！！</p>
<p>2.左脑处理逻辑、词汇、表单、数字、线性和分析等所谓的学术活动。右脑主司节奏、想象、色彩、幻想、空间感、完整倾向(整体观念)和维度。 </p>
<p>3.鼓励人们去开发他们以前认为很弱的脑区。会产生一种协同效应，使整个脑区的智力水平都随之提高。</p>
<p>4.当我们说自己某些方面行，某些方面不行时，我们实际是指已经很成功的开发出来了的潜力和尚未开发出来的，仍然处在蛰伏状态的潜能。如果能将蛰伏状态下的潜能开发出来，大脑将释放出巨大的“能量”。</p>
<p>5.大脑每分钟约要进行10万~100万次不同的化学反应。</p>
<!---more--->


<p><a href="/img/clipboard.png">记忆曲线</a><br><img src="/img/clipboard.png" ></p>
<p>6.感知模型：眼睛-大脑-相机<br>        按照一般人做白日梦的样子，闭上眼睛，想象你最喜欢的物体，在你心目中已经很清晰地记住其图像后，再做下列这些练习:<br>        在面前转动它<br>从顶部看它<br>从底部看它<br>改变它的颜色，至少3次。<br>把她移开，就好像在很远处看它一样。<br>再把它移回来。<br>把它变的极大。<br>把他变小。<br>完全改变它的形状。<br>让它消失。<br>再让它出来。<br>这些活动你做起来好不费事，可是相机的零件却完全无法做到。</p>
<p>思维导图_启动大脑  33页<br>—————————————-2014/10/27 00:03   ————————————————————————–</p>
<ol start="3">
<li><p>大脑受限制的原因</p>
</li>
<li><p>与承认失败相比，更多人会说”我们只是普通人”，这种说法不足以令人信服！我们必须学习大脑是如何工作的，以便充分发挥自身无限的潜力。</p>
<p>2.我们的表现与我们甚至最小潜力不相符的原因就是，我们对自己所拥有的内在潜力一无所知，更不用说如何去充分利用了。<br>3.一个普遍并且被严重误导的神话：人类本身就有不足之处，因此，这场灾难的责任应归结于人类本身的“缺陷”。</p>
<p>4.在全世界范围的教育系统内，人们之所以几乎没有花时间去学习如何学习，是因为我们对这台生物计算机的基本操作规则一无所知。</p>
<p>《启动大脑》 是第一本“大脑使用说明书”，它是专门用来帮助你了解、充实和保养你自己的“超级生物计算机”的，并教你如何释放你所拥有的自然且非凡的智能。</p>
</li>
<li><p>更快、更有效的阅读</p>
<p>   1.我阅读存在的问题</p>
<pre><code>       阅读速度慢，阅读后会忘记、阅读的时间不能保证、阅读后当时掌握回头就会忘记、阅读的时候有些不能很快的理解</code></pre>
<p>阅读定义:“从书中捕捉作者的意图”或“吸收所写文字的内容”。<br>阅读是个人与符号信息之间发生的全部相互联系；它通常是指学习的视觉方面，并包含下述7个步骤。</p>
<pre><code>       辨识、吸收、内部整合、外部整合、保持、回忆、交流</code></pre>
<p>4.3阅读问题存在的原因<br>   答案除了我们早先对大脑缺乏认识之外，主要是因为我们早期的阅读教育方法不当。</p>
<p>眼睛在阅读时，实际是以一系列的停顿和快速跳跃的方式移动的。</p>
<p>   提高速度</p>
<pre><code>   1.消除回读----90%的回跳和回读是因为担心不能对阅读材料完全理解而引起的。
   2.每次凝视的时间可减到最低的1/4秒，------人的眼睛可以在1/100秒的时间内摄入5个单词。
   3.凝视的间隔可扩展到一次摄入3~5个单词。</code></pre>
<p>快速阅读的好处<br>   快速阅读者的优势是他的眼睛在每一页上话费的物理运动较少，不会像慢速阅读者那样，每页紧张的聚焦凝视500多次。快速阅读者每页只凝视100次，其眼肌就不会疲劳。<br>   另一个好处：能有节奏、流畅的阅读和轻松愉快的领略文章的意思。<br>4.6  对阅读的误解<br>   1.一次只能看一个单词————错。人的凝视能力就可以扩展，我们阅读的目的不是理解单个的词，而是整体意思。<br>   2.阅读速度不可能超过每分钟500个单词—-错，每次凝视可以摄入6个单词，而且每秒钟可以凝视4次。这就意味着每分钟1000个单词的阅读速度是完全能达到的。<br>   3.快速阅读者没法欣赏文章———-错。因为快速阅读者能更多的理解所读的内容，能更专注地看材料，所以他有更多的时间去回顾他认为特别有趣的和重要的部分。<br>   4.速度越快注意力就越低——-错。读的越快，得到的刺激就越多，注意力就越集中。<br>   5.一般阅读速度更自然，因此也就最好——错。因为一般阅读速度并不自然。它是早期不完善的训练，加之缺乏眼睛和大脑能以各种可能的速度阅读等方面的知识所造成的。</p>
</li>
</ol>
<p>4.7.1 高级阅读技巧——快上加快<br>        我们要做的不是叫他们把手指从书本上拿开，而是让他们更快的移动手指。它在帮助养成流畅的阅读节奏方面有着不可估量的作用。<br>        用辅助物 阅读时阅读的速度更快。<br>4.7.2                  ———扩大焦点<br>        结合视觉辅助技巧，特别适用于阅读一些轻松的材料和用来预习和复习，还可以提高正常的阅读速度。<br>            很重要的一点是必须使用视觉导引物<br>                    试着采用如斜对角线、曲线和沿书页直线向下等各种视觉导引物。<br>4.7.3  快速理解<br>        尽快从一页浏览到下一页，并尽可能多看一些单词。这种训练可增加每次凝视时摄入更大范围的单词群的能力，也适用于练习纵览和预览技巧，并能把大脑调整到适应更快速、更有效的整体阅读练习状态。</p>
<p>4.8    动机训练<br>        计算每分钟阅读速度的公式：<br>            阅读速度=（所读页数*每页平均单词书）/阅读的分钟数<br>4.9    节拍训练<br>        调整到合理的节奏、即每一拍代表视觉引导物的一次移动的话，用这种方式可以保持一种稳定、连贯的节奏、并可克服阅读开始后不久出现的阅读速度下降的问题。一旦找到最佳的节奏，就可通过每分钟偶尔加一拍的方式提高你的阅读速度。<br>————2014/10/28 00:15——————-</p>
<p>5.3  记忆趋势：在学习期间的开头和结尾记得多；多次重复、易感知、有节奏的内容记得多；突出或独特的内容记得多———–冯-雷斯托夫效应，而学习期间的中间阶段所能机翼的内容却相当少。</p>
<pre><code> 要想保持在一个相当高的水准，必须找到记忆与理解最和谐的工作点。
在正常情况下，这一点出现在学习开始的20~50分钟之间。
学习期间的短暂间隔也常用于放松、消遣。可以使集中注意力学习时紧张的肌肉和神经得以放松。
学习后的回忆量最初是上升，之后才是下降，再后是一条逐渐下降的、以水平线结尾的凹形曲线。

    短暂上升的原因：在学习结束的瞬间，大脑没有足够的时间去整合刚学的新信息，尤其是最后的部分。它需要几分钟的时间将新材料之间的相关联系牢固地连接起来，即使之“沉淀下来”。
    小幅上升之后是一个陡峻的下降，在学习一个小时之后的24小时之内，至少有80%的细节被遗忘了。</code></pre>
<p>5.5 记忆–复习的技巧和理论<br>        安排有计划的复习，而且每次复习必须安排在回忆刚开始下降之前。<br>        eg:第一次复习应该在学习1小时之后的10分钟开始，复习时间以5分钟为宜。这样可以使记忆在高位保持1天左右，然后应该进行第二次复习，时间为2~4分钟。此后，记忆将保持一周左右，然后在一个月之后再次复习约2分钟。经过这最后一次复习，此项知识将被转为长期记忆。</p>
<pre><code>    如果已经做过笔记的话，第一次复习应该是对笔记的全面修订过程，这就意味着要取代原来的笔记的“最终版本”。而第二、三和四次复习则应采用下列方式:不看整理过的笔记，用一张纸概括记下所能回忆的一切，然后将其与整理后的笔记对照，再进行修改和补充。笔记和草稿都应做成思维导图。
    合理复习最重要的一个方面是作用于学习、思维和记忆等各方面的累计效应。

    每次接触新知识时，人们对已学知识的记忆处于低谷，原有知识间自动产生的连接会解体。这样，他对新知识的理解就不能达到应有的水平，效率和速度也必然很低。这种连续的消极过程会使人感到沮丧，最终对能学好的东西也失去了信心-----只要一学新东西就会忘记，一接触新东西心理上就会感到压抑。结果是很多人在完成了正式的考试之后，就很少甚至根本不再碰书本。


    失败的复习对整体记忆同样有害，如果忽略每条新信息的话，那么它将不再保持在意识层中，也不能形成新的记忆链接。由于记忆是一个以连接和联想为基础的过程，因而“记忆库”中的东西越少，其接纳和连接新知识的可能性就越小。
    相反，复习的好处是无穷的。</code></pre>
<p>2014/10/29 10:54<br>    使用某些方法使我们能利用记忆的连接和联想能力，来把这些事项与其对应的数字关联起来。<br>   最好的方法是数字-韵律法。</p>
<p>5.7记忆的“SMASHIN” SCOPE 法<br>        在这种方法中最重要的是要保证押韵字与所要记忆的单词必须全部准确的连接起来。<br>    1.通感/感官(Synaesthesia/Sensuality)<br>            通感，指的是多种感觉的融合。<br>            视觉、听觉、嗅觉、味觉、触觉、动觉—对身体在空间中的位置与运动的感觉。<br>    2.运动(Movenment)<br>            在任何记忆的形象中，运动可以极大的增加大脑连接和记住东西的可能性。—-这里指记忆的形象的运动性。<br>    3.联想(Association)<br>            确保使它与你的内省的某些稳定不变的事物联想或连接起来。衣钩法：1=面包。<br>    4.性(Sexuality)<br>            要加以利用!<br>    5.幽默(Humour)<br>            想象越有趣、越荒谬、越愚蠢、超越现实，就越容易被记住。<br>    6.想象(Imagination)<br>            爱因斯坦说：“想象比知识更重要，因为知识是有限的，而想象却能包容全世界、促进进步、孕育革新。”<br>            在记忆中应用的想象越多，记忆就会越好。<br>    7.编号(Number)<br>            按数字编号使顺序及次序的规则更有针对性，更有效。<br>    8.符号(Symbolism)<br>            用丰富多彩的想象；可以用传统的符号，如休止符、灯泡。<br>    9.颜色(Color)<br>            在适当的地方尽可能使用各种颜色，可使你的想法色彩斑斓，更易于记忆。<br>    10.顺序和/或次序(Order and /or Seguence)<br>            结合其他规则，排列顺序和次序起到了更直接的参考作用，并增加了大脑“随机存取”的可能性。将排列顺序和次序的应用加以扩展，能使你开发记忆矩阵，如自我增强型记忆矩阵。<br>    11.“积极”的形象(Positive Images)<br>            积极愉快的形象更利于记忆，这使大脑乐于工作。<br>    12.夸张(Exageration)<br>            在所想象的情景中，夸大尺寸、形象和声音。</p>
<pre><code>    12个记忆要素很容易用它们的首字母组成的单词“SMASHIN” SCOPE 来记。</code></pre>
<p>5.8  数字–韵律法<br>        在形成头脑中的形象时，很重要的一点是,要在“心目”中看到清晰的图像。经常闭上眼睛，将想象的情景投影到你的眼脸内部，或投影到你大脑的屏幕上，并且去听、去感觉、去闻，或者用对你来说最有效的方式去体验。原书84页。<br>        所有方法中尤其有效的是基本记忆法。它能以“数字-韵律法”的方式记住1000条以上的信息，并且能给出记忆数字与日期的关键方法。“名字-面孔记忆法”能避免你在碰到曾经见过面的人时，避免尴尬。<br>5.9 不可能完成的任务<br>        记忆基本上是一个联想和连接的过程，而且很大程度上取决于关键字，以及用于恰当想象的关键概念。</p>
<p>6.思维导图–词汇与思维特征的介绍<br>6.1 练习与讨论蟋蟀</p>
<p>四象限法则<br>策略：<br>如果你总是有紧急又重要的事情要做，说明你在时间管理上存在问题，设法减少它。<br>尽可能地把时间花在重要但不紧急（第二象限）的事情上，这样才能减少第一象限的工作量。<br>对于紧急但不重要的事情的处理原则是授权，让别人去做。<br>不重要也不紧急的事情尽量少做。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hardy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hardy</p><p class="is-size-6 is-block">不积跬步无以至千里</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">96</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">88</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/believeZJP" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/believeZJP"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="微博" href="https://weibo.com/u/6021664425"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="tencent://message/?uin=421790588&amp;Site=www&amp;Menu=yes"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/es6/"><span class="level-start"><span class="level-item">es6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/http/"><span class="level-start"><span class="level-item">http</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/http/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-29T11:36:01.000Z">2020-12-29</time></p><p class="title"><a href="/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%97%E8%A1%A8/">思维导图列表</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-27T07:25:36.000Z">2020-11-27</time></p><p class="title"><a href="/posts/%E7%BE%BD%E6%AF%9B%E7%90%83%E9%80%9F%E6%88%90/">羽毛球速成</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-11T08:55:34.116Z">2020-09-11</time></p><p class="title"><a href="/posts/Alfred/">Alfred</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-08-20T08:18:50.000Z">2020-08-20</time></p><p class="title"><a href="/posts/React%E4%B8%ADAPI%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">React中API使用的正确姿势</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-07-23T16:06:49.000Z">2020-07-24</time></p><p class="title"><a href="/posts/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8standard%E8%A7%84%E8%8C%83%E5%B9%B6%E7%94%A8eslint%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/">项目使用standard规范并用eslint自动格式化代码</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Alfred/"><span class="tag">Alfred</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS3/"><span class="tag">CSS3</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EventLoop/"><span class="tag">EventLoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitKraken/"><span class="tag">GitKraken</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koa/"><span class="tag">Koa</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NodeJS/"><span class="tag">NodeJS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Promise/"><span class="tag">Promise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-Native/"><span class="tag">React Native</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React%E8%BF%81%E7%A7%BB%E5%88%B0%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">React迁移到百度小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSR/"><span class="tag">SSR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SmartGit/"><span class="tag">SmartGit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/antDesign/"><span class="tag">antDesign</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/async/"><span class="tag">async</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/await/"><span class="tag">await</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compose/"><span class="tag">compose</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es8/"><span class="tag">es8</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/for-of/"><span class="tag">for of</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/generator/"><span class="tag">generator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iTerm2/"><span class="tag">iTerm2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iterator/"><span class="tag">iterator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jQuery/"><span class="tag">jQuery</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nextTick/"><span class="tag">nextTick</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setImmediate/"><span class="tag">setImmediate</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setTimeout/"><span class="tag">setTimeout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack4/"><span class="tag">webpack4</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%9A%E5%8A%A1/"><span class="tag">业务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"><span class="tag">代码示例</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%A5%E6%83%B3/"><span class="tag">冥想</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%8E%E7%AB%AF/"><span class="tag">后端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%93%B2%E5%AD%A6/"><span class="tag">哲学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tag">基础知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/"><span class="tag">处理问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"><span class="tag">学习方法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">学习笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"><span class="tag">定时器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%81%E8%A3%85/"><span class="tag">封装</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"><span class="tag">思维导图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF/"><span class="tag">技术</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8F%92%E4%BB%B6/"><span class="tag">插件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87/"><span class="tag">效率</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"><span class="tag">日常积累</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99/"><span class="tag">正则</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/"><span class="tag">沟通技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">理论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">百度小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9B%91%E6%8E%A7/"><span class="tag">监控</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="tag">知识点</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E8%AF%BB/"><span class="tag">精读</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/"><span class="tag">线上事故</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/"><span class="tag">组合函数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%88%E7%AB%AF/"><span class="tag">终端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"><span class="tag">经验积累</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%91%E6%AD%A5/"><span class="tag">跑步</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%90%E5%8A%A8/"><span class="tag">运动</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><span class="tag">进程管理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="believeZJP" height="28"></a><p class="is-size-7"><span>&copy; 2020 believeZJP</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>