<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>前端经验积累 - believeZJP</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="believeZJP"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="believeZJP"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="判断一个对象是不是数组 instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。  12345678var a&amp;#x3D;&amp;amp;#123;&amp;amp;#125;;var b&amp;#x3D;[];console.log(a instanceof Object);&amp;#x2F;&amp;#x2F;trueconsole.log(b instanceof Array);&amp;#x2F;&amp;amp;#x"><meta property="og:type" content="blog"><meta property="og:title" content="前端经验积累"><meta property="og:url" content="http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"><meta property="og:site_name" content="believeZJP"><meta property="og:description" content="判断一个对象是不是数组 instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。  12345678var a&amp;#x3D;&amp;amp;#123;&amp;amp;#125;;var b&amp;#x3D;[];console.log(a instanceof Object);&amp;#x2F;&amp;#x2F;trueconsole.log(b instanceof Array);&amp;#x2F;&amp;amp;#x"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://believezjp.oriht.com/img/og_image.png"><meta property="article:published_time" content="2018-07-03T13:42:02.000Z"><meta property="article:modified_time" content="2018-11-29T13:42:02.000Z"><meta property="article:author" content="believeZJP"><meta property="article:tag" content="jQuery"><meta property="article:tag" content="插件"><meta property="article:tag" content="封装"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"},"headline":"believeZJP","image":["http://believezjp.oriht.com/img/og_image.png"],"datePublished":"2018-07-03T13:42:02.000Z","dateModified":"2018-11-29T13:42:02.000Z","author":{"@type":"Person","name":"believeZJP"},"description":"判断一个对象是不是数组 instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。  12345678var a&#x3D;&amp;#123;&amp;#125;;var b&#x3D;[];console.log(a instanceof Object);&#x2F;&#x2F;trueconsole.log(b instanceof Array);&#x2F;&amp;#x"}</script><link rel="canonical" href="http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?60d1b1f3f98701021581fc14f9ca17b7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="believeZJP" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/believeZJP"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-07-03T13:42:02.000Z" title="2018-07-03T13:42:02.000Z">2018-07-03</time>发表</span><span class="level-item"><time dateTime="2018-11-29T13:42:02.000Z" title="2018-11-29T13:42:02.000Z">2018-11-29</time>更新</span><span class="level-item">2 小时读完 (大约16587个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">前端经验积累</h1><div class="content"><h1 id="判断一个对象是不是数组"><a href="#判断一个对象是不是数组" class="headerlink" title="判断一个对象是不是数组"></a>判断一个对象是不是数组</h1><ol>
<li>instanceof操作符用来判断要检测对象的原型链上是否存在某个构造函数的prototype属性。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;;</span><br><span class="line">var b&#x3D;[];</span><br><span class="line">console.log(a instanceof Object);&#x2F;&#x2F;true</span><br><span class="line">console.log(b instanceof Array);&#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">注意！！！！！！</span><br><span class="line">console.log(b instanceof Object);&#x2F;&#x2F;true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Array.isArray()</p>
</li>
<li><p>使用Object.prototype上的原生toString()方法判断。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.toString.call(a));&#x2F;&#x2F;[object Object]</span><br><span class="line">console.log(Object.prototype.toString.call(b));&#x2F;&#x2F;[object Array]</span><br><span class="line">同理判断一个对象是否是函数：</span><br><span class="line">console.log(Object.prototype.toString.call(obj)&#x3D;&#x3D;&#x3D;&#39;[object Function]&#39;)    &#x2F;&#x2F;true或false</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>obj.constructor===Array   //true</li>
</ol>
<h1 id="真值-假值（Truthy-Falsy）"><a href="#真值-假值（Truthy-Falsy）" class="headerlink" title="真值 / 假值（Truthy / Falsy）"></a>真值 / 假值（Truthy / Falsy）</h1><p>以下为false</p>
<ul>
<li>false</li>
<li>0</li>
<li>“”（空字符串）</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">!0 &#x2F;&#x2F; true -- 0 is false, 所以返回true</span><br><span class="line">!!0 &#x2F;&#x2F; false -- 0 is falsy so !0 returns true so !(!0) returns false</span><br><span class="line">!!&quot;&quot; &#x2F;&#x2F; false -- empty string is falsy so NOT (NOT false) equals false</span><br><span class="line"></span><br><span class="line">new Boolean(0) &#x2F;&#x2F; false</span><br><span class="line">new Boolean(1) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let a &#x3D; [] &#x3D;&#x3D; true &#x2F;&#x2F; a is false since [].toString() give &quot;&quot; back.</span><br><span class="line">let b &#x3D; [1] &#x3D;&#x3D; true &#x2F;&#x2F; b is true since [1].toString() give &quot;1&quot; back.</span><br><span class="line">let c &#x3D; [2] &#x3D;&#x3D; true &#x2F;&#x2F; c is false since [2].toString() give &quot;2&quot; back.</span><br><span class="line"></span><br><span class="line">在内部，当一个对象与布尔值比较时，</span><br><span class="line">比如[] &#x3D;&#x3D; true，它其实进行的是[].toString() &#x3D;&#x3D; true。</span><br></pre></td></tr></table></figure>

<h1 id="JS语句为什么不能以“function”和大括号开头"><a href="#JS语句为什么不能以“function”和大括号开头" class="headerlink" title="JS语句为什么不能以“function”和大括号开头"></a>JS语句为什么不能以“function”和大括号开头</h1><ul>
<li>以function开头，但必须是一个函数声明语句</li>
<li>以大括号开头，但该大括号不再被当做一个对象处理，而是当做一个语句块处理</li>
<li>综上两条说明，JS语句可以以function，也可以以大括号作为开头，前提是必须符合JS中的语法规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;a: &#39;a&#39;&#125;.a;   &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line">function()&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token (</span><br><span class="line">&#123;&#125;.toString();    &#x2F;&#x2F; Uncaught SyntaxError: Unexpected token .</span><br><span class="line"></span><br><span class="line">“&#123;&#125;.toString();” 等同于: “; .toString();” 未通过对象主体调用“toString”方法，不符合JS中期待的表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Object-assign-JSON-stringify是深拷贝吗"><a href="#Object-assign-JSON-stringify是深拷贝吗" class="headerlink" title="Object.assign, JSON.stringify是深拷贝吗"></a>Object.assign, JSON.stringify是深拷贝吗</h1><p>不是的话怎么解决</p>
<p>shallowCopy（浅拷贝）或 deepCopy（深拷贝）</p>
<p>深拷贝造成了 CPU 和内存的浪费</p>
<p>深拷贝如果是只有最底层一个元素改变，会造成性能影响，怎么解决? immutable</p>
<p>Object.assign()可以对非嵌套对象进行深拷贝的方法,<br>如果对象中出现嵌套情况,那么其对被嵌套对象的行为就成了普通的浅拷贝.<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。</p>
<p>对象解构运算，也是浅拷贝。</p>
<p>JSON对象中包含两个方法, stringify()和parse(),前者可以将对象JSON化,而后者可以将JSON格式转换为对象.这是一种可以实现深拷贝的方法.<br>但这种方法的缺陷是会破坏原型链,并且无法拷贝属性值为function的属性<br>所以如果只是想单纯复制一个嵌套对象,可以使用此方法</p>
<p>缺点是你创建一个临时的，可能很大的字符串，只是为了把它重新放回解析器。另一个缺点是这种方法不能处理循环对象。而且循环对象经常发生。例如，当您构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。另外，诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const x &#x3D; &#123;&#125;;</span><br><span class="line">const y &#x3D; &#123;x&#125;;</span><br><span class="line">x.y &#x3D; y; &#x2F;&#x2F; Cycle: x.y.x.y.x.y.x.y.x...</span><br><span class="line">const copy &#x3D; JSON.parse(JSON.stringify(x)); &#x2F;&#x2F; throws!</span><br><span class="line"></span><br><span class="line">let bar &#x3D; JSON.parse(JSON.stringify(foo));</span><br><span class="line">Object.assign(&#123;&#125;, foo);</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a: 0,</span><br><span class="line">    b: 20,</span><br><span class="line">&#125;</span><br><span class="line">obj &#x3D; &#123;...obj, a: obj.a + 1&#125;</span><br><span class="line"></span><br><span class="line">Structured Clone 结构化克隆算法</span><br><span class="line">MessageChannel</span><br><span class="line">缺点是它是异步的。虽然这并无大碍，</span><br><span class="line">但是有时候你需要使用同步的方式来深度拷贝一个对象</span><br><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;port1, port2&#125; &#x3D; new MessageChannel();</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#x2F;* ... *&#x2F;;</span><br><span class="line">const clone &#x3D; await structuralClone(obj);</span><br></pre></td></tr></table></figure>

<p>es7 … 的方式<br>直接{…obj}赋值属于浅复制，在修改值时{…obj,a:1}就起到了类深复制的效果<br>更新一个 Object</p>
<h3 id="immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"><a href="#immutable-js-这个专门处理不变性数据的库-也是facebook出品-，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发" class="headerlink" title="immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发"></a>immutable.js 这个专门处理不变性数据的库(也是facebook出品)，它可以使用类似赋值的方式生成浅复制的不变性数据，下面来看看它怎么简化我们的开发</h3><p> <a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/3">链接</a></p>
<p> Immutable数据就是一旦创建，就不能更改的数据。每当对Immutable对象进行修改的时候，就会返回一个新的Immutable对象，以此来保证数据的不可变。</p>
<p>为什么immutable比较两个对象不同会快？原因如下：<br>和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。用法：is(map1,map2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">这是原来的 reducer：</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    newState &#x3D; Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        apples: [</span><br><span class="line">            ...state.apples.slice(0, action.payload),</span><br><span class="line">            Object.assign(&#123;&#125;, state.apples[action.payload], &#123; isEaten: true &#125;),</span><br><span class="line">            ...state.apples.slice(action.payload + 1)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">    return newState;</span><br><span class="line"></span><br><span class="line">这是使用 immutable.js 库的reducer :</span><br><span class="line"></span><br><span class="line">import &#123; fromJS &#125; from &#39;immutable&#39;;</span><br><span class="line"></span><br><span class="line">case &#39;apple&#x2F;EAT_APPLE&#39;:</span><br><span class="line">    return fromJS(state).setIn([&#39;apples&#39;,action.payload,&#39;isEaten&#39;], true).toJS();</span><br><span class="line"></span><br><span class="line">团队约定 state 都用 immutable 内部的数据类型，就可以连 fromJS 和 toJS 的转化都省了，超级方便！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="JSONP-后端返回alert-data-，前端会执行吗"><a href="#JSONP-后端返回alert-data-，前端会执行吗" class="headerlink" title="JSONP 后端返回alert(data)，前端会执行吗"></a>JSONP 后端返回alert(data)，前端会执行吗</h1><p>因为后端把回调方法名转成另一个名字将data包在里边，所以不会执行alert。</p>
<p>为什么是jsonp, img, iframe也可以，为什么？</p>
<p>jsonp全名叫做json with padding<br>函数调用，数据都被包裹传递到参数中了，</p>
<p>将服务端的数据用padding包起来，所谓的padding就相当于一个函数。假设我们原来有数据 {“data”,”something”}，用一个名为callback的padding包起来之后 就成了 callback({“data”:”something”})，这样将script标签加载完毕之后，会立马执行这个函数，并将数据当做参数传了进去。如果我们可以事先在前端事先指定一个函数名，并定义这个函数。然后告诉后端，用这个函数名作为padding包裹数据。那么当前端动态创建script标签之后，script加载完毕了就会执行这个函数，这样我们就成功的跨域获得了数据~</p>
<p>从开发者工具里面可以看到实际发送的请求</p>
<p>Request URL:<a target="_blank" rel="noopener" href="https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924">https://api.douban.com/v2/book/1220562?callback=jsonp1430727166924</a></p>
<p>这里可以看出来jQuery自动生成的padding是jsonp1430727166924返回的数据：;jsonp1430727166924({“rating”:{“max”:10,”numRaters”:336,”average”:”7.0”,”min”:0},”price”:”15.00元”});</p>
<h1 id="js-css执行顺序，并行串行，阻塞"><a href="#js-css执行顺序，并行串行，阻塞" class="headerlink" title="js,css执行顺序，并行串行，阻塞"></a>js,css执行顺序，并行串行，阻塞</h1><p><a target="_blank" rel="noopener" href="http://blog.jobbole.com/12749/">链接</a><br>DOM文档的加载顺序是由上而下的顺序加载；</p>
<p>1、DOM加载到link标签</p>
<p>==css文件的加载是与DOM的加载并行的==，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；</p>
<p>2、DOM加载到script标签</p>
<p>由于==js文件不会与DOM并行加载==，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；</p>
<p>js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现；</p>
<p>所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。至到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。</p>
<p>嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。</p>
<p>浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>
<p>3、解决方法</p>
<p>前提，js是外部脚本；</p>
<p>在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；</p>
<p>在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；</p>
<p>同时使用defer和async属性时，defer属性会失效；</p>
<p>可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。</p>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;十进制转其他</span><br><span class="line">var x&#x3D;110;  </span><br><span class="line">alert(x);</span><br><span class="line">alert(x.toString(8));  </span><br><span class="line">alert(x.toString(32));  </span><br><span class="line">alert(x.toString(16));  </span><br><span class="line">&#x2F;&#x2F;其他转十进制</span><br><span class="line">var x&#x3D;&#39;110&#39;;</span><br><span class="line">alert(parseInt(x,2));  </span><br><span class="line">alert(parseInt(x,8));  </span><br><span class="line">alert(parseInt(x,16));  </span><br><span class="line">&#x2F;&#x2F;其他转其他  </span><br><span class="line">&#x2F;&#x2F;先用parseInt转成十进制再用toString转到目标进制  </span><br><span class="line">alert(String.fromCharCode(parseInt(141,8)))  </span><br><span class="line">alert(parseInt(&#39;ff&#39;,16).toString(2));  </span><br></pre></td></tr></table></figure>

<h1 id="两个对象判断"><a href="#两个对象判断" class="headerlink" title="两个对象判断=="></a>两个对象判断==</h1><p>引用下温特大大的总结就是：<br>只要记住 null 只和undefined 相等，<br>有 number 都转 number，<br>有 boolean 也转 number，<br>有 string 都转 string，<br>对象互相不等，<br>NaN 互相不等就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log([] &#x3D;&#x3D; []) &#x2F;&#x2F; false</span><br><span class="line">console.log(![] &#x3D;&#x3D; false) &#x2F;&#x2F; false</span><br><span class="line">console.log([] &#x3D;&#x3D; false) &#x2F;&#x2F; true</span><br><span class="line">console.log(!!&#39;hello&#39;) &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;hello&#39; &#x3D;&#x3D; true) &#x2F;&#x2F; &#39;hello&#39;&#x3D;&#x3D;1  false</span><br><span class="line">console.log(typeof(typeof(&#39;hello&#39;)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typeof的运算数未定义,返回的就是 “undefined”.</span><br><span class="line"></span><br><span class="line">运算数为数字 typeof(x) &#x3D; “number”</span><br><span class="line"></span><br><span class="line">字符串 typeof(x) &#x3D; “string”</span><br><span class="line"></span><br><span class="line">布尔值 typeof(x) &#x3D; “boolean”</span><br><span class="line"></span><br><span class="line">对象,数组和null typeof(x) &#x3D; “object”</span><br><span class="line"></span><br><span class="line">函数 typeof(x) &#x3D; “function”</span><br></pre></td></tr></table></figure>

<h1 id="FOUC无样式内容闪烁"><a href="#FOUC无样式内容闪烁" class="headerlink" title="FOUC无样式内容闪烁"></a>FOUC无样式内容闪烁</h1><p>Flash of Uncompiled Content</p>
<p>原因大致为： 1，使用import方法导入样式表。 2，将样式表放在页面底部 3，有几个样式表，放在html结构的不同位置。</p>
<p>解决方法： 使用LINK标签将样式表放在文档HEAD中。</p>
<ol>
<li><p>v-cloak</p>
</li>
<li><p>用v-text</p>
</li>
<li><p>v-if, v-show</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- same as --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// <span class="tag">&lt;<span class="name">div</span>&gt;</span> 不会显示，直到编译结束。</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">&#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="js实现jQuery-clone"><a href="#js实现jQuery-clone" class="headerlink" title="js实现jQuery.clone"></a>js实现jQuery.clone</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">逐级递归；</span><br><span class="line"></span><br><span class="line">递归中收集每个元素的全部信息，包括该元素上绑定的所有事件。</span><br><span class="line"></span><br><span class="line">复制时候重现按照获得的事件列表逐个加载回去。</span><br><span class="line"></span><br><span class="line">除此之外主要可能是考虑各种兼容，</span><br><span class="line">包括cloneNode方法的兼容，</span><br><span class="line">获取元素属性时候的某些标签的兼容。</span><br></pre></td></tr></table></figure>

<h1 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h1><p>（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。</p>
<h1 id="ajax参数"><a href="#ajax参数" class="headerlink" title="ajax参数"></a>ajax参数</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huiyuantang/p/5458278.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.url: 发送请求的地址</span><br><span class="line">2.type: 请求方式（post或get</span><br><span class="line">3.timeout: 请求超时时间（毫秒）</span><br><span class="line">4.async: 默认设置为true，异步请求</span><br><span class="line">5.cache: 从浏览器缓存中加载请求信息</span><br><span class="line">6.data: 发送到服务器的数据</span><br><span class="line">7.dataType: xml,html, json,text</span><br><span class="line">8.beforeSend：发送请求前，执行一些操作</span><br><span class="line">9.complete：完成后调用的回调函数</span><br><span class="line">10.success：请求成功后调用的回调函数</span><br><span class="line">11.error:</span><br><span class="line">12.contentType：</span><br><span class="line">13.dataFilter：</span><br><span class="line"></span><br><span class="line">16.ifModified：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;闭包限定命名空间</span><br><span class="line">(function ($) &#123;</span><br><span class="line">    $.fn.extend(&#123;</span><br><span class="line">        &quot;highLight&quot;:function(options)&#123;</span><br><span class="line">            &#x2F;&#x2F;do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(window.jQuery);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用</span><br><span class="line">$(&quot;p&quot;).highLight(); &#x2F;&#x2F;调用自定义 高亮插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="exports-module-exports区别"><a href="#exports-module-exports区别" class="headerlink" title="exports, module.exports区别"></a>exports, module.exports区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports</span><br><span class="line"></span><br><span class="line">exports在module.exports 被改变后，失效。</span><br><span class="line"></span><br><span class="line">1. module.exports 初始值为一个空对象 &#123;&#125;</span><br><span class="line">2. exports 是指向的 module.exports 的引用</span><br><span class="line">3. require() 返回的是 module.exports 而不是 exports</span><br></pre></td></tr></table></figure>

<h1 id="上传文件方式"><a href="#上传文件方式" class="headerlink" title="上传文件方式"></a>上传文件方式</h1><ul>
<li><p>form表单上传文件</p>
  <form action="/test/" method="POST" enctype="multipart/form-data">
</li>
<li><p>原生js实现ajax上传文件<br>   var xml=new XMLHttpRequest();</p>
<p>  var data=new FormData; //创建formdata对象</p>
<p>  data.append(“testfile”,document.getElementById(“file_upload”).files[0]);//找到对象之后的file[0]对应的就是文件对象</p>
<p>  xml.open(“POST”,”/test/“,true);</p>
</li>
<li><p>jquery实现ajax上传文件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var data&#x3D;new FormData;</span><br><span class="line">data.append(&quot;testfile&quot;,document.getElementById(&quot;file_upload&quot;).files[0]);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;&#x2F;test&#x2F;&quot;,</span><br><span class="line">    type:&quot;POST&quot;,</span><br><span class="line">    dataType:&quot;JSON&quot;,</span><br><span class="line">    data:data,</span><br><span class="line">    contentType: false,</span><br><span class="line">    processData: false,</span><br><span class="line">    success:function(rst)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>form+iframe上传文件</p>
<h1 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h1><p> @mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin通过 @include来调用。</p>
<p> @mixin通过 @include调用后解析出来的样式是以拷贝形式存在的，而继承则是以联合声明的方式存在的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sass style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">@mixin center-block &#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br><span class="line">.demo&#123;</span><br><span class="line">    @include center-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;css style</span><br><span class="line">&#x2F;&#x2F;-------------------------------</span><br><span class="line">.demo&#123;</span><br><span class="line">    margin-left:auto;</span><br><span class="line">    margin-right:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1，session 在服务器端，</span><br><span class="line">    cookie 在客户端（浏览器）</span><br><span class="line">2，session 默认被存在在服务器</span><br><span class="line">    的一个文件里（不是内存）</span><br><span class="line">3，session 的运行依赖 session id，</span><br><span class="line">    而 session id 是存在 cookie 中的，</span><br><span class="line">    也就是说，如果浏览器禁用了 cookie ，</span><br><span class="line">    同时 session 也会失效</span><br><span class="line">    （但是可以通过其它方式实现，</span><br><span class="line">    比如在 url 中传递 session_id）</span><br><span class="line">4，session 可以放在 文件、数据库、或内存中都可以。</span><br><span class="line">5，用户验证这种场合一般会用 session</span><br><span class="line">因此，维持一个会话的核心就是</span><br><span class="line">客户端的唯一标识，即 session id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="AMD-CMD-CommonJS"><a href="#AMD-CMD-CommonJS" class="headerlink" title="AMD, CMD, CommonJS"></a>AMD, CMD, CommonJS</h1><p>==记忆方法==</p>
<p>AR<br>AMD– require.js</p>
<p>CS<br>CMD– sea.js</p>
<p>A AMD A在前，提前加载</p>
<p>C CMD C在后，延迟加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">node的module遵循CommonJS规范，</span><br><span class="line">requirejs遵循AMD，seajs遵循CMD，</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------- node -----------</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  a : function() &#123;&#125;,</span><br><span class="line">  b : &#39;xxx&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------- AMD or CMD ----------------</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  module.exports &#x3D; &#123;</span><br><span class="line">    a : function() &#123;&#125;,</span><br><span class="line">    b : &#39;xxx&#39;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。</span><br><span class="line">它采用异步方式加载模块，模块的加载不影响它后面语句的运行。</span><br><span class="line">所有依赖这个模块的语句，都定义在一个回调函数中，</span><br><span class="line">等到加载完成之后，这个回调函数才会运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line"></span><br><span class="line">1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</span><br><span class="line">不过 RequireJS 从 2.0 开始，</span><br><span class="line">也改成可以延迟执行（根据写法不同，处理方式不同）。</span><br><span class="line">CMD 推崇 as lazy as possible.</span><br><span class="line"></span><br><span class="line">2. CMD 推崇依赖就近，AMD 推崇依赖前置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="import引入模块"><a href="#import引入模块" class="headerlink" title="import引入模块"></a>import引入模块</h3><p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>注意:import必须放在文件的最开始.import命令是编译阶段执行的，在代码运行之前,表达式和变量只有在运行时才能得到结果的语法结构。import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）所以import中不能含有表达式或者变量,因此无法实现动态加载.<br>因此，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。<br>这样的设计，有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br></pre></td></tr></table></figure>

<h1 id="position取值"><a href="#position取值" class="headerlink" title="position取值"></a>position取值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ralative是指相对定位</span><br><span class="line">元素仍保持其未定位前的形状，它原本所占的空间仍保留。</span><br><span class="line"></span><br><span class="line">absolute是指绝对定位</span><br><span class="line">    即完全离开文档流, 相关于position属性非static值的比来父级元素进行偏移。</span><br><span class="line">    如果不存在这样的父对象，则依据body对象。而其层叠通过z-index属性定义</span><br><span class="line">fixed: 固定定位</span><br><span class="line">    固定定位：即完全离开文档流，相关于视区进行偏移。</span><br><span class="line">static：元素框正常生成</span><br><span class="line">inherit：继承值，对象将继承其父对象相应的值。</span><br></pre></td></tr></table></figure>

<h1 id="类数组转换为数组的方法"><a href="#类数组转换为数组的方法" class="headerlink" title="类数组转换为数组的方法"></a>类数组转换为数组的方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="call和apply-bind区别"><a href="#call和apply-bind区别" class="headerlink" title="call和apply, bind区别"></a>call和apply, bind区别</h1><p>这三个参数的返回值区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">作用完全一样，唯一的区别就在参数上</span><br><span class="line"></span><br><span class="line">call 接收的参数不固定，</span><br><span class="line">第一个参数是函数体内 this 的指向，</span><br><span class="line">第二个参数以下是依次传入的参数。</span><br><span class="line"></span><br><span class="line">apply接收两个参数，</span><br><span class="line">第一个参数也是函数体内 this 的指向。</span><br><span class="line">第二个参数是一个集合对象（数组或者类数组）</span><br><span class="line"></span><br><span class="line">记忆方法：</span><br><span class="line"></span><br><span class="line">apply ---- array 要传数组</span><br><span class="line">call  ---- 逗号隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三个的使用区别：</span><br><span class="line">都是用来改变函数的this对象的指向的；</span><br><span class="line">第一个参数都是this要指向的对象；</span><br><span class="line">都可以利用后续参数传参；</span><br><span class="line">bind是返回对应函数，便于稍后调用，apply、call是立即调用；</span><br><span class="line">bind（）--也是改变函数体内this的指向;</span><br><span class="line">bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind（）方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let obj1&#x3D;&#123;</span><br><span class="line">    a:222</span><br><span class="line">&#125;;</span><br><span class="line">let obj2&#x3D;&#123;</span><br><span class="line">    a:111,</span><br><span class="line">    fn:function()&#123;</span><br><span class="line">        alert(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.fn.call(obj1);&#x2F;&#x2F;222</span><br><span class="line"></span><br><span class="line">call 和 apply 两个主要用途就是</span><br><span class="line"></span><br><span class="line">1.改变 this 的指向（把 this 从 obj2 指向到 obj1 ）</span><br><span class="line"></span><br><span class="line">2.方法借用（ obj1 没有 fn ，只是借用 obj2 方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="箭头函数怎么绑定全局this"><a href="#箭头函数怎么绑定全局this" class="headerlink" title="箭头函数怎么绑定全局this"></a>箭头函数怎么绑定全局this</h1><p>箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () &#x3D;&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  &#x2F;&#x2F; undefined window&#123;...&#125;</span><br><span class="line"></span><br><span class="line">作为方法的箭头函数this指向全局window对象，</span><br><span class="line">而普通函数则指向调用它的对象</span><br></pre></td></tr></table></figure>

<h1 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h1><p><a target="_blank" rel="noopener" href="http://caibaojian.com/es6-features.html">链接</a></p>
<h1 id="foreach-map-reduce-filter区别"><a href="#foreach-map-reduce-filter区别" class="headerlink" title="foreach, map, reduce, filter区别"></a>foreach, map, reduce, filter区别</h1><h1 id="函数声明-amp-函数表达式的区别"><a href="#函数声明-amp-函数表达式的区别" class="headerlink" title="函数声明&amp;函数表达式的区别"></a>函数声明&amp;函数表达式的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">函数声明中函数名是必须的；函数表达式中则是可选的</span><br><span class="line"> &#x2F;&#x2F;函数声明</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(1, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数表达式</span><br><span class="line">&#x2F;* var s &#x3D; function sum(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2)); *&#x2F;</span><br><span class="line"></span><br><span class="line">var s &#x3D; function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(s(1, 2));</span><br><span class="line">&#x2F;&#x2F;以上两种都可以</span><br><span class="line"></span><br><span class="line">二、用函数声明定义的函数,函数可以在函数声明之前调用,而用函数表达式定义的函数只能在声明之后调用。</span><br><span class="line"></span><br><span class="line">【根本原因在于解析器对这两种定义方式读取的顺序不同:解析器会事先读取函数声明，即函数声明放在任意位置都可以被调用；</span><br><span class="line"></span><br><span class="line">对于函数表达式，解析器只有在读到函数表达式所在那行的时候才执行】</span><br><span class="line"></span><br><span class="line">使用var 表达式定义函数， 只有变量声明提前了，变量初始化代码仍然在原来的位置</span><br></pre></td></tr></table></figure>

<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段</p>
<h5 id="addEventListener-evtype-fn-useCapture"><a href="#addEventListener-evtype-fn-useCapture" class="headerlink" title="addEventListener(evtype,fn,useCapture)"></a>addEventListener(evtype,fn,useCapture)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">useCapture是true，则事件处理函数在捕获阶段被执行，否则 在冒泡阶段执行</span><br><span class="line"></span><br><span class="line">因为如果被监听的元素没有子元素，那么哪个监听代码写在前面，就先执行哪个！</span><br><span class="line"></span><br><span class="line">&lt;label&gt;Click me &lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;label&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(&#39;label&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;)</span><br><span class="line">    document.querySelector(&#39;input&#39;).addEventListener(&#39;click&#39;,function () &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">因为label和input是有绑定的</span><br><span class="line">点击label后，浏览器自动帮你再点击一次label</span><br><span class="line">过程就是先进行一次事件机制，这一次对内部input元素的事件监听是不管不问的，所以先打出1</span><br><span class="line">结束后，再进行一次事件机制，这一次，按照正常事件机制流程走，所以接着打出了2,1</span><br></pre></td></tr></table></figure>

<p>阻止冒泡<br>window.event.cancelBubble = true</p>
<p>e.preventDefault();</p>
<p>return false</p>
<p>都能阻止<br> stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。<br>stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡</p>
<h1 id="git-问题"><a href="#git-问题" class="headerlink" title="git 问题"></a>git 问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git回退到某个commit版本</span><br><span class="line"></span><br><span class="line">git reset --hard commitId</span><br><span class="line">强制提交</span><br><span class="line">git push -f origin master</span><br><span class="line">删除分支</span><br><span class="line">git branch -d branchname  </span><br><span class="line"></span><br><span class="line">git 删除远程分支</span><br><span class="line">git push origin branchname</span><br><span class="line"></span><br><span class="line">rebase 和 merge区别</span><br><span class="line"></span><br><span class="line">rebase，合并的结果好看，一条线，但合并过程中出现冲突的话，比较麻烦（rebase过程中，一个commit出现冲突，下一个commit也极有可能出现冲突，一次rebase可能要解决多次冲突）；merge，合并结果不好看，一堆线交错，但合并有冲突的话，只要解一次就行了；</span><br><span class="line"></span><br><span class="line">commit 粒度把握得好，就直接 merge，把握不好，先 rebase 把粒度调整好了，再 merge。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="let-var-const-区别"><a href="#let-var-const-区别" class="headerlink" title="let var const 区别"></a>let var const 区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let 的「创建」过程被提升了，但是初始化没有提升。</span><br><span class="line"></span><br><span class="line">let在未定义之前使用，会报错</span><br><span class="line"></span><br><span class="line">var 的「创建」和「初始化」都被提升了。</span><br><span class="line"></span><br><span class="line">function 的「创建」「初始化」和「赋值」都被提升了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let 声明的变量的作用域是块级的；</span><br><span class="line">let 不能重复声明已存在的变量；</span><br><span class="line">let 有暂时死区，不会被提升。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域</span><br><span class="line">for( let i &#x3D; 0; i&lt; 5; i++) &#123; 循环体 &#125; 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog">js链接</a></p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">链接</a></p>
<p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。</p>
<p>在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>最大用处有两个，<br>一是可以读取函数内部的变量，<br>（创建局部变量，保护局部变量不会被访问和修改）。<br>另一个就是让这些变量的值始终保持在内存中。</p>
<p>闭包常见用途：</p>
<p>创建特权方法用于访问控制<br>事件处理程序及回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">let add&#x3D;(function()&#123;</span><br><span class="line">let now&#x3D;0;</span><br><span class="line">return &#123;</span><br><span class="line"> doAdd:function()&#123;</span><br><span class="line">    now++;</span><br><span class="line">    console.log(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">add.doAdd() &#x2F;&#x2F;1</span><br><span class="line">add.doAdd() &#x2F;&#x2F;2</span><br><span class="line">add.doAdd() &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">now 这个变量，并没有随着函数的执行完毕而被回收，</span><br><span class="line">而是继续保存在内存里面。</span><br><span class="line"></span><br><span class="line">由于 add 里面有函数是依赖于 now 这个变量。所以 now 不会被销毁，回收。</span><br><span class="line">由于 now 在外面访问不到</span><br><span class="line"></span><br><span class="line"> var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于方法里有this.name, 这里的this的是window，所以这里是The Window</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object &#x3D; &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that &#x3D; this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line">　　</span><br><span class="line">&#x2F;&#x2F; 这里的that指向object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(typeof Array.isArray&#x3D;&#x3D;&#x3D;&quot;undefined&quot;)&#123;</span><br><span class="line">  Array.isArray &#x3D; function(arg)&#123;</span><br><span class="line">        return Object.prototype.toString.call(arg)&#x3D;&#x3D;&#x3D;&quot;[object Array]&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="找出数组中的最大值"><a href="#找出数组中的最大值" class="headerlink" title="找出数组中的最大值"></a>找出数组中的最大值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;Math.max.apply(null,a);</span><br><span class="line">console.log(max);</span><br><span class="line">&#x2F;&#x2F;第二种方法</span><br><span class="line">var a&#x3D;[1,2,3,6,5,4];</span><br><span class="line">var max&#x3D;eval(&#39;Math.max(&#39;+a.toString()+&#39;)&#39;);</span><br><span class="line">console.log(max);</span><br><span class="line"></span><br><span class="line">Math.max(...[-1, 5, 11, 3])</span><br><span class="line"> Math.max.apply(Math, [-1, 5, 11, 3])</span><br></pre></td></tr></table></figure>

<h1 id="Javascript的this用法"><a href="#Javascript的this用法" class="headerlink" title="Javascript的this用法"></a>Javascript的this用法</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">链接</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yangbingbinga/article/details/61424363">链接2</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this是Javascript语言的一个关键字。</span><br><span class="line"></span><br><span class="line">它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</span><br><span class="line"></span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window</p>
<p>问题: 如果想要在setTimeout/setInterval中使用这个对象的this引用呢?</p>
<p>用一个 变量提前把正确的 this引用保存 起来, 我们通常使用that = this, 或者 _this = this来保存我们需要的this指针!</p>
<p>也可以使用 func.bind(this) 给回调函数直接绑定宿主对象, bind绑定宿主对象后依然返回这个函数, 这是更优雅的做法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  test: function() &#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(this.a);</span><br><span class="line">    &#125;.bind(this), 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.test();  &#x2F;&#x2F;  2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setTimeout不止两个参数</span><br><span class="line">setTimeout(function(a, b)&#123;</span><br><span class="line">  console.log(a);   &#x2F;&#x2F; 3</span><br><span class="line">  console.log(b);   &#x2F;&#x2F; 4</span><br><span class="line">&#125;,0, 3, 4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">箭头函数比较特殊，没有自己的this，它使用封闭执行上下文(函数或是global)的 this 值。</span><br><span class="line"></span><br><span class="line">var x&#x3D;11;</span><br><span class="line">var obj&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say:()&#x3D;&gt;&#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();&#x2F;&#x2F; 11</span><br><span class="line">obj.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 11</span><br><span class="line">x &#x3D; 14</span><br><span class="line">obj.say() &#x2F;&#x2F; 14</span><br><span class="line">&#x2F;&#x2F;对比一下</span><br><span class="line">var obj2&#x3D;&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say() &#123;</span><br><span class="line">   console.log(this.x); &#x2F;&#x2F;this指向window</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj2.say();&#x2F;&#x2F; 22</span><br><span class="line">obj2.say.call(&#123;x:13&#125;) &#x2F;&#x2F; 13</span><br></pre></td></tr></table></figure>

<h3 id="一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global"><a href="#一、纯粹的函数调用-属于全局性调用，因此this就代表全局对象Global" class="headerlink" title="一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global"></a>一、纯粹的函数调用   属于全局性调用，因此this就代表全局对象Global</h3><p>在严格模式下，默认绑定会将 this 指向 undefined</p>
<h3 id="二、作为对象方法的调用-this就指这个上级对象"><a href="#二、作为对象方法的调用-this就指这个上级对象" class="headerlink" title="二、作为对象方法的调用    this就指这个上级对象"></a>二、作为对象方法的调用    this就指这个上级对象</h3><h3 id="三-作为构造函数调用"><a href="#三-作为构造函数调用" class="headerlink" title="三 作为构造函数调用"></a>三 作为构造函数调用</h3><p>   所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
<h3 id="四-apply调用"><a href="#四-apply调用" class="headerlink" title="四 apply调用"></a>四 apply调用</h3><p>  this指的就是这第一个参数。<br>  apply()的参数为空时，默认调用全局对象。</p>
<h3 id="五-this指向绑定事件的dom元素"><a href="#五-this指向绑定事件的dom元素" class="headerlink" title="五 this指向绑定事件的dom元素"></a>五 this指向绑定事件的dom元素</h3><p>document.querySelector(“#id”).onclick =function(){<br>    this == document.querySelector(“#id”)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">if(!(&quot;a&quot; in window))&#123;</span><br><span class="line">    var a &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; window.hasOwnProperty(&quot;a&quot;) &#x3D;&#x3D;&#x3D; true ..</span><br><span class="line">&#x2F;&#x2F;不用多说了. a 还真存在原型链上</span><br><span class="line">&#x2F;&#x2F; 值是 Location 这个 API 的数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">console.log(typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; true , 这个不用解释了</span><br><span class="line"></span><br><span class="line">console.log(!!typeof count &#x3D;&#x3D;&#x3D; &quot;number&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及到就是优先级和布尔值的问题</span><br><span class="line">&#x2F;&#x2F; typeof count 就是字符串&quot;number&quot;</span><br><span class="line">&#x2F;&#x2F; !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true</span><br><span class="line">&#x2F;&#x2F; 最后才&#x3D;&#x3D;&#x3D; 比较 , true &#x3D;&#x3D;&#x3D; &quot;number&quot; , return false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var a &#x3D; b &#x3D; 3;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(typeof a &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;undefined&quot;); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(&#x3D;号自左向右)</span><br><span class="line">&#x2F;&#x2F; 那个函数可以拆成这样</span><br><span class="line"></span><br><span class="line">(function()</span><br><span class="line">  var a; &#x2F;* 局部变量,外部没法访问*&#x2F;</span><br><span class="line">  b &#x3D; 3; &#x2F;* 全局变量,so . window.b &#x3D;&#x3D;&#x3D; 3 , 外部可以访问到*&#x2F;</span><br><span class="line">  a &#x3D; b;</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 注意a只有在闭包里才能访问(a&#x3D;3)，在外部是undefined  !!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若是改成这样,这道题应该是对的</span><br><span class="line">console.log(typeof b &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D;3</span><br><span class="line">); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">  this.a &#x3D; something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(2)</span><br><span class="line"></span><br><span class="line">console.log(obj1.a) &#x2F;&#x2F; 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2,3); &#x2F;&#x2F; 用 call 强行改变上下文为 obj2内</span><br><span class="line">console.log(obj2.a); &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">var  bar &#x3D; new obj1.foo(4); &#x2F;&#x2F; 这里产生了一个实例</span><br><span class="line">console.log(obj1.a); &#x2F;&#x2F; 2</span><br><span class="line">console.log(bar.a); &#x2F;&#x2F; 4;  new的绑定比隐式和显式绑定优先级更高</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-设计模式你了解多少"><a href="#Q-设计模式你了解多少" class="headerlink" title="Q: 设计模式你了解多少"></a>Q: 设计模式你了解多少</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cnblogs.com&#x2F;tugenhua0707&#x2F;p&#x2F;5198407.html</span><br></pre></td></tr></table></figure>

<h1 id="Q-JS-的基本数据类型有哪些"><a href="#Q-JS-的基本数据类型有哪些" class="headerlink" title="Q: JS 的基本数据类型有哪些"></a>Q: JS 的基本数据类型有哪些</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object</span><br><span class="line">Undefined</span><br><span class="line">Null</span><br><span class="line">Number</span><br><span class="line">Boolean</span><br><span class="line">String</span><br><span class="line">Symbol (ECMAScript 6 新定义)</span><br><span class="line"></span><br><span class="line"> 5 种原始类型即</span><br><span class="line"> Undefined</span><br><span class="line"> Null</span><br><span class="line"> Number</span><br><span class="line"> Boolean</span><br><span class="line"> String</span><br><span class="line"></span><br><span class="line"> 除了Object和Symbol不是，其他都是</span><br></pre></td></tr></table></figure>

<h1 id="Q-null-和-undefined-的差异"><a href="#Q-null-和-undefined-的差异" class="headerlink" title="Q: null 和 undefined 的差异"></a>Q: null 和 undefined 的差异</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">大体说一下,想要知其所以然请引擎搜索</span><br><span class="line"></span><br><span class="line">相同点:</span><br><span class="line"></span><br><span class="line">在 if 判断语句中,值都默认为 false</span><br><span class="line">大体上两者都是代表 无 ,具体看差异</span><br><span class="line">差异:</span><br><span class="line"></span><br><span class="line">null 转为数字类型值为0,而 undefined 转为数字类型为 NaN(Not a Number)</span><br><span class="line">undefined 是代表调用一个值而该值却没有赋值,这时候默认则为 undefined</span><br><span class="line">null 是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)</span><br><span class="line">设置为 null 的变量或者对象会被内存收集器回收</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-清除浮动的方式有哪些-比较好的是哪一种"><a href="#Q-清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="Q: 清除浮动的方式有哪些?比较好的是哪一种"></a>Q: 清除浮动的方式有哪些?比较好的是哪一种</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">常用的一般为三种 .clearfix , clear:both , overflow:hidden ;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  content:&quot;&quot;;&#x2F;&#x2F;设置内容为空</span><br><span class="line">　height:0;&#x2F;&#x2F;高度为0</span><br><span class="line">　line-height:0;&#x2F;&#x2F;行高为0</span><br><span class="line">　display:block;&#x2F;&#x2F;将文本转为块级元素</span><br><span class="line">　visibility:hidden;&#x2F;&#x2F;将元素隐藏</span><br><span class="line">　clear:both&#x2F;&#x2F;清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另一种写法</span><br><span class="line"></span><br><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line"> content:&quot;&quot;;</span><br><span class="line"> display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line"> clear:both;</span><br><span class="line"> overflow:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;&#x2F;&#x2F; 为了兼容IE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">用display:table 是为了避免外边距margin重叠导致的margin塌陷,</span><br><span class="line">内部元素默认会成为 table-cell 单元格的形式</span><br><span class="line">--&gt;</span><br><span class="line">clear:both :若是用在同一个容器内相邻元素上,那是贼好的...有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</span><br><span class="line"></span><br><span class="line">overflow:hidden :这种若是用在同个容器内,可以形成 BFC 避免浮动造成的元素塌陷</span><br></pre></td></tr></table></figure>

<h1 id="Q-跨域问题"><a href="#Q-跨域问题" class="headerlink" title="Q: 跨域问题"></a>Q: 跨域问题</h1><p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/21976">详情</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">我一般用这三种, cors , nginx反向代理 , jsonp</span><br><span class="line"></span><br><span class="line">jsonp : 单纯的 get 一些数据,局限性很大...就是利用script标签的src属性来实现跨域。</span><br><span class="line"></span><br><span class="line">浏览器支持好</span><br><span class="line">调用失败不会返回各种HTTP状态码</span><br><span class="line">给后端传json格式的数据会报415错误，请求格式不正确</span><br><span class="line">callback添加恶意script标签，造成xss漏洞</span><br><span class="line">只能够实现get请求</span><br><span class="line">参数可见</span><br><span class="line"></span><br><span class="line">nginx 反向代理 : 主要就是用了 nginx.conf 内的 proxy_pass http:&#x2F;&#x2F;xxx.xxx.xxx</span><br><span class="line">,会把所有请求代理到那个域名,有利也有弊吧..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cors</span><br><span class="line"></span><br><span class="line">可控性较强,需要前后端都设置,兼容性 IE10+ ,</span><br><span class="line">CORS需要浏览器和服务器同时支持。IE8+：IE8&#x2F;9需要使用XDomainRequest对象来支持CORS。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;foo.example &#x2F;&#x2F; 子域乃至整个域名或所有域名是否允许访问</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS &#x2F;&#x2F; 允许那些行为方法</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type &#x2F;&#x2F; 允许的头部字段</span><br><span class="line">Access-Control-Max-Age: 86400 &#x2F;&#x2F; 有效期</span><br><span class="line">cros 的配置不仅仅这些,还有其他一些,具体引擎吧....</span><br><span class="line"></span><br><span class="line">若是我们要用 nginx 或者 express 配置 cors 应该怎么搞起? 来个简易版本的</span><br><span class="line"></span><br><span class="line">nginx</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   # 检查域名后缀</span><br><span class="line">    add_header Access-Control-Allow-Origin xx.xx.com;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;</span><br><span class="line">    add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;</span><br><span class="line">    add_header Access-Control-Max-Age 86400;</span><br><span class="line">&#125;</span><br><span class="line">express, 当然这货也有一些别人封装好的 cors 中间件,操作性更强...</span><br><span class="line">let express &#x3D; require(&#39;express&#39;);  </span><br><span class="line">let app &#x3D; express();  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置所有请求的头部</span><br><span class="line">app.all(&#39;*&#39;, (req, res, next) &#x3D;&gt;  &#123;  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;);  </span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  </span><br><span class="line">    next();  </span><br><span class="line">&#125;);</span><br><span class="line">有些还会跟你死磕,,除了这些还有其他姿势么...我说了一个HTML5的 postMessage ....</span><br><span class="line"></span><br><span class="line">..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下</span><br><span class="line"></span><br><span class="line">这货用于 iframe 传递消息居多, 大体有这么两步步</span><br><span class="line"></span><br><span class="line">window 打开一个实例,传递一个消息到一个x域名</span><br><span class="line">x 域名下监听 message 事件,获取传递的消息</span><br><span class="line">这货的兼容性没那么好,而且没考虑周全的下容易遭受 CSRF 攻击</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-对于XSS-和-CSRF-如何防范"><a href="#Q-对于XSS-和-CSRF-如何防范" class="headerlink" title="Q: 对于XSS 和 CSRF 如何防范"></a>Q: 对于XSS 和 CSRF 如何防范</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> XSS主要是指跨脚本攻击, 其实就相当于执行js脚本.</span><br><span class="line"></span><br><span class="line">XSS的防范</span><br><span class="line"></span><br><span class="line">1. 验证用户输入的内容, 是否符合规则.</span><br><span class="line">2. 转义 &lt;&gt; 造成代码直接运行的的标签..</span><br><span class="line">    轮询或者正则替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而面试官说这种的效率最低下,找相关资料</span><br><span class="line">若是有用到 cookie ,设置为 http-only ,避免客户端的篡改</span><br><span class="line"></span><br><span class="line">CSP(Content Security Policy)</span><br><span class="line">以白名单的机制对网站加载或执行的资源起作用。</span><br><span class="line">在网页中，这样的策略通过 HTTP 头信息或者 meta</span><br><span class="line">元素定义。CSP虽然提供了强大的安全保护，</span><br><span class="line">但是他也造成了如下问题：Eval及相关函数被禁用、</span><br><span class="line">内嵌的JavaScript代码将不会执行、</span><br><span class="line">只能通过白名单来加载远程脚本。</span><br><span class="line"></span><br><span class="line">CSRF跨域假冒请求</span><br><span class="line"></span><br><span class="line">有3个特性: 跨域, cookie, 请求方式.</span><br><span class="line">CSRF的防范一般这几种</span><br><span class="line"></span><br><span class="line">验证码,用户体验虽然不好,</span><br><span class="line">验证 HTTP Referer 字段,判断请求来源</span><br><span class="line">token加密解密 ,前端和后台双方协定一个token内容</span><br><span class="line"></span><br><span class="line">尽量使用JSON类型传输</span><br><span class="line">    form 传输的格式为:</span><br><span class="line">    Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">    而,JSON的传输类型为:</span><br><span class="line">    Content-Type: application&#x2F;json form</span><br><span class="line">    没有办法去模仿JSON类型进行传输</span><br><span class="line"></span><br><span class="line">DNS劫持, 事实上更偏向于User</span><br><span class="line">    developer实际上对这个也无能为力。</span><br><span class="line"></span><br><span class="line">HTTP(ISP) 劫持</span><br><span class="line">    使用HTTPS 加密方式传输</span><br><span class="line">    替换你的js的提供商，使用HTTPS路径进行加载。</span><br><span class="line"></span><br><span class="line">验证码造成的体验不好,</span><br><span class="line">token 滥用造成的性能问题,轮询替换造成的响应时间等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Q-谈谈你对-Promise-的理解-和-ajax-有关系么"><a href="#Q-谈谈你对-Promise-的理解-和-ajax-有关系么" class="headerlink" title="Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么"></a>Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么</h1><p><a target="_blank" rel="noopener" href="http://imweb.io/topic/57a0760393d9938132cc8da9">链接</a></p>
<p>promise 是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>异步操作队列化，比传统的异步操作回调函数和事件更合理更强大。</p>
<p>能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p>
<p>==Promise对象三种状态：==</p>
<p>Pending（进行中）<br>Fulfilled（已完成，又称为Resolved）<br>Rejectd（已失败）</p>
<p>一些需要注意的小点,如下</p>
<p>在 Pending 转为另外两种之一的状态时候,状态不可在改变..</p>
<p>Promise 的 then 为异步.而( new Promise() )构造函数内为同步</p>
<p>Promise 的 catch 不能捕获任意情况的错误(比如 then 里面的 setTimout 内手动抛出一个 Error )</p>
<p>Promise 的 resolve 若是传入值而非函数,会发生值穿透的现象</p>
<p>Promise 还有一些自带的方法,比如 race , all ,前者有任一一个解析完毕就返回,后者所有解析完毕返回…</p>
<p>==Promise 方法：==</p>
<p>then： 用链式调用的方式执行回调函数。通过 resolve 方法把 Promise 的状态置为完成态（Resolved），这时 then 方法就能捕捉到变化，并执行“成功”情况的回调。<br>then方法返回的是一个新的Promise实例</p>
<p>reject： 把 Promise 的状态置为已失败（Rejected），这时 then 方法执行“失败”情况的回调</p>
<p>catch：和 then 的第二个参数一样，用来指定 reject 的回调   当执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么也不会报错卡死 js，而是会进到这个 catch 方法中。</p>
<p>all:  提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p>
<ul>
<li><p>当该数组里的所有Promise实例都进入Fulfilled状态，Promise.all返回的实例才会变成Fulfilled状态。并将Promise实例数组的所有返回值组成一个数组，传递给Promise.all返回实例的回调函数。</p>
</li>
<li><p>当该数组里的某个Promise实例都进入Rejected状态，Promise.all返回的实例会立即变成Rejected状态。并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数。</p>
</li>
</ul>
<p>race:只要有一个异步操作执行完毕，就立刻执行 then 回调。<br>注意：其它没有执行完毕的异步操作仍然会继续执行，而不是停止。</p>
<h3 id="Promise对象两个特点"><a href="#Promise对象两个特点" class="headerlink" title="Promise对象两个特点"></a>Promise对象两个特点</h3><ol>
<li><p>对象状态只由异步操作结果决定。resolve方法会使Promise对象由pendding状态变为fulfilled状态；reject方法或者异常会使得Promise对象由pendding状态变为rejected状态。Promise状态变化只有上图这两条路径。</p>
</li>
<li><p><strong>对象状态一旦改变，任何时候都能得到这个结果。</strong> 即状态一旦进入fulfilled或者rejected，promise便不再出现状态变化，同时我们再添加回调会立即得到结果。这点跟事件不一样，事件是发生后再绑定监听，就监听不到了。</p>
</li>
<li><p>Promise构造方法接受一个方法作为参数，该方法传入两个参数，resolve和reject。</p>
</li>
<li><p>resolve用来将Promise对象的状态置为成功，并将异步操作结果value作为参数传给成功回调函数。</p>
</li>
<li><p>reject用来将Promise对象的状态置为失败，并将异步操作错误error作为参数传给失败回调函数。</p>
</li>
<li><p>then方法绑定两个回调函数，第一个用来处理Promise成功状态，第二个用来处理Promise失败状态。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Promise 和 ajax 没有直接关系. promise 只是为了解决&quot;回调地狱&quot;</span><br><span class="line">Promise 并不能消灭回调地狱，但是它可以使回调变得可控。</span><br><span class="line"></span><br><span class="line">异步回调的问题：</span><br><span class="line"></span><br><span class="line">嵌套层次深，难以维护</span><br><span class="line">无法正常使用return和catch throw</span><br><span class="line">多个回调之间难以建立联系，一个回调函数一旦开启，就无法对其操作</span><br><span class="line">无法正常索引堆栈信息</span><br><span class="line"></span><br><span class="line">从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... some code</span><br><span class="line">    if ( &#x2F;* 异步操作成功 *&#x2F; ) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">模拟回调函数</span><br><span class="line">function runAsync(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行完成&#39;);</span><br><span class="line">        callback(&#39;随便什么数据&#39;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getUserAdmin()</span><br><span class="line">    .then(getProjects)</span><br><span class="line">    .then(getModules)</span><br><span class="line">    .then(getInterfaces)</span><br><span class="line">    .then(procResult)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a>Promise 必知必会（十道题）</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a04066351882517c416715d">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># Generator 函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;cnodejs.org&#x2F;topic&#x2F;542953d42ca9451e1bf3c251)</span><br><span class="line"></span><br><span class="line">Generator 函数是一个普通函数，但是有两个特征。</span><br><span class="line"></span><br><span class="line">一是，function关键字与函数名之间有一个星号；</span><br><span class="line"></span><br><span class="line">二是，函数体内部使用yield语句，定义不同的内部状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br>}<br>var hw = helloWorldGenerator();</p>
<p>const gen = function* () {<br>  const f1 = yield readFile(‘/etc/fstab’);<br>  const f2 = yield readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>写成async函数，就是下面这样。</p>
<p>const asyncReadFile = async function () {<br>  const f1 = await readFile(‘/etc/fstab’);<br>  const f2 = await readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。<br>以后，每次调用遍历器对象的next方法，<br>就会返回一个有着value和done两个属性的对象。<br>value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；<br>done属性是一个布尔值，表示是否遍历结束。</p>
<p>上面已经介绍了说yield是暂停标志，下面对yield进行一些介绍：</p>
<p>（1）、yield后面的表达式只有当调用next时，才会执行yield后面的表达式。</p>
<p>（2）、yield表达式只能写在Generator函数中 ，而不能写在普通的函数中。</p>
<p>（3）、yield表达式如果与其他表达式相结合，必须写在()里面。</p>
<p>yield与return的异同点：</p>
<p>相同点：都可以返回紧跟后面表达式的值</p>
<p>不同点：<br>(a)、在一个函数内部只能存在一个return语句，而可以存在多个yield语句；<br>(b)、return没有记忆功能，在Generator函数中只有当遍历器对象调用next时<br>    才会返回yield后面表达式的值，<br>    当下一次调用时从上一条yield语句后开始执行，<br>    而return后面的表达式只要函数执行就立即返回。<br>(c)、正常函数只有一个返回值，而Generator函数可以有多个返回值。</p>
<p>Generator函数被执行时，返回的是指向函数内部的遍历器对象，<br>只有调用遍历器对象的next方法时，才会返回yield后面函数表达式的值，<br>但是，其实yield表达式的值一直都是undefined。<br>如果在Generator的函数中传递参数且存在多个yield表达式时，<br>那么调用next方法时就要注意传参了：<br>next()中传递的参数就是上一个yield表达式的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 面试题网站</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com)</span><br><span class="line"></span><br><span class="line"># 作用域</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数和变量的可访问范围。<br>作用域分为全局作用域  函数作用域和eval作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 原型</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dee9f8b14771)</span><br><span class="line"></span><br><span class="line">原型其实就是上述所说的继承中的父类。</span><br><span class="line"></span><br><span class="line">原型链 :利用原型串起一个继承链，让一个引用类型继承另一个引用类型的属性和方法，再以此类推下去.</span><br><span class="line">当一个引用类型继承另一个引用类型的属性和方法时候就会产生一个原型连。</span><br><span class="line">当某个函数当成构造函数来调用时，就会产生一个构造函数的实例。这个实例上会拥有一个 __proto__ 属性，这个属性指向该实例的构造函数的原型对象(也可以称为该实例的原型对象)。</span><br><span class="line"></span><br><span class="line">定律：</span><br><span class="line"></span><br><span class="line">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span><br><span class="line"></span><br><span class="line">原型链是依赖于__proto__，而不是prototype</span><br><span class="line"></span><br><span class="line">**实例与原型**</span><br><span class="line"></span><br><span class="line">当读取实例的属性时，</span><br><span class="line">如果找不到，就会查找与对象关联的原型中的属性，</span><br><span class="line">如果还查不到，就去找原型的原型，一直找到最顶层为止。</span><br><span class="line"></span><br><span class="line">通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加并不是一个明智的选择。这时就该用上原型了。</span><br><span class="line"></span><br><span class="line">在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法。</span><br><span class="line"></span><br><span class="line"> var A &#x3D; new Person();</span><br><span class="line"> Person.prototype &#x3D; A;</span><br><span class="line"></span><br><span class="line">原型对象（Person.prototype）是 构造函数（Person）的一个实例。↓</span><br><span class="line"></span><br><span class="line">#### Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### person1.__proto__ &#x3D;&#x3D; Person.prototype</span><br><span class="line"></span><br><span class="line">实例的构造函数属性（constructor）指向构造函数。↓</span><br><span class="line"></span><br><span class="line">#### person1.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null</span><br><span class="line"></span><br><span class="line">#### person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor &#x3D;&#x3D; Person</span><br><span class="line"></span><br><span class="line">#### obj.__proto__ &#x3D;&#x3D; Object.getPrototypeOf(obj)</span><br><span class="line"></span><br><span class="line"> 原型和原型链是JS实现继承的一种模型。</span><br><span class="line">原型链的形成是真正是靠__proto__ 而非prototype</span><br><span class="line"></span><br><span class="line">## 什么是原型链</span><br><span class="line"></span><br><span class="line"> 由于__proto__是任何对象都有的属性，而js里万物皆对象，</span><br><span class="line"> 所以会形成一条__proto__连起来的链条，递归访问__proto__最终到头，并且值是null</span><br><span class="line"></span><br><span class="line"> 当js引擎查找对象属性时，先查找对象本身是否存在该属性，</span><br><span class="line"> 如果不存在，会在原型链上查找，但不会查找自身的prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>var A = function()&#123;&#125;;
var a = new A();
console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）
console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）
console.log(a.__proto__.__proto__.__proto__); //null</code></pre>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>actions<br>assets<br>components<br>reducers<br>store<br>views<br>index.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># prototype问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function Foo() {<br>    getName = function () { alert (1); };<br>    return this;<br>}<br>Foo.getName = function () { alert (2);};<br>Foo.prototype.getName = function () { alert (3);};<br>var getName = function () { alert (4);};<br>function getName() { alert (5);}</p>
<p>//请写出以下输出结果：<br>Foo.getName();<br>getName();<br>Foo().getName();<br>getName();<br>new Foo.getName();<br>new Foo().getName();<br>new new Foo().getName();</p>
<p>//答案：<br>Foo.getName();//2<br>getName();//4<br>Foo().getName();//1<br>getName();//1<br>new Foo.getName();//2<br>new Foo().getName();//3<br>new new Foo().getName();//3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># var和函数的提前声明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function fn(a) {<br>  console.log(a);<br>  var a = 2;<br>  function a() {}<br>  console.log(a);<br>}</p>
<p>fn(1);<br>　　输出：function  a() {} 2<br>　　<br>　　<br>我们知道var和function是会提前声明的，<br>而且function是优先于var声明的（如果同时存在的话），<br>所以提前声明后输出的a是个function，<br>然后代码往下执行a进行重新赋值了，故第二次输出是2。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zichi/p/4359786.html">http://www.cnblogs.com/zichi/p/4359786.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># javascript实现将多个有序数组合并为一个有序数组的算法</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010302469)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let ret=arr.reduce((arr1,arr2)=&gt;arr1.concat(arr2)).sort((a,b)=&gt;a-b);<br>ret=Array.from(new Set(ret));<br>console.log(ret);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># new操作符具体干了什么呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1、创建一个新对象<br>2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）<br>3、执行构造函数中的代码（为这个新对象添加属性）<br>4、返回新对象</p>
<p>var obj  = {};<br>obj.<strong>proto</strong> = Base.prototype;<br>Base.call(obj);</p>
<p>创建一个新对象foo；</p>
<p>并将它的<strong>proto__指向其构造函数的prototype，<br>foo.__proto</strong> = Foo.prototype;</p>
<p>动态将this指向新对象，Foo.apply(foo，arguments);</p>
<p>执行函数体中的代码；</p>
<p>放回新对象foo;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 怎么画一条0.5px的边</span><br><span class="line"></span><br><span class="line">[链接：](https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5ab65f40f265da2384408a95)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过直接设置宽高border为0.5px、<br>设置box-shadow的垂直方向的偏移量为0.5px、<br>借助线性渐变linear-gradient、<br>使用transform: scaleY(0.5)的方法，<br>使用SVG的方法。<br>最后发现transfrom scale/svg的方法兼容性和效果都是最好的，<br>svg可以支持复杂的图形，<br>所以在viewport是1的情况下，<br>可以使用transform/SVG画0.5px，<br>而如果viewport的缩放比例不是1的话，那么直接画1px即可。</p>
<p>.hairline-border {<br>  box-shadow: 0 0 0 1px;<br>}<br>@media (min-resolution: 2dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.5px;<br>  }<br>}<br>@media (min-resolution: 3dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.33333333px;<br>  }<br>}<br>@media (min-resolution: 4dppx) {<br>  .hairline-border {<br>    box-shadow: 0 0 0 0.25px;<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从 arguments 到剩余参数</span><br><span class="line"></span><br><span class="line">如果你想在 ES5 中让函数(或方法)接受任意数量的参数，必须使用特殊变量 arguments：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function logAllArguments() {<br>    for (var i=0; i &lt; arguments.length; i++) {<br>        console.log(arguments[i]);<br>    }<br>}</p>
<p>ES6 中则可以通过 … 运算符定义一个剩余参数(在下面示例中是args)：</p>
<p>function logAllArguments(…args) {<br>    for (const arg of args) {<br>        console.log(arg);<br>    }<br>}</p>
<p>如果有一部分固定参数，剩余参数就更适用了：</p>
<p>function format(pattern, …args) {<br>    ···<br>}</p>
<p>在 ES5 中处理同样的事情有点麻烦：</p>
<p>function format(pattern) {<br>    var args = [].slice.call(arguments, 1);<br>    ···<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)</span><br><span class="line"></span><br><span class="line">[连接](https:&#x2F;&#x2F;github.com&#x2F;qiu-deqing&#x2F;FE-interview#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BB%A5http%E4%B8%BA%E4%BE%8B)</span><br><span class="line"></span><br><span class="line">1. 输入url</span><br><span class="line">2. 查看缓存</span><br><span class="line">3. 解析URL</span><br><span class="line">4. 组装HTTP请求报文</span><br><span class="line">5. 获取主机ip</span><br><span class="line">6. 建立tcp连接</span><br><span class="line">7. 发送http请求</span><br><span class="line">8. 服务器检查请求头信息</span><br><span class="line">9. 响应报文通过tcp返回</span><br><span class="line">10. 关闭tcp四次握手</span><br><span class="line">11. 检查状态码</span><br><span class="line">12. 缓存</span><br><span class="line">13. 解码</span><br><span class="line">14. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</span><br><span class="line">15. 显示页面</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器地址栏输入URL<br>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤<br>如果资源未缓存，发起新请求<br>如果已缓存，检验是否足够新鲜，<br>足够新鲜直接提供给客户端，否则与服务器进行验证。<br>检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：<br>HTTP1.0提供Expires，<br>值为一个绝对时间表示缓存新鲜日期<br>HTTP1.1增加了Cache-Control: max-age,<br>值为以秒为单位的最大新鲜时间<br>浏览器解析URL获取协议，主机，端口，path<br>浏览器组装一个HTTP（GET）请求报文<br>浏览器获取主机ip地址，过程如下：<br>浏览器缓存<br>本机缓存<br>hosts文件<br>路由器缓存<br>ISP DNS缓存</p>
<p>DNS递归查询（可能存在负载均衡导致每次IP不一样）<br>打开一个socket与目标IP地址，端口建立TCP链接，<br>三次握手如下：<br>客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口<br>服务器发回SYN=1， ACK=X+1， Seq=Y的响应包<br>客户端发送ACK=Y+1， Seq=Z<br>TCP链接建立后发送HTTP请求</p>
<p>服务器接受请求并解析，将请求转发到服务程序，<br>如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
<p>服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，<br>返回304等对应状态码<br>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作<br>服务器将响应报文通过TCP连接发送回浏览器<br>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，<br>关闭TCP连接的四次握手如下：<br>主动方发送Fin=1， Ack=Z， Seq= X报文<br>被动方发送ACK=X+1， Seq=Z报文<br>被动方发送Fin=1， ACK=X， Seq=Y报文<br>主动方发送ACK=Y， Seq=X报文</p>
<p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，<br>这些情况处理与2XX不同<br>如果资源可缓存，进行缓存<br>对响应进行解码（例如gzip压缩）</p>
<p>根据资源类型决定如何处理（假设资源为HTML文档）</p>
<p>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，<br>执行js脚本，这些操作没有严格的先后顺序，以下分别解释<br>构建DOM树：<br>Tokenizing：根据HTML规范将字符流解析为标记<br>Lexing：词法分析将标记转换为对象并定义属性和规则<br>DOM construction：根据HTML标记关系将对象组成DOM树<br>解析过程中遇到图片、样式表、js文件，启动下载<br>构建CSSOM树：<br>Tokenizing：字符流转换为标记流<br>Node：根据标记创建节点<br>CSSOM：节点创建CSSOM树</p>
<p>根据DOM树和CSSOM树构建渲染树:<br>从DOM树的根节点遍历所有可见节点，<br>不可见节点包括：<br>1）script,meta这样本身不可见的标签。<br>2)被css隐藏的节点，如display: none<br>对每一个可见节点，找到恰当的CSSOM规则并应用<br>发布可视节点的内容和计算样式<br>js解析如下：<br>浏览器创建Document对象并解析HTML，<br>将解析到的元素和文本节点添加到文档中，<br>此时document.readystate为loading</p>
<p>HTML解析器遇到没有async和defer的script时，<br>将他们添加到文档中，然后执行行内或外部脚本。<br>这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。<br>这样就可以用document.write()把文本插入到输入流中。<br>同步脚本经常简单定义函数和注册事件处理程序，<br>他们可以遍历和操作script和他们之前的文档内容<br>当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。<br>脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。<br>异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</p>
<p>当文档完成解析，document.readState变成interactive<br>所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，<br>禁止使用document.write()<br>浏览器在Document对象上触发DOMContentLoaded事件<br>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，<br>等这些内容完成载入并且所有异步脚本完成载入和执行，<br>document.readState变为complete,window触发load事件<br>显示页面（HTML解析过程中会逐步显示页面）</p>
<h1 id="浏览器渲染主要流程"><a href="#浏览器渲染主要流程" class="headerlink" title="浏览器渲染主要流程"></a>浏览器渲染主要流程</h1><p>HTML解析出DOM Tree<br>CSS解析出Style Rules<br>将二者关联生成Render Tree<br>Layout 根据Render Tree计算每个节点的信息<br>Painting 根据计算好的信息绘制整个页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Q: 网站性能优化</span><br><span class="line"></span><br><span class="line">[原文](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000013963213#articleHeader0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码层面优化：</p>
<p>一、加载和执行</p>
<pre><code>css方面

将样式表放到页面顶部
不使用CSS表达式
使用link不使用@import
不使用IE的Filter

Javascript方面

将脚本放到页面底部,body标签内底部
将javascript和css从外部引入
压缩javascript和css
删除不需要的脚本
减少DOM访问
合理设计事件监听器


图片方面

优化图片：根据实际颜色需要选择色深、压缩
优化css精灵
合并一些小图片( css sprite )压缩图片
图片转dataUrl
不要在HTML中拉伸图片
保证favicon.ico小并且可缓存
图片编码优化</code></pre>
<p>二、 数据存取<br>    - 尽量使用字面量和局部变量<br>        （局部变量在方法运行过后会自行释放，用完手动置为null或undefined也行），<br>        减少使用对象和数组,</p>
<p>三、 DOM编程**（常见的性能瓶颈）<br>    - 最坏的方式就是在循环中操作或者访问DOM，非常消耗性能。<br>    减少DOM数量<br>    - 遍历dom<br>        querySelectorAll()是获取元素最快的API 返回的是一个NodeList<br>        querySelector() 返回的是element,<br>        querySelectorAll()还有一点就是可以同时获取两类元素</p>
<pre><code>- 重绘和重排都是代价昂贵；尽量减少
    重排何时发生：
    1.添加或删除可见DOM元素
    2.元素位置改变
    3.元素尺寸改变（内外边距、边框厚宽高等）
    4.内容改变 （内容导致尺寸变化的时候）
    5.页面渲染器初始化
    6.浏览器窗口尺寸变化</code></pre>
<p>四、 算法和流程控制<br>    - 循环<br>        (当循环体复杂度为X时，优化方案优先减少循环体的复杂度，<br>        循环体复杂度大于X时，优化方案优先减少迭代次数 )<br>    - 条件语句<br>        当条件较少时 使用if-else更易读，<br>        而当条件较多时if-else性能负担比switch大，易读性也没switch好。<br>        优化if-else的方法是：尽可能的把可能出现的条件放在首位，</p>
<p>五、 字符串和正则表达式<br>    - 字符串<br>        join是比较快的，也是大量字符串拼接的唯一高效方式</p>
<p>六、 快速响应的用户界面<br>    - 浏览器UI线程<br>        浏览器限制JavaScript任务的运行时间，限制两分钟，<br>        可以防止恶意代码不断执行来锁定你的浏览器</p>
<pre><code>    单个JavaScript操作的花费总时间应该小于等于100ms，
    这就意味着在100ms内响应用户的操作，不然就会让用户感受到迟钝感

- 定时器让出时间片断
    使用时间戳计算获得程序运行时间，
    以便快速找到运行时间较长的代码部分进行优化</code></pre>
<p>七、 Ajax<br>    - 数据传输<br>        数据的传输同样影响性能<br>    - 数据格式<br>    - Ajax性能<br>        避免不必要的请求：<br>        使Ajax可缓存：服务端设置HTTP头信息确保响应会被浏览器缓存<br>        客户端讲获取的信息存到本地避免再次请求<br>        （localstorage sessionstorage cookice）<br>        设置HTTP头信息，expiresgaosu告诉浏览器缓存多久<br>        减少HTTP请求，合并css、js、图片资源文件等或使用MXHR<br>        通过次要文件用Ajax获取可缩短页面加载时间</p>
<pre><code>    减小cookie大小
    引入资源的域名不要包含cookie</code></pre>
<p>八、编程实践<br>    - 避免双重求值<br>        eval()、Function慎用，<br>        定时器第一个参数建议函数而不是字符串都能避免字符串双重求值<br>    - 使用对象或者数组直接量<br>    - 避免重复工作<br>        A:延迟加载（懒加载）<br>        B:条件预加载<br>    - 使用JavaScript速度快的部分<br>        A.位操作<br>        B.原生方法，首先原生方法是最快的，而且浏览器会缓存部分原生方法<br>        C.复杂计算时多使用Math对象<br>        D.querySelector和querySelectorAll是查询最快的</p>
<p> 九、 构建并部署高性能JavaScript应用<br>    1.合并多个js文件<br>    2.预处理js文件<br>    3.js压缩<br>    4.js的HTTP压缩<br>    5.缓存js文件<br>    6.处理缓存问题<br>    7.使用内容分发网络（CDN）</p>
<p>移动方面</p>
<pre><code>保证组件小于25k
Pack Components into a Multipart Document

content方面

按需加载资源
非必须组件延迟加载
未来所需组件预加载
    在网站 HTML 中的链接属性上增加
    rel=”prefetch”,rel=”dns-prefetch”，或者 rel=”prerender” 标记。

将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
减少iframe数量
不要404

Server方面

使用CDN
减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。
方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
避免重定向：多余的中间访问
用dns-prefetch

&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//mat1.gtimg.com&quot;&gt;

动静分离
使用nginx的反向代理，对静态资源的请求直接nginx处理，或放到CDN
动态请求转发给tomcat处理

添加Expires或者Cache-Control响应头
对组件使用Gzip压缩
    Brotli 是一个比较新的文件压缩算法，目前正变得越来越受欢迎。
配置ETag
Flush Buffer Early
Ajax使用GET进行请求
避免空src的img标签</code></pre>
<p>十、 工具</p>
<pre><code>若是打包的代码尽可能切割成多个 chunk ,减少单一 chunk 过大
HTTP的缓存头使用的合理
减小第三方库的依赖
对于代码应该考虑性能来编写,比如使用 requestAnimationFrame 绘制动画,尽可能减少页面重绘(DOM 改变)
渐进升级,引入 preload 这些预加载资源
看情况用 server worker 来缓存资源(比如移动端打算搞 PWA)
比如从服务端着手:

带宽,域名解析, 多域名解析等
使用负载均衡方案 多节点部署
页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)
渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)
当然,这是这些都是很片面的点到...实际工作中去开展要复杂的多;


使用索引加速数据库查询
页面静态化CMS</code></pre>
<p>多个维度考虑,优化 DOM 绘制时间,资源加载时间,域名解析这些;</p>
<p>要全面的优化一个项目是一个大工程…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 优雅降级和渐进增强</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优雅降级：<br>Web站点在所有新式浏览器中都能正常工作，<br>如果用户使用的是老式浏览器，<br>则代码会检查以确认它们是否能正常工作。<br>针对不同版本的hack为那些无法支持功能的<br>浏览器增加候选方案，<br>使之在旧式浏览器上以某种形式降级体验<br>却不至于完全失效.</p>
<p>渐进增强：<br>从被所有浏览器支持的基本功能开始，<br>逐步地添加那些只有新式浏览器才支持的功能,<br>向页面增加无害于基础浏览器的<br>额外样式和功能的。<br>当浏览器支持时，<br>它们会自动地呈现出来并发挥作用。</p>
<p>保证所有人都能访问页面的基本内容和功能<br>同时为高级浏览器和高带宽用户提供<br>更好的用户体验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># js控制css3动画</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开始事件 AnimationStart<br>结束事件 AnimationEnd<br>重复运动事件 AnimationIteration  每次开始动画迭代都触发animationiteration</p>
<p>W3c标准：animationstart animationiteration animationend<br>Webkit：webkitAnimationStart webkitAnimationIteration webkitAnimationEnd<br>Firefox：animationstart animationiteration animationend<br>Opera：animationstart animationiteration animationend<br>IE10：MSAnimationStart MSAnimationIteration MSAnimationEnd</p>
<p>var e = document.getElementById(“left1”);  </p>
<p>e.addEventListener(“animationend”, function() {<br>    alert(‘css3运动结束！’);<br>});  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Object循环key</span><br><span class="line"></span><br><span class="line">- for...in循环：只遍历对象自身的和继承的可枚举的属性。</span><br><span class="line">    通常用for in来遍历对象的键名</span><br><span class="line">    for in更适合遍历对象，不要使用for in遍历数组。</span><br><span class="line"></span><br><span class="line">for in 循环会把数组其他扩展方法也循环</span><br><span class="line"></span><br><span class="line">- for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</span><br><span class="line"></span><br><span class="line">for-of循环是遍历实现iterator接口的成员</span><br><span class="line"></span><br><span class="line">只要是一个对象部署了Symbol.interator接口，就可以用for...of遍历该对象，同时也可以调用该接口的Symbol.interator方法调用next()方法对对象进行遍历，不同的是for..of是对该对象的值的输出，而next()返回的是对象。</span><br><span class="line"></span><br><span class="line">在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</span><br><span class="line"></span><br><span class="line">- Object.keys()：返回对象自身的所有可枚举的属性的键名。</span><br><span class="line">- JSON.stringify()：只串行化对象自身的可枚举的属性。</span><br><span class="line">- Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;for...in循环出的是key，for...of循环出的是value&#x3D;&#x3D;</span><br><span class="line">- &#x3D;&#x3D;for...of不能循环普通的对象，需要通过和Object.keys()搭配使用&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">如果实在想用for...of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组</span><br><span class="line">然后遍历：</span><br><span class="line"></span><br><span class="line">## 结论</span><br><span class="line"></span><br><span class="line">1. 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。</span><br><span class="line"></span><br><span class="line">2. for...in循环出的是key，for...of循环出的是value</span><br><span class="line"></span><br><span class="line">3. 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足</span><br><span class="line"></span><br><span class="line">4. for...of不能循环普通的对象，需要通过和Object.keys()搭配使用</span><br><span class="line"></span><br><span class="line">记忆jueqiao :</span><br><span class="line"></span><br><span class="line">已核对 偶数v</span><br><span class="line"></span><br><span class="line">in h（k）对象  o 数组 value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果实在想用for…of来遍历普通对象的属性的话，可以通过和Object.keys()搭配使用，先获取对象的所有key的数组<br>然后遍历：</p>
<p>var student={<br>    name:’wujunchuan’,<br>    age:22,<br>    locate:{<br>    country:’china’,<br>    city:’xiamen’,<br>    school:’XMUT’<br>    }<br>}<br>for(var key of Object.keys(student)){<br>    //使用Object.keys()方法获取对象key的数组<br>    console.log(key+”: “+student[key]);<br>}</p>
<p>for in 可以遍历到myObject的原型方法method,<br>如果不想遍历原型方法和属性的话，<br>可以在循环内部判断一下,<br>hasOwnPropery方法可以判断<br>某属性是否是该对象的实例属性</p>
<p>for (var key in myObject) {<br>　　if（myObject.hasOwnProperty(key)){<br>　　　　console.log(key);<br>　　}<br>}</p>
<pre><code></code></pre>
</div><div class="article-licensing box"><div class="licensing-title"><p>前端经验积累</p><p><a href="http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/">http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>believeZJP</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-07-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2018-11-29</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/jQuery/">jQuery</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%8F%92%E4%BB%B6/">插件</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%B0%81%E8%A3%85/">封装</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">网站搭建</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/React%20%E5%92%8CVue/"><span class="level-item">React和Vue</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://believezjp.oriht.com/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/';
            this.page.identifier = 'posts/前端经验积累/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'hardy' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hardy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hardy</p><p class="is-size-6 is-block">不积跬步无以至千里</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">96</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">88</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/believeZJP" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/believeZJP"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="微博" href="https://weibo.com/u/6021664425"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="tencent://message/?uin=421790588&amp;Site=www&amp;Menu=yes"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/es6/"><span class="level-start"><span class="level-item">es6</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/http/"><span class="level-start"><span class="level-item">http</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/http/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-29T11:36:01.000Z">2020-12-29</time></p><p class="title"><a href="/posts/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%88%97%E8%A1%A8/">思维导图列表</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-27T07:25:36.000Z">2020-11-27</time></p><p class="title"><a href="/posts/%E7%BE%BD%E6%AF%9B%E7%90%83%E9%80%9F%E6%88%90/">羽毛球速成</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-11T08:55:34.116Z">2020-09-11</time></p><p class="title"><a href="/posts/Alfred/">Alfred</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-08-20T08:18:50.000Z">2020-08-20</time></p><p class="title"><a href="/posts/React%E4%B8%ADAPI%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/">React中API使用的正确姿势</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-07-23T16:06:49.000Z">2020-07-24</time></p><p class="title"><a href="/posts/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8standard%E8%A7%84%E8%8C%83%E5%B9%B6%E7%94%A8eslint%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/">项目使用standard规范并用eslint自动格式化代码</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Alfred/"><span class="tag">Alfred</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS3/"><span class="tag">CSS3</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EventLoop/"><span class="tag">EventLoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitKraken/"><span class="tag">GitKraken</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Koa/"><span class="tag">Koa</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Nginx/"><span class="tag">Nginx</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NodeJS/"><span class="tag">NodeJS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Promise/"><span class="tag">Promise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-Native/"><span class="tag">React Native</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React%E8%BF%81%E7%A7%BB%E5%88%B0%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">React迁移到百度小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSR/"><span class="tag">SSR</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SmartGit/"><span class="tag">SmartGit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/antDesign/"><span class="tag">antDesign</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/async/"><span class="tag">async</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/await/"><span class="tag">await</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/compose/"><span class="tag">compose</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es8/"><span class="tag">es8</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/for-of/"><span class="tag">for of</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/generator/"><span class="tag">generator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http/"><span class="tag">http</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iTerm2/"><span class="tag">iTerm2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iterator/"><span class="tag">iterator</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jQuery/"><span class="tag">jQuery</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nextTick/"><span class="tag">nextTick</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setImmediate/"><span class="tag">setImmediate</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/setTimeout/"><span class="tag">setTimeout</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webpack4/"><span class="tag">webpack4</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%9A%E5%8A%A1/"><span class="tag">业务</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"><span class="tag">代码优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"><span class="tag">代码示例</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%A5%E6%83%B3/"><span class="tag">冥想</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%8E%E7%AB%AF/"><span class="tag">后端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%93%B2%E5%AD%A6/"><span class="tag">哲学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tag">基础知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/"><span class="tag">处理问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"><span class="tag">学习方法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="tag">学习笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"><span class="tag">定时器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%81%E8%A3%85/"><span class="tag">封装</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"><span class="tag">思维导图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF/"><span class="tag">技术</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8F%92%E4%BB%B6/"><span class="tag">插件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87/"><span class="tag">效率</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"><span class="tag">日常积累</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99/"><span class="tag">正则</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/"><span class="tag">沟通技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">理论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">百度小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9B%91%E6%8E%A7/"><span class="tag">监控</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"><span class="tag">知识点</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E8%AF%BB/"><span class="tag">精读</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85/"><span class="tag">线上事故</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0/"><span class="tag">组合函数</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%88%E7%AB%AF/"><span class="tag">终端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"><span class="tag">经验积累</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%91%E6%AD%A5/"><span class="tag">跑步</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%90%E5%8A%A8/"><span class="tag">运动</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><span class="tag">进程管理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="believeZJP" height="28"></a><p class="is-size-7"><span>&copy; 2020 believeZJP</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>