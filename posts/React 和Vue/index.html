<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"believezjp.oriht.com","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="在jsx文件中为什么一定要引用react1234567891011121314151617181920212223242526JSX 语法就是用React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。React.createElem">
<meta property="og:type" content="article">
<meta property="og:title" content="React和Vue">
<meta property="og:url" content="http://believezjp.oriht.com/posts/React%20%E5%92%8CVue/index.html">
<meta property="og:site_name" content="believeZJP">
<meta property="og:description" content="在jsx文件中为什么一定要引用react1234567891011121314151617181920212223242526JSX 语法就是用React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。React.createElem">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-04-26T13:42:02.000Z">
<meta property="article:modified_time" content="2018-11-29T13:42:02.000Z">
<meta property="article:author" content="believeZJP">
<meta property="article:tag" content="jQuery">
<meta property="article:tag" content="插件">
<meta property="article:tag" content="封装">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://believezjp.oriht.com/posts/React%20%E5%92%8CVue/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>React和Vue | believeZJP</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">believeZJP</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长路径</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8jsx%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%BC%95%E7%94%A8react"><span class="nav-number">1.</span> <span class="nav-text">在jsx文件中为什么一定要引用react</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React-%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">React 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#React-createClass"><span class="nav-number">2.1.</span> <span class="nav-text">React.createClass()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-class"><span class="nav-number">2.2.</span> <span class="nav-text">ES6 class</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">无状态函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E4%B8%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">元素与组件的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#componentWillReceiveProps%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.</span> <span class="nav-text">componentWillReceiveProps应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vuex%E5%92%8Credux%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">6.</span> <span class="nav-text">vuex和redux使用有什么不同</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#nextTick%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E7%94%A8api%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">7.</span> <span class="nav-text">nextTick的作用，原理，用api的场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue%E7%9A%84props%EF%BC%8Cstate-compute%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">vue的props，state, compute区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#react-native-%E5%92%8C%E5%8E%9F%E7%94%9F%E7%9A%84%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1"><span class="nav-number">9.</span> <span class="nav-text">react native 和原生的怎么通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pure-component"><span class="nav-number">10.</span> <span class="nav-text">pure component</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React-Native-%E4%B8%8E-%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92"><span class="nav-number">11.</span> <span class="nav-text">React Native 与 原生交互</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue-js-%E5%92%8Cvue-runtime-js%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">vue.js 和vue.runtime.js区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%9F%EF%BC%9F-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">13.</span> <span class="nav-text">高阶组件？？ 解决了什么问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#setState%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%8C%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%E8%A7%A3%E5%AF%86"><span class="nav-number">14.</span> <span class="nav-text">setState源码剖析，多次调用解密</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#react-diff"><span class="nav-number">15.</span> <span class="nav-text">react diff</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%BB%84%E4%BB%B6"><span class="nav-number">16.</span> <span class="nav-text">设计组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redux-%E4%B8%AD%E7%9A%84action"><span class="nav-number">17.</span> <span class="nav-text">redux 中的action</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5action%E5%AF%B9%E8%B1%A1"><span class="nav-number">18.</span> <span class="nav-text">异步action对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%9A%84%E8%AE%B2%E8%A7%A3"><span class="nav-number">18.1.</span> <span class="nav-text">非常好的讲解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue-router%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F"><span class="nav-number">19.</span> <span class="nav-text">vue-router传参方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">20.</span> <span class="nav-text">受控组件 非受控组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC"><span class="nav-number">21.</span> <span class="nav-text">没有任何嵌套关系的组件之间传值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this-setState-%E5%8F%82%E6%95%B0"><span class="nav-number">22.</span> <span class="nav-text">this.setState()参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">23.</span> <span class="nav-text">React的生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redux%E5%8E%9F%E7%90%86"><span class="nav-number">24.</span> <span class="nav-text">Redux原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%88%E8%B0%88MVVM%E6%A8%A1%E5%BC%8F"><span class="nav-number">25.</span> <span class="nav-text">谈谈MVVM模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-mvvm%E5%92%8Cmvc%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">2:mvvm和mvc区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A9CSS%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B5%B7%E4%BD%9C%E7%94%A8"><span class="nav-number">27.</span> <span class="nav-text">让CSS只在当前组件中起作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">28.</span> <span class="nav-text">Vue中使用插件的步骤</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E5%85%AC%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">29.</span> <span class="nav-text">组件的使用和自己创建公用组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E9%85%8D%E5%90%88webpack%E8%AE%BE%E7%BD%AE"><span class="nav-number">30.</span> <span class="nav-text">vue如何实现按需加载配合webpack设置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">31.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vue-route%E6%A8%A1%E5%BC%8F"><span class="nav-number">32.</span> <span class="nav-text">vue-route模式</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">believeZJP</p>
  <div class="site-description" itemprop="description">积土成山，风雨兴焉；积水成渊，蛟龙生焉;</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/believeZJP" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;believeZJP" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://believezjp.oriht.com/posts/React%20%E5%92%8CVue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="believeZJP">
      <meta itemprop="description" content="积土成山，风雨兴焉；积水成渊，蛟龙生焉;">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="believeZJP">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React和Vue
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-26 21:42:02" itemprop="dateCreated datePublished" datetime="2018-04-26T21:42:02+08:00">2018-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-11-29 21:42:02" itemprop="dateModified" datetime="2018-11-29T21:42:02+08:00">2018-11-29</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>30k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="在jsx文件中为什么一定要引用react"><a href="#在jsx文件中为什么一定要引用react" class="headerlink" title="在jsx文件中为什么一定要引用react"></a>在jsx文件中为什么一定要引用react</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JSX 语法就是用React.createElement()来构建 React 元素的。</span><br><span class="line">它接受三个参数，第一个参数可以是一个标签名。</span><br><span class="line">如div、span，或者 React 组件。</span><br><span class="line">第二个参数为传入的属性。</span><br><span class="line">第三个以及之后的参数，皆作为组件的子组件。</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">React.cloneElement()</span><br><span class="line"></span><br><span class="line">React.cloneElement()与React.createElement()相似，</span><br><span class="line">不同的是它传入的第一个参数是一个 React</span><br><span class="line">元素，而不是标签名或组件。</span><br><span class="line">新添加的属性会并入原有的属性，</span><br><span class="line">传入到返回的新元素中，而就的子元素奖杯替换。</span><br><span class="line"></span><br><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h1><p>React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。</p>
<h2 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass()"></a>React.createClass()</h2><p>React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Greeting &#x3D; React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h2><p>ES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Greeting extemds React.Component&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="无状态函数"><a href="#无状态函数" class="headerlink" title="无状态函数"></a>无状态函数</h1><p>无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。</p>
<h1 id="元素与组件的区别"><a href="#元素与组件的区别" class="headerlink" title="元素与组件的区别"></a>元素与组件的区别</h1><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Greeting (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="componentWillReceiveProps应用场景"><a href="#componentWillReceiveProps应用场景" class="headerlink" title="componentWillReceiveProps应用场景"></a>componentWillReceiveProps应用场景</h1><p>如果子组件需要的数据是直接由父组件通过props传递过来就不需要在componentwillreceiveprops中setState，但是如果子组件有自己的状态，同时这个状态依赖于父组件的数据，那么就需要子组件单独进行setState操作，否则无法完成子组件的更新。同时有一点，在componentwillreceiveprops中写setState不会再次触发子组件的render。解释一下：父组件setState时会触发子组件的render，此时如果在子组件的componentwillreceiveprops里setState，给人的感觉是会再一次触发子组件的render（加上前面的一次就是两次），实际情况是不会的</p>
<h1 id="vuex和redux使用有什么不同"><a href="#vuex和redux使用有什么不同" class="headerlink" title="vuex和redux使用有什么不同"></a>vuex和redux使用有什么不同</h1><p>Vuex 其实是一个针对 Vue 特化的 Flux，主要是为了配合 Vue 本身的响应式机制。当然吸取了一些 Redux 的特点，比如单状态树和便于测试和热重载的 API，但是也选择性的放弃了一些在 Vue 的场景下并不契合的特性，比如强制的 immutability（在保证了每一次状态变化都能追踪的情况下强制的 immutability 带来的收益就很有限了）、为了同构而设计得较为繁琐的 API、必须依赖第三方库才能相对高效率地获得状态树的局部状态等等（相比之下 Vuex 直接用 Vue 本身的计算属性就可以）所以 Vue + Vuex 会更简洁，也不需要考虑性能问题，代价就是 Vuex 只能和 Vue 配合。Vue + Redux 也不是不可以，但是 Redux 作为一个泛用的实现和 Vue 的契合度肯定不如 Vuex。</p>
<h1 id="nextTick的作用，原理，用api的场景"><a href="#nextTick的作用，原理，用api的场景" class="headerlink" title="nextTick的作用，原理，用api的场景"></a>nextTick的作用，原理，用api的场景</h1><p>$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</p>
<p>也许有人会问，我在 Vue 实例方法中修改了数据，然后再在 $nextTick 回调中获取该数据在相应 DOM 元素所绑定的内容（或属性）殊无必要，我为什么需要这样的 API 呢？</p>
<p>考虑这样一种场景，你有一个 jQuery 插件，希望在 DOM 元素中某些属性发生变化之后重新应用该插件，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。</p>
<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</p>
<p>原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。</p>
<p>当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    example: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; modify data</span><br><span class="line">      this.message &#x3D; &#39;changed&#39;</span><br><span class="line">      &#x2F;&#x2F; DOM is not updated yet</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; DOM is now updated</span><br><span class="line">        &#x2F;&#x2F; &#96;this&#96; is bound to the current instance</span><br><span class="line">        this.doSomethingElse()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中</p>
<h1 id="vue的props，state-compute区别"><a href="#vue的props，state-compute区别" class="headerlink" title="vue的props，state, compute区别"></a>vue的props，state, compute区别</h1><p>data: Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。</p>
<p>props: 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
<p>两个的区别就是data是响应式的？</p>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p>注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>
<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。</p>
<h1 id="react-native-和原生的怎么通信"><a href="#react-native-和原生的怎么通信" class="headerlink" title="react native 和原生的怎么通信"></a>react native 和原生的怎么通信</h1><h1 id="pure-component"><a href="#pure-component" class="headerlink" title="pure component"></a>pure component</h1><p>React15.3中新加了一个 PureComponent 类， 也就是纯组件，取代其前身 PureRenderMixin , PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，</p>
<p>可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。</p>
<h1 id="React-Native-与-原生交互"><a href="#React-Native-与-原生交互" class="headerlink" title="React Native 与 原生交互"></a>React Native 与 原生交互</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41dd77a83c13">链接</a></p>
<h1 id="vue-js-和vue-runtime-js区别"><a href="#vue-js-和vue-runtime-js区别" class="headerlink" title="vue.js 和vue.runtime.js区别"></a>vue.js 和vue.runtime.js区别</h1><p>vue.js</p>
<p>完整版：同时包含编译器和运行时的版本。</p>
<p>runtime.js</p>
<p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p>
<p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</p>
<h1 id="高阶组件？？-解决了什么问题"><a href="#高阶组件？？-解决了什么问题" class="headerlink" title="高阶组件？？ 解决了什么问题"></a>高阶组件？？ 解决了什么问题</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010371752">链接</a></p>
<p>适配器模式，</p>
<p>高阶函数的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。</p>
<p>对于高阶组件，它描述的便是接受React组件作为输入，输出一个新的React组件的组件。</p>
<p>高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的React组件，供其他组件调用。</p>
<p>高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用。</p>
<h1 id="setState源码剖析，多次调用解密"><a href="#setState源码剖析，多次调用解密" class="headerlink" title="setState源码剖析，多次调用解密"></a>setState源码剖析，多次调用解密</h1><p>setState流程还是很复杂的，设计也很精巧，<br>避免了重复无谓的刷新组件。它的主要流程如下</p>
<ol>
<li><p>enqueueSetState将state放入队列中，并调用enqueueUpdate处理要更新的Component</p>
</li>
<li><p>如果组件当前正处于update事务中，则先将Component存入dirtyComponent中。否则调用batchedUpdates处理。</p>
</li>
<li><p>batchedUpdates发起一次transaction.perform()事务<br>开始执行事务初始化，运行，结束三个阶段</p>
<p> 1 初始化：事务初始化阶段没有注册方法，故无方法要执行</p>
<p> 2 运行：执行setSate时传入的callback方法，一般不会传callback参数</p>
<p> 3 结束：更新isBatchingUpdates为false，并执行FLUSH_BATCHED_UPDATES这个wrapper中的close方法<br>FLUSH_BATCHED_UPDATES在close阶段，会循环遍历所有的dirtyComponents，调用updateComponent刷新组件，并执行它的pendingCallbacks, 也就是setState中设置的callback。</p>
</li>
</ol>
<p>会调用到batchedUpdates进行批处理更新，<br>React以事务的方式处理组件update，事务处理完后会调用wrapper.close(),</p>
<h1 id="react-diff"><a href="#react-diff" class="headerlink" title="react diff"></a>react diff</h1><p><a target="_blank" rel="noopener" href="https://github.com/purplebamboo/blog/issues/3">链接</a></p>
<p>三大要点</p>
<ul>
<li>tree diff<br>  两棵树只会对同一层次的节点进行比较。</li>
<li>component diff<br>  判断是否是同一类型组件</li>
<li>element diff<br>  同一节点 插入，删除，移动属性</li>
</ul>
<p>在reactjs中我们需要更新时都是调用的setState</p>
<p>setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。</p>
<p>就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新。</p>
<p>会合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了。</p>
<p>本质上还是递归调用receiveComponent的过程。</p>
<p>这里注意两个函数：</p>
<p>inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。</p>
<p>_shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。</p>
<p>==简单回顾下reactjs的差异算法：==</p>
<p>首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。</p>
<p>react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。</p>
<p>每个类型的元素都要处理好自己的更新：</p>
<p>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</p>
<p>text节点的更新很简单，直接更新文案。</p>
<p>浏览器基本元素的更新，分为两块：</p>
<p>先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。</p>
<p>然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。<br>整个reactjs的差异算法就是这个样子。</p>
<p>最核心的两个_shouldUpdateReactComponent以及diff,patch算法。</p>
<p>//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</p>
<p>_patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20346379?refer=purerender">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"></span><br><span class="line">React 通过制定大胆的 diff 策略，将 O(n3)</span><br><span class="line">复杂度的问题转换成 O(n) 复杂度的问题；</span><br><span class="line"></span><br><span class="line">React 通过分层求异的策略，对 tree diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">React 通过相同类生成相似树形结构，</span><br><span class="line">不同类生成不同树形结构的策略，</span><br><span class="line">对 component diff 进行算法优化；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">React 通过设置唯一 key的策略，</span><br><span class="line">对 element diff 进行算法优化；</span><br><span class="line"></span><br><span class="line">建议，在开发组件时，保持稳定的 DOM</span><br><span class="line">结构会有助于性能的提升；</span><br><span class="line"></span><br><span class="line">建议，在开发过程中，尽量减少类似将最后一个节点移</span><br><span class="line">动到列表首部的操作，当节点数量过大或更新操作</span><br><span class="line">过于频繁时，在一定程度上会影响 React 的渲染性能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tree diff</span><br><span class="line"></span><br><span class="line">React 对树的算法进行了简洁明了的优化，</span><br><span class="line">即对树进行分层比较，两棵树只会对同一层次的</span><br><span class="line">节点进行比较。</span><br><span class="line"></span><br><span class="line">component diff</span><br><span class="line"></span><br><span class="line">如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</span><br><span class="line"></span><br><span class="line">如果不是，则将该组件判断为 dirty component，</span><br><span class="line">从而替换整个组件下的所有子节点。</span><br><span class="line"></span><br><span class="line">对于同一类型的组件，有可能其 Virtual DOM</span><br><span class="line">没有任何变化，如果能够确切的知道这点那可以</span><br><span class="line">节省大量的 diff 运算时间，因此 React 允许用户通过</span><br><span class="line">shouldComponentUpdate() 来判断该组件是否需要进行 diff。</span><br><span class="line"></span><br><span class="line">element diff</span><br><span class="line"></span><br><span class="line">当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</span><br><span class="line"></span><br><span class="line">INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</span><br><span class="line"></span><br><span class="line">MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild&#x3D;nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</span><br><span class="line"></span><br><span class="line">REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</span><br><span class="line"></span><br><span class="line">React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。</span><br><span class="line"></span><br><span class="line">针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="设计组件"><a href="#设计组件" class="headerlink" title="设计组件"></a>设计组件</h1><p>组件尽量只做渲染，逻辑处理放到reducer中</p>
<h1 id="redux-中的action"><a href="#redux-中的action" class="headerlink" title="redux 中的action"></a>redux 中的action</h1><p>Action Creator 的唯一功能就是返回一个Action供 dispatch 进行调用。</p>
<p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件：</p>
<p>是一个纯文本对象</p>
<p>只具备 type 、payload、error 和 meta 中的一个或者多个属性。</p>
<p>type 字段不可缺省，其它字段可缺省</p>
<p>若 Action 报错，error 字段不可缺省，切必须为 true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">在 redux 全家桶中，可以利用 redux-actions 来创建符合 FSA 规范的Action：</span><br><span class="line"></span><br><span class="line">import &#123;creatAction&#125; from &#39;redux-actions&#39;;</span><br><span class="line"></span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO)</span><br><span class="line">&#x2F;&#x2F;same as</span><br><span class="line">let addTodo &#x3D; creatAction(ADD_TODO,data&#x3D;&gt;data)</span><br><span class="line"></span><br><span class="line">Redux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件：</span><br><span class="line"></span><br><span class="line">redux-thunk</span><br><span class="line">redux-promise</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用connect将组件绑定到redux</span><br><span class="line">export const ButtonContainer &#x3D; connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Buttons);</span><br><span class="line"></span><br><span class="line">容器组件实现 mapStateToProps()（用于将状态映射到数据）</span><br><span class="line">和 mapDispatchToProps()（用于将状态映射到行为）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</span><br><span class="line"></span><br><span class="line">操作发起时的 Action</span><br><span class="line">操作成功时的 Action</span><br><span class="line">操作失败时的 Action</span><br><span class="line"></span><br><span class="line">操作开始时，送出一个 Action，触发 State 更新为&quot;正在操作&quot;状态，View 重新渲染</span><br><span class="line"></span><br><span class="line">用户触发第一个 Action，这个跟同步操作一样，没有问题；</span><br><span class="line">如何才能在操作结束时，系统自动送出第二个 Action 呢？</span><br><span class="line"></span><br><span class="line">Action 是由store.dispatch方法发送的。</span><br><span class="line">而store.dispatch方法正常情况下，参数只能是对象，</span><br><span class="line">不能是函数。</span><br><span class="line"></span><br><span class="line">这时，就要使用中间件redux-thunk。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fetchPosts &#x3D; postTitle &#x3D;&gt; (dispatch, getState) &#x3D;&gt; &#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  return fetch(&#96;&#x2F;some&#x2F;API&#x2F;$&#123;postTitle&#125;.json&#96;)</span><br><span class="line">    .then(response &#x3D;&gt; response.json())</span><br><span class="line">    .then(json &#x3D;&gt; dispatch(receivePosts(postTitle, json)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法一</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;));</span><br><span class="line">&#x2F;&#x2F; 使用方法二</span><br><span class="line">store.dispatch(fetchPosts(&#39;reactjs&#39;)).then(() &#x3D;&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">看这里，返回的是Promise，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>==用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。==</p>
<p>store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。</p>
<p>Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，</p>
<p>Redux的单向数据流是同步操作，驱动Redux流程的是action对象，每一个action对象被派发到Store上之后，同步地被分配给所有的reducer函数，每个reducer都是纯函数，纯函数不产生任何副作用，自然是完成数据操作之后立刻同步返回，reducer返回的结果又被同步地拿去更新Store上的状态数据，更新状态数据的操作会立刻被同步给监听Store状态改变的函数，从而引发作为视图的React组件更新过程。</p>
<p>这个过程从头到尾，Redux马不停蹄地一路同步执行，根本没有执行异步操作的机会，那应该在哪里插入访问服务器的异步操作呢？</p>
<p>Redux创立之初就意识到了这种问题，所以提供了thunk这种解决方法，但是thunk并没有作为Redux的一部分一起发布，而是存在一个独立的redux-thunk发布包中，</p>
<p>redux-thunk只是Redux中异步操作的解决方法之一</p>
<p>在Redux架构下，一个action对象在通过store.dispatch派发，在调用reducer函数之前，会先经过一个中间件的环节，这就是产生异步操作的机会，实际上redux-thunk提供的就是一个Redux中间件，我们需要在创建Store时用上这个中间件。</p>
<h1 id="异步action对象"><a href="#异步action对象" class="headerlink" title="异步action对象"></a>异步action对象</h1><h2 id="非常好的讲解"><a href="#非常好的讲解" class="headerlink" title="非常好的讲解"></a><a target="_blank" rel="noopener" href="http://geek.csdn.net/news/detail/202352">非常好的讲解</a></h2><p>当我们想要让Redux帮忙处理一个异步操作的时候，代码一样也要派发一个action对象，毕竟Redux单向数据流就是由action对象驱动的。但是这个引发异步操作的action对象比较特殊，我们叫它们“异步action对象”。</p>
<p>前面例子中的action构造函数返回的都是一个普通的对象，这个对象包含若干字段，其中必不可少的字段是type，但是“异步action对象”不是一个普通JavaScript对象，而是一个函数。</p>
<p>如果没有redux-thunk中间件的存在，这样一个函数类型的action对象被派发出来会一路发送到各个reducer函数，reducer函数从这些实际上是函数的action对象上是无法获得type字段的，所以也做不了什么实质的处理。</p>
<p>不过，有了redux-thunk中间件之后，这些action对象根本没有机会触及到reducer函数，在中间件一层就被redux-thunk截获。</p>
<p>redux-thunk的工作是检查action对象是不是函数，如果不是函数就放行，完成普通action对象的生命周期，而如果发现action对象是函数，那就执行这个函数，并把Store的dispatch函数和getState函数作为参数传递到函数中去，处理过程到此为止，不会让这个异步action对象继续往前派发到reducer函数。</p>
<p>举一个并不涉及网络API访问的异步操作例子，在Counter组件中存在一个普通的同步增加计数的action构造函数increment，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const increment &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">  type: ActionTypes.INCREMENT,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>派发increment执行返回的action对象，Redux会同步更新Store状态和视图，但是我们现在想要创造一个功能，能够发出一个“让Counter组件在1秒之后计数加一”的指令，这就需要定义一个新的异步action构造函数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const incrementAsync &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (dispatch) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      dispatch(increment());</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">异步action构造函数incrementAsync返回的是一个新的函数，这样一个函数被dispatch函数派发之后，会被redux-thunk中间件执行，于是setTimeout函数就会发生作用，在1秒之后利用参数dispatch函数派发出同步action构造函数increment的结果。</span><br><span class="line"></span><br><span class="line">这就是异步action的工作机理，这个例子虽然简单，但是可以看得出来，异步action最终还是要产生同步action派发才能对Redux系统产生影响。</span><br><span class="line"></span><br><span class="line">redux-thunk要做的工作也就不过如此，但因为引入了一次函数执行，而且这个函数还能够访问到dispatch和getState，就给异步操作带来了可能。</span><br><span class="line"></span><br><span class="line">action对象函数中完全可以通过fetch发起一个对服务器的异步请求，当得到服务器结果之后，通过参数dispatch，把成功或者失败的结果当做action对象再派发出去。这一次派发的是普通的action对象，就不会被redux-thunk截获，而是直接被派发到reducer，最终驱动Store上状态的改变。</span><br><span class="line"></span><br><span class="line">通常我们在组件的componentDidMount函数中做请求服务器的事情，因为当生命周期函数componentDidMount被调用的时候，表明装载过程已经完成，组件需要渲染的内容已经在DOM树上出现，对服务器的请求可能依赖于已经渲染的内容，在componentDidMount函数中发送对服务器请求是一个合适的时机。</span><br><span class="line"></span><br><span class="line">fetch函数执行会立刻返回，返回一个Promise类型的对象，所以后面会跟上一大串then和catch的语句。每个Promise成功的时候，对应的then中的回调函数会被调用；如果失败，对应catch中的回调函数也被调用。</span><br><span class="line"></span><br><span class="line"># vue声明组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一、全局注册<br>// 注册<br>Vue.component(‘my-component’, {<br>  template: ‘<div>A custom component!</div>‘<br>})</p>
<p>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</p>
<p>用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？</p>
<p>// 创建根实例<br>new Vue({<br>  el: ‘#example’<br>})</p>
<p>二、局部注册<br>var Child = {<br>  template: ‘<div>A custom component!</div>‘<br>}</p>
<p>new Vue({<br>  // …<br>  components: {<br>    // <my-component> 将只在父组件模板中可用<br>    ‘my-component’: Child<br>  }<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 检测变化的注意事项</span><br><span class="line"></span><br><span class="line">Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</span><br><span class="line"></span><br><span class="line">Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</span><br><span class="line"></span><br><span class="line">Vue.set(vm.someObject, &#39;b&#39;, 2)</span><br><span class="line"></span><br><span class="line">this.$set(this.someObject,&#39;b&#39;,2)</span><br><span class="line"></span><br><span class="line">想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代替 &#96;Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)&#96;</span><br><span class="line">this.someObject &#x3D; Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># watch 深度监听</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;deep： true&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</span><br><span class="line"></span><br><span class="line">不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue &#x3D;&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    a: function (val, oldVal) {<br>      console.log(‘new: %s, old: %s’, val, oldVal)<br>    },<br>    // 方法名<br>    b: ‘someMethod’,<br>    // 深度 watcher<br>    c: {<br>      handler: function (val, oldVal) { /* … <em>/ },<br>      deep: true<br>    },<br>    // 该回调将会在侦听开始之后被立即调用<br>    d: {<br>      handler: function (val, oldVal) { /</em> … <em>/ },<br>      immediate: true<br>    },<br>    e: [<br>      function handle1 (val, oldVal) { /</em> … <em>/ },<br>      function handle2 (val, oldVal) { /</em> … <em>/ }<br>    ],<br>    // watch vm.e.f’s value: {g: 5}<br>    ‘e.f’: function (val, oldVal) { /</em> … */ }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 异步更新队列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>this.$nextTick(function () {<br>    console.log(this.$el.textContent) // =&gt; ‘更新完成’<br>  })</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性 computed</span><br><span class="line"></span><br><span class="line">对于任何复杂逻辑，你都应当使用计算属性。</span><br><span class="line"></span><br><span class="line">当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;方法和计算属性：&#x3D;&#x3D; 两种方式的最终结果确实是完全相同的。</span><br><span class="line"></span><br><span class="line">不同的是计算属性是基于它们的依赖进行缓存的。</span><br><span class="line"></span><br><span class="line">计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage</span><br><span class="line">计算属性会立即返回之前的计算结果，而不必再次执行函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>computed: {<br>    // 计算属性的 getter<br>    reversedMessage: function () {<br>      // <code>this</code> 指向 vm 实例<br>      return this.message.split(‘’).reverse().join(‘’)<br>    }<br>}</p>
<p>  console.log(vm.reversedMessage) // =&gt; ‘olleH’<br>vm.message = ‘Goodbye’<br>console.log(vm.reversedMessage) // =&gt; ‘eybdooG’</p>
<p>// 在组件中<br>methods: {<br>  reversedMessage: function () {<br>    return this.message.split(‘’).reverse().join(‘’)<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 计算属性的 setter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// …<br>computed: {<br>  fullName: {<br>    // getter<br>    get: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>    },<br>    // setter<br>    set: function (newValue) {<br>      var names = newValue.split(‘ ‘)<br>      this.firstName = names[0]<br>      this.lastName = names[names.length - 1]<br>    }<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># watch 侦听器</span><br><span class="line"></span><br><span class="line">虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</span><br><span class="line"></span><br><span class="line">使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>watch: {<br>    // 如果 <code>question</code> 发生改变，这个函数就会运行<br>    question: function (newQuestion, oldQuestion) {<br>      this.answer = ‘Waiting for you to stop typing…’<br>      this.getAnswer()<br>    }<br>},</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># getters作用</span><br><span class="line"></span><br><span class="line">Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</span><br><span class="line"></span><br><span class="line">this.$store.getters.doneTodosCount</span><br><span class="line"></span><br><span class="line"># mapGetters 辅助函数</span><br><span class="line"></span><br><span class="line">mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</span><br><span class="line"></span><br><span class="line"># 提交 mutation 的另一种方式是直接使用包含 type 属性的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>store.commit({<br>  type: ‘increment’,<br>  amount: 10<br>})</p>
<p>store.commit(‘increment’, {<br>  amount: 10<br>})<br>可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，<br>或者使用 mapMutations 辅助函数将组件中的 methods<br>映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 分发 Action</span><br><span class="line"></span><br><span class="line">Action 通过 store.dispatch 方法触发：</span><br><span class="line"></span><br><span class="line">store.dispatch(&#39;increment&#39;)</span><br><span class="line"></span><br><span class="line"># vue组件类型, 怎么定义一个组件</span><br><span class="line"></span><br><span class="line"># vue切换路由</span><br><span class="line"></span><br><span class="line">其他方式 不留痕迹</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">一、router.push(location, onComplete?, onAbort?)</span><br><span class="line"></span><br><span class="line">&lt;router-link :to&#x3D;&quot;...&quot;&gt; router.push(...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const userId &#x3D; 123</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123</span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">router.push(&#39;home&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象</span><br><span class="line">router.push(&#123; path: &#39;home&#39; &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命名的路由</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private</span><br><span class="line">router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">二、 router.replace(location, onComplete?, onAbort?)</span><br><span class="line">跟 router.push 很像，唯一的不同就是，它不会向 history</span><br><span class="line">添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</span><br><span class="line"></span><br><span class="line">三、router.go(n)</span><br><span class="line">在 history 记录中向前或者后退多少步，</span><br><span class="line">类似 window.history.go(n)。</span><br></pre></td></tr></table></figure>

<h1 id="vue-router传参方式"><a href="#vue-router传参方式" class="headerlink" title="vue-router传参方式"></a>vue-router传参方式</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">query 和params</span><br><span class="line"> &#123; <span class="attr">path</span>: <span class="string">&#x27;/news/:id&#x27;</span>, <span class="attr">component</span>: NewsDetail &#125;,</span><br><span class="line">      &lt;span&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line"><span class="number">1</span>、用法</span><br><span class="line">    query要用path来引入，params要用name来引入，</span><br><span class="line">    接收参数都是类似的，</span><br><span class="line">    分别是<span class="built_in">this</span>.$route.query.name和<span class="built_in">this</span>.$route.params.name。</span><br><span class="line"></span><br><span class="line">    接收参数时，已经是$route而不是$router了哦！！</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、展示</span><br><span class="line">　　query更加类似于我们ajax中get传参，params则类似于post，</span><br><span class="line">　　说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</span><br><span class="line"></span><br><span class="line">query:</span><br><span class="line">params:</span><br></pre></td></tr></table></figure>

<h1 id="受控组件-非受控组件"><a href="#受控组件-非受控组件" class="headerlink" title="受控组件 非受控组件"></a>受控组件 非受控组件</h1><h1 id="没有任何嵌套关系的组件之间传值"><a href="#没有任何嵌套关系的组件之间传值" class="headerlink" title="没有任何嵌套关系的组件之间传值"></a>没有任何嵌套关系的组件之间传值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(1) Event Emitter&#x2F;Target&#x2F;Dispatcher</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.addEventListener(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.dispatchEvent(‘click’);</span><br><span class="line"></span><br><span class="line">(2) Publish &#x2F; Subscribe</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">globalBroadcaster.subscribe(‘click’, function() &#123; alert(‘click!’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">globalBroadcaster.publish(‘click’);</span><br><span class="line"></span><br><span class="line">(3) Signals</span><br><span class="line">&#x2F;&#x2F; to subscribe</span><br><span class="line">otherObject.clicked.add(function() &#123; alert(‘click’); &#125;);</span><br><span class="line">&#x2F;&#x2F; to dispatch</span><br><span class="line">this.clicked.dispatch();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="this-setState-参数"><a href="#this-setState-参数" class="headerlink" title="this.setState()参数"></a>this.setState()参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这个函数接受两个参数，</span><br><span class="line">第一个参数表示上一个状态值，</span><br><span class="line">第二参数表示当前的 props，</span><br><span class="line">第二个参数是 state 导致的页面变化完成后的回调，等价于componentDidUpdate。</span><br><span class="line"></span><br><span class="line">this.setState((prevState, props) &#x3D;&gt; (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">setState的关键点:</span><br><span class="line"></span><br><span class="line">setState不会立刻改变React组件中state的值；</span><br><span class="line">setState通过引发一次组件的更新过程来引发重新绘制；</span><br><span class="line">多次setState函数调用产生的效果会合并。</span><br><span class="line"></span><br><span class="line">当setState被调用时，能驱动组件的更新过程，引发componentDidUpdate、render等一系列函数的调用。</span><br></pre></td></tr></table></figure>

<h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><p>主要分为三段，mount（挂载）、update（更新）、unmount（卸载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">一、mount，即挂载阶段，</span><br><span class="line">    第一次让组件出现在页面中的过程，React会将render的返回值插入到页面中，</span><br><span class="line">    这个过程会暴露以下几个钩子（hook）：</span><br><span class="line"></span><br><span class="line">    constructor()       &#x2F;&#x2F; 初始化props和state</span><br><span class="line"></span><br><span class="line">    　　初始化getDefaultProps()和getInitialState()</span><br><span class="line"></span><br><span class="line">    　　getDefaultProps: 执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的</span><br><span class="line">这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制</span><br><span class="line"></span><br><span class="line">getInitialState : 控件加载之前执行，返回值会被用于state的初始化值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    　　初始化</span><br><span class="line">    componentWillMount()    &#x2F;&#x2F; 将要被插入</span><br><span class="line"></span><br><span class="line">    执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次</span><br><span class="line"></span><br><span class="line">    render()    &#x2F;&#x2F; 将return的内容插入到页面里</span><br><span class="line">    componentDidMount()   &#x2F;&#x2F; 插入完成后的动作</span><br><span class="line">        在组件被装配后立即调用。</span><br><span class="line">        初始化使得DOM节点应该进行到这里。</span><br><span class="line">        若你需要从远端加载数据，</span><br><span class="line">        这是一个适合实现网络请求的地方。</span><br><span class="line">        在该方法里设置状态将会触发重渲。</span><br><span class="line"></span><br><span class="line">二、update，即更新阶段，如果数据有任何变动就会来这一阶段，这个过程有5个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillReceiveProps( nextprops )   &#x2F;&#x2F; 接受需要更新的props</span><br><span class="line">    　　在装配了的组件接收到新属性前调用。</span><br><span class="line">    　　若你需要更新状态响应属性改变（例如，重置它），</span><br><span class="line">    　　你可能需对比this.props和nextProps</span><br><span class="line">    　　并在该方法中使用this.setState()处理状态改变。</span><br><span class="line"></span><br><span class="line">    注意即使属性未有任何改变，React可能也会调用该方法，因此若你想要处理改变，请确保比较当前和之后的值。这可能会发生在当父组件引起你的组件重渲。</span><br><span class="line"></span><br><span class="line">　　shouldComponentUpdate( nextProps, nextState )   &#x2F;&#x2F; 请问要不要更新组件 true&#x2F;false</span><br><span class="line"></span><br><span class="line">        接收到新属性或状态时，</span><br><span class="line">        shouldComponentUpdate() 在渲染前被调用。默认为true。</span><br><span class="line">        该方法并不会在初始化渲染或当使用forceUpdate()时被调用。</span><br><span class="line">        当他们状态改变时，返回false 并不能阻止子组件重渲。</span><br><span class="line">        若shouldComponentUpdate()返回false，componentWillUpdate()将不会被调用。</span><br><span class="line">　　componentWillUpdate()  &#x2F;&#x2F; 准备更新组件啦</span><br><span class="line"></span><br><span class="line">　　render() &#x2F;&#x2F; 更新</span><br><span class="line"></span><br><span class="line">　　componentDidUpdate()   &#x2F;&#x2F; 更新完成</span><br><span class="line">    该方法并不会在初始化渲染时调用。</span><br><span class="line">三、unmount，即卸载过程，当一个组件要从页面移除时，会进入这个过程，其中有一个钩子：</span><br><span class="line"></span><br><span class="line">　　componentWillUnmount()    &#x2F;&#x2F; 要卸载啦</span><br><span class="line">    可以在该方法里处理任何必要的清理工作，</span><br><span class="line">    例如解绑定时器，取消网络请求，</span><br><span class="line">    清理任何在componentDidMount环节创建的DOM元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一般我们只在这几个钩子里setState：</span><br><span class="line"></span><br><span class="line">componentWillMount()</span><br><span class="line"></span><br><span class="line">componentDidMount()</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Redux原理"><a href="#Redux原理" class="headerlink" title="Redux原理"></a>Redux原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Redux 和 React 没有直接关系，</span><br><span class="line">它瞄准的目标是应用状态管理。</span><br><span class="line"></span><br><span class="line">核心概念是 Map&#x2F;Reduce 中的 Reduce。</span><br><span class="line">且 Reducer 的执行是同步，</span><br><span class="line">产生的 State 是 Immutable 的。</span><br><span class="line"></span><br><span class="line">改变 State 只能通过向 Reducer dispatch actions 来完成。</span><br><span class="line"></span><br><span class="line">State 的不同字段，可以通过不同的 Reducers 来分别维护。</span><br><span class="line">combineReducers 负责组合这些 Reducers，</span><br><span class="line">前提是每个 Reducer 只能维护自己关心的字段。</span><br><span class="line"></span><br><span class="line">Action 对象只能是 Javascript Plain Object，</span><br><span class="line">但是通过在 store 上装载 middleware，</span><br><span class="line">则可以任意定义 action 对象的形式，</span><br><span class="line">反正会有特定的 middleware 负责</span><br><span class="line">将此 action 对象变为 Javascript Plain Object。</span><br><span class="line"></span><br><span class="line">可以以middleware 链条为集中点实现很多控制逻辑，</span><br><span class="line">例如 Log，Undo, ErrorHandler 等。</span><br><span class="line"></span><br><span class="line">Redux 仅仅专注于应用状态的维护，</span><br><span class="line">reducer、dispatch&#x2F;middleware 是两个常用扩展点、</span><br><span class="line">Higher-order Store 则仅针对需要扩展全部 Store 功能时使用。</span><br><span class="line"></span><br><span class="line">react-redux 是 Redux 针对 React&#x2F;React-Native 的 Binding，</span><br><span class="line">connect&#x2F;selector 是扩展点，</span><br><span class="line">负责将 store 中的状态添加到 React component 的 props 中。</span><br><span class="line"></span><br><span class="line">Redux 借用了很多函数式编程的思想，</span><br><span class="line">了解函数式编程会利于理解其实现原理，</span><br><span class="line">虽然使用它不需要了解很多函数式编程的概念。</span><br><span class="line">和 Flux 相比，Redux 的概念更精简、约定更严格、状态更确定、而是扩展却更灵活。</span><br><span class="line"></span><br><span class="line">通过 https:&#x2F;&#x2F;github.com&#x2F;xgrommx&#x2F;awesome-redux 可以获得大量参考。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;3334467e4b32</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redux有三大准则</span><br><span class="line"></span><br><span class="line">单一数据源</span><br><span class="line">整个应用状态，都应该被存储在单一store的对象树中。</span><br><span class="line"></span><br><span class="line">只读状态</span><br><span class="line">唯一可以修改状态的方式，</span><br><span class="line">就是发送（dispatch）一个动作（Action），</span><br><span class="line">通俗来讲，就是说只有getter，没有setter。</span><br><span class="line"></span><br><span class="line">使用纯函数去修改状态</span><br><span class="line">纯函数保障了状态的稳定性，</span><br><span class="line">不会因不同环境导致应用程序出现不同情况，</span><br><span class="line">听说是redux真正的精髓，日后可以深入了解。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="谈谈MVVM模式"><a href="#谈谈MVVM模式" class="headerlink" title="谈谈MVVM模式"></a>谈谈MVVM模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</span><br><span class="line"></span><br><span class="line">DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</span><br><span class="line"></span><br><span class="line">MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</span><br><span class="line"></span><br><span class="line">在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</span><br><span class="line"></span><br><span class="line">ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-mvvm和mvc区别"><a href="#2-mvvm和mvc区别" class="headerlink" title="2:mvvm和mvc区别"></a>2:mvvm和mvc区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvc和mvvm其实区别并不大。都是一种设计思想。</span><br><span class="line">主要就是mvc中Controller演变成mvvm中的viewModel。</span><br><span class="line">mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，</span><br><span class="line">加载速度变慢，影响用户体验。</span><br><span class="line">和当 Model 频繁发生变化，开发者需要主动更新到View 。</span><br></pre></td></tr></table></figure>

<h1 id="让CSS只在当前组件中起作用"><a href="#让CSS只在当前组件中起作用" class="headerlink" title="让CSS只在当前组件中起作用"></a>让CSS只在当前组件中起作用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将当前组件的&lt;style&gt;修改为&lt;style scoped&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Vue中使用插件的步骤"><a href="#Vue中使用插件的步骤" class="headerlink" title="Vue中使用插件的步骤"></a>Vue中使用插件的步骤</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件</span><br><span class="line">使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, &#123; someOption: true &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件的使用和自己创建公用组件"><a href="#组件的使用和自己创建公用组件" class="headerlink" title="组件的使用和自己创建公用组件"></a>组件的使用和自己创建公用组件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步：在components目录新建你的组件文件（indexPage.vue），</span><br><span class="line">    script一定要export default &#123;&#125;</span><br><span class="line">第二步：在需要用的页面（组件）中导入：</span><br><span class="line">    import indexPage from &#39;@&#x2F;components&#x2F;indexPage.vue&#39;</span><br><span class="line">第三步：注入到vue的子组件的components属性上面,components:&#123;indexPage&#125;</span><br><span class="line">第四步：在template视图view中使用，</span><br><span class="line">问题有indexPage命名，使用的时候则index-page。</span><br></pre></td></tr></table></figure>

<h1 id="vue如何实现按需加载配合webpack设置"><a href="#vue如何实现按需加载配合webpack设置" class="headerlink" title="vue如何实现按需加载配合webpack设置"></a>vue如何实现按需加载配合webpack设置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpack中提供了require.ensure()来实现按需加载。以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。</span><br><span class="line">不进行页面按需加载引入方式：import  home   from &#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;</span><br><span class="line">进行页面按需加载的引入方式：const  home &#x3D; r &#x3D;&gt; require.ensure( [], () &#x3D;&gt; r (require(&#39;..&#x2F;..&#x2F;common&#x2F;home.vue&#39;)))</span><br></pre></td></tr></table></figure>

<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a><keep-alive></keep-alive>作用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</span><br></pre></td></tr></table></figure>

<h1 id="vue-route模式"><a href="#vue-route模式" class="headerlink" title="vue-route模式"></a>vue-route模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">默认为hash，但是用hash模式的话，页面地址会加#</span><br><span class="line"></span><br><span class="line">所以一般采用 history模式</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"># vue阻止事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　.stop 阻止事件冒泡<br>　.prevent 阻止默认事件<br>　.capture　阻止事件捕获<br>　.once 只触发一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># router传参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>routes: [<br>    {<br>        path: ‘/linkParams/:name’,<br>        name:’linkParams’,<br>        component: linkParams<br>    }<br>]</p>
<p>获取name</p>
<p>let name = this.$route.params.name</p>
<p>// 字符串,这里的字符串是路径path匹配噢，不是router配置里的name<br>this.$router.push(‘home’)</p>
<p>// 对象<br>this.$router.push({ path: ‘home’ })</p>
<p>// 命名的路由 这里会变成 /user/123<br>this.$router.push({ name: ‘user’, params: { userId: 123 }})</p>
<p>// 带查询参数，变成 /register?plan=private<br>this.$router.push({ path: ‘register’, query: { plan: ‘private’ }})</p>
<p>router.beforeEach((to, from, next)=&gt;{<br>  //do something<br>  next();<br>});<br>router.afterEach((to, from, next) =&gt; {<br>    console.log(to.path);<br>});</p>
<p>每个钩子方法接收三个参数：</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p>
<p>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。</p>
<p>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。</p>
<p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SSR实现原理</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。<br>webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。<br>服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。<br>客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端。</p>
<p>Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue实例初始化的过程中实现依赖管理的分析</span><br><span class="line"></span><br><span class="line">[链接](http:&#x2F;&#x2F;www.bslxx.com&#x2F;a&#x2F;vue&#x2F;2018&#x2F;0301&#x2F;1795.html)</span><br><span class="line"></span><br><span class="line">大致的总结下就是：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>initState的过程中，<br>将props,computed,data等属性通过Object.defineProperty<br>来改造其getter/setter属性，<br>并为每一个响应式属性实例化一个observer观察者。<br>这个observer内部dep记录了这个响应式属性的所有依赖。</p>
<p>当响应式属性调用setter函数时，<br>通过dep.notify()方法去遍历所有的依赖，<br>调用watcher.update()去完成数据的动态响应。</p>
<p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，<br>通过Object.defineProperty()来劫持各个属性的setter，getter，<br>在数据变动时发布消息给订阅者，<br>触发相应的监听回调。</p>
<p>具体步骤：<br>第一步：需要observe的数据对象进行递归遍历，<br>包括子属性对象的属性，<br>都加上 setter和getter<br>这样的话，<br>给这个对象的某个值赋值，就会触发setter，<br>那么就能监听到了数据变化</p>
<p>第二步：compile解析模板指令，<br>将模板中的变量替换成数据，<br>然后初始化渲染页面视图，<br>并将每个指令对应的节点绑定更新函数，<br>添加监听数据的订阅者，一旦数据有变动，<br>收到通知，更新视图</p>
<p>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，<br>主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，<br>能调用自身的update()方法，<br>并触发Compile中绑定的回调，则功成身退。</p>
<p>第四步：MVVM作为数据绑定的入口，<br>整合Observer、Compile和Watcher三者，<br>通过Observer来监听自己的model数据变化，<br>通过Compile来解析编译模板指令，<br>最终利用Watcher搭起Observer和Compile之间的通信桥梁，<br>达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue声明组件的state是用data方法，那为什么data是通过一个function来返回一个对象，而不是直接写一个对象呢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：从语法上说，如果不用function返回就会出现语法错误导致编译不通过。从原理上的话，大概就是组件可以被多次创建，如果不使用function就会使所有调用该组件的页面公用同一个数据域，这样就失去了组件的概念了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># vuex</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> State、 Getter、Mutation 、Action、 Module<br>通过状态（数据源）集中管理驱动组件的变化<br>（好比spring的IOC容器对bean进行集中管理）。<br>应用级的状态集中放在store中；<br>改变状态的方式是提交mutations，<br>这是个同步的事物； 异步逻辑应该封装在action中。</p>
<p>一、Action 类似于 mutation，不同在于：<br>二、Action 提交的是 mutation，而不是直接变更状态。<br>三、Action 可以包含任意异步操作</p>
<p>一、getters 可以对State进行计算操作，它就是Store的计算属性<br>二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用<br>三、 如果一个状态只在一个组件内使用，是可以不用getters</p>
<p>二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新<br>三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 说下vue组件之间的通信</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答：<br>非父子组件间通信，Vue 有提供 Vuex，以状态共享方式来实现通信</p>
<p>prop 向下传递，事件向上传递。<br>还可以通过$emit方法出发一个消息，然后$on接收这个消息</p>
<p>兄弟组件间的数据通讯，它们将会 寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法 。</p>
<p>var Event = new Vue()<br>//父组件<br> Event.$on(“a-msg”, function (a) {<br>    this.a = a;<br>  }.bind(this));</p>
<p>// 子组件<br> Event.$emit(“a-msg”, this.a);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue 生命周期</span><br><span class="line"></span><br><span class="line"># 简单描述每个周期具体适合哪些场景</span><br><span class="line"></span><br><span class="line">Create  Mount  Update  Destroy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>beforeCreate（创建前）,<br>created（创建后）,</p>
<p>beforeMount(载入前),<br>mounted（载入后）,</p>
<p>beforeUpdate（更新前）,<br>updated（更新后）,</p>
<p>beforeDestroy（销毁前）,<br>destroyed（销毁后）</p>
<p>每个钩子函数都在啥时间触发</p>
<p>beforeCreate<br>在实例初始化之后，<br>数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>
<p>created<br>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>beforeMount<br>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p>mounted<br>挂载元素，获取到DOM节点<br>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。<br>如果 root 实例挂载了一个文档内元素，<br>当 mounted 被调用时 vm.$el 也在文档内。</p>
<p>beforeUpdate<br>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p>updated<br>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。<br>然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<p>beforeDestroy<br>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p>destroyed<br>Vue 实例销毁后调用。<br>调用后，Vue 实例指示的所有东西都会解绑定，<br>所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
<p>生命周期钩子的一些常见使用方法：</p>
<p>beforecreate : 可以在这加个loading事件，<br>在加载实例时触发</p>
<p>created : 初始化完成时需要执行的事件写在这里，<br>如在这结束loading事件，异步请求也适宜在这里调用</p>
<p>mounted: 在这发起后端请求，拿回数据，配合路由钩子做一些事情</p>
<p>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框 你确认删除XX吗？<br>nextTick : 更新数据后立即操作dom<br>activated::keep-alive组件激活时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># v-show和v-if指令的共同点和不同点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏<br>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</p>
<p>v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。<br>因此，如果需要频繁切换 v-show 较好，<br>如果在运行时条件不大可能改变 v-if 较好。</p>
<p>1.v-if 指令可以应用于template包装元素上，<br>而v-show不支持template<br>2.将v-show应用在组件上时，因为指令的优先级<br>v-else 会出现问题，<br>解决办法就是用另一个 v-show 替换 v-else</p>
<p>// 错误<br><custom-component v-show="condition"></custom-component></p>
<p v-else>这可能也是一个组件</p>
     // 正确做法
<custom-component v-show="condition"></custom-component>
<p v-show="!condition">这可能也是一个组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># vue 父子组件嵌套时，组件内部的各个生命周期钩子触发先后顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
顺序是 先创建父组件(父组件beforeMount)，然后才创建子组件，当子组件创建完成并且实体dom挂载完成后(子组件先mounted)父组件才挂载完成(父组件mounted)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># h函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
它来自单词 hyperscript，
这个单词通常用在 virtual-dom 的实现中。
Hyperscript 本身是指

<p>生成HTML 结构的 script 脚本，<br>因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言）</p>
<p>个人理解：<br>createElement 函数是用来生成 HTML DOM<br>元素的，也就是上文中的 generate HTML<br>structures，也就是 Hyperscript，<br>这样作者才把 createElement 简写成 h。</p>
<p>大概的翻译下：<br>render: h =&gt; h(App) 是下面内容的缩写：</p>
<p>render: function (createElement) {<br>    return createElement(App);<br>}<br>进一步缩写为(ES6 语法)：</p>
<p>render (createElement) {<br>    return createElement(App);<br>}<br>再进一步缩写为：</p>
<p>render (h){<br>    return h(App);<br>}<br>按照 ES6 箭头函数的写法，就得到了：</p>
<p>render: h =&gt; h(App);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># react-redux中connect函数</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010188279)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>connect方法做的事情是<br>将state和dispatch绑定到Connect组件的参数上，<br>然后Connect组件将你当前的App组件封装起来，<br>使得App组件可以通过props获取到父<br>组件Connect传递的state和props。</p>
<p>Provider是顶层组件的作用，<br>将store作为上下文提供给全局共享，<br>而Connect组件是局部组件，将某个react组件包装起来，<br>传递指定的state和props给该组件访问。</p>
<p>connect()返回值是Connect组件（请注意大小写的区别）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Vue和React区别</span><br><span class="line"></span><br><span class="line">### 相同</span><br><span class="line"></span><br><span class="line">- 使用 Virtual DOM</span><br><span class="line">- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</span><br><span class="line">- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</span><br><span class="line"></span><br><span class="line">都是JavaScript的UI框架，专注于创造前端的富应用。</span><br><span class="line">不同于早期的JavaScript框架“功能齐全”，</span><br><span class="line"></span><br><span class="line">### 区别</span><br><span class="line"></span><br><span class="line">- **性能**</span><br><span class="line"></span><br><span class="line">    计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。</span><br><span class="line"></span><br><span class="line">    Vue可以更快地计算出Virtual DOM的差异，</span><br><span class="line">    这是由于它在渲染过程中，</span><br><span class="line">    会跟踪每一个组件的依赖关系，</span><br><span class="line">    不需要重新渲染整个组件树。</span><br><span class="line"></span><br><span class="line">    而对于React而言，每当应用的状态被改变时，</span><br><span class="line">    全部子组件都会重新渲染。</span><br><span class="line">    当然，这可以通过shouldComponentUpdate</span><br><span class="line">    这个生命周期方法来进行控制，</span><br><span class="line">    但Vue将此视为默认的优化。</span><br><span class="line"></span><br><span class="line">- **JSX和Templates**</span><br><span class="line"></span><br><span class="line">    React 中，所有的组件的渲染功能都依靠 JSX</span><br><span class="line">    可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。</span><br><span class="line"></span><br><span class="line">    模板比起 JSX 读写起来更自然。</span><br><span class="line">    基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。</span><br><span class="line">    可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。</span><br><span class="line"></span><br><span class="line">    vue的模板语法去除了往视图&#x2F;组件中添加逻辑的诱惑，保持了关注点分离。</span><br><span class="line"></span><br><span class="line">    与React一样，Vue在技术上也支持render函数和JSX，但只是不是默认的而已。</span><br><span class="line"></span><br><span class="line">- **组件作用域内的 CSS**</span><br><span class="line"></span><br><span class="line">    Vue 设置样式的默认方法是单文件组件里类似 style 的标签。</span><br><span class="line">    可选 scoped 属性会自动添加一个唯一的属性</span><br><span class="line"></span><br><span class="line">    CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的</span><br><span class="line"></span><br><span class="line">- **Props**</span><br><span class="line"></span><br><span class="line">    JSX库中，数据通过props传到子组件中去。</span><br><span class="line"></span><br><span class="line">    在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”</span><br><span class="line"></span><br><span class="line">    在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。</span><br><span class="line"></span><br><span class="line">- **构建工具**</span><br><span class="line"></span><br><span class="line">    React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。</span><br><span class="line"></span><br><span class="line">- **配套框架**</span><br><span class="line"></span><br><span class="line">    Vue的核心团队维护着vue-router和vuex，</span><br><span class="line">    它们由官方维护支持且与核心库同步更新的。</span><br><span class="line">    而React的react-router和react-redux则是由社区成员维护，</span><br><span class="line">    创建了一个更分散的生态系统</span><br><span class="line"></span><br><span class="line">- **向下扩展**</span><br><span class="line"></span><br><span class="line">    React 学习曲线陡峭，学 React 前，你需要知道 JSX 和 ES2015，</span><br><span class="line"></span><br><span class="line">- **原生渲染**</span><br><span class="line"></span><br><span class="line">    Weex 还在积极发展，成熟度也不能和 React Native 相抗衡。</span><br><span class="line"></span><br><span class="line">&lt;https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5a9b8417518825558251ce15&gt;</span><br><span class="line"></span><br><span class="line"># redux原理</span><br><span class="line"></span><br><span class="line">[链接](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000004236064)</span><br><span class="line"></span><br><span class="line"># redux流程</span><br><span class="line"></span><br><span class="line">[Redux 入门教程](http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;2016&#x2F;09&#x2F;redux_tutorial_part_one_basic_usages.html)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// store<br>// Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>//数据集合，就叫做 State<br>const state = store.getState();</p>
<p>// Action Creator定义一个函数来生成 Action<br>const ADD_TODO = ‘添加 TODO’;</p>
<p>function addTodo(text) {<br>  return {<br>    type: ADD_TODO,<br>    text<br>  }<br>}</p>
<p>const action = addTodo(‘Learn Redux’);</p>
<p>//store.dispatch()是 View 发出 Action 的唯一方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
<p>store.dispatch({<br>  type: ‘ADD_TODO’,<br>  payload: ‘Learn Redux’<br>});</p>
<p>store.dispatch(addTodo(‘Learn Redux’));</p>
<p>//Reducer State 的计算过程就叫做 Reducer。<br>接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<p>const reducer = function (state, action) {<br>  // …<br>  return new_state;<br>};</p>
<p>const defaultState = 0;<br>const reducer = (state = defaultState, action) =&gt; {<br>  switch (action.type) {<br>    case ‘ADD’:<br>      return state + action.payload;<br>    default:<br>      return state;<br>  }<br>};</p>
<p>const state = reducer(1, {<br>  type: ‘ADD’,<br>  payload: 2<br>});</p>
<p>Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</p>
<p>import { createStore } from ‘redux’;<br>const store = createStore(reducer);</p>
<p>createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p>
<p>reducer最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<p>不得改写参数<br>不能调用系统 I/O 的API<br>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</p>
<p>必须返回一个全新的对象<br>// State 是一个对象<br>function reducer(state, action) {<br>  return Object.assign({}, state, { thingToChange });<br>  // 或者<br>  return { …state, …newState };<br>}</p>
<p>// State 是一个数组<br>function reducer(state, action) {<br>  return […state, newItem];<br>}</p>
<pre><code></code></pre>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/jQuery插件思路整理/" rel="bookmark">jQuery插件思路整理</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/原型/" rel="bookmark">原型</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/posts/前端经验积累/" rel="bookmark">前端经验积累</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/img/alipay.png" alt="believeZJP 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/img/wechat.png" alt="believeZJP 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/jQuery/" rel="tag"># jQuery</a>
              <a href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag"># 插件</a>
              <a href="/tags/%E5%B0%81%E8%A3%85/" rel="tag"># 封装</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/%E5%8E%9F%E5%9E%8B/" rel="prev" title="原型">
                  <i class="fa fa-chevron-left"></i> 原型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/" rel="next" title="前端经验积累">
                  前端经验积累 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">believeZJP</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">662k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:02</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

<script src="/js/local-search.js"></script>






  






</body>
</html>
